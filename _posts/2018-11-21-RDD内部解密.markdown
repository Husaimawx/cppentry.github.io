---
layout:     post
title:      RDD内部解密
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                
<p><span style="font-size:14px;">第一阶段（<span style="font-family:Calibri;">1-3</span><span style="font-family:'宋体';">月）：会从浅入深，基于大量案例实战，深度剖析和讲解</span><span style="font-family:Calibri;">Spark</span><span style="font-family:'宋体';">，并且会包含完全从企业真实复杂业务需求中抽取出的案例实战。课程会涵盖</span><span style="font-family:Calibri;">Scala</span><span style="font-family:'宋体';">编程详解、</span><span style="font-family:Calibri;">Spark</span><span style="font-family:'宋体';">核心编程、</span><span style="font-family:Calibri;">Spark SQL</span><span style="font-family:'宋体';">和</span><span style="font-family:Calibri;">Spark Streaming</span><span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">Spark GraphX</span><span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">SparkR</span><span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">Machine Learning</span><span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">Spark</span><span style="font-family:'宋体';">内核以及源码剖析、性能调优、企业级案例实战等部分</span></span></p>
<p><span style="font-size:14px;">第二阶段（<span style="font-family:Calibri;">Spark</span><span style="font-family:'宋体';">超大规模大数据案例实战）：使用了</span><span style="font-family:Calibri;">Spark</span><span style="font-family:'宋体';">技术生态栈中的</span><span style="font-family:Calibri;">Spark Core</span><span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">Spark SQL</span><span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">Spark Streaming</span><span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">SparkR</span><span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">Machine Learning</span><span style="font-family:'宋体';">，进行离线计算和实时计算业务模块的开发、数据的关联性分析、用户行为模式和特征的训练与应用、用户网络的社区发现、用户影响力、能量传播、标签传播、标签推理、人群划分、年龄段预测、商品交易时序跳转</span></span></p>
<p><strong>本课内容：</strong></p>
<p>1 RDD<span style="font-family:'宋体';">：基于工作集的应用抽象</span></p>
<p>2 RDD<span style="font-family:'宋体';">内幕解密</span></p>
<p>3 RDD<span style="font-family:'宋体';">思考</span></p>
<p></p>
<p style="font-family:'宋体';"><strong>（1）RDD(<span style="font-family:'宋体';">弹性分布式数据集</span><span style="font-family:Calibri;">)</span></strong></p>
<p style="font-family:'宋体';">分布式是基于内存的计算方式，特别适合于迭代计算，也可以基于磁盘计算，适合各种规模的集群的计算。<span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">是基于工作集的应用抽象，具有位置感知，容错 负载均衡的优点。</span></p>
<p style="font-family:'宋体';">RDD<span style="font-family:'宋体';">基于数据集的处理：从物理存储上加载数据，然后操作数据 最后写入物理存储设备。基于数据集的方式，不适用：</span></p>
<p style="font-family:'宋体';">1、不适合于含有大量迭代；</p>
<p style="font-family:'宋体';">2、不适合交互式查询；</p>
<p style="font-family:'宋体';">重点是：基于数据流的方式 不能够复用曾经的结果或者中间计算结果</p>
<p style="font-family:'宋体';"> </p>
<p style="font-family:'宋体';"><strong>（2）RDD<span style="font-family:'宋体';">组成：</span></strong></p>
<p style="font-family:'宋体';">RDD<span style="font-family:'宋体';">由以下几个主要部分组成</span></p>
<p style="font-family:'宋体';">partitions<span style="font-family:'宋体';">——</span><span style="font-family:Calibri;">partition</span><span style="font-family:'宋体';">集合，一个</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">中有多少</span><span style="font-family:Calibri;">data partition</span></p>
<p style="font-family:'宋体';">dependencies<span style="font-family:'宋体';">——</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">依赖关系</span></p>
<p style="font-family:'宋体';">compute(parition)<span style="font-family:'宋体';">——对于给定的数据集，需要作哪些计算</span></p>
<p style="font-family:'宋体';">preferredLocations<span style="font-family:'宋体';">——对于</span><span style="font-family:Calibri;">data partition</span><span style="font-family:'宋体';">的位置偏好</span></p>
<p style="font-family:'宋体';"> </p>
<p style="font-family:'宋体';"> </p>
<p style="font-family:'宋体';">1<span style="font-family:'宋体';">、分布式：多态集群，整个</span><span style="font-family:Calibri;">Spark</span><span style="font-family:'宋体';">有一个提交程序的</span><span style="font-family:Calibri;">Driver</span><span style="font-family:'宋体';">端，提交给集群（多台）进行运行，不同的</span><span style="font-family:Calibri;">Node</span><span style="font-family:'宋体';">处理其中一部分内容，</span><span style="font-family:Calibri;">Node</span><span style="font-family:'宋体';">间各不影响。</span></p>
<p style="font-family:'宋体';">2<span style="font-family:'宋体';">、主要基于内存：</span><span style="font-family:Calibri;">data</span><span style="font-family:'宋体';">首先会考虑在</span><span style="font-family:Calibri;">MEM</span><span style="font-family:'宋体';">中运行，</span><span style="font-family:Calibri;">data</span><span style="font-family:'宋体';">太大可将部分</span><span style="font-family:Calibri;">data</span><span style="font-family:'宋体';">数据存放于</span><span style="font-family:Calibri;">disk</span><span style="font-family:'宋体';">上，</span></p>
<p style="font-family:'宋体';">3<span style="font-family:'宋体';">、擅长迭代计算（多步骤计算）</span><span style="font-family:Calibri;">shuffle</span></p>
<p style="font-family:'宋体';">RDD:rdd<span style="font-family:'宋体';">代表要处理的数据，分布式处理，</span><span style="font-family:Calibri;">data</span><span style="font-family:'宋体';">分成若干分片</span><span style="font-family:Calibri;">Partition</span><span style="font-family:'宋体';">，存储于不同的节点中，只进行</span><span style="font-family:Calibri;">rdd</span><span style="font-family:'宋体';">的处理，</span></p>
<p><strong><span style="font-family:'宋体';">（</span><span style="font-family:Calibri;">3</span><span style="font-family:'宋体';">）</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">弹性的特点：</span></strong></p>
<p style="font-family:'宋体';">1<span style="font-family:'宋体';">、弹性之一：自动的进行内存和磁盘数据存储的切换；</span></p>
<p style="font-family:'宋体';">2<span style="font-family:'宋体';">、弹性之二：基于</span><span style="font-family:Calibri;">Lineage</span><span style="font-family:'宋体';">的高效容错（第</span><span style="font-family:Calibri;">n</span><span style="font-family:'宋体';">个节点出错，会从第</span><span style="font-family:Calibri;">n-1</span><span style="font-family:'宋体';">个节点恢复，血统容错）；</span></p>
<p style="font-family:'宋体';">3<span style="font-family:'宋体';">、弹性之三：</span><span style="font-family:Calibri;">Task</span><span style="font-family:'宋体';">如果失败会自动进行特定次数的重试（默认</span><span style="font-family:Calibri;">4</span><span style="font-family:'宋体';">次）；</span></p>
<p style="font-family:'宋体';">4<span style="font-family:'宋体';">、弹性之四：</span><span style="font-family:Calibri;">Stage</span><span style="font-family:'宋体';">如果失败会自动进行特定次数的重试（可以值运行计算失败的阶段）；只计算失败的数据分片；</span></p>
<p style="font-family:'宋体';">5<span style="font-family:'宋体';">、弹性之五：</span><span style="font-family:Calibri;">checkpoint</span></p>
<p style="font-family:'宋体';">6<span style="font-family:'宋体';">、弹性之六：数据调度弹性：</span><span style="font-family:Calibri;">DAG TASK </span><span style="font-family:'宋体';">和资源 管理无关</span></p>
<p style="font-family:'宋体';">7<span style="font-family:'宋体';">、弹性之七：数据分片的高度弹性</span><span style="font-family:Calibri;">,repartition</span></p>
<p style="font-family:'宋体';"> </p>
<p style="font-family:'宋体';">RDD:<span style="font-family:'宋体';">是分布式函数式编程的抽象，采用</span><span style="font-family:Calibri;">Lazy</span><span style="font-family:'宋体';">级别，开始的时候只对数据集合做标记（操作的标记），如，下面</span><span style="font-family:Calibri;">flatmap</span><span style="font-family:'宋体';">中，下面的</span><span style="font-family:Calibri;">this</span><span style="font-family:'宋体';">为父</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">，即每次父</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">都会作为第一个参数传进来，构成了链条，也是一个函数展开的过程，即操作的标记。</span></p>
<p style="font-family:'宋体';">new MapPartitionsRDD[U, T](this, (context, pid, iter) =&gt; iter.flatMap(cleanF))</p>
<p style="font-family:'宋体';">1、RDD<span style="font-family:'宋体';">基于内存迭代，需要很多内存，</span></p>
<p style="font-family:'宋体';">2、Spark1.x<span style="font-family:'宋体';">之前收数据规模的限制，受限于</span><span style="font-family:Calibri;">shuffle</span><span style="font-family:'宋体';">的机制</span></p>
<p style="font-family:'宋体';"><strong>（4）常规的容错的方式：</strong></p>
<p style="font-family:'宋体';">1、数据检查点（<span style="font-family:Calibri;">IDC</span><span style="font-family:'宋体';">网络连接每台机器，操作前都需赋值数据集，极大的销号数据，网络带宽压力太大）</span></p>
<p style="font-family:'宋体';">2、记录数据的更新（每次变化都需要记录，缺点为：复杂易失控）</p>
<p style="font-family:'宋体';">数据复制或日志记录。对于以数据为中心的系统而言，这两种方式都非常昂贵，因为它需要跨集群网络拷贝大量数据，毕竟带宽的数据远远低于内存。</p>
<p style="font-family:'宋体';">RDD<span style="font-family:'宋体';">天生是支持容错的。首先，它自身是一个不变的</span><span style="font-family:Calibri;">(immutable)</span><span style="font-family:'宋体';">数据集，其次，它能够记住构建它的操作图（</span><span style="font-family:Calibri;">Graph of Operation</span><span style="font-family:'宋体';">），因此当执行任务的</span><span style="font-family:Calibri;">Worker</span><span style="font-family:'宋体';">失败时，完全可以通过操作图获得之前执行的操作，进行重新计算。由于无需采用</span><span style="font-family:Calibri;">replication</span><span style="font-family:'宋体';">方式支持容错，很好地降低了跨网络的数据传输成本。</span></p>
<p style="font-family:'宋体';">不过，在某些场景下，<span style="font-family:Calibri;">Spark</span><span style="font-family:'宋体';">也需要利用记录日志的方式来支持容错。例如，在</span><span style="font-family:Calibri;">Spark Streaming</span><span style="font-family:'宋体';">中，针对数据进行</span><span style="font-family:Calibri;">update</span><span style="font-family:'宋体';">操作，或者调用</span><span style="font-family:Calibri;">Streaming</span><span style="font-family:'宋体';">提供的</span><span style="font-family:Calibri;">window</span><span style="font-family:'宋体';">操作时，就需要恢复执行过程的中间状态。此时，需要通过</span><span style="font-family:Calibri;">Spark</span><span style="font-family:'宋体';">提供的</span><span style="font-family:Calibri;">checkpoint</span><span style="font-family:'宋体';">机制，以支持操作能够从</span><span style="font-family:Calibri;">checkpoint</span><span style="font-family:'宋体';">得到恢复。</span></p>
<p style="font-family:'宋体';">针对<span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">的</span><span style="font-family:Calibri;">wide dependency</span><span style="font-family:'宋体';">，最有效的容错方式同样还是采用</span><span style="font-family:Calibri;">checkpoint</span><span style="font-family:'宋体';">机制。不过，似乎</span><span style="font-family:Calibri;">Spark</span><span style="font-family:'宋体';">的最新版本仍然没有引入</span><span style="font-family:Calibri;">auto checkpointing</span><span style="font-family:'宋体';">机制。</span></p>
<p style="font-family:'宋体';"> </p>
<p style="font-family:'宋体';"><strong>（5）Spark<span style="font-family:'宋体';">就是基于数据更新，</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">通过记录数据更新的方式为何很高效？</span></strong></p>
<p style="font-family:'宋体';">1、RDD<span style="font-family:'宋体';">不可变（每次操作变成新的</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">，构成计算链条，不会产生中间结果，没有中间结果，就不需要维护）且</span><span style="font-family:Calibri;">Lazy</span><span style="font-family:'宋体';">级别的；</span></p>
<p style="font-family:'宋体';">从第<span style="font-family:Calibri;">900</span><span style="font-family:'宋体';">步恢复的前提是要在</span><span style="font-family:Calibri;">900</span><span style="font-family:'宋体';">步持久化，每次产生新的</span><span style="font-family:Calibri;">RDD, </span><span style="font-family:'宋体';">因为没有全局修改数据</span><span style="font-family:Calibri;">, </span><span style="font-family:'宋体';">从而控制难度下降</span><span style="font-family:Calibri;">, </span><span style="font-family:'宋体';">在这个基础之上</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">还有计算链条</span><span style="font-family:Calibri;">, </span><span style="font-family:'宋体';">当第</span><span style="font-family:Calibri;">901</span><span style="font-family:'宋体';">个步骤出错了</span><span style="font-family:Calibri;">, </span><span style="font-family:'宋体';">我们就可以从第</span><span style="font-family:Calibri;">900</span><span style="font-family:'宋体';">个步骤恢复</span><span style="font-family:Calibri;">, </span><span style="font-family:'宋体';">因为每次都以前一个</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">作为标记</span><span style="font-family:Calibri;">, </span><span style="font-family:'宋体';">因此可以做到在哪出错就在哪恢复。</span></p>
<p style="font-family:'宋体';">2、RDD<span style="font-family:'宋体';">为什么是粗粒度（对</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">的所有写操作都是粗粒度的，对</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">进行的读操作可以是粗粒度和细粒度）：为了效率，为了简化。</span></p>
<p style="font-family:'宋体';">RDD<span style="font-family:'宋体';">本身各种转换都的惰性的，只记录，并不真实计算， </span><span style="font-family:Calibri;">action</span><span style="font-family:'宋体';">的时候才计算，出错的时候，会从记录源头开始重新计算，迭代时，为了避免这些重复计算，会引进一些机制，比如缓存，</span><span style="font-family:Calibri;">Checkpoint</span><span style="font-family:'宋体';">等等。这些控制性的操作之后，就直接从缓存或</span><span style="font-family:Calibri;">Checkpoint</span><span style="font-family:'宋体';">中获取数据，而不需要重新计算整个记录的操作，所以可以在内存中迭代使用</span><span style="font-family:Calibri;">rdd</span><span style="font-family:'宋体';">。另外，</span><span style="font-family:Calibri;">stage</span><span style="font-family:'宋体';">内的因为不需要</span><span style="font-family:Calibri;">Shuffle</span><span style="font-family:'宋体';">，所以可以</span><span style="font-family:Calibri;">pipeline</span><span style="font-family:'宋体';">方式，在内存中流式的计算数据，而对应的，</span><span style="font-family:Calibri;">stage</span><span style="font-family:'宋体';">的结果，也有一个重复利用的机制，当写磁盘后，后续可以重复使用这个</span><span style="font-family:Calibri;">stage</span><span style="font-family:'宋体';">的写磁盘结果，而不需要多次重复计算整个</span><span style="font-family:Calibri;">stage</span><span style="font-family:'宋体';">。</span></p>
<p style="font-family:'宋体';">narrow dependencies<span style="font-family:'宋体';">可以支持在同一个</span><span style="font-family:Calibri;">cluster node</span><span style="font-family:'宋体';">上以管道形式执行多条命令，例如在执行了</span><span style="font-family:Calibri;">map</span><span style="font-family:'宋体';">后，紧接着执行</span><span style="font-family:Calibri;">filter</span><span style="font-family:'宋体';">。相反，</span><span style="font-family:Calibri;">wide dependencies</span><span style="font-family:'宋体';">需要所有的父分区都是可用的，可能还需要调用类似</span><span style="font-family:Calibri;">MapReduce</span><span style="font-family:'宋体';">之类的操作进行跨节点传递。</span></p>
<p style="font-family:'宋体';">其次，则是从失败恢复的角度考虑。<span style="font-family:Calibri;">narrow dependencies</span><span style="font-family:'宋体';">的失败恢复更有效，因为它只需要重新计算丢失的</span><span style="font-family:Calibri;">parent partition</span><span style="font-family:'宋体';">即可，而且可以并行地在不同节点进行重计算。而</span><span style="font-family:Calibri;">wide dependencies</span><span style="font-family:'宋体';">牵涉到</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">各级的多个</span><span style="font-family:Calibri;">Parent Partitions</span><span style="font-family:'宋体';">。</span></p>
<p style="font-family:'宋体';"><strong>（6）覆写<span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">情况：</span></strong></p>
<p style="font-family:'宋体';">listPartition<span style="font-family:'宋体';">，必须知道数据分片的位置，</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">的数据分片计算逻辑都是一致的，处理数据不同。</span></p>
<p style="font-family:'宋体';">RDD<span style="font-family:'宋体';">在函数展开的时候默认只会记录一次数据，除非进行</span><span style="font-family:Calibri;">checkpoint</span><span style="font-family:'宋体';">或者</span><span style="font-family:Calibri;">persist</span><span style="font-family:'宋体';">等情况。</span></p>
<p style="font-family:'宋体';">所有的<span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">返回都是一个迭代器</span><span style="font-family:Calibri;">Iterator</span><span style="font-family:'宋体';">，所以</span><span style="font-family:Calibri;">SparkSQL</span><span style="font-family:'宋体';">和</span><span style="font-family:Calibri;">Spark Streaming</span><span style="color:rgb(255,0,0);">无缝集成</span>各种框架（其内可以互相操作，<span style="font-family:Calibri;">this.type</span><span style="font-family:'宋体';">）。</span></p>
<p style="font-family:'宋体';">注：<span style="font-family:Calibri;">Tachyon</span><span style="font-family:'宋体';">整合南北数据中心不同步数据的</span></p>
<p style="font-family:'宋体';"><span style="color:rgb(255,0,0);">Spark<span style="font-family:'宋体';">不擅长处理实时事物性处理，一统数据计算领域</span></span></p>
<p style="font-family:'宋体';"><strong>（7）RDD<span style="font-family:'宋体';">缺陷：</span></strong></p>
<p style="font-family:'宋体';">1、主要不支持细粒度的写操作</p>
<p style="font-family:'宋体';">2、不支持增量迭代计算（计算的时候只计算一部分数据）</p>
<p style="font-family:'宋体';">Spark Streaming+kafka<span style="font-family:'宋体';">取代</span><span style="font-family:Calibri;">Storm</span></p>
<p style="font-family:'宋体';"> </p>
<p style="font-family:'宋体';"></p><pre><code class="language-java">def repartition(numPartitions: Int)(implicit ord: Ordering[T] = null): RDD[T] = withScope {
coalesce(numPartitions, shuffle = true)}
 
def coalesce(numPartitions: Int, shuffle: Boolean = false)(implicit ord: Ordering[T] = null)</code></pre><br><p style="font-family:'宋体';"><strong>注：</strong></p>
<p style="font-family:'宋体';">1<span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">有依赖的清除需要</span><span style="font-family:Calibri;">checkpoint</span><span style="font-family:'宋体';">（一般存磁盘）</span></p>
<p style="font-family:'宋体';">2<span style="font-family:'宋体';">、假设有</span><span style="font-family:Calibri;">1000</span><span style="font-family:'宋体';">个</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">，不会产生中间结果，只产生一次结果，若一个</span><span style="font-family:Calibri;">Stage</span><span style="font-family:'宋体';">有</span><span style="font-family:Calibri;">1000</span><span style="font-family:'宋体';">步骤，默认产生一次结果。</span></p>
<p style="font-family:'宋体';"> </p>
<p style="font-family:'宋体';"> </p>
<p style="font-family:'宋体';">Spark<span style="font-family:'宋体';">，在进行下一步操作的时候，会感知当前位置。</span></p>
<p><strong><span style="font-family:'宋体';">（8）</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">写入缓存</span><span style="font-family:Calibri;">cache</span><span style="font-family:'宋体';">的几种情况：</span></strong></p>
<p style="font-family:'宋体';">1<span style="font-family:'宋体';">、计算步骤特别耗时会做</span><span style="font-family:Calibri;">Cache</span></p>
<p style="font-family:'宋体';">2<span style="font-family:'宋体';">、计算链条很长，失败的时候会有很大代价，血统容错恢复；</span></p>
<p style="font-family:'宋体';">3<span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">shuffle</span><span style="font-family:'宋体';">之后；</span></p>
<p style="font-family:'宋体';">4<span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">checkPoint</span><span style="font-family:'宋体';">：</span><span style="font-family:Calibri;">Tachyon</span><span style="font-family:'宋体';">（</span><span style="font-family:Calibri;">Cache</span><span style="font-family:'宋体';">不可靠）</span><span style="font-family:Calibri;">data</span><span style="font-family:'宋体';">放于文件系统中，保证数据安全</span></p>
<p style="font-family:'宋体';"><strong>（9）RDD<span style="font-family:'宋体';">如何保障数据处理效率？</span></strong></p>
<p style="font-family:'宋体';">RDD<span style="font-family:'宋体';">提供了两方面的特性</span><span style="font-family:Calibri;">persistence</span><span style="font-family:'宋体';">和</span><span style="font-family:Calibri;">patitioning</span><span style="font-family:'宋体';">，用户可以通过</span><span style="font-family:Calibri;">persist</span><span style="font-family:'宋体';">与</span><span style="font-family:Calibri;">patitionBy</span><span style="font-family:'宋体';">函数来控制</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">的这两个方面。</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">的分区特性与并行计算能力</span><span style="font-family:Calibri;">(RDD</span><span style="font-family:'宋体';">定义了</span><span style="font-family:Calibri;">parallerize</span><span style="font-family:'宋体';">函数</span><span style="font-family:Calibri;">)</span><span style="font-family:'宋体';">，使得</span><span style="font-family:Calibri;">Spark</span><span style="font-family:'宋体';">可以更好地利用可伸缩的硬件资源。若将分区与持久化二者结合起来，就能更加高效地处理海量数据。</span></p>
<p style="font-family:'宋体';">RDD<span style="font-family:'宋体';">的特性可以总结如下：</span></p>
<p style="font-family:'宋体';">·<span style="font-family:Calibri;"> </span><span style="font-family:'宋体';">它是不变的数据结构存储</span></p>
<p style="font-family:'宋体';">·<span style="font-family:Calibri;"> </span><span style="font-family:'宋体';">它是支持跨集群的分布式数据结构</span></p>
<p style="font-family:'宋体';">·<span style="font-family:Calibri;"> </span><span style="font-family:'宋体';">可以根据数据记录的</span><span style="font-family:Calibri;">key</span><span style="font-family:'宋体';">对结构进行分区</span></p>
<p style="font-family:'宋体';">·<span style="font-family:Calibri;"> </span><span style="font-family:'宋体';">提供了粗粒度的操作，且这些操作都支持分区</span></p>
<p style="font-family:'宋体';">·<span style="font-family:Calibri;"> </span><span style="font-family:'宋体';">它将数据存储在内存中，从而提供了低延迟性</span></p>
<br><p><span style="font-family:'宋体';"></span></p>
<p>ＤＴ大数据梦工厂</p>
<p>新浪微博：<a href="http://www.weibo.com/ilovepains/" rel="nofollow"><span style="color:rgb(0,0,255);">www.weibo.com/ilovepains/</span></a></p>
<p>微信公众号：<span style="font-family:Calibri;">DT_Spark</span></p>
<p>博客：<a href="/ilovepains" rel="nofollow"><span style="color:rgb(0,0,255);">http://.blog.sina.com.cn/ilovepains</span></a></p>
<p>TEL:18610086859</p>
<p>Email:18610086859@vip.126.com</p>
<br><p><span style="font-family:'宋体';"><br></span></p>
<p><span style="font-family:'宋体';"><br></span></p>
<p><span style="font-family:'宋体';"><br></span></p>
<p><span style="font-family:'宋体';"><br></span></p>
<p><span style="font-family:'宋体';"><br></span></p>
<p><span style="font-family:'宋体';"><br></span></p>
<p><span style="font-family:'宋体';"><br></span></p>
            </div>
                </div>