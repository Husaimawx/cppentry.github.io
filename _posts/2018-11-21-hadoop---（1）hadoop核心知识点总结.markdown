---
layout:     post
title:      hadoop---（1）hadoop核心知识点总结
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                <h1 class="csdn_top" style="color:rgb(44,48,51);font-size:24px;line-height:38px;">hadoop核心知识点总结</h1><div class="article_content csdn-tracking-statistics tracking-click" style="color:rgb(69,69,69);"><div class="htmledit_views"><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">1、  安装hadoop需要配置的hadoop中的配置文件有哪些?<span></span></span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;"><span></span></span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"></p><ul style="list-style:none;color:rgb(85,85,85);font-family:'microsoft yahei';font-size:15px;"><li><span style="font-size:18px;">hadoop-env.sh</span></li><li><span style="font-size:18px;">yarn-env.sh</span></li><li><span style="font-size:18px;">core-site.xml</span></li><li><span style="font-size:18px;">hdfs-site.xml</span></li><li><span style="font-size:18px;">mapred-site.xml</span></li><li><span style="font-size:18px;">yarn-site.xml</span></li><li><span style="font-size:18px;">slaves</span></li></ul><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">2、  Hadoop的核心模块和相应的进程</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;"><span></span>HDFS:namenode,datanode,secondarynamenode,namenodemanager,datanodemanager</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;"><span></span>MapReduce:ResourceManager,NodeManager,Application master</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">3、  SecondaryNameNode的作用</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;"><span></span>如果运行namenode服务的机器损坏，那么文件系统上所有的文件都将丢失，因此，namenode的容错非常重要，hadoop为此提供了两种机制，secondaryNameNode是其中之一：</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;"><span></span>在namenode运行的时候，同时运行一个secondaryNameNode，但是它不会被用作namenode，它的作用是定期的通过编辑日志文件（edits）合并命名空间镜像（images），以防编辑日志过大，secondaryNameNode一般运行在另一台单独的计算机上，因为它需要占用大量的CPU时间与namenode相同容量的内存来执行合并操作。它保存合并后的镜像副本，并在namenode发生故障后启用。但是，secondaryNameNode保存的状态总是滞后于namenode的，因此主节点全部失效时，肯定会丢失一部分数据。</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><br></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;"><span></span></span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">4、  Edits文件和fsimages文件的作用</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;"><span></span>fsimages文件包含整个HDFS系统中的所有目录和文件的inode信息，对于文件来说包含了数据块描述信息，修改时间，访问时间；对于目录来说，包括修改时间，访问权限控制信息等；</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;"><span></span>Edits文件主要是在namenode已经启动的情况下对HDFS进行的各种更新操作进行记录</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">5、  结合图描述hdfs写原理</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;"><br></span></p><span style="color:rgb(85,85,85);font-family:'microsoft yahei';font-size:18px;"><img src="https://img-blog.csdn.net/20161014172222689?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" style="border:0px;"><br></span><span style="color:rgb(85,85,85);font-family:'microsoft yahei';font-size:15px;"></span><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">（1）client通过对dfs对象调用create方法创建一个新的文件</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">（2）dfs对namenode创建一个RPC（remote proecdure call）调用，在文件的命名空间中新建一个文件，此时该文件还没有对应的数据块，namenode通过对其权限检查和路径检查无误后，为创建新文件记录一条记录，就是一个edits文件</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">（3）dfs向对象返回一个fsdos对象，client通过该对象向hdfs中写入数据</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">（4）dfsos将文件分成一个个的数据包，并写入内部队列，成为数据队列（data queue）。datastreamer处理数据队列，它的责任是根据datanode列表来要求namenode分配适合的新块来存储数据副本。默认分配三个节点，datastreamer将数据包流式传输到管线中的datanode1上，该节点存储数据包并将它发送到管线中的datanode2，以此类推</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">（5）dfsos也维护着一个确认队列等待datanode的确认回执，当收取到所有的datanode确认回执的时候，该数据包才会从确认队列删除</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">（6）client完成写入后，对数据流调用close方法</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;"><br></span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;"><br></span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">6、结合图描述hdfs的读取原理</span></p><span style="color:rgb(85,85,85);font-family:'microsoft yahei';font-size:18px;"><img src="https://img-blog.csdn.net/20161014172237772?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" style="border:0px;"><br></span><span style="color:rgb(85,85,85);font-family:'microsoft yahei';font-size:15px;"></span><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><br></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">•使用HDFS提供的客户端开发库Client，向远程的Namenode发起RPC请求；</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">• Namenode会视情况返回文件的部分或者全部block列表，对于每个block，Namenode都会返回有该block拷贝的DataNode地址；</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">•客户端开发库Client会选取离客户端最接近的DataNode来读取block；如果客户端本身就是DataNode,那么将从本地直接获取数据.</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">•读取完当前block的数据后，关闭与当前的DataNode连接，并为读取下一个block寻找最佳的DataNode；</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">•当读完列表的block后，且文件读取还没有结束，客户端开发库会继续向Namenode获取下一批的block列表。</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">•读取完一个block都会进行checksum验证，如果读取datanode时出现错误，客户端会通知Namenode，然后再从下一个拥有该block拷贝的datanode继续读</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">7、  根据图描述hdfs的构架原理</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;"><img src="https://img-blog.csdn.net/20161014172250678?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" style="border:0px;"><br></span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">HDFS被设计成在一个大集群中可以跨机器地可靠地存储海量的文件。它将每个文件存储成block序列，除了最后一个block，所有的block都是同 样的大小。文件的所有block为了容错都会被复制。每个文件的block大小和replication因子都是可配置的。Replication因子可 以在文件创建的时候配置，以后也可以改变。HDFS中的文件是write-one，并且严格要求在任何时候只有一个writer。Namenode全权管 理block的复制，它周期性地从集群中的每个Datanode接收心跳包和一个Blockreport。心跳包的接收表示该Datanode节点正常工 作，而Blockreport包括了该Datanode上所有的block组成的列表。</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">（1）副本的存放<br>    副本的存放是HDFS可靠性和性能的关键。HDFS采用一种称为rack-aware的策略来改进数据的可靠性、有效性和网络带宽的利用。这个策略实现的短期目标是验证在生产环境下的表现，观察它的行为，构建测试和研究的基础，以便实现更先进的策略。庞大的HDFS实例一般运行在多个机架的计算机形成的集群上，不同机架间的两台机器的通讯需要通过交换机，显然通常情况下，同一个机架内的两个节点间的带宽会比不同机架间的两台机器的带宽大。<br>    通过一个称为Rack Awareness的过程，Namenode决定了每个Datanode所属的rack id。一个简单但没有优化的策略就是将副本存放在单独的机架上。这样可以防止整个机架（非副本存放）失效的情况，并且允许读数据的时候可以从多个机架读取。这个简单策略设置可以将副本分布在集群中，有利于组件失败情况下的负载均衡。但是，这个简单策略加大了写的代价，因为一个写操作需要传输block到 多个机架。<br>    在大多数情况下，replication因子是3，HDFS的存放策略是将一个副本存放在本地机架上的节点，一个副本放在同一机架上的另一个节点，最后一个副本放在不同机架上的一个节点。机架的错误远远比节点的错误少，这个策略不会影响到数据的可靠性和有效性。三分之一的副本在一个节点上，三分之二在一 个机架上，其他保存在剩下的机架中，这一策略改进了写的性能。</span></p><span style="color:rgb(85,85,85);font-family:'microsoft yahei';font-size:18px;">（2）副本的选择<br>    为了降低整体的带宽消耗和读延时，HDFS会尽量让reader读最近的副本。如果在reader的同一个机架上有一个副本，那么就读该副本。如果一个HDFS集群跨越多个数据中心，那么reader也将首先尝试读本地数据中心的副本。<br></span><span style="color:rgb(85,85,85);font-family:'microsoft yahei';font-size:15px;"></span><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">8、  简述hdfs的优缺点</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;"><span></span>1）处理超大文件<br><br>　　这里的超大文件通常是指百MB、设置数百TB大小的文件。目前在实际应用中，HDFS已经能用来存储管理PB级的数据了。<br><br>　　2）流式的访问数据<br><br>　　HDFS的设计建立在更多地响应"一次写入、多次读写"任务的基础上。这意味着一个数据集一旦由数据源生成，就会被复制分发到不同的存储节点中，然后 响应各种各样的数据分析任务请求。在多数情况下，分析任务都会涉及数据集中的大部分数据，也就是说，对HDFS来说，请求读取整个数据集要比读取一条记录 更加高效。<br><br>　　3）运行于廉价的商用机器集群上<br><br>　　Hadoop设计对硬件需求比较低，只须运行在低廉的商用硬件集群上，而无需昂贵的高可用性机器上。廉价的商用机也就意味着大型集群中出现节点故障情况的概率非常高。这就要求设计HDFS时要充分考虑数据的可靠性，安全性及高可用性。<br><span></span>4）不适合低延迟数据访问<br><br>　　如果要处理一些用户要求时间比较短的低延迟应用请求，则HDFS不适合。HDFS是为了处理大型数据集分析任务的，主要是为达到高的数据吞吐量而设计的，这就可能要求以高延迟作为代价。<br><br>　　改进策略：对于那些有低延时要求的应用程序，HBase是一个更好的选择。通过上层数据管理项目来尽可能地弥补这个不足。在性能上有了很大的提升，它的口号就是goes real time。使用缓存或多master设计可以降低client的数据请求压力，以减少延时。还有就是对HDFS系统内部的修改，这就得权衡大吞吐量与低延时了，HDFS不是万能的银弹。<br><br>　　5）无法高效存储大量小文件<br><br>　　因为Namenode把文件系统的元数据放置在内存中，所以文件系统所能容纳的文件数目是由Namenode的内存大小来决定。一般来说，每一个文 件、文件夹和Block需要占据150字节左右的空间，所以，如果你有100万个文件，每一个占据一个Block，你就至少需要300MB内存。当前来 说，数百万的文件还是可行的，当扩展到数十亿时，对于当前的硬件水平来说就没法实现了。还有一个问题就是，因为Map task的数量是由splits来决定的，所以用MR处理大量的小文件时，就会产生过多的Maptask，线程管理开销将会增加作业时间。举个例子，处理 10000M的文件，若每个split为1M，那就会有10000个Maptasks，会有很大的线程开销；若每个split为100M，则只有100个 Maptasks，每个Maptask将会有更多的事情做，而线程的管理开销也将减小很多。<br><br>　　改进策略：要想让HDFS能处理好小文件，有不少方法。<br><br>利用SequenceFile、MapFile、Har等方式归档小文件，这个方法的原理就是把小文件归档起来管理，HBase就是基于此的。对于这种方法，如果想找回原来的小文件内容，那就必须得知道与归档文件的映射关系。<br>横向扩展，一个Hadoop集群能管理的小文件有限，那就把几个Hadoop集群拖在一个虚拟服务器后面，形成一个大的Hadoop集群。google也是这么干过的。<br>多Master设计，这个作用显而易见了。正在研发中的GFSII也要改为分布式多Master设计，还支持Master的Failover，而且Block大小改为1M，有意要调优处理小文件啊。<br>附带个Alibaba DFS的设计，也是多Master设计，它把Metadata的映射存储和管理分开了，由多个Metadata存储节点和一个查询Master节点组成。<br>　　6）不支持多用户写入及任意修改文件<br><br>　　在HDFS的一个文件中只有一个写入者，而且写操作只能在文件末尾完成，即只能执行追加操作。目前HDFS还不支持多个用户对同一文件的写操作，以及在文件任意位置进行修改。</span></p><span style="color:rgb(85,85,85);font-family:'microsoft yahei';font-size:18px;"><br></span><span style="color:rgb(85,85,85);font-family:'microsoft yahei';font-size:15px;"></span><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">9、 启动hadoop的脚本和用法</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"></p><ul style="list-style:none;color:rgb(85,85,85);font-family:'microsoft yahei';font-size:15px;"><li><span style="font-size:18px;">start-all.sh 启动所有的Hadoop守护进程。包括NameNode、 SecondaryNameNode、DataNode、NameNodeManager、 DataNodeManager</span></li><li><span style="font-size:18px;">stop-all.sh 停止所有的Hadoop守护进程。包括NameNode、 SecondaryNameNode、DataNode、NameNodeManager、 DataNodeManager</span></li><li><span style="font-size:18px;">start-dfs.sh 启动Hadoop HDFS守护进程NameNode、SecondaryNameNode和DataNode</span></li><li><span style="font-size:18px;">stop-dfs.sh 停止Hadoop HDFS守护进程NameNode、SecondaryNameNode和DataNode</span></li><li><br></li></ul><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">10、  linux下如何使用命令上传文件到hdfs上，如何下载文件到本地文件</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;"><span></span>hdfs dfs –put /home/admin/newFile /user/admin/aaron<span></span>上传</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;"><span></span>hdfs dfs –get /user/admin/aaron/newFile /home/admin/newFile<span></span>下载</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">hdfs dfs –copyFromLocal /home/admin/newFile /user/admin/aaron<span></span>上传</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;"><span></span>hdfs dfs –copyToLocal /user/admin/aaron/newFile /home/admin/newFile<span></span>下载</span></p><span style="color:rgb(85,85,85);font-family:'microsoft yahei';font-size:18px;"><br></span><span style="color:rgb(85,85,85);font-family:'microsoft yahei';font-size:15px;"></span><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">11、  结合图描述yarn框架的原理以及它与hadoop1.x中Mapreduce框架的区别。</span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;"></span></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><img src="https://img-blog.csdn.net/20161014172303251?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" style="border:0px;"><br></p><p style="font-size:15px;color:rgb(85,85,85);font-family:'microsoft yahei';"><span style="font-size:18px;">本题答案看我上篇微博</span></p></div></div>            </div>
                </div>