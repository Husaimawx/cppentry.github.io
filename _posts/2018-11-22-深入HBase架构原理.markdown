---
layout:     post
title:      深入HBase架构原理
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								<div class="article-copyright">
					版权声明：本文为博主原创文章，未经博主允许不得转载。					https://blog.csdn.net/WYpersist/article/details/79811268				</div>
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                <div><h1><strong>深入学习HBase架构原理</strong></h1><h2><strong>HBase定义</strong></h2><p>HBase 是一个高可靠、高性能、面向列、可伸缩的分布式存储系统，利用Hbase技术可在廉价PC Server上搭建大规模结构化存储集群。</p><p align="justify">HBase 是Google Bigtable 的开源实现，与Google Bigtable 利用GFS<span style="font-family:'宋体';">作为其文件存储系统类似，</span> HBase <span style="font-family:'宋体';">利用</span>Hadoop HDFS <span style="font-family:'宋体';">作为其文件存储系统；</span>Google <span style="font-family:'宋体';">运行</span>MapReduce <span style="font-family:'宋体';">来处理</span>Bigtable<span style="font-family:'宋体';">中的海量数据，</span> HBase <span style="font-family:'宋体';">同样利用</span>Hadoop MapReduce来处理HBase中的海量数据；Google Bigtable <span style="font-family:'宋体';">利用</span>Chubby<span style="font-family:'宋体';">作为协同服务，</span> HBase <span style="font-family:'宋体';">利用</span>Zookeeper作为对应。</p><h2><strong>HBase 的特点</strong></h2><p>HBase <span style="font-family:'宋体';">中的表一般有以下特点。</span></p><p>1) <span style="font-family:'宋体';">大：一个表可以有上亿行，上百万列。</span></p><p>2) <span style="font-family:'宋体';">面向列：面向列表（簇）的存储和权限控制，列（簇）独立检索。</span></p><p>3) <span style="font-family:'宋体';">列式存储，其数据在表中是按照某列存储的，这样在查询只需要少数几个字段时，能大大减少读取的数据量。</span></p><p>4) <span style="font-family:'宋体';">稀疏：对于为空（</span>NULL<span style="font-family:'宋体';">）的列，并不占用存储空间，因此，表可以设计的非常稀疏。</span></p><p>5) 无模式：每一行都有一个可以排序的主键和任意多的列，列可以根据需要动态增加，同一张表中不同的行可以有截然不同的列</p><p>6) 数据<span style="font-family:'宋体';">多版本：</span>Hbase<span style="font-family:'宋体';">每一个列的存储有多个</span><span style="font-family:'Times New Roman';">Version</span><span style="font-family:'宋体';">。</span></p><p>7) 数据类型单一，Hbase<span style="font-family:'宋体';">中的数据都是字符串，没有类型。</span></p><p>8) <span style="font-family:'宋体';">扩展性：底层依赖</span>HDFS<span style="font-family:'宋体';">。</span></p><p>9) <span style="font-family:'宋体';">高可靠性：</span>WAL<span style="font-family:'宋体';">机制保证了数据写入时不会因集群异常而导致写入数据丢失，</span><span style="font-family:'Times New Roman';">Replication</span><span style="font-family:'宋体';">机制保证了在集群出现严重的问题时，数据不会发生丢失或损坏。而且</span><span style="font-family:'Times New Roman';">Hbase</span><span style="font-family:'宋体';">底层使用</span><span style="font-family:'Times New Roman';">HDFS</span><span style="font-family:'宋体';">，</span><span style="font-family:'Times New Roman';">HDFS</span><span style="font-family:'宋体';">本身也有备份</span>。</p><p>10) <span style="font-family:'宋体';">高性能：底层的</span>LSM<span style="font-family:'宋体';">数据结构和</span><span style="font-family:'Times New Roman';">Rowkey</span><span style="font-family:'宋体';">有序排列等架构上的独特设计，使得</span><span style="font-family:'Times New Roman';">Hbase</span><span style="font-family:'宋体';">具有非常高的写入性能。</span><span style="font-family:'Times New Roman';">region</span><span style="font-family:'宋体';">切分，主键索引和缓存机制使得</span><span style="font-family:'Times New Roman';">Hbase</span><span style="font-family:'宋体';">在海量数据下具备一定的随机读取性能，该性能真对</span><span style="font-family:'Times New Roman';">Rowkey</span><span style="font-family:'宋体';">的查询能到达到毫秒级别</span><span style="font-family:'宋体';">。</span></p><h2><strong>MapReduce on HBase</strong></h2><p><span style="font-family:'宋体';">在</span>HBase<span style="font-family:'宋体';">系统上运行</span>批处理<span style="font-family:'宋体';">运算，最方便和实用的模型依然是</span>MapReduce<span style="font-family:'宋体';">，如下图：</span></p><p><span style="font-family:'宋体';"><img src="https://img-blog.csdn.net/20180404001934946" alt=""><br></span></p><p>HBase Table<span style="font-family:'宋体';">和</span><span style="font-family:'Times New Roman';">Region</span><span style="font-family:'宋体';">的关系，比较类似</span><span style="font-family:'Times New Roman';">HDFS File</span><span style="font-family:'宋体';">和</span><span style="font-family:'Times New Roman';">Block</span><span style="font-family:'宋体';">的关系，</span><span style="font-family:'Times New Roman';">HBase</span><span style="font-family:'宋体';">提供了配套的</span><span style="font-family:'Times New Roman';">TableInputFormat</span><span style="font-family:'宋体';">和</span><span style="font-family:'Times New Roman';">TableOutputFormat API</span><span style="font-family:'宋体';">，可以方便的将</span><span style="font-family:'Times New Roman';">HBase Table</span><span style="font-family:'宋体';">作为</span><span style="font-family:'Times New Roman';">Hadoop MapReduce</span><span style="font-family:'宋体';">的</span><span style="font-family:'Times New Roman';">Source</span><span style="font-family:'宋体';">和</span><span style="font-family:'Times New Roman';">Sink</span><span style="font-family:'宋体';">，对于</span><span style="font-family:'Times New Roman';">MapReduce Job</span><span style="font-family:'宋体';">应用开发人员来说，基本不需要关注</span><span style="font-family:'Times New Roman';">HBase</span><span style="font-family:'宋体';">系统自身的细节。</span></p><h2><strong>Table &amp; Region</strong></h2><p><span style="font-family:'宋体';">当</span>Table<span style="font-family:'宋体';">随着记录数不断增加而变大后，会逐渐分裂成多份</span><span style="font-family:'Times New Roman';">splits</span><span style="font-family:'宋体';">，成为</span><span style="font-family:'Times New Roman';">regions</span><span style="font-family:'宋体';">，一个</span><span style="font-family:'Times New Roman';">region</span><span style="font-family:'宋体';">由</span><span style="font-family:'Times New Roman';">[startkey,endkey)</span><span style="font-family:'宋体';">表示，不同</span><span style="font-family:'Times New Roman';">region</span><span style="font-family:'宋体';">会被</span><span style="font-family:'Times New Roman';">Master</span><span style="font-family:'宋体';">分配给相应的</span><span style="font-family:'Times New Roman';">RegionServer</span><span style="font-family:'宋体';">进行管理。</span> </p><p><img src="https://img-blog.csdn.net/20180404001955756" alt=""><br></p><p>HBase<span style="font-family:'宋体';">中有两张特殊的</span><span style="font-family:'Times New Roman';">Table</span><span style="font-family:'宋体';">， </span><span style="font-family:'Times New Roman';">-ROOT- </span><span style="font-family:'宋体';">和 </span><span style="font-family:'Times New Roman';">.META.</span> <br>- .META. <span style="font-family:'宋体';">：记录了用户表的</span><span style="font-family:'Times New Roman';">Region</span><span style="font-family:'宋体';">信息，</span><span style="font-family:'Times New Roman';">.META.</span><span style="font-family:'宋体';">可以有多个</span><span style="font-family:'Times New Roman';">region </span></p><p><span style="font-family:'宋体';">表包含所有的用户空间</span>region<span style="font-family:'宋体';">列表，以及</span><span style="font-family:'Times New Roman';">Region Server</span><span style="font-family:'宋体';">的服务器地址</span></p><p>- -ROOT-<span style="font-family:'宋体';">：记录了</span><span style="font-family:'Times New Roman';">.META.</span><span style="font-family:'宋体';">表的</span><span style="font-family:'Times New Roman';">Region</span><span style="font-family:'宋体';">信息，</span><span style="font-family:'Times New Roman';">-ROOT-</span><span style="font-family:'宋体';">只有一个</span><span style="font-family:'Times New Roman';">region </span></p><p><span style="font-family:'宋体';">表包含</span>.META.<span style="font-family:'宋体';">表所在的</span><span style="font-family:'Times New Roman';">region</span><span style="font-family:'宋体';">列表，该表只有一个</span><span style="font-family:'Times New Roman';">Region;Zookeeper</span><span style="font-family:'宋体';">中记录了</span><span style="font-family:'Times New Roman';">-ROOT-</span><span style="font-family:'宋体';">表的</span><span style="font-family:'Times New Roman';">location</span></p><p>- Zookeeper<span style="font-family:'宋体';">中记录了</span><span style="font-family:'Times New Roman';">-ROOT-</span><span style="font-family:'宋体';">表的</span><span style="font-family:'Times New Roman';">location </span><br>Client<span style="font-family:'宋体';">访问用户数据之前需要先访问</span><span style="font-family:'Times New Roman';">zookeeper</span><span style="font-family:'宋体';">，然后访问</span><span style="font-family:'Times New Roman';">-ROOT-</span><span style="font-family:'宋体';">表，接着访问</span><span style="font-family:'Times New Roman';">.META.</span><span style="font-family:'宋体';">表，最后才能找到用户数据的位置去访问，中间需要多次网络操作，不过</span><span style="font-family:'Times New Roman';">client</span><span style="font-family:'宋体';">端会做</span><span style="font-family:'Times New Roman';">cache</span><span style="font-family:'宋体';">缓存。</span></p><h2><strong>HBase 访问接口</strong></h2><p>HBase 支持很多种访问，访问HBase的常见接口如下。</p><p>1、Native Java API，最常规和高效的访问方式，适合Hadoop MapReduce Job并行</p><p>批处理HBase表数据。</p><p>2、HBase Shell，HBase的命令行工具，最简单的接口，适合HBase管理使用。</p><p>3、Thrift Gateway，利用Thrift序列化技术，支持C++，PHP，Python等多种语言，</p><p>适合其他异构系统在线访问HBase表数据。</p><p>4、REST Gateway，支持REST 风格的Http API访问HBase, 解除了语言限制。</p><p>5、Pig，可以使用Pig Latin流式编程语言来操作HBase中的数据，和Hive类似，本质最终也是编译成MapReduce Job来处理HBase表数据，适合做数据统计。</p><p>6、Hive，当前Hive的Release版本尚没有加入对HBase的支持，但在下一个版本Hive 0.7.0中将会支持HBase，可以使用类似SQL语言来访问HBase。</p><h2><strong>HBase <span style="font-family:'宋体';">存储结构</span><a></a>（系统结构）</strong></h2><div><strong><img src="https://img-blog.csdn.net/20180404002033871" alt=""><br></strong></div><div><strong><img src="https://img-blog.csdn.net/20180404002042191" alt=""><br></strong></div><p><a>从</a>HBase的架构图上可以看出，HBase中的存储包括<strong>Client、</strong>HMaster、HRegionServer、HRegion、Store、MemStore、StoreFile、HFile、HLog等，接下来绍他们的作用</p><p align="justify">HBase中的每张表都通过行键按照一定的范围被分割成多个子表（HRegion），默认一个HRegion超过256M就要被分割成两个，这个过程由HRegionServer管理，而HRegion的分配由HMaster管理。</p><h3><strong>Client</strong></h3><p><span style="font-family:'宋体';">包含访问</span>HBase<span style="font-family:'宋体';">的接口，并维护</span><span style="font-family:'Times New Roman';">cache</span><span style="font-family:'宋体';">来加快对</span><span style="font-family:'Times New Roman';">HBase</span><span style="font-family:'宋体';">的访问，比如</span><span style="font-family:'Times New Roman';">region</span><span style="font-family:'宋体';">的位置信息</span></p><h3><strong>Zookeeper</strong></h3><p><span style="color:rgb(75,75,75);">1. </span><span style="color:rgb(75,75,75);"><span style="font-family:georgia;">存放整个</span> HBase集群的元数据以及集群的状态信息。</span></p><p><span style="color:rgb(75,75,75);">2. </span><span style="color:rgb(75,75,75);"><span style="font-family:georgia;">实现</span>HMaster主从节点的failover。</span></p><p><span style="color:rgb(63,63,63);background:rgb(255,255,255);">3. </span><span style="color:rgb(63,63,63);background:rgb(255,255,255);"><span style="font-family:'微软雅黑';">保证任何时候，集群中只有一个</span>master</span></p><p><span style="color:rgb(63,63,63);background:rgb(255,255,255);">4. </span><span style="color:rgb(63,63,63);background:rgb(255,255,255);"><span style="font-family:'微软雅黑';">存储所有</span>Region的寻址入口</span></p><p><span style="color:rgb(63,63,63);background:rgb(255,255,255);">5. </span><span style="color:rgb(63,63,63);background:rgb(255,255,255);"><span style="font-family:'微软雅黑';">实时监控</span>Region server的上线和下线信息。并实时通知给master</span></p><p><span style="color:rgb(63,63,63);background:rgb(255,255,255);">6. </span><span style="color:rgb(63,63,63);background:rgb(255,255,255);"><span style="font-family:'微软雅黑';">存储</span>HBase的schema和table元数据</span></p><h3><strong>HMaster</strong></h3><p>1、为Region server分配region。</p><p>2、负责Region server的负载均衡。</p><p>3、发现失效的Region server并重新分配其上的region。</p><p>4、 HDFS上的垃圾文件回收。</p><p>5、 处理schema更新请求，ü<span style="font-family:'宋体';">管理用户对</span><span style="font-family:'Times New Roman';">table</span><span style="font-family:'宋体';">的增删改查操作</span></p><h3><strong>HRegionServer</strong></h3><p>1、维护master分配给他的region，处理对这些region的io请求。</p><p>2、负责切分正在运行过程中变的过大的region。</p><p>可以看到，client访问hbase上的数据并不需要master参与（寻址访问zookeeper<span style="font-family:'宋体';">和</span> region server，数据读写访问region server），master仅仅维护table和region的元数据信息（table的元数据信息保存在zookeeper<span style="font-family:'宋体';">上），负载很低。</span> HRegionServer存取一个子表</p><p>时，会创建一个HRegion对象，然后对表的每个列族创建一个Store实例，每个Store<span style="font-family:'宋体';">都会有</span><a></a><a>一个</a>MemStore和0个或多个StoreFile与之对应，每个StoreFile都会对应一个HFile<span style="font-family:'宋体';">，</span></p><p>HFile就是实际的存储文件。因此，一个HRegion有多少个列族就有多少个Store。一个</p><p>HRegionServer会有多个HRegion和一个HLog。</p><h3><strong>HRegion</strong></h3><p>table在行的方向上分隔为多个Region。Region是HBase中分布式存储和负载均衡的最小单元，即不同的region可以分别在不同的Region Server上，但同一个Region是不会拆分</p><p>到多个server上。</p><p>Region按大小分隔，每个表一般是只有一个region。随着数据不断插入表，region不断增大，当region的某个列族达到一个阈值（默认256M）时就会分成两个新的region。</p><p>每个region由以下信息标识：</p><p>1、&lt; 表名,startRowkey,创建时间&gt;</p><p>2、由目录表(-ROOT-和.META.)记录该region的endRowkey</p><p>HRegion定位：Region被分配给哪个Region Server是完全动态的，所以需要机制来定位Region具体在哪个region server。</p><h4><strong>HBase使用三层结构来定位region：</strong></h4><img src="https://img-blog.csdn.net/20180404002120737" alt=""><p></p><p>1、通过zk里的文件/hbase/rs得到-ROOT-表的位置。-ROOT-表只有一个region。</p><p>2、通过-ROOT-表查找.META.表的第一个表中相应的region的位置。其实-ROOT-表是.META.表的第一个region；.META.表中的每一个region在-ROOT-表中都是一行记录。</p><p align="justify">3、通过.META.表找到所要的用户表region的位置。用户表中的每个region在.META.表中都是一行记录。</p><p align="justify">-ROOT-表永远不会被分隔为多个region，保证了最多需要三次跳转，就能定位到任意的region。client会将查询的位置信息保存缓存起来，缓存不会主动失效，因此如果client上的缓存全部失效，则需要进行6次网络来回，才能定位到正确的region，其中三次用来发现缓存失效，另外三次用来获取位置信息。</p><p>Store每一个region由一个或多个store组成，至少是一个store，hbase会把一起访问的数据</p><p>放在一个store里面，即为每个ColumnFamily建一个store，如果有几个ColumnFamily，也就有几个Store。一个Store由一个memStore和0或者多个StoreFile<span style="font-family:'宋体';">组成。</span> HBase以store的大小来判断是否需要切分region。</p><h3><strong>MemStore<a></a></strong></h3><p>memStore 是放在内存里的。保存修改的数据即keyValues。当memStore的大小达到</p><p>一个阀值（默认64MB）时，memStore会被flush到文件，即生成一个快照。目前hbase <span style="font-family:'宋体';">会</span></p><p>有一个线程来负责memStore的flush<span style="font-family:'宋体';">操作。</span> StoreFile</p><p>memStore内存中的数据写到文件后就是StoreFile，StoreFile底层是以HFile的格式保存。</p><h3><strong>HFile</strong></h3><p>HBase中KeyValue数据的存储格式，是hadoop的二进制格式文件。首先HFile文件是不定长的，长度固定的只有其中的两块：Trailer和FileInfo。Trailer中有指针指向其他数据块</p><p>的起始点，FileInfo记录了文件的一些meta<span style="font-family:'宋体';">信息。</span> Data Block是hbase io的基本单元，为了提高效率，HRegionServer中有基于LRU的block cache机制。每个Data块的大小可以在创</p><p align="justify">建一个Table的时候通过参数指定（默认块大小64KB），大号的Block有利于顺序Scan，小号的Block利于随机查询。每个Data块除了开头的Magic以外就是一个个KeyValue对拼接而成，Magic内容就是一些随机数字，目的是防止数据损坏，结构如下。</p><p align="justify"> <img src="https://img-blog.csdn.net/20180404002159516" alt=""></p><h3><strong>HFile结构图如下：</strong></h3><img src="https://img-blog.csdn.net/20180404002208684" alt=""><p align="justify">Data Block段用来保存表中的数据，这部分可以被压缩。 Meta Block段（可选的）用来保存用户自定义的kv<span style="font-family:'宋体';">段，可以被压缩。</span> FileInfo段用来保存HFile<span style="font-family:'宋体';">的元信息，不能被压缩，用户也可以在这一部分添加自己的元信息。</span> Data Block Index段（可选的）用来保存Meta Blcok的索引。 Trailer这一段是定长的。保存了每一段的偏移量，读取一个HFile时，会首先</p><p>读取Trailer，Trailer保存了每个段的起始位置(段的Magic Number用来做安全check)，然</p><p align="justify">后，DataBlock Index会被读取到内存中，这样，当检索某个key时，不需要扫描整个HFile，而只需从内存中找到key所在的block，通过一次磁盘io将整个 block读取到内存中，</p><p>再找到需要的key。DataBlock Index采用LRU<span style="font-family:'宋体';">机制淘汰。</span> HFile的Data Block，Meta Block</p><p>通常采用压缩方式存储，压缩之后可以大大减少网络IO和磁盘IO，随之而来的开销当然是需要花费cpu进行压缩和解压缩。目标HFile的压缩支持两种方式：gzip、lzo。</p><p> <img src="https://img-blog.csdn.net/20180404002321122" alt=""></p><p>另外，针对目前针对现有HFile的两个主要缺陷：</p><p align="justify">a) 占用过多内存</p><p align="justify">b) 启动加载时间缓慢</p><p>基于此缺陷，提出了HFile Version2<span style="font-family:'宋体';">设计。</span> HLog</p><p align="right">其实HLog文件就是一个普通的Hadoop Sequence File<span style="font-family:'宋体';">，</span> Sequence File的value是key</p><p>时HLogKey对象，其中记录了写入数据的归属信息，除了table和region名字外，还同时包</p><p>括sequence number和timestamp，timestamp是写入时间，sequence number的起始值为0，或者是最近一次存入文件系统中的sequence number<span style="font-family:'宋体';">。</span> Sequence File的value是HBase的KeyValue对象，即对应HFile中的KeyValue<span style="font-family:'宋体';">。</span><a></a></p><p><img src="https://img-blog.csdn.net/20180404002431344" alt=""><br></p><p>HLog(WAL log)：WAL意为write ahead log，用来做灾难恢复使用，HLog记录数据的所有变更，一旦region server <span style="font-family:'宋体';">宕机，就可以从</span>log中进行恢复。</p><p><img src="https://img-blog.csdn.net/20180404002449539" alt=""><br></p><p>LogFlusher</p><p>前面提到，数据以KeyValue形式到达HRegionServer，将写入WAL之后，写入一个</p><p>SequenceFile。看过去没问题，但是因为数据流在写入文件系统时，经常会缓存以提高性能。这样，有些本以为在日志文件中的数据实际在内存中。这里，我们提供了一个</p><p>LogFlusher的类。它调用HLog.optionalSync(),后者根据 hbase.regionserver.optionallogflushinterval (默认是10秒)，定期调用Hlog.sync()。另外，HLog.doWrite()<span style="font-family:'宋体';">也会根据</span> hbase.regionserver.flushlogentries (默认100秒)定期调用Hlog.sync()。Sync() 本身调用HLog.Writer.sync()，它由SequenceFileLogWriter实现。 LogRoller</p><p>Log的大小通过$HBASE_HOME/conf/hbase-site.xml 的</p><p>hbase.regionserver.logroll.period 限制，默认是一个小时。所以每60分钟，会打开一个新的log文件。久而久之，会有一大堆的文件需要维护。首先，LogRoller调用</p><p>HLog.rollWriter()，定时滚动日志，之后，利用HLog.cleanOldLogs()可以清除旧的日志。</p></div><p>它首先取得存储文件中的最大的sequence number，之后检查是否存在一个log所有的条目</p><p>的“sequence number”均低于这个值，如果存在，将删除这个log。每个region server维</p><p align="justify">护一个HLog，而不是每一个region一个，这样不同region（来自不同的table）的日志会混在一起，这样做的目的是不断追加单个文件相对于同时写多个文件而言，可以减少磁盘寻址次数，因此可以提高table的写性能。带来麻烦的时，如果一个region server下线，为了恢复其上的region，需要将region server上的log进行拆分，然后分发到其他region server上进</p><p>行恢复。</p><h2><strong>HBase<span style="font-family:'黑体';">与</span><span style="font-family:Arial;">Zookeeper</span><span style="font-family:'黑体';">的关系</span><span style="font-family:Arial;"> </span></strong></h2><p> <img src="https://img-blog.csdn.net/20180404002507335" alt=""></p><p> 1. HBase<span style="font-family:'宋体';">依赖</span><span style="font-family:'Times New Roman';">Zookeeper</span></p><p>       <span style="font-family:'宋体';">首先</span><span style="font-family:'Times New Roman';">HMaster</span><span style="font-family:'宋体';">和</span><span style="font-family:'Times New Roman';">RegionServer</span><span style="font-family:'宋体';">都需要和</span><span style="font-family:'Times New Roman';">Zookeeper</span><span style="font-family:'宋体';">交互，因为</span><span style="font-family:'Times New Roman';">RegionServer</span><span style="font-family:'宋体';">上线了还需要交互，之后</span><span style="font-family:'Times New Roman';">Zookeeper</span><span style="font-family:'宋体';">知道了告诉</span><span style="font-family:'Times New Roman';">HMaster</span><span style="font-family:'宋体';">，而下线或断开了</span><span style="font-family:'Times New Roman';">Zookeeper</span><span style="font-family:'宋体';">知道了也告诉</span><span style="font-family:'Times New Roman';">HMaster</span><span style="font-family:'宋体';">；同时</span><span style="font-family:'Times New Roman';">HMaster</span><span style="font-family:'宋体';">还管理</span><span style="font-family:'Times New Roman';">RegionServer</span><span style="font-family:'宋体';">，</span><span style="font-family:'Times New Roman';">HMaster</span><span style="font-family:'宋体';">还会在</span><span style="font-family:'Times New Roman';">HDFS</span><span style="font-family:'宋体';">上写</span><span style="font-family:'Times New Roman';">Region</span><span style="font-family:'宋体';">数据。</span></p><p>       2. <span style="font-family:'宋体';">默认情况下，</span><span style="font-family:'Times New Roman';">HBase</span>依赖、<span style="font-family:'宋体';">管理</span>Zookeeper<span style="font-family:'宋体';">实例，比如，启动或者停止</span><span style="font-family:'Times New Roman';">Zookeeper</span><span style="font-family:'宋体';">；</span></p><p>       3. HMaster<span style="font-family:'宋体';">与</span><span style="font-family:'Times New Roman';">HRegionServer</span><span style="font-family:'宋体';">启动时会向</span><span style="font-family:'Times New Roman';">Zookeeper</span><span style="font-family:'宋体';">注册；</span></p><p>       4. Zookeeper<span style="font-family:'宋体';">的引入使得</span><span style="font-family:'Times New Roman';">HMaster</span><span style="font-family:'宋体';">不再是单点故障。</span></p><h2><strong>HBase 设计</strong></h2><p>HBase 中的每一张表就是所谓的 BigTable。BigTable 会存储一系列的行记录，行记录</p><p><span style="color:rgb(255,0,0);">有三个基本类型的定义：</span><span style="color:rgb(255,0,0);">Row Key</span><span style="color:rgb(255,0,0);">、</span><span style="color:rgb(255,0,0);">Time Stamp</span><span style="color:rgb(255,0,0);">、</span><span style="color:rgb(255,0,0);">Column</span><span style="color:rgb(255,0,0);">。</span></p><p>1、Row Key 是行在 BigTable 中的唯一标识。</p><p>2、Time Stamp 是每次数据操作对应关联的时间戳，可以看做 SVN 的版本。</p><p>3、Column 定义为&lt; family&gt;:&lt; label&gt;，通过这两部分可以指定唯一的数据的存储列，family <span style="font-family:'宋体';">的定义和修改需要对</span> HBase <span style="font-family:'宋体';">进行类似于</span> DB <span style="font-family:'宋体';">的</span> DDL <span style="font-family:'宋体';">操作，而</span> label <span style="font-family:'宋体';">，不需要定义直接可以使用，这也为动态定制列提供了一种手段。</span>family <span style="font-family:'宋体';">另一个作用体现在物理存储优化读写操作上，同</span> family <span style="font-family:'宋体';">的数据物理上保存的会比较临近，因此在业务设计的过程中可以利用这个特性。</span></p><h3><strong>HBase逻辑模型</strong></h3><p><strong>HBase 以表的形式存储数据。表由行和列组成。列划分为若干个列族（row family），如下图所示。</strong></p><p><img src="https://img-blog.csdn.net/20180404011945605" alt=""></p><h2>HBase逻辑数据模型图</h2><p> <img src="https://img-blog.csdn.net/20180404002525701" alt=""></p><h4><strong>1、 Row Key</strong></h4><p><span style="font-family:'宋体';">与</span> NoSQL <span style="font-family:'宋体';">数据库一样，</span>Row Key <span style="font-family:'宋体';">是用来检索记录的主键。访问</span> HBase table <span style="font-family:'宋体';">中的行，只有三种方式：</span></p><p>1)通过单个 Row Key 访问。</p><p>2)通过 Row Key 的 range 全表扫描。</p><p><a>3)Row </a>Key 可以使任意字符串（最大长度是64KB，实际应用中长度一般为 10 ~</p><p>100bytes），在HBase 内部，Row Key 保存为字节数组。</p><p align="justify"><span style="font-family:'宋体';">在存储时，数据按照</span> Row Key <span style="font-family:'宋体';">的字典序（</span>byte order<span style="font-family:'宋体';">）排序存储。设计</span> Key <span style="font-family:'宋体';">时，要充分排序存储这个特性，将经常一起读取的行存储到一起（位置相关性）。</span></p><p><span style="font-family:'宋体';">注意字典序对</span> int <span style="font-family:'宋体';">排序的结果是 </span><span style="font-family:'Times New Roman';">1</span><span style="font-family:'宋体';">，</span><span style="font-family:'Times New Roman';">10,100,11,12,13,14,15,16,17,18,19,20,21</span><span style="font-family:'宋体';">，</span><span style="font-family:'Times New Roman';">...</span><span style="font-family:'宋体';">， </span><span style="font-family:'Times New Roman';">9</span><span style="font-family:'宋体';">，</span><span style="font-family:'Times New Roman';">91,92,93,94,95,96,97,98,99</span><span style="font-family:'宋体';">。要保存整形的自然序，</span><span style="font-family:'Times New Roman';">Row Key </span><span style="font-family:'宋体';">必须用 </span><span style="font-family:'Times New Roman';">0 </span><span style="font-family:'宋体';">进行左填充。</span></p><p align="justify">行的一次读写是原子操作（不论一次读写多少列）。这个设计决策能够使用户很容易理解程序在对同一个行进行并发更新操作时的行为。</p><h4><strong>2、列族</strong></h4><p>HBase 表中的每个列都归属于某个列族。列族是表的 Schema <span style="font-family:'宋体';">的一部分（而列不是），必须在使用表之前定义。列名都以列族作为前缀，例如</span> courses:history、</p><p>courses:math 都属于 courses 这个列族。</p><p align="justify">访问控制、磁盘和内存的使用统计都是在列族层面进行的。在实际应用中，列族上的控制权限能帮助我们管理不同类型的应用，例如，允许一些应用可以添加新的基本数据、一些应用可以读取基本数据并创建继承的列族、一些应用则只允许浏览数据（甚至可能因为隐私的原因不能浏览所有数据）。</p><h4><strong>3、时间戳</strong></h4><p>HBase 中通过 Row 和 Columns 确定的一个存储单元称为 Cell。每个 Cell 都保存着同</p><p align="justify"><span style="font-family:'宋体';">一份数据的多个版本。版本通过时间戳来索引，时间戳的类型是</span> 64 <span style="font-family:'宋体';">位整型。时间戳可以由</span>HBase<span style="font-family:'宋体';">（在数据写入时自动）赋值，此时时间戳是精确到毫秒的当前系统时间。时间戳也可以由客户显示赋值。如果应用程序要避免数据版本冲突，就必须自己生成具有唯一性的时间戳。每个</span> Cell <span style="font-family:'宋体';">中，不同版本的数据按照时间倒序排序，即最新的数据排在最前面。</span></p><p align="justify">为了避免数据存在过多版本造成的管理（包括存储和索引）负担，HBase <span style="font-family:'宋体';">提供了两种数据版本回收方式。一是保存数据的最后</span> n <span style="font-family:'宋体';">个版本，二是保存最近一段时间内的版本（比如最近七天）。用户可以针对每个列族进行设置。</span></p><h4><strong>4、 Cell</strong></h4><p>Cell 是由 {row key，column(=&lt; family&gt; + &lt; label&gt;)，version} 唯一确定的单元。</p><p>Cell <span style="font-family:'宋体';">中的数据是没有类型的，全部是字节码形式存储。</span></p><h2><span style="font-family:'宋体';">HBase物理存储</span></h2><h2><a style="font-size:16px;font-weight:normal;text-align:center;">Table </a><span style="font-size:16px;font-weight:normal;text-align:center;">在行的方向上分割为多个HRegion，每个HRegion分散在不同的RegionServer中。</span></h2><p align="center"><img src="https://img-blog.csdn.net/20180404002615441" alt=""><br></p><p>每个HRegion由多个Store构成，每个Store由一个memStore和0或多个StoreFile组成，每个Store保存一个Columns Family</p><h3>HRegion与Store关系图</h3><p><img src="https://img-blog.csdn.net/20180404002644565" alt=""><br></p><p>StoreFile以HFile格式存储在HDFS中。</p><h2><strong>小小总结</strong></h2><h3><strong>1、有关Hbase表的特点</strong></h3><p><span style="color:rgb(255,0,0);"> A</span><span style="color:rgb(255,0,0);">、大：一个表可以有上亿行，上百万列</span></p><p><span style="color:rgb(255,0,0);"> B</span><span style="color:rgb(255,0,0);">、面向列：面向列表（簇）的存储和权限控制，列（簇）独立检索</span></p><p><span style="color:rgb(255,0,0);"> C</span><span style="color:rgb(255,0,0);">、稀疏：对于为空（</span><span style="color:rgb(255,0,0);">NULL</span><span style="color:rgb(255,0,0);">）的列，并不占用存储空间，因此，表可以设计的非常稀疏</span></p><h3><strong>2、有关HMaster的作用</strong></h3><p><span style="color:rgb(255,0,0);"> A</span><span style="color:rgb(255,0,0);">、为</span><span style="color:rgb(255,0,0);">Region server</span><span style="color:rgb(255,0,0);">分配</span><span style="color:rgb(255,0,0);">region</span></p><p><span style="color:rgb(255,0,0);"> B</span><span style="color:rgb(255,0,0);">、负责</span><span style="color:rgb(255,0,0);">Region server</span><span style="color:rgb(255,0,0);">的负载均衡</span></p><p><span style="color:rgb(255,0,0);"> C</span><span style="color:rgb(255,0,0);">、发现失效的</span><span style="color:rgb(255,0,0);">Region server</span><span style="color:rgb(255,0,0);">并重新分配其上的</span><span style="color:rgb(255,0,0);">region</span></p><p><span style="color:rgb(255,0,0);"> D</span><span style="color:rgb(255,0,0);">、</span><span style="color:rgb(255,0,0);">HDFS</span><span style="color:rgb(255,0,0);">上的垃圾文件回收</span></p><h3><strong>3、HBase定位region</strong></h3><p><span style="color:rgb(255,0,0);"> A</span><span style="color:rgb(255,0,0);">、通过</span><span style="color:rgb(255,0,0);">zk</span><span style="color:rgb(255,0,0);">里的文件</span><span style="color:rgb(255,0,0);">/hbase/rs</span><span style="color:rgb(255,0,0);">得到</span><span style="color:rgb(255,0,0);">-ROOT-</span><span style="color:rgb(255,0,0);">表的位置。</span><span style="color:rgb(255,0,0);">-ROOT-</span><span style="color:rgb(255,0,0);">表只有一个</span><span style="color:rgb(255,0,0);">region</span></p><p><span style="color:rgb(255,0,0);"> B</span><span style="color:rgb(255,0,0);">、通过</span><span style="color:rgb(255,0,0);">-ROOT-</span><span style="color:rgb(255,0,0);">表查找</span><span style="color:rgb(255,0,0);">.META.</span><span style="color:rgb(255,0,0);">表的第一个表中相应的</span><span style="color:rgb(255,0,0);">region</span><span style="color:rgb(255,0,0);">的位置。其实</span><span style="color:rgb(255,0,0);">-ROOT-</span><span style="color:rgb(255,0,0);">表是</span><span style="color:rgb(255,0,0);">.META.</span><span style="color:rgb(255,0,0);">表的第一个</span><span style="color:rgb(255,0,0);">region</span><span style="color:rgb(255,0,0);">；</span><span style="color:rgb(255,0,0);">.META.</span><span style="color:rgb(255,0,0);">表中的每一个</span><span style="color:rgb(255,0,0);">region</span><span style="color:rgb(255,0,0);">在</span><span style="color:rgb(255,0,0);">-ROOT-</span><span style="color:rgb(255,0,0);">表中都是一行记录</span></p><p><span style="color:rgb(255,0,0);"> C</span><span style="color:rgb(255,0,0);">、通过</span><span style="color:rgb(255,0,0);">.META.</span><span style="color:rgb(255,0,0);">表找到所要的用户表</span><span style="color:rgb(255,0,0);">region</span><span style="color:rgb(255,0,0);">的位置。用户表中的每个</span><span style="color:rgb(255,0,0);">region</span><span style="color:rgb(255,0,0);">在</span><span style="color:rgb(255,0,0);">.META.</span><span style="color:rgb(255,0,0);">表中都是一行记录</span></p>            </div>
                </div>