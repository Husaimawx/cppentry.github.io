---
layout:     post
title:      记一次web服务的调优
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                
<p><span style="font-size:14px;">首先，描述一下环境，简单的web服务，关键日志写入kafka，要求qps达到单机10K即可。</span></p>
<p><span style="font-size:14px;">后面将遇到的问题、解决方案和原理记录如下：</span></p>
<p><span style="font-size:14px;"><br></span></p>
<p><strong><span style="font-size:14px;">1、<span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">内存占用过大，虽然</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">jvm</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">的堆内存设为</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">1G</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">，但进程实际内存使用量达到了</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">12G</span></span></strong></p>
<p><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us"><span style="font-size:14px;">     <strong>解决方案</strong>：<span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">程序中使用了</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">kafka</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">，</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">new</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">出</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">kafka
 producer</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">来向</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">kafka</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">中写日志，调整</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">kafka</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">参数解决，调大了</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">batch.size</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">和</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">partition</span></span></span></p>
<p><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us"><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us"><span style="font-size:14px;">     <strong>原理</strong>：<span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">原因还是</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">batch.size</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">和</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">partition</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">设置过小，导致要发送的数据包过多，都堵在了</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">producer</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">的机器上，而</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">kafka
 producer</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">又使用了</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">zero copy</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">技术，使得占用了大量的内核态内存无法释放，而内核态内存又不是堆内存，不由用户控制，所以出现了进程占用内存过大的情况，</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">kafka</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">版本为</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">0.8.2.2</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">。</span><span lang="zh-cn" style="font-family:Calibri;" xml:lang="zh-cn">（其实这里还存在一点疑问，网上说kafka通信时使用了zerocopy，但我实际跟进代码时，producer使用的是ByteBuffer.allocate，也就是说使用的是堆内存，而没有调用ByteBuffer.allocateDirect创建非堆内存，与网上说的有冲突。如果哪位朋友知道这个问题的原理，还请赐教）</span></span></span></span></p>
<p><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us"><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us"><span lang="zh-cn" style="font-family:Calibri;" xml:lang="zh-cn"><span style="font-size:14px;"><br></span></span></span></span></p>
<p><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us"><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us"><span lang="zh-cn" style="font-family:Calibri;" xml:lang="zh-cn"><strong><span style="font-size:14px;">2、<span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">长时间负载高的情况下，程序性能下降明显，查看</span><span lang="en-us" xml:lang="en-us">GC</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">情况，发现频繁进行</span><span lang="en-us" xml:lang="en-us">full
 gc</span></span></strong></span></span></span></p>
<p><span style="font-size:14px;"><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">       <strong>解决方案</strong>：</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">通过使用</span><span lang="zh-cn" style="font-family:Calibri;" xml:lang="zh-cn">jmap -dump</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">将内存中的对象信息导出到文件，使用</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">jhat</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">命令分析，查出是一个</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">kafka
 callback</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">对象过多，而这个</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">Callback</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">对象包含了一些内容较长的字符串类型的私有变量，导致字符串占了较多内存，而</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">kafka</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">的</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">producer</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">有缓存机制，就会导致</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">Callback</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">对象占据内存无法释放，后来通过删除了</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">Callback</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">的私有变量，将</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">Call</span><span lang="en-us" style="font-family:SimSun;" xml:lang="en-us">back</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">变为单例，来减少了内存占用</span></span></p>
<p lang="en-us" style="font-family:Calibri;" xml:lang="en-us"><span style="font-size:14px;"> </span></p>
<p><strong><span style="font-size:14px;"><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">3</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">、多线程丢数据</span></span></strong></p>
<p><span style="font-family:SimSun;"><span style="font-size:14px;"> <strong>解决方案</strong>：由于有实时性要求，所以不能阻塞，只能通过加大队列长度和子线程的数量的方式 </span></span></p>
<p><span style="font-size:14px;">     <strong>原理</strong>：<span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">主线程向子线程分配任务时，未自己管理</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">BlockingQueue</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">，而是交由操作系统自己管理，向子线程分配任务时，直接分配</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">Callable</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">对象</span></span></p>
<p></p>
<pre><code class="language-java">// 创建线程池
ExecutorService pool = newThreadPoolExecutor(threadPoolSize, threadPoolSize, 0L, TimeUnit.MILLISECONDS,
          newLinkedBlockingQueue&lt;&gt;(queueCapacity));
// 向子线程分配任务
pool.submit(() -&gt;producer.send(new ProducerRecord&lt;&gt;(topic, null, record), kafkaCallback));</code></pre><span style="font-size:14px;"><br><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">由于</span><span lang="en-us" xml:lang="en-us">submit</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">方法调用了</span><span lang="en-us" xml:lang="en-us">BlockingQueue</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">的</span><span lang="en-us" xml:lang="en-us">offer</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">方法来添加，若队列已满，则返回</span><span lang="en-us" xml:lang="en-us">false</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">，而不是阻塞，且会抛出</span><span lang="zh-cn" xml:lang="zh-cn">RejectedExecutionException</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">（</span><span lang="en-us" xml:lang="en-us">RuntimeException</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">的子类），导致抛出异常和数据丢失</span></span>
<p></p>
<p><span style="font-size:14px;"><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">若考虑使用阻塞的方式，则可修改为自己控制</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">BlockingQueue</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">，若不想使用阻塞的方式，则可加大</span><span lang="zh-cn" style="font-family:Calibri;" xml:lang="zh-cn">queueCapacity</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">和</span><span lang="zh-cn" style="font-family:Calibri;" xml:lang="zh-cn">threadPoolSize</span></span></p>
<p style="font-family:Calibri;"><span style="font-size:14px;"> </span></p>
<p><strong><span style="font-size:14px;"><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">4</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">、日志使用</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">log4j</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">记录和写</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">kafka</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">性能差别过大，写日志文件达到</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">3000qps</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">，写</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">kafka</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">能达到</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">11Kqps</span></span></strong></p>
<p><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us"><span style="font-size:14px;">     <strong>解决方案</strong>：改为使用log4j 2.x，或使用kafka</span></span></p>
<p><span style="font-size:14px;"><span lang="zh-cn" xml:lang="zh-cn"><span style="font-family:Calibri;">      </span></span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn"><strong>原理</strong>：通过跟进log4j的代码，发现</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">log4j
 1.x</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">中使用了很多</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">sychronized</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">代码，导致</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">log4j</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">多线程下性能问题严重，改为</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">log4j
 2.x</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">可使</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">qps</span><span lang="zh-cn" style="font-family:SimSun;" xml:lang="zh-cn">提高到</span><span lang="en-us" style="font-family:Calibri;" xml:lang="en-us">10K</span></span></p>
            </div>
                </div>