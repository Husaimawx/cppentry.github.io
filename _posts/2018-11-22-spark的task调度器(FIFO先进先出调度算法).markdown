---
layout:     post
title:      spark的task调度器(FIFO先进先出调度算法)
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								<div class="article-copyright">
					版权声明：本文为博主原创文章，未经博主允许不得转载。					https://blog.csdn.net/u014393917/article/details/50619184				</div>
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                
<h2>FIFO<span style="font-family:SimSun;">先进先出调度</span></h2>
<h3>代码流程</h3>
<p>针对于一个<span style="font-family:'Times New Roman';">FIFO</span><span style="font-family:SimSun;">的调度器</span><span style="font-family:'Times New Roman';">,</span><span style="font-family:SimSun;">调用</span><span style="font-family:'Times New Roman';">addTaskSetManager</span><span style="font-family:SimSun;">函数时(也就是submitTasks时)</span><span style="font-family:'Times New Roman';">.</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(228,228,255);">schedulableBuilder</span><span style="color:#000000;background:rgb(255,255,255);">.addTaskSetManager(manager</span><span style="color:#cc7832;background:rgb(255,255,255);">, </span><span style="color:#000000;background:rgb(255,255,255);">manager.taskSet.properties)</span></p>
<p style="background:rgb(255,255,255);"><span style="background:rgb(255,255,255);">override def </span><span style="color:#000000;background:rgb(255,255,255);">addTaskSetManager(manager: Schedulable</span><span style="color:#cc7832;background:rgb(255,255,255);">, </span><span style="color:#000000;background:rgb(255,255,255);">properties: Properties) {</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  rootPool.addSchedulable(manager)</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">}</span></p>
<p>而在<span style="font-family:'Times New Roman';">Pool</span><span style="font-family:SimSun;">实例中</span><span style="font-family:'Times New Roman';">,addSchedulable</span><span style="font-family:SimSun;">函数的实现为</span><span style="font-family:'Times New Roman';">:</span></p>
<p>函数传入的参数为一个<span style="font-family:'Times New Roman';">Schedulable</span><span style="font-family:SimSun;">的实例</span><span style="font-family:'Times New Roman';">,</span><span style="font-family:SimSun;">这个实例就是一个</span><span style="font-family:'Times New Roman';">TaskSetManager.</span></p>
<p style="background:rgb(255,255,255);"><span style="background:rgb(255,255,255);">override def </span><span style="color:#000000;background:rgb(255,255,255);">addSchedulable(schedulable: Schedulable) {</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="color:#000000;background:rgb(255,255,255);">require</span><span style="color:#000000;background:rgb(255,255,255);">(schedulable != </span><span style="background:rgb(255,255,255);">null</span><span style="color:#000000;background:rgb(255,255,255);">)</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">添加到调度的队列中.</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">schedulableQueue</span><span style="color:#000000;background:rgb(255,255,255);">.add(schedulable)</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">schedulableNameToSchedulable</span><span style="color:#000000;background:rgb(255,255,255);">.put(schedulable.name</span><span style="color:#cc7832;background:rgb(255,255,255);">, </span><span style="color:#000000;background:rgb(255,255,255);">schedulable)</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  schedulable.parent = </span><span style="background:rgb(255,255,255);">this</span><span style="background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">}</span></p>
<p> </p>
<p style="background:rgb(255,255,255);">在执行task向executor发起启动时,会调用Pool实例中的<span style="color:#000000;background:rgb(228,228,255);">getSortedTaskSetQueue</span>函数,这个函数根据调度算法来得到一组需要进行调度的TaskSetManager.</p>
<p style="background:rgb(255,255,255);"><span style="background:rgb(255,255,255);">override def </span><span style="color:#000000;background:rgb(255,255,255);">getSortedTaskSetQueue: ArrayBuffer[TaskSetManager] = {</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">var </span><span style="color:#000000;background:rgb(255,255,255);">sortedTaskSetQueue = </span><span style="background:rgb(255,255,255);">new </span><span style="color:#000000;background:rgb(255,255,255);">ArrayBuffer[TaskSetManager]</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">这里通过调度算法对队列进行排序,然后迭代排序后的集合,按优先级返回给调用方进行task的启动.</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">val </span><span style="color:#000000;background:rgb(255,255,255);">sortedSchedulableQueue =</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">   </span><span style="background:rgb(255,255,255);">schedulableQueue</span><span style="color:#000000;background:rgb(255,255,255);">.asScala.toSeq.sortWith(</span><span style="background:rgb(255,255,255);">taskSetSchedulingAlgorithm</span><span style="color:#000000;background:rgb(255,255,255);">.comparator)</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">for </span><span style="color:#000000;background:rgb(255,255,255);">(schedulable &lt;- sortedSchedulableQueue) {</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">    sortedTaskSetQueue ++= schedulable.getSortedTaskSetQueue</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  }</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  sortedTaskSetQueue</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">}</span></p>
<p style="background:rgb(255,255,255);">接下来看看FIFO的调度算法,如果从队列中得到需要进行调度的TaskSetManager集合.先看看在fifo的算法的comparator如何对队列进行排序的代码实现.</p>
<p style="background:rgb(255,255,255);"><span style="background:rgb(255,255,255);">private</span><span style="color:#000000;background:rgb(255,255,255);">[spark] </span><span style="background:rgb(255,255,255);">class </span><span style="color:#000000;background:rgb(255,255,255);">FIFOSchedulingAlgorithm </span><span style="background:rgb(255,255,255);">extends </span><span style="color:#000000;background:rgb(255,255,255);">SchedulingAlgorithm {</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">override def </span><span style="color:#000000;background:rgb(255,255,255);">comparator(s1: Schedulable</span><span style="color:#cc7832;background:rgb(255,255,255);">, </span><span style="color:#000000;background:rgb(255,255,255);">s2: Schedulable): </span><span style="color:#cc7832;background:rgb(255,255,255);">Boolean </span><span style="color:#000000;background:rgb(255,255,255);">= {</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">    </span><span style="background:rgb(255,255,255);">val </span><span style="color:#000000;background:rgb(255,255,255);">priority1 = s1.priority</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">    </span><span style="background:rgb(255,255,255);">val </span><span style="color:#000000;background:rgb(255,255,255);">priority2 = s2.priority</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">先计算两个tasksetmanager的优先级,math.signum函数如果传入的值大于0,返回1,小于0返回-1,等于0返回0.这里算出优先级最大的一个tasksetmanager,priority的值越小,优先级越高.</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">    </span><span style="background:rgb(255,255,255);">var </span><span style="color:#000000;background:rgb(255,255,255);">res = math.</span><span style="color:#000000;background:rgb(255,255,255);">signum</span><span style="color:#000000;background:rgb(255,255,255);">(priority1 - priority2)</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">    </span><span style="background:rgb(255,255,255);">if </span><span style="color:#000000;background:rgb(255,255,255);">(res == </span><span style="background:rgb(255,255,255);">0</span><span style="color:#000000;background:rgb(255,255,255);">) {</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">如果两个tasksetmanager的优先级相同,</span><span style="color:#000000;background:rgb(255,255,255);">比较两个tasksetmanager中的stageId,这个stageId越早造成的,那么这个值也就越小,这里计算出优先级,stageId越小的的taskset优先级也就越高.</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">      </span><span style="background:rgb(255,255,255);">val </span><span style="color:#000000;background:rgb(255,255,255);">stageId1 = s1.stageId</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">      </span><span style="background:rgb(255,255,255);">val </span><span style="color:#000000;background:rgb(255,255,255);">stageId2 = s2.stageId</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">      res = math.</span><span style="color:#000000;background:rgb(255,255,255);">signum</span><span style="color:#000000;background:rgb(255,255,255);">(stageId1 - stageId2)</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">    }</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">    </span><span style="background:rgb(255,255,255);">if </span><span style="color:#000000;background:rgb(255,255,255);">(res &lt; </span><span style="background:rgb(255,255,255);">0</span><span style="color:#000000;background:rgb(255,255,255);">) {</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">      </span><span style="background:rgb(255,255,255);">true</span><span style="background:rgb(255,255,255);"><br></span><span style="background:rgb(255,255,255);">    </span><span style="color:#000000;background:rgb(255,255,255);">} </span><span style="background:rgb(255,255,255);">else </span><span style="color:#000000;background:rgb(255,255,255);">{</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">      </span><span style="background:rgb(255,255,255);">false</span><span style="background:rgb(255,255,255);"><br></span><span style="background:rgb(255,255,255);">    </span><span style="color:#000000;background:rgb(255,255,255);">}</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  }</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">}</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);"> </span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">上面的代码中,得到taskset的优先级是直接通过Schedulable的proiority得到的,也这个Schedulable的实现是TaskSetManager,接下来看看TaskSetManager中如何生成的针对这个stage的所有的task的优先级,实现代码如下:</span></p>
<p style="background:rgb(255,255,255);"><span style="background:rgb(255,255,255);">var </span><span style="background:rgb(255,255,255);">priority </span><span style="color:#000000;background:rgb(255,255,255);">= taskSet.priority</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="background:rgb(255,255,255);">var </span><span style="background:rgb(255,255,255);">stageId </span><span style="color:#000000;background:rgb(255,255,255);">= taskSet.stageId</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(228,228,255);"> </span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(228,228,255);"> </span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">从上面的代码中可以看到priority与stageId的值TaskSetManager中得到是直接通过此manager生成时传入的taskSet实例得到的.因此我们还需要看看TaskSet中如何生成的优先级.</span></p>
<p style="background:rgb(255,255,255);"><span style="background:rgb(255,255,255);">private</span><span style="color:#000000;background:rgb(255,255,255);">[spark] </span><span style="background:rgb(255,255,255);">class </span><span style="color:#000000;background:rgb(255,255,255);">TaskSet(</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">    </span><span style="background:rgb(255,255,255);">val </span><span style="color:#000000;background:rgb(255,255,255);">tasks: Array[Task[_]]</span><span style="color:#cc7832;background:rgb(255,255,255);">,</span><span style="color:#cc7832;background:rgb(255,255,255);"><br></span><span style="color:#cc7832;background:rgb(255,255,255);">    </span><span style="background:rgb(255,255,255);">val </span><span style="color:#000000;background:rgb(255,255,255);">stageId: </span><span style="color:#cc7832;background:rgb(255,255,255);">Int,</span><span style="color:#cc7832;background:rgb(255,255,255);"><br></span><span style="color:#cc7832;background:rgb(255,255,255);">    </span><span style="background:rgb(255,255,255);">val </span><span style="color:#000000;background:rgb(255,255,255);">stageAttemptId: </span><span style="color:#cc7832;background:rgb(255,255,255);">Int,</span><span style="color:#cc7832;background:rgb(255,255,255);"><br></span><span style="color:#cc7832;background:rgb(255,255,255);">    </span><span style="background:rgb(255,255,255);">val </span><span style="color:#000000;background:rgb(255,255,255);">priority: </span><span style="color:#cc7832;background:rgb(255,255,255);">Int,</span><span style="color:#cc7832;background:rgb(255,255,255);"><br></span><span style="color:#cc7832;background:rgb(255,255,255);">    </span><span style="background:rgb(255,255,255);">val </span><span style="color:#000000;background:rgb(255,255,255);">properties: Properties) {</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">而在TaskSet中,stageId与priority都是由生成此TaskSet实例时,直接传入的.而TaskSet的实例生成由DAGScheduler中在调用TaskSchedulerImpl中的submitTasks时,会生成此实例.</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(228,228,255);">taskScheduler</span><span style="color:#000000;background:rgb(255,255,255);">.submitTasks(</span><span style="background:rgb(255,255,255);">new </span><span style="color:#000000;background:rgb(255,255,255);">TaskSet(</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  tasks.toArray</span><span style="color:#cc7832;background:rgb(255,255,255);">, </span><span style="color:#000000;background:rgb(255,255,255);">stage.id</span><span style="color:#cc7832;background:rgb(255,255,255);">, </span><span style="color:#000000;background:rgb(255,255,255);">stage.latestInfo.attemptId</span><span style="color:#cc7832;background:rgb(255,255,255);">, </span><span style="color:#000000;background:rgb(255,255,255);">jobId</span><span style="color:#cc7832;background:rgb(255,255,255);">, </span><span style="color:#000000;background:rgb(255,255,255);">properties))</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);"> </span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">由上面的代码可以看到,taskSet的实例中stageId就是对应此stage的id,priority的值是提交这次action动作时的jobId的值.</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);"> </span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">最后在说明一下:</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">每一次在执行spark的action时,会生成一个job,这个job会生成一个向后递增的jobId的值,在同一个任务中,每执行一次action就会生成一个job,每一个job的id会向后递加.</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">在一个action中,根据执行这个action的rdd,向上找依赖,如果向上的rdd的依赖中包含有shuffle的依赖时,会生成一个stage,每一个stage的id也是向后递增的一个过程.</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">因此,在spark中FIFO的调度算法中,根据生成JOB的先后顺序,先生成的JOB(对应SPARK中代码就是先执行的ACTION)先进行调度,如果在同一个JOB中,包含有多个STAGE时,最上层的STAGE最先被调度.</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);"> </span></p>
<h3>示例代码说明</h3>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">示例代码:</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">Val hadoopRdd = sc.textfile(“/xxx/xx”)</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">Val records = hadoopRDD.count()</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">Val filterRDD = hadoopRdd.filter(kv =&gt; kv._1.equals(‘hehe’)).map(kv =&gt; kv._1 -&gt; 1)</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">Val reduceRDD = filterRDD.reduceByKey(_ + _)</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">Val results = reduceRDD.filter(kv =&gt; kv._2 &gt; 5).collect()</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);"> </span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">调度流程(linux的系统,没办法画图):</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">1.</span><span style="color:#000000;background:rgb(255,255,255);">在hadoopRDD.count执行时,生成一个jobId:1,并解析这个job中的stage,此时这个job中并没有需要执行的shuffle操作,生成ResultStage,stageid:1,针对这个任务调度,只有一个stage,直接调度.</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">2.</span><span style="color:#000000;background:rgb(255,255,255);">在reduceRDD.filter.collect执行时,生成一个jobId:2,解析这个job时,由于这个job对应的rdd包含有上层的shuffle的RDD的依赖(reduceByKey),因此这个job中需要生成两个STAGE,一个为ShuffleStage,一个为ResultStage,对应的stageId分别为2,3两个,并分别生成Taskset,这个时候针对这个JOB的调度时,首先比较两个TaskSet的jobid,由于这是在一个job内,因此,jobId相同,接下来调度开始比较两个stage的stageid, shuffleStage的stageId为2,ResultStage的stageId为3,因此,调度算法排序后,Taskset的队列为ShuffleStage的TaskSet比ResultStage的TaskSet先被执行.</span></p>
            </div>
                </div>