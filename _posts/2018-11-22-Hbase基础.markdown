---
layout:     post
title:      Hbase基础
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								<div class="article-copyright">
					版权声明：本文为博主原创文章，未经博主允许不得转载。					https://blog.csdn.net/u012893747/article/details/77331490				</div>
								            <div id="content_views" class="markdown_views prism-atom-one-dark">
							<!-- flowchart 箭头图标 勿删 -->
							<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path></svg>
							<p>一、Hbase概念</p>

<pre><code>    Hbase是一个高可靠、高性能、面向列、可伸缩的分布式数据库，利用hBase技术可以在廉价pc上搭建大规模结构化数据集群。Hbase参考Google的BigTable建模，使用类似GFS的HDFS作为底层文件存储系统，在其上可以运行MapReduce批量处理数据，使用Zookeeper作为协同服务组件。
</code></pre>

<p>二、Hbase特性</p>

<pre><code>Hbase作为一个典型的NoSQL数据库，可以通过行健检索数据，仅支持单行事务，主要用于存储非结构化数据和半结构化的松散数据，

    1.容量巨大
        Habse的单标可以有百亿行、百万列，数据矩阵横向和纵向两个维度所支持的数据量级都非常具有弹性。
    2.面向列
        Hbase是面向列的存储和权限控制，并支持列独立检索。
            列式数据库特性：
                1）数据按列存储，即每一列单独存放
                2）数据即索引
                3）只访问查询涉及的列，可以大量降低系统IO
                4）每一列由一个线索来处理，即查询的并发处理性能高
                5）数据类型一致，数据特征相似，可以高效压缩
    3.稀疏性
        传统数据库中为NULL的列占用存储空间，造成存储空间浪费，而Hbase中为NULL的列不占用存储空间，因此，表可以设计的非常稀疏
    4.扩展性
        Hbase底层文件存储依赖HDFS，因此Hbase具备可扩展性。Hbase的扩展是热扩展，在不停止现有服务的前提下，可以随时添加或减少节点。
    5.高可靠性
        Hbase提供了WAL和Replication机制。前者保证了数据写入时不会因集群异常而导致写入数据的丢失；后者保证了在集群出现严重问题时数据不会发生丢失或者损坏。
    6.高性能
        底层的LSM数据结构和RowKey有序排列等架构上的独特设计，使得Hbase具有非常高的写入性能。Region切分、主键索引和缓存机制使得Hbase在海量数据下具备一定的随机读取性能，改性能针对RowKey的查询能达到毫秒级。
</code></pre>

<p>三、Hbase数据模型</p>

<pre><code>Hbase是一种列式存储的分布式数据库，其核心概念是表。与传统的关系型数据库一样，表由行和列组成，但Hbase同一列可以存储不同时刻的值，同时多个列可以组成一个列族。

表：
    在Hbase中数据以标的形式存储，同一个表中的数据通常是相关的，通过列族进一步把一些列组织在一起进行访问。
    Hbase列式存储格式允许用户存储大量的信息在相同的表中，而在RDBMS模型中，大量信息则需要切分成多个表存储。
    Hbase创建表时，需要指定表名和至少一个列族，。列族影响表的无力存储结构，创建表后列族还可以更改，只是比较麻烦。

行健（RowKey）：
    行健是不可分割的字节数组，行健是按字典排序由低到高存储在表中的，一亿个空的数组来标识表空间的其实或者结尾。
    RowKey被冗余存储，所以长度不宜过长，过长的RowKey将会占用大量的空间同时会降低检索效率。
    RowKey应该尽量分布均匀，这样不会产生热点现象。
    RowKey在设计上必须保证唯一性。

列族：
    Hbase中的列族是一些列的集合。一个列族中所有的列成员有着相同的前缀。
    冒号（:）是列族的分隔符，用来区分列族前缀和列名。
    在物理上一个列族的成员在文件系统都是存储在一起的。因为存储优化都是针对列族级别的，这就意味着，一个列族的所有成员都是通过相同的方式访问的。
    在创建表的时候至少要指定一个列族，新的列族可以随后按需动态的添加，但是修改列族要先停用表。
    应该将经常一起查询的列放到同一个列族中，合理的划分列族将减少查询时加载到缓存的数据，提高查询的效率。但是页不要有太多的列族，因为跨列族访问是非常低效的。

单元格：
    Hbase中的单元格由行健、列族、列、时间戳唯一确定。
    单元格的内容是不可分隔的字节数组。
    每个单元格都保存着同一份数据的多个版本，不同时间版本的数据按照时间顺序倒序排序，最新的时间排在最前面，时间戳是64位的整数，可以由客户端在写入数据时赋值也可以由RegionServer自动赋值。
</code></pre>

<p>四、数据模型的操作</p>

<pre><code>Hbase对数据模型的四个操作主要是Get、Put、Scan和Delete。通过实例进行操作，用户可以完成向Hbase存储和检索数据，以及删除无效数据之类的操作。
所有修改数据的操作都必须保证行级别的原子性，多个客户端或线程对同一行的读写操作都不会影响该数据的原子性，要么读到最新的数据，要么等待系统允许写入该行的修改。

读Get:
    Get操作是指从客户端API中获取已存储数据的方法。HTable类中提供了get（）方法，同时还有与之对应的Get类，Get操作返回一行或多行数据。
    get（）方法默认一次取回该行全部列的数据，我们可以限定只取回某个列族对应的列的数据，或者进一步限定只取回某些列的数据。
    当用户使用get（）方法获取数据时，Hbase返回的结果包含所有匹配的单元格数据，这些数据将被封装在一个Result的实例中返回给用户。用Result类提供的方法，可以从服务器端获取匹配指定行的特定返回值。这些值包括列族、列限定符和时间戳等。

写Put：
    Put操作要么向表增加新行（Key不存在），要么更新行（Key已存在）。
    Put可以一次向表中插入一行数据，也可以一次操作一个集合，同时向表中写入多行数据。如果要频繁的修改某些数据，用户应该创建一个RowLock实例来防止其他用户对该数据进行修改。
    Put操作每次都会发起一次到服务器的RPC操作，如果有大量的数据要写入表中，就会有数千次的RPC操作，这样会导致效率很低。Hbase客户端有一个缓冲区，负责将数据批量的仅通过一次RPC操作发送到服务器端，这样可以大大提高写入性能，默认客户端写缓冲区是关闭的，需要显示打开该选项。
    当将一个Put集合提交到服务端的时候，可能会出现部分成功或部分失败的可能，失败的数据会被保存到缓冲区中进行重试。
    Hbase还提供了一个compare-and-set操作，这个操作先进行检查，条件满足后在执行，这个操作对于行是原子性的。

扫描（Scan）：
    Scan操作允许多行特定属性迭代，其实用与get（）方法非常类似。
    Scan操作执行后将得到一个执行结果，该结果被封装在一个ResultScanner实例中。

删除（Delete）：
    Delete用于从表中删除数据。HTable除了提供删除方法delete（）方法只外，还有一个与之对应的Delete类，用户可以通过多中方法限定要删除的列。
    Hbase的delete操作可以指定删除某个列族或者某个列，或者指定某个时间戳，删除比这个时间早的数据。
    Hbase的delete操作并不是正真从磁盘删除数据，而是通过创建墓碑标志进行处理。这些墓碑标记的值和小于该时间版本的单元格在大合并时被清除。
</code></pre>

<p>五、数据模型的特殊属性</p>

<pre><code>1.版本
    RowKey（行健）、Column（列族和列）、Version（版本）组合在一起成为Hbase中的一个单元格，但是因为有可能会有很多单元格的行和列式相同的，因此要区分不同的单元格可以使用版本。
    RowKey和Column的值是用字节数组表示的，而Version则使用一个长整型表示，这个长整型值是使用java.util.Date.getTime()或者System.currentTimeMillis()产生的这就意味着它的含义是“当前时间和1970-01-01 UTC的时间差，单位毫秒”。
    在Hbase中，版本是按倒序排列的，因此读取这个文件的时候，最先找到的是最近的版本。

2，排序
    Get和Scan操作返回的都是经过排序的数据。列在服务器端也是字典排序的，所以按照名称的字典顺序返回。总体来说，返回的数据首先按字典序排序，其次是列族，然后是列修饰符，最后是时间戳反向排序，最新的在最前面。

3.列的元数据
    对于Hbase表中的列族，除了KeyValue实例以外，没有关于元数据的描述，KeyValue对象表示Hbase的最小单位是cell。Hbase的表不仅在一行中支持许多列，而且支持行之间有不同的列，所以需要单独维护行和列之间的关系。获取列族完整列名的唯一方法就是处理所有行。

4.连接查询
    Hbase不支持连接查询，用户想要在应用中实现连接查询，必须要自己实现。

5.计数器
    ICV是Hbase的计数器，可以使用它完成一些诸如计算页面浏览量的操作。ICV操作发生在RegionServer上，而不是在客户端，所以速度快，使用方式也没有那么繁琐。

6.原子操作
    类似Java的原子类，HTableInterface接口也提供checkAndPut和checkAndDelete方法。

7.事务特性ACID
    Hbase数据库仅提供对行级别的原子性保证，也就是说同时对同一个Key下的数据进行两个操作，在实际执行的时候会串行的执行，保证了没一个KeyValue对不会被破坏。
    Hbase不是一个具备完整ACID特性的数据库，它只是实现了某些属性。
    HbaseACID设计原则：
        1）对于同一行所有列的修改是原子性的，对于该行的put操作要么整体成功要么整体失败。
        2）一个返回成功标志的操作肯定是完全成功的。
        3）一个返回失败标志的操作肯定是完全失败的。
        4）超时的操作可能成功也可能失败。但不会是部分成功或失败。
        5）对于同一行跨多个列族的的操作也遵循上面的原则。
        6）多行操作不能保证原子性
        7）checkAndPut是原子性的
        8）批量修改操作不能跨越多行
        9）所有修改操作是保证顺序的
        10）一致性和隔离性。通过API得到的行的数据是一个完整的行，数据由表中某个时刻的数据构成
        11）持久性。所有可以读取到的数据保证都是已经被持久化到磁盘上的。也就是说不会读到没有写到磁盘上的数据。所有返回成功操作的数据都是处于持久化到磁盘上的。返回失败的都没有持久化。

8.行锁
    Hbase API中put()、delete()、checkAndPut()等修改操作是独立执行的这意味着在一个串行方式的执行中，对于每一行必须保证行级别的操作是原子性的。RegionServer提供了一个行锁特性，这个特性保证了只有一个客户端能获取一行数据相应的锁，同时对该行进项修改。

9.自动分区
    Hbase中的一个表的数据会被划分成很多Region，Region可以动态扩展，而且Hbase保证Region的负载均衡。Region实际上是行健排序后的按规则分割的连续的存储空间。如果Region太大会被动态拆分，相反，多个Region会合并成一个较大的Region。
</code></pre>            </div>
						<link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-9e5741c4b9.css" rel="stylesheet">
                </div>