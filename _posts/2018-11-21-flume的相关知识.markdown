---
layout:     post
title:      flume的相关知识
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                一、Flume<br>1.概述<br><span style="white-space:pre;">	</span>flume是分布式的，可靠的，用于从不同的来源有效收集 聚集 和 移动 大量的日志数据用以集中式管理的系统。<br><span style="white-space:pre;">	</span>是apache的一个顶级项目<br><br><br><span style="white-space:pre;">	</span>系统需求：<br><span style="white-space:pre;">		</span>jdk6以上，推荐java7<br><span style="white-space:pre;">	</span><br>2.下载安装flume<br><span style="white-space:pre;">	</span>（1）下载<br><span style="white-space:pre;">		</span>可以apache官网下载flume的安装包<br><span style="white-space:pre;">		</span>下载时注意，flume具有两个版本，0.9.x和1.x,两个版本并不兼容，我们学习的是最新的1.x版本，也叫flume-ng版本。<br><span style="white-space:pre;">	</span>（2）安装<br><span style="white-space:pre;">		</span>解压到指定目录即可<br><br><br>3.概念、模型和特点<br><span style="white-space:pre;">	</span>Flume Event - Flume 事件 - 被定义为一个具有有效荷载的字节数据流和可选的字符串属性集。<br><span style="white-space:pre;">	</span>Flume Agent- Flume 代理 - 是一个进程承载从外部源事件流到下一个目的地的过程。包含source channel 和 sink<br><span style="white-space:pre;">	</span>Source - 数据源 - 消耗外部传递给他的事件，外部源将数据按照Flume Source 能识别的格式将Flume事件发送给Flume Source<br><span style="white-space:pre;">	</span>Channel - 数据通道 -  是一个被动的存储，用来保持事件，直到由一个Flume Sink消耗。<br><span style="white-space:pre;">	</span>Sink - 数据汇聚点 - 代表外部数据存放位置。发送flume中的事件到指定的外部目标。<br><br><br><span style="white-space:pre;">	</span>复杂流动<br><span style="white-space:pre;">		</span>Flume允许用户进行多级流动到最终目的地，也允许扇出流(一到多)、扇入流(多到一)的流动和故障转移、失败处理。<br><span style="white-space:pre;">	</span>可靠性<br><span style="white-space:pre;">		</span>事务型的数据传递，保证数据的可靠性。<br><span style="white-space:pre;">	</span>可恢复<br><span style="white-space:pre;">		</span>通道可以以内存或文件的方式实现，内存更快，但是不可恢复，文件比较慢但提供了可恢复性。<br><br><br>4.入门案例<br><span style="white-space:pre;">	</span>首先需要通过一个配置文件来配置Agent。<br><span style="white-space:pre;">	</span>通过flume提供的工具启动agent就可以工作了。<br><br><br><span style="white-space:pre;">	</span>(1)编写配置文件<br><span style="white-space:pre;">		</span>#example.conf：单节点Flume配置<br><span style="white-space:pre;">		</span>#命名Agent a1的组件<br><span style="white-space:pre;">		</span>a1.sources  =  r1<br><span style="white-space:pre;">		</span>a1.sinks  =  k1<br><span style="white-space:pre;">		</span>a1.channels  =  c1<br><br><br><span style="white-space:pre;">		</span>#描述/配置Source<br><span style="white-space:pre;">		</span>a1.sources.r1.type  =  netcat<br><span style="white-space:pre;">		</span>a1.sources.r1.bind  =  0.0.0.0<br><span style="white-space:pre;">		</span>a1.sources.r1.port  =  44444<br><br><br><span style="white-space:pre;">		</span>#描述Sink<br><span style="white-space:pre;">		</span>a1.sinks.k1.type  =  logger<br><br><br><span style="white-space:pre;">		</span>#描述内存Channel<br><span style="white-space:pre;">		</span>a1.channels.c1.type  =  memory<br><span style="white-space:pre;">		</span>a1.channels.c1.capacity  =  1000 <br><span style="white-space:pre;">		</span>a1.channels.c1.transactionCapacity  =  100<br><br><br><span style="white-space:pre;">		</span>#为Channle绑定Source和Sink<br><span style="white-space:pre;">		</span>a1.sources.r1.channels  =  c1<br><span style="white-space:pre;">		</span>a1.sinks.k1.channel  =  c1<br><br><br><span style="white-space:pre;">		</span>**一个配置文件中可以配置多个Agent，一个Agent中可以包含多个Source Sink Channel<br><span style="white-space:pre;">		</span>**一个Source 可以绑定到多个通道，一个Sink只能绑定到一个通道<br><br><br><span style="white-space:pre;">	</span>(2)通过flume的工具启动agent<br><span style="white-space:pre;">		</span>$ bin/flume-ng agent --conf ../conf --conf-file ../conf/example.conf --name a1 -Dflume.root.logger=INFO,console<br><span style="white-space:pre;">	</span><br><span style="white-space:pre;">	</span>(3)在windows中通过telnet命令连接flume所在机器的44444端口发送数据。<br><span style="white-space:pre;">		</span>发现，flume确实收集到了该信息。<br><br><br>5.Source<br><span style="white-space:pre;">	</span>!!!1.Avro Source<br><span style="white-space:pre;">		</span>监听AVRO端口来接受来自外部AVRO客户端的事件流。<br><span style="white-space:pre;">		</span>利用Avro Source可以实现多级流动、扇出流、扇入流等效果。<br><span style="white-space:pre;">		</span>另外也可以接受通过flume提供的Avro客户端发送的日志信息。<br><br><br><br><br><span style="white-space:pre;">		</span>支持的属性:<br><span style="white-space:pre;">			</span>!channels<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span> <br><span style="white-space:pre;">			</span>!type<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>类型名称，"AVRO"<br><span style="white-space:pre;">			</span>!bind<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>需要监听的主机名或IP<br><span style="white-space:pre;">			</span>!port<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>要监听的端口<br><span style="white-space:pre;">			</span>threads<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>工作线程最大线程数<br><span style="white-space:pre;">			</span>selector.type<span style="white-space:pre;">	</span> <span style="white-space:pre;">	</span> <br><span style="white-space:pre;">			</span>selector.*<span style="white-space:pre;">	</span> <span style="white-space:pre;">	</span> <br><span style="white-space:pre;">			</span>interceptors<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>空格分隔的拦截器列表<br><span style="white-space:pre;">			</span>interceptors.*<span style="white-space:pre;">	</span> <span style="white-space:pre;">	</span> <br><span style="white-space:pre;">			</span>compression-type<span style="white-space:pre;">	</span>none<span style="white-space:pre;">	</span>压缩类型，可以是“none”或“default”，这个值必须和AvroSource的压缩格式匹配<br><span style="white-space:pre;">			</span>ssl<span style="white-space:pre;">	</span>false<span style="white-space:pre;">	</span>是否启用ssl加密，如果启用还需要配置一个“keystore”和一个“keystore-password”.<br><span style="white-space:pre;">			</span>keystore<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>为SSL提供的 java密钥文件 所在路径<br><span style="white-space:pre;">			</span>keystore-password<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>为SSL提供的 java密钥文件 密码<br><span style="white-space:pre;">			</span>keystore-type<span style="white-space:pre;">	</span>JKS<span style="white-space:pre;">	</span>密钥库类型可以是 “JKS” 或 “PKCS12”.<br><span style="white-space:pre;">			</span>exclude-protocols<span style="white-space:pre;">	</span>SSLv3<span style="white-space:pre;">	</span>空格分隔开的列表，用来指定在SSL / TLS协议中排除。SSLv3将总是被排除除了所指定的协议。<br><span style="white-space:pre;">			</span>ipFilter<span style="white-space:pre;">	</span>false<span style="white-space:pre;">	</span>如果需要为netty开启ip过滤，将此项设置为true<br><span style="white-space:pre;">			</span>ipFilterRules<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>陪netty的ip过滤设置表达式规则<br><span style="white-space:pre;">	</span><br><span style="white-space:pre;">		</span>案例：<br><span style="white-space:pre;">			</span>编写配置文件：<br><span style="white-space:pre;">				</span>＃命名Agent a1的组件<br><span style="white-space:pre;">				</span>a1.sources  =  r1<br><span style="white-space:pre;">				</span>a1.sinks  =  k1<br><span style="white-space:pre;">				</span>a1.channels  =  c1<br><br><br><span style="white-space:pre;">				</span>＃描述/配置Source<br><span style="white-space:pre;">				</span>a1.sources.r1.type  =  avro<br><span style="white-space:pre;">				</span>a1.sources.r1.bind  =  0.0.0.0<br><span style="white-space:pre;">				</span>a1.sources.r1.port  =  33333<br><br><br><span style="white-space:pre;">				</span>＃描述Sink<br><span style="white-space:pre;">				</span>a1.sinks.k1.type  =  logger<br><span style="white-space:pre;">				</span>＃描述内存Channel<br><span style="white-space:pre;">				</span>a1.channels.c1.type  =  memory<br><span style="white-space:pre;">				</span>a1.channels.c1.capacity  =  1000<br><span style="white-space:pre;">				</span>a1.channels.c1.transactionCapacity  =  100<br><br><br><span style="white-space:pre;">				</span>＃为Channle绑定Source和Sink<br><span style="white-space:pre;">				</span>a1.sources.r1.channels  =  c1<br><span style="white-space:pre;">				</span>a1.sinks.k1.channel  =  c1<br><span style="white-space:pre;">			</span>启动flume：<br><span style="white-space:pre;">				</span>./flume-ng agent --conf ../conf --conf-file ../conf/template2.conf --name a1 -Dflume.root.logger=INFO,console<br><span style="white-space:pre;">			</span>通过flume提供的avro客户端向指定机器指定端口发送日志信息：<br><span style="white-space:pre;">				</span>./flume-ng avro-client --conf ../conf --host 0.0.0.0 --port 33333 --filename ../mydata/log1.txt<br><span style="white-space:pre;">			</span>发现确实收集到了日志<br><br><br><span style="white-space:pre;">	</span>2.Exec Source<br><span style="white-space:pre;">		</span>可以将命令产生的输出作为源<br><br><br><span style="white-space:pre;">		</span>属性说明：<br><span style="white-space:pre;">			</span>!channels<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span> <br><span style="white-space:pre;">			</span>!type<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>类型名称，需要是"exec"<br><span style="white-space:pre;">			</span>!command<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>要执行的命令<br><span style="white-space:pre;">			</span>shell<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>A shell invocation used to run the command. e.g. /bin/sh -c. Required only for commands relying on shell features like wildcards, back ticks, pipes etc.<br><span style="white-space:pre;">			</span>restartThrottle<span style="white-space:pre;">	</span>10000<span style="white-space:pre;">	</span>毫秒为单位的时间，用来声明等待多久后尝试重试命令<br><span style="white-space:pre;">			</span>restart<span style="white-space:pre;">	</span>false<span style="white-space:pre;">	</span>如果cmd挂了，是否重启cmd<br><span style="white-space:pre;">			</span>logStdErr<span style="white-space:pre;">	</span>false<span style="white-space:pre;">	</span>无论是否是标准错误都该被记录<br><span style="white-space:pre;">			</span>batchSize<span style="white-space:pre;">	</span>20<span style="white-space:pre;">	</span>同时发送到通道中的最大行数<br><span style="white-space:pre;">			</span>batchTimeout<span style="white-space:pre;">	</span>3000<span style="white-space:pre;">	</span>如果缓冲区没有满，经过多长时间发送数据<br><span style="white-space:pre;">			</span>selector.type<span style="white-space:pre;">	</span>复制还是多路复用<br><span style="white-space:pre;">			</span>selector.*<span style="white-space:pre;">	</span> <span style="white-space:pre;">	</span>Depends on the selector.type value<br><span style="white-space:pre;">			</span>interceptors<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>空格分隔的拦截器列表<br><span style="white-space:pre;">			</span>interceptors.*<span style="white-space:pre;">	</span> <span style="white-space:pre;">	</span> <br><span style="white-space:pre;">		</span>案例：<br><span style="white-space:pre;">			</span>编写配置文件：<br><span style="white-space:pre;">				</span>＃命名Agent a1的组件<br><span style="white-space:pre;">				</span>a1.sources  =  r1<br><span style="white-space:pre;">				</span>a1.sinks  =  k1<br><span style="white-space:pre;">				</span>a1.channels  =  c1<br><br><br><span style="white-space:pre;">				</span>＃描述/配置Source<br><span style="white-space:pre;">				</span>a1.sources.r1.type  =  exec<br><span style="white-space:pre;">				</span>a1.sources.r1.bind  =  0.0.0.0<br><span style="white-space:pre;">				</span>a1.sources.r1.port  =  33333<br><span style="white-space:pre;">				</span>a1.sources.r1.command = ls /etc<br><br><br><span style="white-space:pre;">				</span>＃描述Sink<br><span style="white-space:pre;">				</span>a1.sinks.k1.type  =  logger<br><span style="white-space:pre;">				</span>＃描述内存Channel<br><span style="white-space:pre;">				</span>a1.channels.c1.type  =  memory<br><span style="white-space:pre;">				</span>a1.channels.c1.capacity  =  1000<br><span style="white-space:pre;">				</span>a1.channels.c1.transactionCapacity  =  100<br><br><br><span style="white-space:pre;">				</span>＃为Channle绑定Source和Sink<br><span style="white-space:pre;">				</span>a1.sources.r1.channels  =  c1<br><span style="white-space:pre;">				</span>a1.sinks.k1.channel  =  c1<br><br><br><span style="white-space:pre;">			</span>启动flume：<br><span style="white-space:pre;">				</span>./flume-ng agent --conf ../conf --conf-file ../conf/template2.conf --name a1 -Dflume.root.logger=INFO,console<br><br><br><span style="white-space:pre;">			</span>**可以通过tail命令，收集日志文件中后续追加的日志<br><br><br><span style="white-space:pre;">	</span>!!!3.Spooling Directory Source<span style="white-space:pre;">	</span><br><span style="white-space:pre;">		</span>这个Source允许你将文件将要收集的数据放置到"自动搜集"目录中。这个Source将监视该目录，并将解析新文件的出现。事件处理逻辑是可插拔的，当一个文件被完全读入信道，它会被重命名或可选的直接删除。<br><span style="white-space:pre;">		</span>要注意的是，放置到自动搜集目录下的文件不能修改，如果修改，则flume会报错。<br><span style="white-space:pre;">		</span>另外，也不能产生重名的文件，如果有重名的文件被放置进来，则flume会报错。<br><br><br><br><br><span style="white-space:pre;">		</span>属性说明：<br><span style="white-space:pre;">			</span>!channels<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span> <br><span style="white-space:pre;">			</span>!type<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>类型，需要指定为"spooldir"<br><span style="white-space:pre;">			</span>!spoolDir<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>读取文件的路径，即"搜集目录"<br><span style="white-space:pre;">			</span>fileSuffix<span style="white-space:pre;">	</span>.COMPLETED<span style="white-space:pre;">	</span>对处理完成的文件追加的后缀<br><span style="white-space:pre;">			</span>deletePolicy<span style="white-space:pre;">	</span>never<span style="white-space:pre;">	</span>处理完成后是否删除文件，需是"never"或"immediate"<br><span style="white-space:pre;">			</span>fileHeader<span style="white-space:pre;">	</span>false<span style="white-space:pre;">	</span>Whether to add a header storing the absolute path filename.<br><span style="white-space:pre;">			</span>fileHeaderKey<span style="white-space:pre;">	</span>file<span style="white-space:pre;">	</span>Header key to use when appending absolute path filename to event header.<br><span style="white-space:pre;">			</span>basenameHeader<span style="white-space:pre;">	</span>false<span style="white-space:pre;">	</span>Whether to add a header storing the basename of the file.<br><span style="white-space:pre;">			</span>basenameHeaderKey<span style="white-space:pre;">	</span>basename<span style="white-space:pre;">	</span>Header Key to use when appending basename of file to event header.<br><span style="white-space:pre;">			</span>ignorePattern<span style="white-space:pre;">	</span>^$<span style="white-space:pre;">	</span>正则表达式指定哪些文件需要忽略<br><span style="white-space:pre;">			</span>trackerDir<span style="white-space:pre;">	</span>.flumespool<span style="white-space:pre;">	</span>Directory to store metadata related to processing of files. If this path is not an absolute path, then it is interpreted as relative to the spoolDir.<br><span style="white-space:pre;">			</span>consumeOrder<span style="white-space:pre;">	</span>处理文件的策略，oldest, youngest 或 random。<br><span style="white-space:pre;">			</span>maxBackoff<span style="white-space:pre;">	</span>4000<span style="white-space:pre;">	</span>The maximum time (in millis) to wait between consecutive attempts to write to the channel(s) if the channel is full. The source will start at a low backoff and increase it exponentially each time the channel throws a ChannelException, upto the value specified by this parameter.<br><span style="white-space:pre;">			</span>batchSize<span style="white-space:pre;">	</span>100<span style="white-space:pre;">	</span>Granularity at which to batch transfer to the channel<br><span style="white-space:pre;">			</span>inputCharset<span style="white-space:pre;">	</span>UTF-8<span style="white-space:pre;">	</span>读取文件时使用的编码。<br><span style="white-space:pre;">			</span>decodeErrorPolicy<span style="white-space:pre;">	</span>FAIL<span style="white-space:pre;">	</span>当在输入文件中发现无法处理的字符编码时如何处理。FAIL：抛出一个异常而无法 ​​解析该文件。REPLACE：用“替换字符”字符，通常是Unicode的U + FFFD更换不可解析角色。 忽略：掉落的不可解析的字符序列。<br><span style="white-space:pre;">			</span>deserializer<span style="white-space:pre;">	</span>LINE<span style="white-space:pre;">	</span>声明用来将文件解析为事件的解析器。默认一行为一个事件。处理类必须实现EventDeserializer.Builder接口。<br><span style="white-space:pre;">			</span>deserializer.*<span style="white-space:pre;">	</span> <span style="white-space:pre;">	</span>Varies per event deserializer.<br><span style="white-space:pre;">			</span>bufferMaxLines<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>(Obselete) This option is now ignored.<br><span style="white-space:pre;">			</span>bufferMaxLineLength<span style="white-space:pre;">	</span>5000<span style="white-space:pre;">	</span>(Deprecated) Maximum length of a line in the commit buffer. Use deserializer.maxLineLength instead.<br><span style="white-space:pre;">			</span>selector.type<span style="white-space:pre;">	</span>replicating<span style="white-space:pre;">	</span>replicating or multiplexing<br><span style="white-space:pre;">			</span>selector.*<span style="white-space:pre;">	</span> <span style="white-space:pre;">	</span>Depends on the selector.type value<br><span style="white-space:pre;">			</span>interceptors<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>Space-separated list of interceptors<br><span style="white-space:pre;">			</span>interceptors.*<span style="white-space:pre;">	</span> <span style="white-space:pre;">	</span> <br><br><br><span style="white-space:pre;">		</span>案例：<br><span style="white-space:pre;">			</span>编写配置文件：<br><span style="white-space:pre;">				</span>＃命名Agent a1的组件<br><span style="white-space:pre;">				</span>a1.sources  =  r1<br><span style="white-space:pre;">				</span>a1.sinks  =  k1<br><span style="white-space:pre;">				</span>a1.channels  =  c1<br><br><br><span style="white-space:pre;">				</span>＃描述/配置Source<br><span style="white-space:pre;">				</span>a1.sources.r1.type  = spooldir<br><span style="white-space:pre;">				</span>a1.sources.r1.spoolDir  = /home/park/work/apache-flume-1.6.0-bin/mydata<br><br><br><span style="white-space:pre;">				</span>＃描述Sink<br><span style="white-space:pre;">				</span>a1.sinks.k1.type  =  logger<br><span style="white-space:pre;">				</span>＃描述内存Channel<br><span style="white-space:pre;">				</span>a1.channels.c1.type  =  memory<br><span style="white-space:pre;">				</span>a1.channels.c1.capacity  =  1000<br><span style="white-space:pre;">				</span>a1.channels.c1.transactionCapacity  =  100<br><br><br><span style="white-space:pre;">				</span>＃为Channle绑定Source和Sink<br><span style="white-space:pre;">				</span>a1.sources.r1.channels  =  c1<br><span style="white-space:pre;">				</span>a1.sinks.k1.channel  =  c1<br><br><br><br><br><span style="white-space:pre;">			</span>启动flume：<br><span style="white-space:pre;">				</span>./flume-ng agent --conf ../conf --conf-file ../conf/template4.conf --name a1 -Dflume.root.logger=INFO,console<br><br><br><span style="white-space:pre;">			</span>向指定目录中传输文件，发现flume收集到了该文件，将文件中的每一行都作为日志来处理。<br><br><br><span style="white-space:pre;">	</span><br><span style="white-space:pre;">	</span>!4.NetCat Source<br><span style="white-space:pre;">		</span>一个NetCat Source用来监听一个指定端口，并将接收到的数据的每一行转换为一个事件。<br><br><br><span style="white-space:pre;">		</span>属性说明：<br><span style="white-space:pre;">			</span>!channels<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span> <br><span style="white-space:pre;">			</span>!type<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>类型名称，需要被设置为"netcat"<br><span style="white-space:pre;">			</span>!bind<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>指定要绑定到的ip或主机名。<br><span style="white-space:pre;">			</span>!port<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>指定要绑定到的端口号<br><span style="white-space:pre;">			</span>max-line-length<span style="white-space:pre;">	</span>512<span style="white-space:pre;">	</span>单行最大字节数<br><span style="white-space:pre;">			</span>ack-every-event<span style="white-space:pre;">	</span>true<span style="white-space:pre;">	</span>对于收到的每一个Event是否响应"OK"<br><span style="white-space:pre;">			</span>selector.type<span style="white-space:pre;">	</span><br><span style="white-space:pre;">			</span>selector.*<span style="white-space:pre;">	</span> <span style="white-space:pre;">	</span><br><span style="white-space:pre;">			</span>interceptors<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span><br><span style="white-space:pre;">			</span>interceptors.*<span style="white-space:pre;">	</span><br><br><br><span style="white-space:pre;">		</span>案例:<br><span style="white-space:pre;">			</span>参见快速入门案例<br><br><br><span style="white-space:pre;">	</span>5.Sequence Generator Source -- 序列发生器源<br><span style="white-space:pre;">		</span>一个简单的序列发生器，不断的产生事件，值是从0开始每次递增1。<br><span style="white-space:pre;">		</span>主要用来进行测试。<br><br><br><span style="white-space:pre;">		</span>参数说明：<br><span style="white-space:pre;">			</span>!channels<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span> <br><span style="white-space:pre;">			</span>!type<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>类型名称，必须为"seq"<br><span style="white-space:pre;">			</span>selector.type<span style="white-space:pre;">	</span> <span style="white-space:pre;">	</span><br><span style="white-space:pre;">			</span>selector.*<span style="white-space:pre;">	</span><br><span style="white-space:pre;">			</span>interceptors<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span><br><span style="white-space:pre;">			</span>interceptors.*<span style="white-space:pre;">	</span> <span style="white-space:pre;">	</span> <br><span style="white-space:pre;">			</span>batchSize<span style="white-space:pre;">	</span>1<br><br><br><span style="white-space:pre;">		</span>案例：<br><span style="white-space:pre;">			</span>编写配置文件:<br><span style="white-space:pre;">				</span>＃命名Agent a1的组件<br><span style="white-space:pre;">				</span>a1.sources  =  r1<br><span style="white-space:pre;">				</span>a1.sinks  =  k1<br><span style="white-space:pre;">				</span>a1.channels  =  c1<br><br><br><span style="white-space:pre;">				</span>＃描述/配置Source<br><span style="white-space:pre;">				</span>a1.sources.r1.type  = seq<br><br><br><span style="white-space:pre;">				</span>＃描述Sink<br><span style="white-space:pre;">				</span>a1.sinks.k1.type  =  logger<br><span style="white-space:pre;">				</span>＃描述内存Channel<br><span style="white-space:pre;">				</span>a1.channels.c1.type  =  memory<br><span style="white-space:pre;">				</span>a1.channels.c1.capacity  =  1000<br><span style="white-space:pre;">				</span>a1.channels.c1.transactionCapacity  =  100<br><br><br><span style="white-space:pre;">				</span>＃为Channle绑定Source和Sink<br><span style="white-space:pre;">				</span>a1.sources.r1.channels  =  c1<br><span style="white-space:pre;">				</span>a1.sinks.k1.channel  =  c1<br><span style="white-space:pre;">			</span>启动flume:<br><span style="white-space:pre;">				</span>./flume-ng agent --conf ../conf --conf-file ../conf/template4.conf --name a1 -Dflume.root.logger=INFO,console<br><span style="white-space:pre;">				</span>发现打印了日志<br><br><br><span style="white-space:pre;">	</span>!6.HTTP Source<br><span style="white-space:pre;">		</span>此Source接受HTTP的GET和POST请求作为Flume的事件。<br><span style="white-space:pre;">		</span>其中GET方式应该只用于试验。<br><span style="white-space:pre;">		</span>需要提供一个可插拔的"处理器"来将请求转换为事件对象，这个处理器必须实现HTTPSourceHandler接口<br><span style="white-space:pre;">		</span>这个处理器接受一个 HttpServletRequest对象，并返回一个Flume Envent对象集合。<br><span style="white-space:pre;">		</span>从一个HTTP请求中得到的事件将在一个事务中提交到通道中。thus allowing for increased efficiency on channels like the file channel。<br><span style="white-space:pre;">		</span>如果处理器抛出一个异常，Source将会返回一个400的HTTP状态码。<br><span style="white-space:pre;">		</span>如果通道已满，无法再将Event加入Channel，则Source返回503的HTTP状态码，表示暂时不可用。<br><br><br><span style="white-space:pre;">		</span>参数说明:<br><span style="white-space:pre;">			</span>!type<span style="white-space:pre;">	</span> <span style="white-space:pre;">	</span>类型，必须为"HTTP"<br><span style="white-space:pre;">			</span>!port<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>监听的端口<br><span style="white-space:pre;">			</span>bind<span style="white-space:pre;">	</span>0.0.0.0<span style="white-space:pre;">	</span>监听的主机名或ip<br><span style="white-space:pre;">			</span>handler<span style="white-space:pre;">	</span>org.apache.flume.source.http.JSONHandler<span style="white-space:pre;">	</span>处理器类，需要实现HTTPSourceHandler接口<br><span style="white-space:pre;">			</span>handler.*<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>处理器的配置参数<br><span style="white-space:pre;">			</span>selector.type<span style="white-space:pre;">	</span><br><span style="white-space:pre;">			</span>selector.*<span style="white-space:pre;">	</span> <span style="white-space:pre;">	</span><br><span style="white-space:pre;">			</span>interceptors<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span><br><span style="white-space:pre;">			</span>interceptors.*<span style="white-space:pre;">	</span> <span style="white-space:pre;">	</span> <br><span style="white-space:pre;">			</span>enableSSL<span style="white-space:pre;">	</span>false<span style="white-space:pre;">	</span>是否开启SSL,如果需要设置为true。注意，HTTP不支持SSLv3。<br><span style="white-space:pre;">			</span>excludeProtocols<span style="white-space:pre;">	</span>SSLv3<span style="white-space:pre;">	</span>空格分隔的要排除的SSL/TLS协议。SSLv3总是被排除的。<br><span style="white-space:pre;">			</span>keystore<span style="white-space:pre;">	</span> <span style="white-space:pre;">	</span>密钥库文件所在位置。<br><span style="white-space:pre;">			</span>keystorePassword Keystore 密钥库密码<br><br><br><span style="white-space:pre;">		</span>案例:<br><span style="white-space:pre;">			</span>编写配置文件:<br><span style="white-space:pre;">				</span>＃命名Agent a1的组件<br><span style="white-space:pre;">				</span>a1.sources  =  r1<br><span style="white-space:pre;">				</span>a1.sinks  =  k1<br><span style="white-space:pre;">				</span>a1.channels  =  c1<br><br><br><span style="white-space:pre;">				</span>＃描述/配置Source<br><span style="white-space:pre;">				</span>a1.sources.r1.type  = http<br><span style="white-space:pre;">				</span>a1.sources.r1.port  = 66666<br><br><br><span style="white-space:pre;">				</span>＃描述Sink<br><span style="white-space:pre;">				</span>a1.sinks.k1.type  =  logger<br><span style="white-space:pre;">				</span>＃描述内存Channel<br><span style="white-space:pre;">				</span>a1.channels.c1.type  =  memory<br><span style="white-space:pre;">				</span>a1.channels.c1.capacity  =  1000<br><span style="white-space:pre;">				</span>a1.channels.c1.transactionCapacity  =  100<br><br><br><span style="white-space:pre;">				</span>＃为Channle绑定Source和Sink<br><span style="white-space:pre;">				</span>a1.sources.r1.channels  =  c1<br><span style="white-space:pre;">				</span>a1.sinks.k1.channel  =  c1<br><br><br><span style="white-space:pre;">			</span>启动flume:<br><span style="white-space:pre;">				</span>./flume-ng agent --conf ../conf --conf-file ../conf/template6.conf --name a1 -Dflume.root.logger=INFO,console<br><span style="white-space:pre;">			</span>通过命令发送HTTP请求到指定端口：<br><span style="white-space:pre;">				</span>curl -X POST -d '[{ "headers" :{"a" : "a1","b" : "b1"},"body" : "hello~http~flume~"}]' http://0.0.0.0:6666<br><span style="white-space:pre;">			</span>发现flume收集到了日志<br><br><br><span style="white-space:pre;">		</span>常见的Handler：<br><span style="white-space:pre;">			</span>JSONHandler<br><span style="white-space:pre;">				</span>可以处理JSON格式的数据，并支持UTF-8 UTF-16 UTF-32字符集<br><span style="white-space:pre;">				</span>该handler接受Evnet数组，并根据请求头中指定的编码将其转换为Flume Event<br><span style="white-space:pre;">				</span>如果没有指定编码，默认编码为UTF-8.<br><span style="white-space:pre;">				</span>JSON格式如下：<br><span style="white-space:pre;">				</span>--<br><span style="white-space:pre;">				</span>[{<br><span style="white-space:pre;">				</span>  "headers" : {<br><span style="white-space:pre;">				</span>             "timestamp" : "434324343",<br><span style="white-space:pre;">				</span>             "host" : "random_host.example.com"<br><span style="white-space:pre;">				</span>             },<br><span style="white-space:pre;">				</span>  "body" : "random_body"<br><span style="white-space:pre;">				</span>  },<br><span style="white-space:pre;">				</span>  {<br><span style="white-space:pre;">				</span>  "headers" : {<br><span style="white-space:pre;">				</span>             "namenode" : "namenode.example.com",<br><span style="white-space:pre;">				</span>             "datanode" : "random_datanode.example.com"<br><span style="white-space:pre;">				</span>             },<br><span style="white-space:pre;">				</span>  "body" : "really_random_body"<br><span style="white-space:pre;">				</span>  }]<br><span style="white-space:pre;">				</span>--<br><span style="white-space:pre;">			</span>To set the charset, the request must have content type specified as application/json;charset=UTF-8 (replace UTF-8 with UTF-16 or UTF-32 as required).<br><span style="white-space:pre;">			</span>One way to create an event in the format expected by this handler is to use JSONEvent provided in the Flume SDK and use Google Gson to create the JSON string using the Gson#fromJson(Object, Type) method.<br><span style="white-space:pre;">			</span>Typetype=newTypeToken&lt;List&lt;JSONEvent&gt;&gt;(){}.getType();<br><br><br><span style="white-space:pre;">		</span>BlobHandler<br><span style="white-space:pre;">			</span>BlobHandler是一种将请求中上传文件信息转化为event的处理器。<br><span style="white-space:pre;">			</span>参数说明，加！为必须属性：<br><span style="white-space:pre;">				</span>！handler<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>The FQCN of this class: org.apache.flume.sink.solr.morphline.BlobHandler<br><span style="white-space:pre;">				</span>handler.maxBlobLength<span style="white-space:pre;">	</span>100000000<span style="white-space:pre;">	</span>The maximum number of bytes to read and buffer for a given request<span style="white-space:pre;">	</span><br><br><br><span style="white-space:pre;">	</span>7.Custom source -- 自定义源<br><span style="white-space:pre;">		</span>自定义源是自己实现源接口得到的。<br><span style="white-space:pre;">		</span>自定义源的类和其依赖包必须在开始时就放置到Flume的类加载目录下。<br><br><br><span style="white-space:pre;">		</span>参数说明，加！为必须属性：<br><span style="white-space:pre;">			</span>!channels<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span> <br><span style="white-space:pre;">			</span>!type<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>类型，必须设置为自己的自定义处理类的全路径名<br><span style="white-space:pre;">			</span>selector.type<span style="white-space:pre;">	</span> <span style="white-space:pre;">	</span><br><span style="white-space:pre;">			</span>selector.*<span style="white-space:pre;">	</span><br><span style="white-space:pre;">			</span>interceptors<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span><br><span style="white-space:pre;">			</span>interceptors.*<span style="white-space:pre;">	</span><br><span style="white-space:pre;">	</span><br>6.Sink - 汇聚点<br><span style="white-space:pre;">	</span>!!!1.Logger Sink <br><span style="white-space:pre;">		</span>记录指定级别的日志，通常用于调试。<br><br><br><span style="white-space:pre;">		</span>属性说明：<br><span style="white-space:pre;">			</span>!channel<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span> <br><span style="white-space:pre;">			</span>!type<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>The component type name, needs to be logger<br><span style="white-space:pre;">			</span>maxBytesToLog<span style="white-space:pre;">	</span>16<span style="white-space:pre;">	</span>Maximum number of bytes of the Event body to log<br><br><br><span style="white-space:pre;">			</span>要求必须在 --conf 参数指定的目录下有 log4j的配置文件<br><span style="white-space:pre;">			</span>可以通过-Dflume.root.logger=INFO,console在命令启动时手动指定log4j参数<br><br><br><span style="white-space:pre;">		</span>案例：gb  <br><span style="white-space:pre;">			</span>参见入门案例<br><br><br><span style="white-space:pre;">	</span>!!!2.File Roll Sink<br><span style="white-space:pre;">		</span>在本地文件系统中存储事件。<br><span style="white-space:pre;">		</span>每隔指定时长生成文件保存这段时间内收集到的日志信息。<br><br><br><span style="white-space:pre;">		</span>属性说明：<br><span style="white-space:pre;">			</span>!channel<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span> <br><span style="white-space:pre;">			</span>!type<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>类型，必须是"file_roll"<br><span style="white-space:pre;">			</span>!sink.directory<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>文件被存储的目录<br><span style="white-space:pre;">			</span>sink.rollInterval<span style="white-space:pre;">	</span>30<span style="white-space:pre;">	</span>滚动文件每隔30秒（应该是每隔30秒钟单独切割数据到一个文件的意思）。如果设置为0，则禁止滚动，从而导致所有数据被写入到一个文件中。<br><span style="white-space:pre;">			</span>sink.serializer<span style="white-space:pre;">	</span>TEXT<span style="white-space:pre;">	</span>Other possible options include avro_event or the FQCN of an implementation of EventSerializer.Builder interface.<br><span style="white-space:pre;">			</span>batchSize<span style="white-space:pre;">	</span>100<span style="white-space:pre;">	</span> <br><br><br><span style="white-space:pre;">		</span>案例：<br><span style="white-space:pre;">			</span>编写配置文件:<br><span style="white-space:pre;">				</span>＃命名Agent a1的组件<br><span style="white-space:pre;">				</span>a1.sources  =  r1<br><span style="white-space:pre;">				</span>a1.sinks  =  k1<br><span style="white-space:pre;">				</span>a1.channels  =  c1<br><br><br><span style="white-space:pre;">				</span>＃描述/配置Source<br><span style="white-space:pre;">				</span>a1.sources.r1.type  = http<br><span style="white-space:pre;">				</span>a1.sources.r1.port  = 6666<br><br><br><span style="white-space:pre;">				</span>＃描述Sink<br><span style="white-space:pre;">				</span>a1.sinks.k1.type  = file_roll<br><span style="white-space:pre;">				</span>a1.sinks.k1.sink.directory = /home/park/work/apache-flume-1.6.0-bin/mysink<br><span style="white-space:pre;">				</span>＃描述内存Channel<br><span style="white-space:pre;">				</span>a1.channels.c1.type  =  memory<br><span style="white-space:pre;">				</span>a1.channels.c1.capacity  =  1000<br><span style="white-space:pre;">				</span>a1.channels.c1.transactionCapacity  =  100<br><br><br><span style="white-space:pre;">				</span>＃为Channle绑定Source和Sink<br><span style="white-space:pre;">				</span>a1.sources.r1.channels  =  c1<br><span style="white-space:pre;">				</span>a1.sinks.k1.channel  =  c1<br><br><br><span style="white-space:pre;">			</span>启动flume:<br><span style="white-space:pre;">				</span>./flume-ng agent --conf ../conf --conf-file ../conf/template7.conf --name a1 -Dflume.root.logger=INFO,console<br><span style="white-space:pre;">	</span>!!!3.Avro Sink<br><span style="white-space:pre;">		</span>是实现多级流动 和 扇出流(1到多) 扇入流(多到1) 的基础。<span style="white-space:pre;">	</span><br><br><br><span style="white-space:pre;">		</span>属性说明:<br><span style="white-space:pre;">			</span>!channel<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span> <br><span style="white-space:pre;">			</span>!type<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>The component type name, needs to be avro.<br><span style="white-space:pre;">			</span>!hostname<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>The hostname or IP address to bind to.<br><span style="white-space:pre;">			</span>!port<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>The port # to listen on.<br><span style="white-space:pre;">			</span>batch-size<span style="white-space:pre;">	</span>100<span style="white-space:pre;">	</span>number of event to batch together for send.<br><span style="white-space:pre;">			</span>connect-timeout<span style="white-space:pre;">	</span>20000<span style="white-space:pre;">	</span>Amount of time (ms) to allow for the first (handshake) request.<br><span style="white-space:pre;">			</span>request-timeout<span style="white-space:pre;">	</span>20000<span style="white-space:pre;">	</span>Amount of time (ms) to allow for requests after the first.<br><span style="white-space:pre;">			</span>reset-connection-interval<span style="white-space:pre;">	</span>none<span style="white-space:pre;">	</span>Amount of time (s) before the connection to the next hop is reset. This will force the Avro Sink to reconnect to the next hop. This will allow the sink to connect to hosts behind a hardware load-balancer when news hosts are added without having to restart the agent.<br><span style="white-space:pre;">			</span>compression-type<span style="white-space:pre;">	</span>none<span style="white-space:pre;">	</span>This can be “none” or “deflate”. The compression-type must match the compression-type of matching AvroSource<br><span style="white-space:pre;">			</span>compression-level<span style="white-space:pre;">	</span>6<span style="white-space:pre;">	</span>The level of compression to compress event. 0 = no compression and 1-9 is compression. The higher the number the more compression<br><span style="white-space:pre;">			</span>ssl<span style="white-space:pre;">	</span>false<span style="white-space:pre;">	</span>Set to true to enable SSL for this AvroSink. When configuring SSL, you can optionally set a “truststore”, “truststore-password”, “truststore-type”, and specify whether to “trust-all-certs”.<br><span style="white-space:pre;">			</span>trust-all-certs<span style="white-space:pre;">	</span>false<span style="white-space:pre;">	</span>If this is set to true, SSL server certificates for remote servers (Avro Sources) will not be checked. This should NOT be used in production because it makes it easier for an attacker to execute a man-in-the-middle attack and “listen in” on the encrypted connection.<br><span style="white-space:pre;">			</span>truststore<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>The path to a custom Java truststore file. Flume uses the certificate authority information in this file to determine whether the remote Avro Source’s SSL authentication credentials should be trusted. If not specified, the default Java JSSE certificate authority files (typically “jssecacerts” or “cacerts” in the Oracle JRE) will be used.<br><span style="white-space:pre;">			</span>truststore-password<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>The password for the specified truststore.<br><span style="white-space:pre;">			</span>truststore-type<span style="white-space:pre;">	</span>JKS<span style="white-space:pre;">	</span>The type of the Java truststore. This can be “JKS” or other supported Java truststore type.<br><span style="white-space:pre;">			</span>exclude-protocols<span style="white-space:pre;">	</span>SSLv3<span style="white-space:pre;">	</span>Space-separated list of SSL/TLS protocols to exclude. SSLv3 will always be excluded in addition to the protocols specified.<br><span style="white-space:pre;">			</span>maxIoWorkers<span style="white-space:pre;">	</span>2 * the number of available processors in the machine<span style="white-space:pre;">	</span>The maximum number of I/O w<br><br><br><span style="white-space:pre;">		</span>案例1 - 多级流动：<br><span style="white-space:pre;">			</span>h2:<br><span style="white-space:pre;">				</span>配置配置文件:<br><span style="white-space:pre;">					</span>#命名Agent组件<br><span style="white-space:pre;">					</span>a1.sources=r1<br><span style="white-space:pre;">					</span>a1.sinks=k1<br><span style="white-space:pre;">					</span>a1.channels=c1<br><br><br><span style="white-space:pre;">					</span>#描述/配置Source<br><span style="white-space:pre;">					</span>a1.sources.r1.type=avro<br><span style="white-space:pre;">					</span>a1.sources.r1.bind=0.0.0.0<br><span style="white-space:pre;">					</span>a1.sources.r1.port=9988<br><span style="white-space:pre;">					</span>#描述Sink<br><span style="white-space:pre;">					</span>a1.sinks.k1.type=logger<br><span style="white-space:pre;">					</span>#描述内存Channel<br><span style="white-space:pre;">					</span>a1.channels.c1.type=memory<br><span style="white-space:pre;">					</span>a1.channels.c1.capacity=1000<br><span style="white-space:pre;">					</span>a1.channels.c1.transactionCapacity=1000<br><span style="white-space:pre;">					</span>#为Channel绑定Source和Sink<br><span style="white-space:pre;">					</span>a1.sources.r1.channels=c1<br><span style="white-space:pre;">					</span>a1.sinks.k1.channel=c1<br><span style="white-space:pre;">				</span>启动flume:<br><span style="white-space:pre;">					</span>./flume-ng agent --conf ../conf --conf-file ../conf/template8.conf --name a1 -Dflume.root.logger=INFO,console<br><br><br><span style="white-space:pre;">				</span><br><span style="white-space:pre;">			</span>h1:<br><span style="white-space:pre;">				</span>配置配置文件<br><span style="white-space:pre;">					</span>#命名Agent组件<br><span style="white-space:pre;">					</span>a1.sources=r1<br><span style="white-space:pre;">					</span>a1.sinks=k1<br><span style="white-space:pre;">					</span>a1.channels=c1<br><br><br><span style="white-space:pre;">					</span>#描述/配置Source<br><span style="white-space:pre;">					</span>a1.sources.r1.type=http<br><span style="white-space:pre;">					</span>a1.sources.r1.port=8888<br><span style="white-space:pre;">					</span>#描述Sink<br><span style="white-space:pre;">					</span>a1.sinks.k1.type=avro<br><span style="white-space:pre;">					</span>a1.sinks.k1.hostname=192.168.242.138<br><span style="white-space:pre;">					</span>a1.sinks.k1.port=9988<br><span style="white-space:pre;">					</span>#描述内存Channel<br><span style="white-space:pre;">					</span>a1.channels.c1.type=memory<br><span style="white-space:pre;">					</span>a1.channels.c1.capacity=1000<br><span style="white-space:pre;">					</span>a1.channels.c1.transactionCapacity=1000<br><span style="white-space:pre;">					</span>#为Channel绑定Source和Sink<br><span style="white-space:pre;">					</span>a1.sources.r1.chafile:///C:/Users/park/Desktop/Day01_Flume/%E6%96%87%E6%A1%A3/Flume%201.6.0%20User%20Guide%20%E2%80%94%20Apache%20Flume.htm#irc-sinknnels=c1<br><span style="white-space:pre;">					</span>a1.sinks.k1.channel=c1<br><span style="white-space:pre;">			</span>启动flume:<br><span style="white-space:pre;">				</span>./flume-ng agent --conf ../conf --conf-file ../conf/template8.conf --name a1 -Dflume.root.logger=INFO,console<br><br><br><span style="white-space:pre;">			</span>发送http请求到h1：<br><span style="white-space:pre;">				</span>curl -X POST -d '[{ "headers" :{"a" : "a1","b" : "b1"},"body" : "hello~http~flume~"}]' http://192.168.242.133:8888<br><span style="white-space:pre;">			</span>稍等几秒后，发现h2最终收到了这条消息<br><br><br><span style="white-space:pre;">		</span>案例2：扇出流 - 复制<br><span style="white-space:pre;">			</span>h2 h3:<br><span style="white-space:pre;">				</span>配置配置文件:<br><span style="white-space:pre;">					</span>#命名Agent组件<br><span style="white-space:pre;">					</span>a1.sources=r1<br><span style="white-space:pre;">					</span>a1.sinks=k1<br><span style="white-space:pre;">					</span>a1.channels=c1<br><br><br><span style="white-space:pre;">					</span>#描述/配置Source<br><span style="white-space:pre;">					</span>a1.sources.r1.type=avro<br><span style="white-space:pre;">					</span>a1.sources.r1.bind=0.0.0.0<br><span style="white-space:pre;">					</span>a1.sources.r1.port=9988<br><span style="white-space:pre;">					</span>#描述Sink<br><span style="white-space:pre;">					</span>a1.sinks.k1.type=logger<br><span style="white-space:pre;">					</span>#描述内存Channel<br><span style="white-space:pre;">					</span>a1.channels.c1.type=memory<br><span style="white-space:pre;">					</span>a1.channels.c1.capacity=1000<br><span style="white-space:pre;">					</span>a1.channels.c1.transactionCapacity=1000<br><span style="white-space:pre;">					</span>#为Channel绑定Source和Sink<br><span style="white-space:pre;">					</span>a1.sources.r1.channels=c1<br><span style="white-space:pre;">					</span>a1.sinks.k1.channel=c1<br><span style="white-space:pre;">				</span>启动flume:<br><span style="white-space:pre;">					</span>./flume-ng agent --conf ../conf --conf-file ../conf/template8.conf --name a1 -Dflume.root.logger=INFO,console<br><br><br><span style="white-space:pre;">			</span>h1:<br><span style="white-space:pre;">				</span>配置配置文件<br><span style="white-space:pre;">					</span>#命名Agent组件<br><span style="white-space:pre;">					</span>a1.sources=r1<br><span style="white-space:pre;">					</span>a1.sinks=k1 k2<br><span style="white-space:pre;">					</span>a1.channels=c1 c2<br><br><br><span style="white-space:pre;">					</span>#描述/配置Source<br><span style="white-space:pre;">					</span>a1.sources.r1.type=http<br><span style="white-space:pre;">					</span>a1.sources.r1.port=8888<br><span style="white-space:pre;">					</span>#描述Sink<br><span style="white-space:pre;">					</span>a1.sinks.k1.type=avro<br><span style="white-space:pre;">					</span>a1.sinks.k1.hostname=192.168.242.138<br><span style="white-space:pre;">					</span>a1.sinks.k1.port=9988<br><span style="white-space:pre;">					</span>a1.sinks.k2.type=avro<br><span style="white-space:pre;">					</span>a1.sinks.k2.hostname=192.168.242.135<br><span style="white-space:pre;">					</span>a1.sinks.k2.port=9988<br><span style="white-space:pre;">					</span>#描述内存Channel<br><span style="white-space:pre;">					</span>a1.channels.c1.type=memory<br><span style="white-space:pre;">					</span>a1.channels.c1.capacity=1000<br><span style="white-space:pre;">					</span>a1.channels.c1.transactionCapacity=1000<br><span style="white-space:pre;">					</span>a1.channels.c2.type=memory<br><span style="white-space:pre;">					</span>a1.channels.c2.capacity=1000<br><span style="white-space:pre;">					</span>a1.channels.c2.transactionCapacity=1000<br><span style="white-space:pre;">					</span>#为Channel绑定Source和Sink<br><span style="white-space:pre;">					</span>a1.sources.r1.channels=c1 c2<br><span style="white-space:pre;">					</span>a1.sinks.k1.channel=c1<span style="white-space:pre;">	</span><br><span style="white-space:pre;">					</span>a1.sinks.k2.channel=c2<span style="white-space:pre;">	</span><br><span style="white-space:pre;">			</span>启动flume:<br><span style="white-space:pre;">					</span>./flume-ng agent --conf ../conf --conf-file ../conf/template8.conf --name a1 -Dflume.root.logger=INFO,console<br><br><br><span style="white-space:pre;">		</span>案例3：扇出流 - 多路复用（路由）<br><span style="white-space:pre;">				</span>h2 h3:<br><span style="white-space:pre;">				</span>配置配置文件:<br><span style="white-space:pre;">					</span>#命名Agent组件<br><span style="white-space:pre;">					</span>a1.sources=r1<br><span style="white-space:pre;">					</span>a1.sinks=k1<br><span style="white-space:pre;">					</span>a1.channels=c1<br><br><br><span style="white-space:pre;">					</span>#描述/配置Source<br><span style="white-space:pre;">					</span>a1.sources.r1.type=avro<br><span style="white-space:pre;">					</span>a1.sources.r1.bind=0.0.0.0<br><span style="white-space:pre;">					</span>a1.sources.r1.port=9988<br><span style="white-space:pre;">					</span>#描述Sink<br><span style="white-space:pre;">					</span>a1.sinks.k1.type=logger<br><span style="white-space:pre;">					</span>#描述内存Channel<br><span style="white-space:pre;">					</span>a1.channels.c1.type=memory<br><span style="white-space:pre;">					</span>a1.channels.c1.capacity=1000<br><span style="white-space:pre;">					</span>a1.channels.c1.transactionCapacity=1000<br><span style="white-space:pre;">					</span>#为Channel绑定Source和Sink<br><span style="white-space:pre;">					</span>a1.sources.r1.channels=c1<br><span style="white-space:pre;">					</span>a1.sinks.k1.channel=c1<br><span style="white-space:pre;">				</span>启动flume:<br><span style="white-space:pre;">					</span>./flume-ng agent --conf ../conf --conf-file ../conf/template8.conf --name a1 -Dflume.root.logger=INFO,console<br><br><br><span style="white-space:pre;">			</span>h1:<br><span style="white-space:pre;">				</span>配置配置文件<br><span style="white-space:pre;">					</span>#配置Agent组件<br><span style="white-space:pre;">					</span>a1.sources=r1<br><span style="white-space:pre;">					</span>a1.sinks=k1 k2<br><span style="white-space:pre;">					</span>a1.channels=c1 c2<br><br><br><span style="white-space:pre;">					</span>#描述/配置Source<br><span style="white-space:pre;">					</span>a1.sources.r1.type=http<br><span style="white-space:pre;">					</span>a1.sources.r1.port=8888<br><span style="white-space:pre;">					</span>a1.sources.r1.selector.type=multiplexing<br><span style="white-space:pre;">					</span>a1.sources.r1.selector.header=flag<br><span style="white-space:pre;">					</span>a1.sources.r1.selector.mapping.aaa=c1<br><span style="white-space:pre;">					</span>a1.sources.r1.selector.mapping.bbb=c2<br><span style="white-space:pre;">					</span>a1.sources.r1.selector.default=c1<br><span style="white-space:pre;">					</span>#描述Sink<br><span style="white-space:pre;">					</span>a1.sinks.k1.type=avro<br><span style="white-space:pre;">					</span>a1.sinks.k1.hostname=192.168.242.138<br><span style="white-space:pre;">					</span>a1.sinks.k1.port=9988<br><span style="white-space:pre;">					</span>a1.sinks.k2.type=avro<br><span style="white-space:pre;">					</span>a1.sinks.k2.hostname=192.168.242.135<br><span style="white-space:pre;">					</span>a1.sinks.k2.port=9988<br><span style="white-space:pre;">					</span>#描述内存Channel<br><span style="white-space:pre;">					</span>a1.channels.c1.type=memory<br><span style="white-space:pre;">					</span>a1.channels.c1.capacity=1000<br><span style="white-space:pre;">					</span>a1.channels.c1.transactionCapacity=1000<br><span style="white-space:pre;">					</span>a1.channels.c2.type=memory<br><span style="white-space:pre;">					</span>a1.channels.c2.capacity=1000<br><span style="white-space:pre;">					</span>a1.channels.c2.transactionCapacity=1000<br><span style="white-space:pre;">					</span>#为Channel绑定Source和Sink<br><span style="white-space:pre;">					</span>a1.sources.r1.channels=c1 c2<br><span style="white-space:pre;">					</span>a1.sinks.k1.channel=c1<br><span style="white-space:pre;">					</span>a1.sinks.k2.channel=c2<br><span style="white-space:pre;">			</span>启动flume:<br><span style="white-space:pre;">				</span>./flume-ng agent --conf ../conf --conf-file ../conf/template8.conf --name a1 -Dflume.root.logger=INFO,console<br><span style="white-space:pre;">			</span>发送http请求进行测试。发现可以实现路由效果<br><br><br><span style="white-space:pre;">		</span>案例4：扇入流<br><span style="white-space:pre;">			</span>m3:<br><span style="white-space:pre;">				</span>编写配置文件:<br><span style="white-space:pre;">					</span>#命名Agent组件<br><span style="white-space:pre;">					</span>a1.sources=r1<br><span style="white-space:pre;">					</span>a1.sinks=k1<br><span style="white-space:pre;">					</span>a1.channels=c1<br><span style="white-space:pre;">					</span>#描述/配置Source<br><span style="white-space:pre;">					</span>a1.sources.r1.type=avro<br><span style="white-space:pre;">					</span>a1.sources.r1.bind=0.0.0.0<br><span style="white-space:pre;">					</span>a1.sources.r1.port=4141<br><span style="white-space:pre;">					</span>#描述Sink<br><span style="white-space:pre;">					</span>a1.sinks.k1.type=logger<br><span style="white-space:pre;">					</span>#描述内存Channel<br><span style="white-space:pre;">					</span>a1.channels.c1.type=memory<br><span style="white-space:pre;">					</span>a1.channels.c1.capacity=1000<br><span style="white-space:pre;">					</span>a1.channels.c1.transactionCapacity=1000<br><span style="white-space:pre;">					</span>#为Channel绑定Source和Sink<br><span style="white-space:pre;">					</span>a1.sources.r1.channels=c1<br><span style="white-space:pre;">					</span>a1.sinks.k1.channel=c1<br><span style="white-space:pre;">				</span>启动flume:<br><span style="white-space:pre;">					</span>./flume-ng agent --conf ../conf --conf-file ../conf/template.conf --name a1 -Dflume.root.logger=INFO,console<br><span style="white-space:pre;">			</span><br><span style="white-space:pre;">			</span>m1、m2:<br><span style="white-space:pre;">				</span>编写配置文件:<br><span style="white-space:pre;">					</span>#命名Agent组件<br><span style="white-space:pre;">					</span>a1.sources=r1<br><span style="white-space:pre;">					</span>a1.sinks=k1<br><span style="white-space:pre;">					</span>a1.channels=c1<br><br><br><span style="white-space:pre;">					</span>#描述/配置Source<br><span style="white-space:pre;">					</span>a1.sources.r1.type=http<br><span style="white-space:pre;">					</span>a1.sources.r1.port=8888<br><span style="white-space:pre;">					</span>#描述Sink<br><span style="white-space:pre;">					</span>a1.sinks.k1.type=avro<br><span style="white-space:pre;">					</span>a1.sinks.k1.hostname=192.168.242.135<br><span style="white-space:pre;">					</span>a1.sinks.k1.port=4141<br><span style="white-space:pre;">					</span>#描述内存Channel<br><span style="white-space:pre;">					</span>a1.channels.c1.type=memory<br><span style="white-space:pre;">					</span>a1.channels.c1.capacity=1000<br><span style="white-space:pre;">					</span>a1.channels.c1.transactionCapacity=1000<br><span style="white-space:pre;">					</span>#为Channel绑定Source和Sink<br><span style="white-space:pre;">					</span>a1.sources.r1.channels=c1<br><span style="white-space:pre;">					</span>a1.sinks.k1.channel=c1<br><span style="white-space:pre;">				</span>启动flume:<br><span style="white-space:pre;">					</span>./flume-ng agent --conf ../conf --conf-file ../conf/template9.conf --name a1 -Dflume.root.logger=INFO,console<br><span style="white-space:pre;">				</span>m1通过curl发送一条http请求，由于默认使用的是jsonHandler，数据格式必须是指定的json格式：<br><span style="white-space:pre;">					</span>[root@localhost conf]# curl -X POST -d '[{ "headers" :{"flag" : "c"},"body" : "idoall.org_body"}]' http://0.0.0.0:8888<br><span style="white-space:pre;">			</span> <span style="white-space:pre;">	</span>m2通过curl发送一条http请求，由于默认使用的是jsonHandler，数据格式必须是指定的json格式：<br><span style="white-space:pre;">					</span>[root@localhost conf]# curl -X POST -d '[{ "headers" :{"flag" : "c"},"body" : "idoall.org_body"}]' http://0.0.0.0:8888<br><span style="white-space:pre;">				</span>发现m3均能正确收到消息<br><br><br><br><br><span style="white-space:pre;">	</span>!!!!4.HDFS Sink<br><span style="white-space:pre;">		</span>此Sink将事件写入到Hadoop分布式文件系统HDFS中。<br><span style="white-space:pre;">		</span>目前它支持创建文本文件和序列化文件。<br><span style="white-space:pre;">		</span>对这两种格式都支持压缩。<br><span style="white-space:pre;">		</span>这些文件可以分卷，按照指定的时间或数据量或事件的数量为基础。<br><span style="white-space:pre;">		</span>它还通过类似时间戳或机器属性对数据进行 buckets/partitions 操作    It also buckets/partitions data by attributes like timestamp or machine where the event originated.<br><span style="white-space:pre;">		</span>HDFS的目录路径可以包含将要由HDFS替换格式的转移序列用以生成存储事件的目录/文件名。<br><span style="white-space:pre;">		</span>使用这个Sink要求hadoop必须已经安装好，以便Flume可以通过hadoop提供的jar包与HDFS进行通信。<br><span style="white-space:pre;">		</span>注意，此版本hadoop必须支持sync()调用。<br><br><br><span style="white-space:pre;">		</span>属性说明:<br><span style="white-space:pre;">			</span>!channel<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span> <br><span style="white-space:pre;">			</span>!type<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>类型名称，必须是“HDFS”<br><span style="white-space:pre;">			</span>!hdfs.path<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>HDFS 目录路径 (eg hdfs://namenode/flume/webdata/)<br><span style="white-space:pre;">			</span>hdfs.filePrefix<span style="white-space:pre;">	</span>FlumeData<span style="white-space:pre;">	</span>Flume在目录下创建文件的名称前缀<br><span style="white-space:pre;">			</span>hdfs.fileSuffix<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>追加到文件的名称后缀 (eg .avro - 注: 日期时间不会自动添加)<br><span style="white-space:pre;">			</span>hdfs.inUsePrefix<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>Flume正在处理的文件所加的前缀<br><span style="white-space:pre;">			</span>hdfs.inUseSuffix<span style="white-space:pre;">	</span>.tmp<span style="white-space:pre;">	</span>Flume正在处理的文件所加的后缀<br><span style="white-space:pre;">			</span>hdfs.rollInterval<span style="white-space:pre;">	</span>30<span style="white-space:pre;">	</span>Number of seconds to wait before rolling current file (0 = never roll based on time interval)<br><span style="white-space:pre;">			</span>hdfs.rollSize<span style="white-space:pre;">	</span>1024<span style="white-space:pre;">	</span>File size to trigger roll, in bytes (0: never roll based on file size)<br><span style="white-space:pre;">			</span>hdfs.rollCount<span style="white-space:pre;">	</span>10<span style="white-space:pre;">	</span>Number of events written to file before it rolled (0 = never roll based on number of events)<br><span style="white-space:pre;">			</span>hdfs.idleTimeout<span style="white-space:pre;">	</span>0<span style="white-space:pre;">	</span>Timeout after which inactive files get closed (0 = disable automatic closing of idle files)<br><span style="white-space:pre;">			</span>hdfs.batchSize<span style="white-space:pre;">	</span>100<span style="white-space:pre;">	</span>number of events written to file before it is flushed to HDFS<br><span style="white-space:pre;">			</span>hdfs.codeC<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>Compression codec. one of following : gzip, bzip2, lzo, lzop, snappy<br><span style="white-space:pre;">			</span>hdfs.fileType<span style="white-space:pre;">	</span>SequenceFile<span style="white-space:pre;">	</span>File format: currently SequenceFile, DataStream or CompressedStream (1)DataStream will not compress output file and please don’t set codeC (2)CompressedStream requires set hdfs.codeC with an available codeC<br><span style="white-space:pre;">			</span>hdfs.maxOpenFiles<span style="white-space:pre;">	</span>5000<span style="white-space:pre;">	</span>Allow only this number of open files. If this number is exceeded, the oldest file is closed.<br><span style="white-space:pre;">			</span>hdfs.minBlockReplicas<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>Specify minimum number of replicas per HDFS block. If not specified, it comes from the default Hadoop config in the classpath.<br><span style="white-space:pre;">			</span>hdfs.writeFormat<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>Format for sequence file records. One of “Text” or “Writable” (the default).<br><span style="white-space:pre;">			</span>hdfs.callTimeout<span style="white-space:pre;">	</span>10000<span style="white-space:pre;">	</span>Number of milliseconds allowed for HDFS operations, such as open, write, flush, close. This number should be increased if many HDFS timeout operations are occurring.<br><span style="white-space:pre;">			</span>hdfs.threadsPoolSize<span style="white-space:pre;">	</span>10<span style="white-space:pre;">	</span>Number of threads per HDFS sink for HDFS IO ops (open, write, etc.)<br><span style="white-space:pre;">			</span>hdfs.rollTimerPoolSize<span style="white-space:pre;">	</span>1<span style="white-space:pre;">	</span>Number of threads per HDFS sink for scheduling timed file rolling<br><span style="white-space:pre;">			</span>hdfs.kerberosPrincipal<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>Kerberos user principal for accessing secure HDFS<br><span style="white-space:pre;">			</span>hdfs.kerberosKeytab<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>Kerberos keytab for accessing secure HDFS<br><span style="white-space:pre;">			</span>hdfs.proxyUser<span style="white-space:pre;">	</span> <span style="white-space:pre;">	</span> <br><span style="white-space:pre;">			</span>hdfs.round<span style="white-space:pre;">	</span>false<span style="white-space:pre;">	</span>时间戳是否向下取整（如果是true，会影响所有基于时间的转移序列，除了%T）<br><span style="white-space:pre;">			</span>hdfs.roundValue<span style="white-space:pre;">	</span>1<span style="white-space:pre;">	</span>舍值的边界值<br><span style="white-space:pre;">			</span>hdfs.roundUnit<span style="white-space:pre;">	</span>向下舍值的单位 -  second, minute , hour<br><span style="white-space:pre;">			</span>hdfs.timeZone<span style="white-space:pre;">	</span>Local Time<span style="white-space:pre;">	</span>Name of the timezone that should be used for resolving the directory path, e.g. America/Los_Angeles.<br><span style="white-space:pre;">			</span>hdfs.useLocalTimeStamp<span style="white-space:pre;">	</span>false<span style="white-space:pre;">	</span>Use the local time (instead of the timestamp from the event header) while replacing the escape sequences.<br><span style="white-space:pre;">			</span>hdfs.closeTries<span style="white-space:pre;">	</span>0<span style="white-space:pre;">	</span>Number of times the sink must try renaming a file, after initiating a close attempt. If set to 1, this sink will not re-try a failed rename (due to, for example, NameNode or DataNode failure), and may leave the file in an open state with a .tmp extension. If set to 0, the sink will try to rename the file until the file is eventually renamed (there is no limit on the number of times it would try). The file may still remain open if the close call fails but the data will be intact and in this case, the file will be closed only after a Flume restart.<br><span style="white-space:pre;">			</span>hdfs.retryInterval<span style="white-space:pre;">	</span>180<span style="white-space:pre;">	</span>Time in seconds between consecutive attempts to close a file. Each close call costs multiple RPC round-trips to the Namenode, so setting this too low can cause a lot of load on the name node. If set to 0 or less, the sink will not attempt to close the file if the first attempt fails, and may leave the file open or with a ”.tmp” extension.<br><span style="white-space:pre;">			</span>serializer<span style="white-space:pre;">	</span>TEXT<span style="white-space:pre;">	</span>Other possible options include avro_event or the fully-qualified class name of an implementation of the EventSerializer.Builder interface.<br><br><br><span style="white-space:pre;">		</span>案例：<br><span style="white-space:pre;">			</span>编写配置文件:<br><span style="white-space:pre;">				</span>#命名Agent组件<br><span style="white-space:pre;">				</span>a1.sources=r1<br><span style="white-space:pre;">				</span>a1.sinks=k1<br><span style="white-space:pre;">				</span>a1.channels=c1<br><br><br><span style="white-space:pre;">				</span>#描述/配置Source<br><span style="white-space:pre;">				</span>a1.sources.r1.type=http<br><span style="white-space:pre;">				</span>a1.sources.r1.port=8888<br><span style="white-space:pre;">				</span>#描述Sink<br><span style="white-space:pre;">				</span>a1.sinks.k1.type=hdfs<br><span style="white-space:pre;">				</span>a1.sinks.k1.hdfs.path=hdfs://0.0.0.0:9000/ppp<br><span style="white-space:pre;">				</span>#描述内存Channel<br><span style="white-space:pre;">				</span>a1.channels.c1.type=memory<br><span style="white-space:pre;">				</span>a1.channels.c1.capacity=1000<br><span style="white-space:pre;">				</span>a1.channels.c1.transactionCapacity=1000<br><span style="white-space:pre;">				</span>#为Channel绑定Source和Sink<br><span style="white-space:pre;">				</span>a1.sources.r1.channels=c1<br><span style="white-space:pre;">				</span>a1.sinks.k1.channel=c1<br><span style="white-space:pre;">			</span>启动flume:<br><span style="white-space:pre;">				</span>./flume-ng agent --conf ../conf --conf-file ../conf/template9.conf --name a1 -Dflume.root.logger=INFO,console<span style="white-space:pre;">	</span><br><br><br><span style="white-space:pre;">	</span>5.Hive Sink<br><span style="white-space:pre;">		</span><br><br><br><span style="white-space:pre;">	</span>6.Custom Sink<span style="white-space:pre;">	</span><br><span style="white-space:pre;">		</span>自定义接收器，是自己实现的接收器接口Sink来实现的。<br><span style="white-space:pre;">		</span>自定义接收器的类及其依赖类须在Flume启动前放置到Flume类加载目录下。<br><br><br><span style="white-space:pre;">		</span>属性说明：<br><span style="white-space:pre;">			</span>type<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>类型，需要指定为自己实现的Sink类的全路径名<br>7.Selector<br><span style="white-space:pre;">	</span>选择器用来控制在扇出时数据分发的方式<br><span style="white-space:pre;">	</span><br><span style="white-space:pre;">	</span>选择器可以工作在 复制 多路复用(路由)模式 下<span style="white-space:pre;">	</span><br><br><br><span style="white-space:pre;">	</span>复制模式<br><span style="white-space:pre;">		</span>属性说明：<br><span style="white-space:pre;">			</span>selector.type replicating 类型名称，必须是 replicating <br><span style="white-space:pre;">			</span>selector.optional<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>标志通道为可选<br><span style="white-space:pre;">		</span>案例：<br><span style="white-space:pre;">			</span>参看avro sink案例<br><br><br><span style="white-space:pre;">	</span>多路复用（路由）模式<br><span style="white-space:pre;">			</span>属性说明：<br><span style="white-space:pre;">				</span>selector.type<span style="white-space:pre;">	</span>类型，必须是"multiplexing"<br><span style="white-space:pre;">				</span>selector.header<span style="white-space:pre;">	</span>指定要监测的头的名称<span style="white-space:pre;">	</span> <br><span style="white-space:pre;">				</span>selector.default<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span> <br><span style="white-space:pre;">				</span>selector.mapping.*<span style="white-space:pre;">	</span>–<br><span style="white-space:pre;">			</span>举例：<br><span style="white-space:pre;">				</span>a1.sources = r1<br><span style="white-space:pre;">				</span>a1.channels = c1 c2 c3 c4<br><span style="white-space:pre;">				</span>a1.sources.r1.selector.type = multiplexing<br><span style="white-space:pre;">				</span>a1.sources.r1.selector.header = state<br><span style="white-space:pre;">				</span>a1.sources.r1.selector.mapping.CZ = c1<br><span style="white-space:pre;">				</span>a1.sources.r1.selector.mapping.US = c2 c3<br><span style="white-space:pre;">				</span>a1.sources.r1.selector.default = c4<br><span style="white-space:pre;">			</span>案例：<br><span style="white-space:pre;">				</span>参看 avro sink案例<br><br><br>8.Processor<br><span style="white-space:pre;">	</span>1.概述<br><span style="white-space:pre;">		</span>处理器 - 实现负载均衡 或 失败恢复 的组件<br><span style="white-space:pre;">		</span>需要将若干sink组成一个sink group组<br><span style="white-space:pre;">		</span>为sink group 配置processor<br><span style="white-space:pre;">		</span>processor可以基于切换 group中的 sink 来实现负载均衡 或 失败恢复。<br><span style="white-space:pre;">	</span><br><span style="white-space:pre;">		</span>sinks<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>用空格分隔的Sink集合<br><span style="white-space:pre;">		</span>processor.type<span style="white-space:pre;">	</span>default<span style="white-space:pre;">	</span>类型名称，必须是 default、failover 或 load_balance<br><br><br><span style="white-space:pre;">	</span>2.Default Sink Processor<br><span style="white-space:pre;">		</span>Default Sink Processor 只接受一个 Sink。<br><span style="white-space:pre;">		</span>不要求用户为单一Sink创建processor<br><br><br><span style="white-space:pre;">	</span>3.Failover Sink Processor<br><span style="white-space:pre;">		</span>Failover Sink Processor 维护一个sink们的优先表。确保只要一个是可用的就事件就可以被处理。<br><span style="white-space:pre;">		</span>失败处理原理是，为失效的sink指定一个冷却时间，在冷却时间到达后再重新使用。<br><span style="white-space:pre;">		</span>sink们可以被配置一个优先级，数字越大优先级越高。<br><span style="white-space:pre;">		</span>如果sink发送事件失败，则下一个最高优先级的sink将会尝试接着发送事件。<br><span style="white-space:pre;">		</span>如果没有指定优先级，则优先级顺序取决于sink们的配置顺序，先配置的默认优先级高于后配置的。<br><span style="white-space:pre;">		</span>在配置的过程中，设置一个group processor ，并且为每个sink都指定一个优先级。<br><span style="white-space:pre;">		</span>优先级必须是唯一的。<br><span style="white-space:pre;">		</span>另外可以设置maxpenalty属性指定限定失败时间。<br><br><br><span style="white-space:pre;">		</span>sinks<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>Space-separated list of sinks that are participating in the group<br><span style="white-space:pre;">		</span>processor.type<span style="white-space:pre;">	</span>default<span style="white-space:pre;">	</span>The component type name, needs to be failover<br><span style="white-space:pre;">		</span>processor.priority.&lt;sinkName&gt;<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>Priority value. &lt;sinkName&gt; must be one of the sink instances associated with the current sink group A higher priority value Sink gets activated earlier. A larger absolute value indicates higher priority<br><span style="white-space:pre;">		</span>processor.maxpenalty<span style="white-space:pre;">	</span>30000<span style="white-space:pre;">	</span>The maximum backoff period for the failed Sink (in millis)<br><br><br><span style="white-space:pre;">		</span>Example for agent named a1:<br><span style="white-space:pre;">		</span>------<br><span style="white-space:pre;">		</span>a1.sinkgroups = g1<br><span style="white-space:pre;">		</span>a1.sinkgroups.g1.sinks = k1 k2<br><span style="white-space:pre;">		</span>a1.sinkgroups.g1.processor.type = failover<br><span style="white-space:pre;">		</span>a1.sinkgroups.g1.processor.priority.k1 = 5<br><span style="white-space:pre;">		</span>a1.sinkgroups.g1.processor.priority.k2 = 10<br><span style="white-space:pre;">		</span>a1.sinkgroups.g1.processor.maxpenalty = 10000<br><span style="white-space:pre;">		</span>------<br><span style="white-space:pre;">	</span><br><span style="white-space:pre;">	</span>4.Load balancing Sink Processor<br><span style="white-space:pre;">		</span>Load balancing Sink processor 提供了在多个sink之间实现负载均衡的能力。<br><span style="white-space:pre;">		</span>它维护了一个活动sink的索引列表。<br><span style="white-space:pre;">		</span>它支持轮询 或 随机方式的负载均衡，默认值是轮询方式，可以通过配置指定。<br><span style="white-space:pre;">		</span>也可以通过实现AbstractSinkSelector接口实现自定义的选择机制。<br><br><br><span style="white-space:pre;">		</span>!processor.sinks<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>Space-separated list of sinks that are participating in the group<br><span style="white-space:pre;">		</span>!processor.type<span style="white-space:pre;">	</span>default<span style="white-space:pre;">	</span>The component type name, needs to be load_balance<br><span style="white-space:pre;">		</span>processor.backoff<span style="white-space:pre;">	</span>false<span style="white-space:pre;">	</span>Should failed sinks be backed off exponentially.<br><span style="white-space:pre;">		</span>processor.selector<span style="white-space:pre;">	</span>round_robin<span style="white-space:pre;">	</span>Selection mechanism. Must be either round_robin, random or FQCN of custom class that inherits from AbstractSinkSelector<br><span style="white-space:pre;">		</span>processor.selector.maxTimeOut<span style="white-space:pre;">	</span>30000<span style="white-space:pre;">	</span>Used by backoff selectors to limit exponential backoff (in milliseconds)<br><br><br><span style="white-space:pre;">		</span>------<br><span style="white-space:pre;">		</span>a1.sinkgroups = g1<br><span style="white-space:pre;">		</span>a1.sinkgroups.g1.sinks = k1 k2<br><span style="white-space:pre;">		</span>a1.sinkgroups.g1.processor.type = load_balance<br><span style="white-space:pre;">		</span>a1.sinkgroups.g1.processor.backoff = true<br><span style="white-space:pre;">		</span>a1.sinkgroups.g1.processor.selector = random<br><span style="white-space:pre;">		</span>------<span style="white-space:pre;">	</span><br><br><br>9.Interceptors - 拦截器<br><span style="white-space:pre;">	</span>0.概述<br><span style="white-space:pre;">		</span>Flume有能力在运行阶段修改/删除Event，这是通过拦截器（Interceptors）来实现的。<br><span style="white-space:pre;">		</span>拦截器需要实现org.apache.flume.interceptor.Interceptor接口。<br><span style="white-space:pre;">		</span>拦截器可以修改或删除事件基于开发者在选择器中选择的任何条件。<br><span style="white-space:pre;">		</span>拦截器采用了责任链模式，多个拦截器可以按指定顺序拦截。<br><span style="white-space:pre;">		</span>一个拦截器返回的事件列表被传递给链中的下一个拦截器。<br><span style="white-space:pre;">		</span>如果一个拦截器需要删除事件，它只需要在返回的事件集中不包含要删除的事件即可。<br><span style="white-space:pre;">		</span>如果要删除所有事件，只需返回一个空列表。<br><span style="white-space:pre;">		</span><br><span style="white-space:pre;">	</span>1.Timestamp Interceptor<br><span style="white-space:pre;">		</span>这个拦截器在事件头中插入以毫秒为单位的当前处理时间。<br><span style="white-space:pre;">		</span>头的名字为timestamp，值为当前处理的时间戳。<br><span style="white-space:pre;">		</span>如果在之前已经有这个时间戳，则不保留原有的时间戳。<br><br><br><span style="white-space:pre;">		</span>参数说明：<br><span style="white-space:pre;">			</span>!type<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>类型名称，必须是timestamp或自定义类的全路径名<br><span style="white-space:pre;">			</span>preserveExisting<span style="white-space:pre;">	</span>false<span style="white-space:pre;">	</span>如果时间戳已经存在是否保留<br><br><br><span style="white-space:pre;">	</span>2.Host Interceptor<br><span style="white-space:pre;">		</span>这个拦截器插入当前处理Agent的主机名或ip<br><span style="white-space:pre;">		</span>头的名字为host或配置的名称<br><span style="white-space:pre;">		</span>值是主机名或ip地址，基于配置。<br><br><br><span style="white-space:pre;">		</span>参数说明：<br><span style="white-space:pre;">			</span>!type<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>类型名称，必须是host<br><span style="white-space:pre;">			</span>preserveExisting<span style="white-space:pre;">	</span>false<span style="white-space:pre;">	</span>如果主机名已经存在是否保留<br><span style="white-space:pre;">			</span>useIP<span style="white-space:pre;">	</span>true<span style="white-space:pre;">	</span>如果配置为true则用IP，配置为false则用主机名<br><span style="white-space:pre;">			</span>hostHeader<span style="white-space:pre;">	</span>host<span style="white-space:pre;">	</span>加入头时使用的名称<br><br><br><span style="white-space:pre;">	</span>3.Static Interceptor<br><span style="white-space:pre;">		</span>此拦截器允许用户增加静态头信息使用静态的值到所有事件。<br><span style="white-space:pre;">		</span>目前的实现中不允许一次指定多个头。<br><span style="white-space:pre;">		</span>如果需要增加多个静态头可以指定多个Static interceptors<br><span style="white-space:pre;">		</span>属性说明:<br><span style="white-space:pre;">			</span>!type<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>类型，必须是static<br><span style="white-space:pre;">			</span>preserveExisting<span style="white-space:pre;">	</span>true<span style="white-space:pre;">	</span>如果配置头已经存在是否应该保留<br><span style="white-space:pre;">			</span>key<span style="white-space:pre;">	</span>key<span style="white-space:pre;">	</span>要增加的透明<br><span style="white-space:pre;">			</span>value<span style="white-space:pre;">	</span>value<span style="white-space:pre;">	</span>要增加的头值<br><br><br><span style="white-space:pre;">	</span>4.UUID Interceptor<br><span style="white-space:pre;">		</span>这个拦截器在所有事件头中增加一个全局一致性标志。<br><span style="white-space:pre;">		</span>其实就是UUID。<br><br><br><span style="white-space:pre;">		</span>属性说明：<br><span style="white-space:pre;">			</span>!type<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>类型名称，必须是org.apache.flume.sink.solr.morphline.UUIDInterceptor$Builder<br><span style="white-space:pre;">			</span>headerName<span style="white-space:pre;">	</span>id<span style="white-space:pre;">	</span>头名称<br><span style="white-space:pre;">			</span>preserveExisting<span style="white-space:pre;">	</span>true<span style="white-space:pre;">	</span>如果头已经存在，是否保留<br><span style="white-space:pre;">			</span>prefix<span style="white-space:pre;">	</span>“”<span style="white-space:pre;">	</span>在UUID前拼接的字符串前缀<br><span style="white-space:pre;">		</span><br><span style="white-space:pre;">	</span>5.Search and Replace Interceptor<br><span style="white-space:pre;">		</span>这个拦截器提供了简单的基于字符串的正则搜索和替换功能。<br><br><br><span style="white-space:pre;">		</span>属性说明：<br><span style="white-space:pre;">			</span>type<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>类型名称，必须是"search_replace"<br><span style="white-space:pre;">			</span>searchPattern<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>要搜索和替换的正则表达式<br><span style="white-space:pre;">			</span>replaceString<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>要替换为的字符串<br><span style="white-space:pre;">			</span>charset<span style="white-space:pre;">	</span>UTF-8<span style="white-space:pre;">	</span>字符集编码，默认utf-8<br><br><br><span style="white-space:pre;">	</span>6.Regex Filtering Interceptor<br><span style="white-space:pre;">		</span>此拦截器通过解析事件体去匹配给定正则表达式来筛选事件。<br><span style="white-space:pre;">		</span>所提供的正则表达式即可以用来包含或刨除事件。<br><br><br><span style="white-space:pre;">		</span>属性说明：<br><span style="white-space:pre;">		</span>!type<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>类型，必须设定为regex_filter<br><span style="white-space:pre;">		</span>regex<span style="white-space:pre;">	</span>”.*” 所要匹配的正则表达式<br><span style="white-space:pre;">		</span>excludeEvents<span style="white-space:pre;">	</span>false<span style="white-space:pre;">	</span>如果是true则刨除匹配的事件，false则包含匹配的事件。<br><br><br><span style="white-space:pre;">	</span>#7.Regex Extractor Interceptor<br><span style="white-space:pre;">		</span>使用指定正则表达式匹配事件，并将匹配到的组作为头加入到事件中。<br><span style="white-space:pre;">		</span>它也支持插件化的序列化器用来格式化匹配到的组在加入他们作为头之前。<br><br><br><span style="white-space:pre;">		</span>属性说明：<br><span style="white-space:pre;">			</span>!type<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>类型，必须是regex_extractor<br><span style="white-space:pre;">			</span>!regex<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>要匹配的正则表达式<br><span style="white-space:pre;">			</span>!serializers<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>Space-separated list of serializers for mapping matches to header names and serializing their values. (See example below) Flume provides built-in support for the following serializers: org.apache.flume.interceptor.RegexExtractorInterceptorPassThroughSerializer org.apache.flume.interceptor.RegexExtractorInterceptorMillisSerializer<br><span style="white-space:pre;">			</span>serializers.&lt;s1&gt;.type<span style="white-space:pre;">	</span>default<span style="white-space:pre;">	</span>Must be default (org.apache.flume.interceptor.RegexExtractorInterceptorPassThroughSerializer), org.apache.flume.interceptor.RegexExtractorInterceptorMillisSerializer, or the FQCN of a custom class that implements org.apache.flume.interceptor.RegexExtractorInterceptorSerializer<br><span style="white-space:pre;">			</span>serializers.&lt;s1&gt;.name<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span> <br><span style="white-space:pre;">			</span>serializers.*<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>Serializer-specific properties<br><br><br><span style="white-space:pre;">		</span>----<br><span style="white-space:pre;">		</span>If the Flume event body contained 1:2:3.4foobar5 and the following configuration was used<br><span style="white-space:pre;">											</span><br><span style="white-space:pre;">		</span>a1.sources.r1.interceptors.i1.regex = (\\d):(\\d):(\\d)<br><span style="white-space:pre;">		</span>a1.sources.r1.interceptors.i1.serializers = s1 s2 s3<br><span style="white-space:pre;">		</span>a1.sources.r1.interceptors.i1.serializers.s1.name = one<br><span style="white-space:pre;">		</span>a1.sources.r1.interceptors.i1.serializers.s2.name = two<br><span style="white-space:pre;">		</span>a1.sources.r1.interceptors.i1.serializers.s3.name = three<br><br><br><span style="white-space:pre;">		</span>The extracted event will contain the same body but the following headers will have been added one=&gt;1, two=&gt;2, three=&gt;3<br><span style="white-space:pre;">		</span>----<br><span style="white-space:pre;">		</span><br>10.channel<br><span style="white-space:pre;">	</span>!!!1.Memory Channel 内存通道<br><span style="white-space:pre;">		</span>事件将被存储在内存中的具有指定大小的队列中。<br><span style="white-space:pre;">		</span>非常适合那些需要高吞吐量但是失败是会丢失数据的场景下。<br><br><br><span style="white-space:pre;">		</span>属性说明：<br><span style="white-space:pre;">			</span>!type<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>类型，必须是“memory”<br><span style="white-space:pre;">			</span>capacity<span style="white-space:pre;">	</span>100<span style="white-space:pre;">	</span>事件存储在信道中的最大数量<br><span style="white-space:pre;">			</span>transactionCapacity<span style="white-space:pre;">	</span>100<span style="white-space:pre;">	</span>每个事务中的最大事件数<br><span style="white-space:pre;">			</span>keep-alive<span style="white-space:pre;">	</span>3<span style="white-space:pre;">	</span>添加或删除操作的超时时间<br><span style="white-space:pre;">			</span>byteCapacityBufferPercentage<span style="white-space:pre;">	</span>20<span style="white-space:pre;">	</span>Defines the percent of buffer between byteCapacity and the estimated total size of all events in the channel, to account for data in headers. See below.<br><span style="white-space:pre;">			</span>byteCapacity<span style="white-space:pre;">	</span>see description<span style="white-space:pre;">	</span>Maximum total bytes of memory allowed as a sum of all events in this channel. The implementation only counts the Event body, which is the reason for providing the byteCapacityBufferPercentage configuration parameter as well. Defaults to a computed value equal to 80% of the maximum memory available to the JVM (i.e. 80% of the -Xmx value passed on the command line). Note that if you have multiple memory channels on a single JVM, and they happen to hold the same physical events (i.e. if you are using a replicating channel selector from a single source) then those event sizes may be double-counted for channel byteCapacity purposes. Setting this value to 0 will cause this value to fall back to a hard internal limit of about 200 GB.<br><br><br><span style="white-space:pre;">		</span>案例:参看入门案例<br><span style="white-space:pre;">	</span>2.JDBC Channel<br><span style="white-space:pre;">		</span>事件被持久存储在可靠的数据库中。目前支持嵌入式的Derby数据库。如果可恢复性非常的重要可以使用这种方式。<br><br><br><span style="white-space:pre;">	</span>!!!3.File Channel<br><span style="white-space:pre;">		</span>性能会比较低下，但是即使程序出错数据不会丢失<br><span style="white-space:pre;">		</span>属性说明:<br><span style="white-space:pre;">			</span>!type<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>类型，必须是“file”<br><span style="white-space:pre;">			</span>checkpointDir<span style="white-space:pre;">	</span>~/.flume/file-channel/checkpoint<span style="white-space:pre;">	</span>检查点文件存放的位置<br><span style="white-space:pre;">			</span>useDualCheckpoints<span style="white-space:pre;">	</span>false<span style="white-space:pre;">	</span>Backup the checkpoint. If this is set to true, backupCheckpointDir must be set<br><span style="white-space:pre;">			</span>backupCheckpointDir<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>The directory where the checkpoint is backed up to. This directory must not be the same as the data directories or the checkpoint directory<br><span style="white-space:pre;">			</span>dataDirs<span style="white-space:pre;">	</span>~/.flume/file-channel/data<span style="white-space:pre;">	</span>逗号分隔的目录列表，用以存放日志文件。使用单独的磁盘上的多个目录可以提高文件通道效率。<br><span style="white-space:pre;">			</span>transactionCapacity<span style="white-space:pre;">	</span>10000<span style="white-space:pre;">	</span>The maximum size of transaction supported by the channel<br><span style="white-space:pre;">			</span>checkpointInterval<span style="white-space:pre;">	</span>30000<span style="white-space:pre;">	</span>Amount of time (in millis) between checkpoints<br><span style="white-space:pre;">			</span>maxFileSize<span style="white-space:pre;">	</span>2146435071<span style="white-space:pre;">	</span>一个日志文件的最大尺寸<br><span style="white-space:pre;">			</span>minimumRequiredSpace<span style="white-space:pre;">	</span>524288000<span style="white-space:pre;">	</span>Minimum Required free space (in bytes). To avoid data corruption, File Channel stops accepting take/put requests when free space drops below this value<br><span style="white-space:pre;">			</span>capacity<span style="white-space:pre;">	</span>1000000<span style="white-space:pre;">	</span>Maximum capacity of the channel<br><span style="white-space:pre;">			</span>keep-alive<span style="white-space:pre;">	</span>3<span style="white-space:pre;">	</span>Amount of time (in sec) to wait for a put operation<br><span style="white-space:pre;">			</span>use-log-replay-v1<span style="white-space:pre;">	</span>false<span style="white-space:pre;">	</span>Expert: Use old replay logic<br><span style="white-space:pre;">			</span>use-fast-replay<span style="white-space:pre;">	</span>false<span style="white-space:pre;">	</span>Expert: Replay without using queue<br><span style="white-space:pre;">			</span>checkpointOnClose<span style="white-space:pre;">	</span>true<span style="white-space:pre;">	</span>Controls if a checkpoint is created when the channel is closed. Creating a checkpoint on close speeds up subsequent startup of the file channel by avoiding replay.<br><span style="white-space:pre;">			</span>encryption.activeKey<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>Key name used to encrypt new data<br><span style="white-space:pre;">			</span>encryption.cipherProvider<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>Cipher provider type, supported types: AESCTRNOPADDING<br><span style="white-space:pre;">			</span>encryption.keyProvider<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>Key provider type, supported types: JCEKSFILE<br><span style="white-space:pre;">			</span>encryption.keyProvider.keyStoreFile<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>Path to the keystore file<br><span style="white-space:pre;">			</span>encrpytion.keyProvider.keyStorePasswordFile<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>Path to the keystore password file<br><span style="white-space:pre;">			</span>encryption.keyProvider.keys<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>List of all keys (e.g. history of the activeKey setting)<br><span style="white-space:pre;">			</span>encyption.keyProvider.keys.*.passwordFile<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>Path to the optional key password file<br><span style="white-space:pre;">	</span>!!!4.Spillable Memory Channel -- 内存溢出通道<br><span style="white-space:pre;">		</span>事件被存储在内存队列和磁盘中。<br><span style="white-space:pre;">		</span>内存队列作为主存储，而磁盘作为溢出内容的存储。<br><span style="white-space:pre;">		</span>内存存储通过embedded File channel来进行管理。<br><span style="white-space:pre;">		</span>当内存队列已满时，后续的事件将被存储在文件通道中。 <br><span style="white-space:pre;">		</span>这个通道适用于正常操作期间适用内存通道已期实现高效吞吐，而在高峰期间适用文件通道实现高耐受性。通过降低吞吐效率提高系统可耐受性。<br><span style="white-space:pre;">		</span>如果Agent崩溃，则只有存储在文件系统中的事件可以被恢复。<br><span style="white-space:pre;">		</span>此通道处于试验阶段，不建议在生产环境中使用。 <br><br><br><span style="white-space:pre;">		</span>属性说明：<br><span style="white-space:pre;">		</span>!type<span style="white-space:pre;">	</span>–<span style="white-space:pre;">	</span>类型，必须是"SPILLABLEMEMORY"<br><span style="white-space:pre;">		</span>memoryCapacity<span style="white-space:pre;">	</span>10000<span style="white-space:pre;">	</span>内存中存储事件的最大值，如果想要禁用内存缓冲区将此值设置为0。<br><span style="white-space:pre;">		</span>overflowCapacity<span style="white-space:pre;">	</span>100000000<span style="white-space:pre;">	</span>可以存储在磁盘中的事件数量最大值。设置为0可以禁用磁盘存储。 <br><span style="white-space:pre;">		</span>overflowTimeout<span style="white-space:pre;">	</span>3<span style="white-space:pre;">	</span>The number of seconds to wait before enabling disk overflow when memory fills up.<br><span style="white-space:pre;">		</span>byteCapacityBufferPercentage<span style="white-space:pre;">	</span>20<span style="white-space:pre;">	</span>Defines the percent of buffer between byteCapacity and the estimated total size of all events in the channel, to account for data in headers. See below.<br><span style="white-space:pre;">		</span>byteCapacity<span style="white-space:pre;">	</span>see description<span style="white-space:pre;">	</span>Maximum bytes of memory allowed as a sum of all events in the memory queue. The implementation only counts the Event body, which is the reason for providing the byteCapacityBufferPercentage configuration parameter as well. Defaults to a computed value equal to 80% of the maximum memory available to the JVM (i.e. 80% of the -Xmx value passed on the command line). Note that if you have multiple memory channels on a single JVM, and they happen to hold the same physical events (i.e. if you are using a replicating channel selector from a single source) then those event sizes may be double-counted for channel byteCapacity purposes. Setting this value to 0 will cause this value to fall back to a hard internal limit of about 200 GB.<br><span style="white-space:pre;">		</span>avgEventSize<span style="white-space:pre;">	</span>500<span style="white-space:pre;">	</span>Estimated average size of events, in bytes, going into the channel<br><span style="white-space:pre;">		</span>&lt;file channel properties&gt;<span style="white-space:pre;">	</span>see file channel<span style="white-space:pre;">	</span>Any file channel property with the exception of ‘keep-alive’ and ‘capacity’ can be used. The keep-alive of file channel is managed by Spillable Memory Channel. Use ‘overflowCapacity’ to set the File channel’s capacity.<br><br><br><span style="white-space:pre;">	</span>5.自定义通道<br><span style="white-space:pre;">		</span>自定义渠道需要自己实现Channel接口。<br><span style="white-space:pre;">		</span>自定义Channle类及其依赖类必须在Flume启动前放置到类加载的目录下。<br><br><br><span style="white-space:pre;">		</span>参数说明：<br><span style="white-space:pre;">			</span>type - 自己实现的Channle类的全路径名称<br><br><br><br><br><br><br>----------------------------------------------<br>课后练习<br><span style="white-space:pre;">	</span>flume从多个netcat中获取日志<br><span style="white-space:pre;">	</span>通过Interceptors在事件中增加host信息<br><span style="white-space:pre;">	</span>通过selector实现多路复用<br><span style="white-space:pre;">	</span>不同的ip进行扇出，进入不同的channel和sink进行发送<br><span style="white-space:pre;">	</span>存储到本地文件系统 存储到hdfs 存储到logger中<br><span style="white-space:pre;">	</span><br><span style="white-space:pre;">	</span>整体结构参看图<br><span style="white-space:pre;">	</span>            </div>
                </div>