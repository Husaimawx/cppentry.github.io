---
layout:     post
title:      Flume整体架构总结
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								<div class="article-copyright">
					版权声明：本文为博主原创文章，未经博主允许不得转载。					https://blog.csdn.net/qq_35488412/article/details/78491222				</div>
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                <h1><span style="color:#333399;">Flume简介<span style="font-size:18px;">：</span></span></h1><p><span style="font-size:18px;"> Flume 是Cloudera提供的一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统， Flume支持在日志系统中定制各类数据发送方，用于收集数据；同时，Flume提供对数据进行简单处理，并写到各种数据接受方（可定制）的能力。（Flume使用java编写，支持Java1.6及以上。）</span></p><p><span style="font-size:18px;"><span style="color:rgb(51,51,51);">由原来的</span><span style="color:rgb(51,51,51);">Flume OG</span><span style="color:rgb(51,51,51);">到现在的</span><span style="color:rgb(51,51,51);">Flume NG</span><span style="color:rgb(51,51,51);">，进行了架构重构，并且现在</span><span style="color:rgb(51,51,51);">NG</span><span style="color:rgb(51,51,51);">版本完全不兼容原来的</span><span style="color:rgb(51,51,51);">OG</span><span style="color:rgb(51,51,51);">版本。经过架构重构后，</span><span style="color:rgb(51,51,51);">Flume NG</span><span style="color:rgb(51,51,51);">更像是一个轻量的小工具，非常简单，容易适应各种方式日志收集，并支持</span><span style="color:rgb(51,51,51);">failover</span><span style="color:rgb(51,51,51);">和负载均衡。</span></span></p><p><span style="font-size:18px;"><span style="color:rgb(51,51,51);"><br></span></span></p><p><span style="font-size:24px;color:#ff0000;">1.主要的核心概念：</span></p><p style="text-align:center;"><span style="font-size:24px;"><img src="" alt=""><br></span></p><p></p><p><span style="font-size:18px;"><em>Event</em><span style="color:rgb(51,51,51);">：</span><span style="color:rgb(51,51,51);">flume</span><span style="color:rgb(51,51,51);">最基本的数据单元，带有一个可选的消息头（</span><span style="color:rgb(51,51,51);">headers</span><span style="color:rgb(51,51,51);">）</span><span style="color:rgb(51,51,51);">。如果是文本，</span><span style="color:rgb(51,51,51);">event</span><span style="color:rgb(51,51,51);">通常是一行记录，</span><span style="color:rgb(51,51,51);">event</span><span style="color:rgb(51,51,51);">也是事务的基本单位。</span></span></p><p><span style="font-size:18px;"><em>Flow</em><span style="color:rgb(51,51,51);">：</span><span style="color:rgb(51,51,51);">Event</span><span style="color:rgb(51,51,51);">从源点到达目的点的迁移的抽象。</span></span></p><p><span style="font-size:18px;"><em>Client</em><span style="color:rgb(51,51,51);">：操作位于源点处的</span><span style="color:rgb(51,51,51);">Event</span><span style="color:rgb(51,51,51);">，将其发送到</span><span style="color:rgb(51,51,51);">Flume Agent</span><span style="color:rgb(51,51,51);">。</span></span></p><p><span style="font-size:18px;"><em>Agent</em><span style="color:rgb(51,51,51);">：一个独立的</span><span style="color:rgb(51,51,51);">Flume</span><span style="color:rgb(51,51,51);">进程，包含组件</span><span style="color:rgb(51,51,51);">Source</span><span style="color:rgb(51,51,51);">、</span><span style="color:rgb(51,51,51);">Channel</span><span style="color:rgb(51,51,51);">、</span><span style="color:rgb(51,51,51);">Sink</span><span style="color:rgb(51,51,51);">。</span></span></p><p><span style="font-size:18px;"><em>Source</em><span style="color:rgb(51,51,51);">：用来消费传递到该组件的</span><span style="color:rgb(51,51,51);">Event</span><span style="color:rgb(51,51,51);">，完成对数据的收集，分成</span><span style="color:rgb(51,51,51);">transtion</span><span style="color:rgb(51,51,51);">和</span><span style="color:rgb(51,51,51);">event</span><span style="color:rgb(51,51,51);">打入到</span><span style="color:rgb(51,51,51);">channel</span><span style="color:rgb(51,51,51);">之中。不同的</span><span style="color:rgb(51,51,51);"> source</span><span style="color:rgb(51,51,51);">，可以接受不同的数据格式。</span></span></p><p><span style="font-size:18px;"><em>Channel</em>:<span style="color:rgb(51,51,51);">主要提供一个队列的功能，对</span><span style="color:rgb(51,51,51);">source</span><span style="color:rgb(51,51,51);">提供中的数据进行简单缓存，作用是保证</span><span style="color:rgb(51,51,51);">source</span><span style="color:rgb(51,51,51);">到</span><span style="color:rgb(51,51,51);">sink</span><span style="color:rgb(51,51,51);">的数据传输过程一定能成功。</span></span></p><p><span style="font-size:18px;"><em>Sink</em><span style="color:rgb(51,51,51);">：取出</span><span style="color:rgb(51,51,51);">Channel</span><span style="color:rgb(51,51,51);">中的数据，进行相应的存储文件系统、数据库等。</span></span></p><p align="left"><span style="font-size:18px;"> </span></p><blockquote style="border:none;"><p align="left"><span style="background-color:rgb(255,255,255);"><span style="font-size:18px;color:#33ccff;">Flume逻辑上分三层架构：agent，collector，storage。</span></span></p><p align="left" style="text-align:center;"><span style="background-color:rgb(255,255,255);"><span style="font-size:18px;color:#33ccff;"><img src="https://img-blog.csdn.net/20171110123606121?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU0ODg0MTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></span></span></p><p align="left" style="text-align:center;"><span style="background-color:rgb(255,255,255);"><span style="font-size:18px;color:#33ccff;"><img src="" alt=""><br></span></span></p></blockquote><p align="center"></p><p><span style="font-size:18px;"><em>agent </em><span style="color:rgb(51,51,51);background:rgb(254,254,254);">用于采集数据，</span><span style="color:rgb(51,51,51);background:rgb(254,254,254);">agent</span><span style="color:rgb(51,51,51);background:rgb(254,254,254);">是</span><span style="color:rgb(51,51,51);background:rgb(254,254,254);">flume</span><span style="color:rgb(51,51,51);background:rgb(254,254,254);">中产生数据流的地方，同时，</span><span style="color:rgb(51,51,51);background:rgb(254,254,254);">agent</span><span style="color:rgb(51,51,51);background:rgb(254,254,254);">会将产生的数据流传输到</span><span style="color:rgb(51,51,51);background:rgb(254,254,254);">collector</span><span style="color:rgb(51,51,51);background:rgb(254,254,254);">。</span><span style="color:rgb(51,51,51);"><br></span><em>collector </em><span style="color:rgb(51,51,51);background:rgb(254,254,254);">的作用是将多个</span><span style="color:rgb(51,51,51);background:rgb(254,254,254);">agent</span><span style="color:rgb(51,51,51);background:rgb(254,254,254);">的数据汇总后，加载到</span><span style="color:rgb(51,51,51);background:rgb(254,254,254);">storage</span><span style="color:rgb(51,51,51);background:rgb(254,254,254);">中。</span></span></p><p><span style="font-size:18px;"><em>storage </em><span style="color:rgb(51,51,51);background:rgb(254,254,254);">是存储系统，可以是一个普通</span><span style="color:rgb(51,51,51);background:rgb(254,254,254);">file</span><span style="color:rgb(51,51,51);background:rgb(254,254,254);">，也可以是</span><span style="color:rgb(51,51,51);background:rgb(254,254,254);">HDFS</span><span style="color:rgb(51,51,51);background:rgb(254,254,254);">，</span><span style="color:rgb(51,51,51);background:rgb(254,254,254);">HIVE</span><span style="color:rgb(51,51,51);background:rgb(254,254,254);">，</span><span style="color:rgb(51,51,51);background:rgb(254,254,254);">HBase</span><span style="color:rgb(51,51,51);background:rgb(254,254,254);">等。</span></span></p><p><span style="font-size:18px;"><span style="color:rgb(51,51,51);background:rgb(254,254,254);"><br></span></span></p><h2><span style="font-size:24px;"><span style="color:#ff0000;">2.核心组件配置介绍：</span></span></h2><p><em><span style="font-size:24px;color:#33ffff;">source：</span></em><span style="font-size:18px;">client端操作消费数据的来源，支持的类型有Avro、log4j、tailDir、http post、Thrift、JMS、Spooling Directory等类型。</span></p><p style="text-align:center;"><span style="font-size:18px;"><img src="https://img-blog.csdn.net/20171110123648394?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU0ODg0MTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></span></p><p><span style="font-size:18px;"><img src="" alt=""><br></span></p><p></p><p align="left"><span style="font-size:18px;"><span style="color:#333333;">       对原程序影响最小的方式是直接读取程序原来记录的日志文件，基本可以实现无缝接入，不需要对现有程序进行任何改动。</span><strong>对于直接读取文件 Source,有两种方式：</strong></span></p><ul type="disc"><li style="color:rgb(51,51,51);"><span style="font-size:18px;">ExecSource: 以运行 Linux 命令的方式，持续的输出最新的数据，如 <span style="color:#C7254E;background:#F9F2F4;">tail -F</span><span style="color:#C7254E;background:#F9F2F4;">文件名</span> 指令，在这种方式下，取的文件名必须是指定的。 ExecSource 可以实现对日志的实时收集，但是存在Flume不运行、指令执行出错或者channel爆仓，将导致event传送失败，无法保证日志数据的完整性。</span></li><li style="color:rgb(51,51,51);"><span style="font-size:18px;">SpoolSource: 监测配置的目录下新增的文件，并将文件中的数据读取出来。需要注意两点：拷贝到 spool 目录下的文件不可以再打开编辑；spool 目录下不可包含相应的子目录。</span></li></ul><p align="left"><span style="font-size:18px;"><span style="color:#333333;">SpoolSource</span><span style="color:#333333;">虽然无法实现实时的收集数据，但是可以使用以分钟的方式分割文件，趋近于实时。</span></span></p><p><span style="font-size:18px;">    使用SpoolingDirectorySource的时候，一定要避免同时读写一个文件的情况。 可以通过 source1.ignorePattern=^(.)*\\.tmp$ 配置，让spoolingsource不读取该格式的文件。</span></p><p><span style="font-size:18px;">    <span style="color:#ff0000;">RPC：</span> RPC 的主要功能目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。</span></p><p><span style="font-size:18px;">        比如服务器A、B，一个应用部署在A服务器上，相应调用B服务器上应用提供的函数\方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。1.首先解决通讯问题，建立TCP连接，解决寻址问题。通过序列化利用二进制传输，收到数据后反序列化，恢复内存中的表达方式，找到对应方法后执行得到返回值。</span></p><p><span style="font-size:18px;"><span style="color:#ff0000;">    Avro</span>:  是一个基于二进制数据传输的高性能的中间件，avro可以将数据结构或对象转化为便于存储或传输的格式，适合远程或本地大规模的存储和交。Avro支持两种序列化编码方式：二进制编码和JSON编码。使用二进制编码会高效序列化，并且序列化后得到的结果会比较小；而JSON一般用于调试系统或是基于WEB的应用。Avro也被作为一种RPC框架来使用。</span></p><p><span style="font-size:18px;">   <span style="color:#ff0000;">Thrift</span>： <a href="https://thrift.apache.org/" rel="nofollow"><span style="color:#000000;">Thrift</span></a>是一个跨语言的服务部署框架，最初由Facebook于2007年开发，2008年进入Apache开源项目。Thrift通过IDL（Interface Definition Language，接口定义语言）来定义<a href="http://www.ibm.com/developerworks/cn/aix/library/au-rpc_programming/" rel="nofollow"><span style="color:#000000;">RPC</span></a>（Remote Procedure Call，远程过程调用）的接口和数据类型，然后通过thrift编译器生成不同语言的代码（目前支持C++,Java, Python, PHP, Ruby, Erlang, Perl,Haskell, C#, Cocoa, Smalltalk和OCaml），并由生成的代码负责RPC协议层和传输层的实现。</span></p><p><span style="font-size:18px;"> <span style="color:#ff0000;">  Netcat</span>： NetCat是一个非常简单的Unix工具，可以读、写TCP或UDP网络连接(network connection)。最简单的使用方法，”nc host port”，能建立一个TCP连接，连向指定的主机和端口。接下来，你的从标准输入中输入的任何内容都会被发送到指定的主机，任何通过连接返回来的信息都被显示在你的标准输出上。这个连接会一直持续下去，至到连接两端的程序关闭连接。</span></p><p><span style="font-size:18px;"><em><span style="color:#33ffff;">channel： </span> </em>有MemoryChannel, JDBC Channel, File Channel, Kafka Channel. 比较常用的是前三种。有capacity、transactionCapacity、keep-alive等属性。</span></p><p><span style="font-size:18px;">MemoryChannel可以实现高速的吞吐，但是无法保证数据的完整性。</span></p><p><span style="font-size:18px;">FileChannel保证数据的完整性与一致性。在具体配置FileChannel时，建议FileChannel设置的目录和程序日志文件保存的目录设成不同的磁盘，以便提高效率。<em></em></span></p><p><span style="font-size:18px;"><em><span style="color:#33ffff;">Sink：</span></em>支持的数据类型：HDFS Sink,Logger Sink, Kafka Sink，Avro Sink, Thrift, IPC, File Roll 等。<em></em></span></p><p><span style="font-size:18px;"><span style="color:rgb(51,51,51);">Sink</span><span style="color:rgb(51,51,51);">在设置存储数据时，可以向文件系统、数据库、</span><span style="color:rgb(51,51,51);">hadoop</span><span style="color:rgb(51,51,51);">存数据，在日志数据较少时，可以将数据存储在文件系中，并且设定一定的时间间隔保存数据。在日志数据较多时，可以将相应的日志数据存储到</span><span style="color:rgb(51,51,51);">Hadoop</span><span style="color:rgb(51,51,51);">中，便于日后进行相应的数据分析。</span></span></p><p><span style="font-size:18px;"><span style="color:rgb(51,51,51);"><br></span></span></p><h2><span style="font-size:24px;"><span style="color:#ff0000;">3.应用场景：</span></span></h2><ul type="disc"><li style="color:#FF0000;"><span style="font-size:18px;">多个 agent 顺序连接：</span></li></ul><p style="text-align:center;"><span style="font-size:18px;"><img src="https://img-blog.csdn.net/20171110123720987?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU0ODg0MTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><img src="" alt="">       </span></p><p style="text-align:left;"><span style="font-size:18px;">可以将多个Agent顺序连接起来，将最初的数据源经过收集，存储到最终的存储系统中。这是最简单的情况，一般情况下，应该控制这种顺序连接的Agent的数量，因为数据流经的路径变长了，如果不考虑failover的话，出现故障将影响整个Flow上的Agent收集服务。</span></p><p><br></p><ul type="disc"><li style="color:#FF0000;"><span style="font-size:18px;">多个Agent的数据汇聚到同一个Agent:</span></li></ul><p><span style="font-size:18px;"><span style="color:rgb(51,51,51);">       这种情况应用的场景比较多，比如要收集</span><span style="color:rgb(51,51,51);">Web</span><span style="color:rgb(51,51,51);">网站的用户行为日志，</span><span style="color:rgb(51,51,51);">Web</span><span style="color:rgb(51,51,51);">网站为了可用性使用的负载均衡的集群模式，每个节点都产生用户行为日志，可以为每个节点都配置一个</span><span style="color:rgb(51,51,51);">Agent</span><span style="color:rgb(51,51,51);">来单独收集日志数据，然后多个</span><span style="color:rgb(51,51,51);">Agent</span><span style="color:rgb(51,51,51);">将数据最终汇聚到一个</span><span style="color:rgb(51,51,51);">agent</span><span style="color:rgb(51,51,51);">上用来存储数据存储系统，如</span><span style="color:rgb(51,51,51);">HDFS</span><span style="color:rgb(51,51,51);">上。</span></span></p><p style="text-align:center;"><span style="font-size:18px;"><span style="color:rgb(51,51,51);"><img src="https://img-blog.csdn.net/20171110123726546?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzU0ODg0MTI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></span></span></p><ul type="disc"><li style="color:#FF0000;"><span style="font-size:18px;">多路（Multiplexing）Agent</span></li></ul><p style="text-align:center;"><img src="" alt=""></p><p><span style="font-size:18px;">这种模式，有两种方式，一种是用来复制（Replication），另一种是用来分流（Multiplexing）。Replication方式，可以将最前端的数据源复制多份，分别传递到多个channel中，每个channel接收到的数据都是相同的。<span style="color:rgb(51,51,51);">Multiplexing</span><span style="color:rgb(51,51,51);">方式，</span><span style="color:rgb(51,51,51);">selector</span><span style="color:rgb(51,51,51);">可以根据</span><span style="color:rgb(51,51,51);">header</span><span style="color:rgb(51,51,51);">的值来确定数据传递到哪一个</span><span style="color:rgb(51,51,51);">channel</span><span style="color:rgb(51,51,51);">。</span></span></p><ul type="disc"><li style="color:#FF0000;"><span style="font-size:18px;">实现load balance功能</span></li></ul><p align="left"><span style="font-size:18px;"><span style="color:#333333;">Load balancing Sink Processor</span><span style="color:#333333;">能够实现</span><span style="color:#333333;">load balance</span><span style="color:#333333;">功能，上图</span><span style="color:#333333;">Agent1</span><span style="color:#333333;">是一个路由节点，负责将</span><span style="color:#333333;">Channel</span><span style="color:#333333;">暂存的</span><span style="color:#333333;">Event</span><span style="color:#333333;">均衡到对应的多个</span><span style="color:#333333;">Sink</span><span style="color:#333333;">组件上，而每个</span><span style="color:#333333;">Sink</span><span style="color:#333333;">组件分别连接到一个独立的</span><span style="color:#333333;">Agent</span><span style="color:#333333;">上。</span></span></p><ul type="disc"><li style="color:#FF0000;"><span style="font-size:18px;">实现failover能</span></li></ul><p align="left"><span style="font-size:18px;"><span style="color:#333333;">Failover Sink Processor</span><span style="color:#333333;">能够实现</span><span style="color:#333333;">failover</span><span style="color:#333333;">功能，具体流程类似</span><span style="color:#333333;">load balance</span><span style="color:#333333;">，但是内部处理机制与</span><span style="color:#333333;">load balance</span><span style="color:#333333;">完全不同：</span><span style="color:#333333;">Failover Sink Processor</span><span style="color:#333333;">维护一个优先级</span><span style="color:#333333;">Sink</span><span style="color:#333333;">组件列表，只要有一个</span><span style="color:#333333;">Sink</span><span style="color:#333333;">组件可用，</span><span style="color:#333333;">Event</span><span style="color:#333333;">就被传递到下一个组件。如果一个</span><span style="color:#333333;">Sink</span><span style="color:#333333;">能够成功处理</span><span style="color:#333333;">Event</span><span style="color:#333333;">，则会加入到一个</span><span style="color:#333333;">Pool</span><span style="color:#333333;">中，否则会被移出</span><span style="color:#333333;">Pool</span><span style="color:#333333;">并计算失败次数，设置一个惩罚因子。</span></span></p><p><em><span style="font-size:18px;"> </span></em></p><h2><em><span style="font-size:24px;"><strong><span style="color:#ff0000;">4相关场景：</span></strong></span><span style="font-size:18px;"><strong></strong></span></em></h2><p><span style="font-size:18px;"><span style="color:#FF0000;">启动</span><span style="color:#FF0000;">agent</span><span style="color:#FF0000;">的</span><span style="color:#FF0000;">shell</span><span style="color:#FF0000;">操作：</span></span></p><div><p align="left"><span style="color:#333333;"><span style="font-size:18px;">    flume-ng agent -n a1  -c  ../conf -f  ../conf/example.file</span></span></p><p align="left"><span style="color:#333333;"><span style="font-size:18px;">    -Dflume.root.logger=DEBUG,console </span></span></p></div><p><span style="font-size:18px;">参数说明：  -n 指定agent名称(与配置文件中代理的名字相同) <br>  -c 指定flume中配置文件的目录           -f 指定配置文件 <br>  -Dflume.root.logger=DEBUG,console 设置日志等级</span></p><p><span style="font-size:18px;">例：flume-ng agent -n a1 -c/usr/local/flume/conf -f /usr/local/flume/conf/avro.conf</span></p><p><span style="font-size:18px;"> -Dflume.root.logger=INFO,console</span></p><p><span style="font-size:18px;"><br></span></p><p align="left"><em><span style="font-size:18px;"><span style="color:#ff0000;">Kafka、Flume区别：</span>都可以实现数据传输，但侧重点不同。</span></em></p><p><strong><span style="font-size:18px;">Kafka追求的是高吞吐量、高负载（topic下可以有多个partition）</span></strong></p><p><strong><span style="font-size:18px;">Flume追求的是数据的多样性：数据来源的多样性、数据流向的多样性。</span></strong></p><p><span style="font-size:18px;">如果数据来源很单一、想要高吞吐的话可以使用Kafka；如果数据来源很多、数据流向很多的话可以使用Flume；也可以将Kafka和Flume结合起来使用。</span></p><p><em><span style="font-size:18px;"><span style="color:#ff0000;">关于flume和kafka的集成</span></span></em></p><p><span style="font-size:18px;">Flume的kafka Sink目前只支持Kafka 0.9及以上的版本，目前kafka最新版本是1.0</span></p><p><span style="font-size:18px;">Flume的source、channel、sink均支持kafka接口。</span></p><p></p><p><span style="font-size:18px;"> </span></p><span style="font-size:18px;"></span><p><span style="font-size:18px;">参考：</span><a href="http://flume.apache.org/FlumeUserGuide.html" rel="nofollow" style="font-size:18px;">Flume官方文档</a></p><p><a href="http://blog.javachen.com/2014/07/22/flume-ng.html" rel="nofollow"><span style="font-size:18px;">Flume-ng的原理和使用</span></a><br></p><p><span style="font-size:18px;"></span></p>            </div>
                </div>