---
layout:     post
title:      hive
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                <p style="margin-left:0cm;">学习目标：</p>

<p style="margin-left:0cm;">1、熟练掌握hive的使用</p>

<p style="margin-left:0cm;">2、熟练掌握hql的编写</p>

<p style="margin-left:0cm;">3、理解hive的工作原理</p>

<p style="margin-left:0cm;">4、具备hive应用实战能力</p>

<p> </p>

<p style="margin-left:203pt;"> </p>

<ul><li><strong><a name="_Toc436149194"></a><a name="_Toc439081658"> 一、Hive</a>基本概念</strong></li>
	<li><strong> <a name="_Toc436149195"></a><a name="_Toc439081659">1.1Hive</a>简介</strong></li>
	<li><strong><a name="_Toc439081660"></a><a name="_Toc436149196"> 1.1.1什么是Hive</a></strong></li>
</ul><p style="margin-left:0cm;">Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供类SQL查询功能。</p>

<ul><li><strong><a name="_Toc439081661"></a><a name="_Toc436149197"> 1.1.2为什么使用Hive</a></strong></li>
	<li>直接使用hadoop所面临的问题</li>
</ul><p style="margin-left:0cm;">人员学习成本太高</p>

<p style="margin-left:0cm;">项目周期要求太短</p>

<p style="margin-left:0cm;">MapReduce实现复杂查询逻辑开发难度太大</p>

<p style="margin-left:0cm;"> </p>

<ul><li>为什么要使用Hive</li>
</ul><p style="margin-left:0cm;">操作接口采用类SQL语法，提供快速开发的能力。</p>

<p style="margin-left:0cm;">避免了去写MapReduce，减少开发人员的学习成本。</p>

<p style="margin-left:0cm;">扩展功能很方便。</p>

<ul><li><strong><a name="_Toc439081662"></a><a name="_Toc436149198"> 1.1.3Hive</a>的特点</strong></li>
	<li>可扩展</li>
</ul><p style="margin-left:0cm;">Hive可以自由的扩展集群的规模，一般情况下不需要重启服务。</p>

<p style="margin-left:0cm;"> </p>

<ul><li>延展性</li>
</ul><p style="margin-left:0cm;">Hive支持用户自定义函数，用户可以根据自己的需求来实现自己的函数。</p>

<p style="margin-left:0cm;"> </p>

<ul><li>容错</li>
</ul><p style="margin-left:0cm;">良好的容错性，节点出现问题SQL仍可完成执行。</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p> </p>

<ul><li><strong> <a name="_Toc439081663"></a><a name="_Toc436149199">1.2Hive</a>架构</strong></li>
	<li><strong><a name="_Toc436149200"></a><a name="_Toc439081664"> 1.2.1架构图</a></strong></li>
</ul><p style="margin-left:0cm;"><img alt="" class="has" height="561" src="https://img-blog.csdnimg.cn/20181106165301954.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dveHV5YW9oYW9oYW94dWV4aQ==,size_16,color_FFFFFF,t_70" width="429"></p>

<p style="margin-left:0cm;"><span style="color:#0000ff;">Jobtracker</span><span style="color:#0000ff;">是hadoop1.x中的组件，它的功能相当于： Resourcemanager+AppMaster</span></p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><span style="color:#0000ff;">TaskTracker </span><span style="color:#0000ff;">相当于：  Nodemanager  +  yarnchild</span></p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<ul><li><strong><a name="_Toc439081665"></a><a name="_Toc436149201"> 1.2.2基本组成</a></strong></li>
	<li>用户接口：包括 CLI、JDBC/ODBC、WebGUI。</li>
	<li>元数据存储：通常是存储在关系数据库如 mysql , derby中。</li>
	<li>解释器、编译器、优化器、执行器。.</li>
</ul><p> </p>

<p> </p>

<p> </p>

<ul><li><strong><a name="_Toc436149202"></a><a name="_Toc439081666"> 1.2.3各组件的基本功能</a></strong></li>
	<li>用户接口主要由三个：CLI、JDBC/ODBC和WebGUI。其中，CLI为shell命令行；JDBC/ODBC是Hive的JAVA实现，与传统数据库JDBC类似；WebGUI是通过浏览器访问Hive。</li>
	<li>元数据存储：Hive 将元数据存储在数据库中。Hive 中的元数据包括表的名字，表的列和分区及其属性，表的属性（是否为外部表等），表的数据所在目录等。</li>
	<li>解释器、编译器、优化器完成 HQL 查询语句从词法分析、语法分析、编译、优化以及查询计划的生成。生成的查询计划存储在 HDFS 中，并在随后有 MapReduce 调用执行。</li>
</ul><p> </p>

<p> </p>

<ul><li> </li>
	<li><strong><a name="_Toc439081667">1.3Hive</a>与Hadoop的关系 </strong></li>
</ul><p style="margin-left:0cm;">Hive利用HDFS存储数据，利用MapReduce查询数据</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="270" src="https://img-blog.csdnimg.cn/20181106165505489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dveHV5YW9oYW9oYW94dWV4aQ==,size_16,color_FFFFFF,t_70" width="760"></p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p> </p>

<ul><li><strong><a name="_Toc439081668"></a><a name="_Toc436149204"> 1.4Hive</a>与传统数据库<a>对比</a></strong></li>
</ul><p style="margin-left:0cm;"><img alt="" class="has" height="308" src="https://img-blog.csdnimg.cn/20181106165534570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dveHV5YW9oYW9oYW94dWV4aQ==,size_16,color_FFFFFF,t_70" width="565"></p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><em>总结：hive</em><em>具有sql</em><em>数据库的外表，但应用场景完全不同，hive</em><em>只适合用来做批量数据统计分析</em></p>

<p> </p>

<ul><li><strong><a name="_Toc436149205"></a><a name="_Toc439081669"> 1.5Hive</a>的数据存储</strong></li>
</ul><p style="margin-left:0cm;">1、Hive中所有的数据都存储在 HDFS 中，没有专门的数据存储格式（可支持Text，SequenceFile，ParquetFile，RCFILE等）</p>

<p style="margin-left:0cm;">2、只需要在创建表的时候告诉 Hive 数据中的列分隔符和行分隔符，Hive 就可以解析数据。</p>

<p style="margin-left:0cm;">3、Hive 中包含以下数据模型：DB、Table，External Table，Partition，Bucket。</p>

<ul><li>db：在hdfs中表现为${hive.metastore.warehouse.dir}目录下一个文件夹</li>
	<li>table：在hdfs中表现所属db目录下一个文件夹</li>
	<li>external table：外部表, 与table类似，不过其数据存放位置可以在任意指定路径</li>
</ul><p style="margin-left:0cm;">普通表: 删除表后, hdfs上的文件都删了</p>

<p style="margin-left:0cm;">External外部表删除后, hdfs上的文件没有删除, 只是把文件删除了</p>

<ul><li>partition：在hdfs中表现为table目录下的子目录</li>
	<li>bucket：桶, 在hdfs中表现为同一个表目录下根据hash散列之后的多个文件, 会根据不同的文件把数据放到不同的文件中</li>
</ul><p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<ul><li>
	<p style="margin-left:0cm;"><strong>1.6 HIVE的安装部署</strong></p>
	</li>
	<li>
	<p style="margin-left:0cm;"><strong>1.6.1 安装</strong></p>
	</li>
</ul><p style="margin-left:0cm;">单机版：</p>

<p style="margin-left:0cm;">元数据库mysql版：</p>

<p style="margin-left:0cm;"> </p>

<h3 style="margin-left:0cm;"><strong>1.6.2 使用方式</strong></h3>

<p><strong>Hive交互shell</strong></p>

<p style="margin-left:0cm;">bin/hive</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p><strong>Hive thrift服务</strong></p>

<p style="margin-left:0cm;"><img alt="" class="has" height="444" src="https://img-blog.csdnimg.cn/2018110616563058.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dveHV5YW9oYW9oYW94dWV4aQ==,size_16,color_FFFFFF,t_70" width="1106"></p>

<p style="margin-left:0cm;">启动方式，（假如是在hadoop01上）：</p>

<p style="margin-left:0cm;">启动为前台：bin/hiveserver2</p>

<p style="margin-left:0cm;">启动为后台：nohup bin/hiveserver2 1&gt;/var/log/hiveserver.log 2&gt;/var/log/hiveserver.err &amp;</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">启动成功后，可以在别的节点上用beeline去连接</p>

<ul><li>方式（1）</li>
</ul><p style="margin-left:0cm;">hive/bin/beeline  回车，进入beeline的命令界面</p>

<p style="margin-left:0cm;">输入命令连接hiveserver2</p>

<p style="margin-left:0cm;">beeline&gt; !connect jdbc:hive2//mini1:10000</p>

<p style="margin-left:0cm;">（hadoop01是hiveserver2所启动的那台主机名，端口默认是10000）</p>

<ul><li>方式（2）</li>
</ul><p style="margin-left:0cm;">或者启动就连接：</p>

<p style="margin-left:0cm;"><strong><span style="color:#0000ff;">bin/beeline -u jdbc:hive2://mini1:10000 -n hadoop</span></strong></p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">接下来就可以做正常sql查询了</p>

<p style="margin-left:0cm;"> </p>

<p><strong>Hive命令</strong></p>

<p style="margin-left:0cm;">[hadoop@hdp-node-02 ~]$ hive  -e  ‘sql’</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<ul><li><strong><a name="_Toc439081670"></a><a name="_Toc436149206"> 二、Hive</a>基本操作</strong></li>
	<li><strong> <a name="_Toc436149207"></a><a name="_Toc439081671">2.1DDL</a>操作</strong></li>
	<li><strong><a name="_Toc439081672"></a><a name="_Toc436149208"> 2.1.1创建表</a></strong></li>
</ul><p><strong>建表语法</strong></p>

<p style="margin-left:0cm;">CREATE [EXTERNAL] TABLE [IF NOT EXISTS] table_name</p>

<p style="margin-left:0cm;">   [(col_name data_type [COMMENT col_comment], ...)]</p>

<p style="margin-left:0cm;">   [COMMENT table_comment]</p>

<p style="margin-left:0cm;">   [PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)]</p>

<p style="margin-left:0cm;">   [CLUSTERED BY (col_name, col_name, ...)</p>

<p style="margin-left:0cm;">   [SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS]</p>

<p style="margin-left:0cm;">   [ROW FORMAT row_format]</p>

<p style="margin-left:0cm;">   [STORED AS file_format]</p>

<p style="margin-left:0cm;">   [LOCATION hdfs_path]</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">说明：</p>

<p>1.CREATE TABLE 创建一个指定名字的表。如果相同名字的表已经存在，则抛出异常；用户可以用 IF NOT EXISTS 选项来忽略这个异常。</p>

<p>2.EXTERNAL关键字可以让用户创建一个外部表，在建表的同时指定一个指向实际数据的路径（LOCATION），Hive 创建内部表时，会将数据移动到数据仓库指向的路径；若创建外部表，仅记录数据所在的路径，不对数据的位置做任何改变。在删除表的时候，内部表的元数据和数据会被一起删除，而外部表只删除元数据，不删除数据。</p>

<p>3.LIKE 允许用户复制现有的表结构，但是不复制数据。</p>

<p>4.ROW FORMAT</p>

<p style="margin-left:0cm;">DELIMITED [FIELDS TERMINATED BY char] [COLLECTION ITEMS TERMINATED BY char]</p>

<p style="margin-left:0cm;">        [MAP KEYS TERMINATED BY char] [LINES TERMINATED BY char]</p>

<p style="margin-left:0cm;">   | SERDE serde_name [WITH SERDEPROPERTIES (property_name=property_value, property_name=property_value, ...)]</p>

<p style="margin-left:0cm;">用户在建表的时候可以自定义 SerDe 或者使用自带的 SerDe。如果没有指定 ROW FORMAT 或者 ROW FORMAT DELIMITED，将会使用自带的 SerDe。在建表的时候，用户还需要为表指定列，用户在指定表的列的同时也会指定自定义的 SerDe，Hive通过 SerDe 确定表的具体的列的数据。</p>

<p><strong>5.STORED AS</strong></p>

<p style="margin-left:0cm;">SEQUENCEFILE|TEXTFILE|RCFILE</p>

<p style="margin-left:0cm;">如果文件数据是纯文本，可以使用 STORED AS TEXTFILE。如果数据需要压缩，使用 STORED AS SEQUENCEFILE。</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:21pt;"><strong>6、CLUSTERED BY</strong></p>

<p style="margin-left:21pt;">对于每一个表（table）或者分区， Hive可以进一步组织成桶，也就是说桶是更为细粒度的数据范围划分。Hive也是 针对某一列进行桶的组织。Hive采用对列值哈希，然后除以桶的个数求余的方式决定该条记录存放在哪个桶当中。</p>

<p style="margin-left:21pt;">把表（或者分区）组织成桶（Bucket）有两个理由：</p>

<p style="margin-left:21pt;">（1）获得更高的查询处理效率。桶为表加上了额外的结构，Hive 在处理有些查询时能利用这个结构。具体而言，连接两个在（包含连接列的）相同列上划分了桶的表，可以使用 Map 端连接 （Map-side join）高效的实现。比如JOIN操作。对于JOIN操作两个表有一个相同的列，如果对这两个表都进行了桶操作。那么将保存相同列值的桶进行JOIN操作就可以，可以大大较少JOIN的数据量。</p>

<p style="margin-left:21pt;">（2）使取样（sampling）更高效。在处理大规模数据集时，在开发和修改查询的阶段，如果能在数据集的一小部分数据上试运行查询，会带来很多方便。</p>

<p style="margin-left:21pt;"> </p>

<p style="margin-left:21pt;"> </p>

<ul><li><strong>具体实例</strong></li>
	<li>创建内部表mytable。</li>
</ul><p style="margin-left:0cm;"><img alt="" class="has" height="115" src="https://img-blog.csdnimg.cn/20181106165934558.png" width="487"></p>

<p style="margin-left:0cm;"> </p>

<ul><li>创建外部表pageview。</li>
</ul><p style="margin-left:0cm;"><img alt="" class="has" height="157" src="https://img-blog.csdnimg.cn/20181106165938439.png" width="484"></p>

<p style="margin-left:0cm;"> </p>

<ul><li>创建分区表invites。</li>
</ul><table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:426.1pt;">
			<p style="margin-left:0cm;">create table student_p(Sno int,Sname string,Sex string,Sage int,Sdept string) partitioned by(part string) row format delimited fields terminated by ','stored as textfile;</p>
			</td>
		</tr></tbody></table><p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><img alt="" class="has" height="440" src="https://img-blog.csdnimg.cn/20181106165950176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dveHV5YW9oYW9oYW94dWV4aQ==,size_16,color_FFFFFF,t_70" width="754"></p>

<p style="margin-left:0cm;"> </p>

<ul><li>创建带桶的表student。</li>
</ul><p style="margin-left:0cm;"><img alt="" class="has" height="269" src="https://img-blog.csdnimg.cn/20181106165953544.png" width="841"></p>

<p> </p>

<p> </p>

<ul><li><strong><a name="_Toc439081673"></a><a name="_Toc436149209"> 2.1.2修改表</a></strong></li>
</ul><p><strong>增加/删除分区</strong></p>

<ul><li>语法结构</li>
</ul><p style="margin-left:0cm;">ALTER TABLE table_name ADD [IF NOT EXISTS] partition_spec [ LOCATION 'location1' ] partition_spec [ LOCATION 'location2' ] ...</p>

<p style="margin-left:0cm;">partition_spec:</p>

<p style="margin-left:0cm;">: PARTITION (partition_col = partition_col_value, partition_col = partiton_col_value, ...)</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">ALTER TABLE table_name DROP partition_spec, partition_spec,...</p>

<ul><li>具体实例</li>
</ul><table border="1" cellspacing="0" style="width:521px;"><tbody><tr><td style="vertical-align:top;width:426.1pt;">
			<p style="margin-left:0cm;">alter table student_p add partition(part='a') partition(part='b');</p>
			</td>
		</tr></tbody></table><p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><img alt="" class="has" height="186" src="https://img-blog.csdnimg.cn/20181106170042211.png" width="845"></p>

<p style="margin-left:0cm;"><img alt="" class="has" height="297" src="https://img-blog.csdnimg.cn/20181106170044658.png" width="837"></p>

<p style="margin-left:0cm;"> </p>

<p><strong>重命名表</strong></p>

<ul><li>语法结构</li>
</ul><p style="margin-left:0cm;">ALTER TABLE table_name RENAME TO new_table_name</p>

<ul><li>具体实例</li>
</ul><p style="margin-left:0cm;"><img alt="" class="has" height="83" src="https://img-blog.csdnimg.cn/20181106170104214.png" width="485"></p>

<p><strong>增加/更新列</strong></p>

<ul><li>语法结构</li>
</ul><p style="margin-left:0cm;">ALTER TABLE table_name ADD|REPLACE COLUMNS (col_name data_type [COMMENT col_comment], ...)</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><em>注：ADD</em><em>是代表新增一字段，字段位置在所有列后面(partition</em><em>列前)</em><em>，REPLACE</em><em>则是表示替换表中所有字段。</em></p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">ALTER TABLE table_name CHANGE [COLUMN] col_old_name col_new_name column_type [COMMENT col_comment] [FIRST|AFTER column_name]</p>

<ul><li>具体实例</li>
</ul><p style="margin-left:0cm;"><img alt="" class="has" height="376" src="https://img-blog.csdnimg.cn/20181106170135292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dveHV5YW9oYW9oYW94dWV4aQ==,size_16,color_FFFFFF,t_70" width="480"></p>

<p> </p>

<p> </p>

<ul><li><strong><a name="_Toc439081674"></a><a name="_Toc436149210"> 2.1.3显示命令</a></strong></li>
</ul><p style="margin-left:0cm;">show tables</p>

<p style="margin-left:0cm;">show databases</p>

<p style="margin-left:0cm;">show partitions</p>

<p style="margin-left:0cm;">show functions</p>

<p style="margin-left:0cm;">desc extended t_name;</p>

<p style="margin-left:0cm;">desc formatted table_name;</p>

<p> </p>

<ul><li><strong>2.2 <a name="_Toc436149211"></a><a name="_Toc439081675">DML</a>操作</strong></li>
	<li><strong><a name="_Toc439081676"></a><a name="_Toc436149212"> 2.2.1Load</a></strong></li>
	<li>语法结构</li>
</ul><p style="margin-left:0cm;">LOAD DATA [LOCAL] INPATH 'filepath' [OVERWRITE] INTO</p>

<p style="margin-left:0cm;">TABLE tablename [PARTITION (partcol1=val1, partcol2=val2 ...)]</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">说明：</p>

<ul><li>Load 操作只是单纯的复制/移动操作，将数据文件移动到 Hive 表对应的位置。</li>
	<li>filepath：</li>
</ul><p style="margin-left:0cm;">相对路径，例如：project/data1</p>

<p style="margin-left:0cm;">绝对路径，例如：/user/hive/project/data1</p>

<p style="margin-left:0cm;">包含模式的完整 URI，列如：</p>

<p style="margin-left:0cm;">hdfs://namenode:9000/user/hive/project/data1</p>

<ul><li>LOCAL关键字</li>
</ul><p style="margin-left:0cm;">如果指定了 LOCAL， load 命令会去查找本地文件系统中的 filepath。</p>

<p style="margin-left:0cm;">如果没有指定 LOCAL 关键字，则根据inpath中的<a>uri</a> 查找文件</p>

<ul><li>OVERWRITE 关键字</li>
</ul><p style="margin-left:0cm;">如果使用了 OVERWRITE 关键字，则目标表（或者分区）中的内容会被删除，然后再将 filepath 指向的文件/目录中的内容添加到表/分区中。</p>

<p style="margin-left:0cm;">如果目标表（分区）已经有一个文件，并且文件名和 filepath 中的文件名冲突，那么现有的文件会被新文件所替代。</p>

<p style="margin-left:0cm;"> </p>

<ul><li>具体实例</li>
</ul><p>1.加载相对路径数据。</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="248" src="https://img-blog.csdnimg.cn/20181106170255497.png" width="851"></p>

<p style="margin-left:0cm;"> </p>

<p>2.加载绝对路径数据。</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="185" src="https://img-blog.csdnimg.cn/20181106170302160.png" width="889"></p>

<p style="margin-left:0cm;"> </p>

<p>3.加载包含模式数据。</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="204" src="https://img-blog.csdnimg.cn/201811061703086.png" width="888"></p>

<p style="margin-left:0cm;"> </p>

<p>4.OVERWRITE关键字使用。</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="166" src="https://img-blog.csdnimg.cn/20181106170313855.png" width="894"></p>

<p> </p>

<p> </p>

<ul><li><strong><a name="_Toc439081677"></a><a name="_Toc436149213"> 2.2.2Insert</a></strong></li>
	<li>将查询结果插入Hive表</li>
</ul><ul><li>语法结构</li>
</ul><p style="margin-left:0cm;">INSERT OVERWRITE TABLE tablename1 [PARTITION (partcol1=val1, partcol2=val2 ...)] select_statement1 FROM from_statement</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">Multiple inserts:</p>

<p style="margin-left:0cm;">FROM from_statement</p>

<p style="margin-left:0cm;">INSERT OVERWRITE TABLE tablename1 [PARTITION (partcol1=val1, partcol2=val2 ...)] select_statement1</p>

<p style="margin-left:0cm;">[INSERT OVERWRITE TABLE tablename2 [PARTITION ...] select_statement2] ...</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">Dynamic partition inserts:</p>

<p style="margin-left:0cm;">INSERT OVERWRITE TABLE tablename PARTITION (partcol1[=val1], partcol2[=val2] ...) select_statement FROM from_statement</p>

<p style="margin-left:0cm;"> </p>

<ul><li>具体实例</li>
</ul><p style="margin-left:0cm;">1、基本模式插入。</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="496" src="https://img-blog.csdnimg.cn/20181106170344124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dveHV5YW9oYW9oYW94dWV4aQ==,size_16,color_FFFFFF,t_70" width="776"></p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">2、多插入模式。</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="508" src="https://img-blog.csdnimg.cn/20181106170356241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dveHV5YW9oYW9oYW94dWV4aQ==,size_16,color_FFFFFF,t_70" width="774"></p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">3、自动分区模式。</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="311" src="https://img-blog.csdnimg.cn/20181106170407650.png" width="799"></p>

<p style="margin-left:0cm;"> </p>

<ul><li><span style="color:#000000;">导出表数据</span></li>
	<li><span style="color:#000000;">语法结构</span></li>
</ul><p style="margin-left:0cm;">INSERT OVERWRITE [LOCAL] DIRECTORY directory1 SELECT ... FROM ...</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">multiple inserts:</p>

<p style="margin-left:0cm;">FROM from_statement</p>

<p style="margin-left:0cm;">INSERT OVERWRITE [LOCAL] DIRECTORY directory1 select_statement1</p>

<p style="margin-left:0cm;">[INSERT OVERWRITE [LOCAL] DIRECTORY directory2 select_statement2] ...</p>

<p style="margin-left:0cm;"> </p>

<ul><li>具体实例</li>
</ul><p style="margin-left:0cm;">1、导出文件到本地。</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="312" src="https://img-blog.csdnimg.cn/20181106170431547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dveHV5YW9oYW9oYW94dWV4aQ==,size_16,color_FFFFFF,t_70" width="750"></p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">说明：</p>

<p style="margin-left:0cm;"><em>数据写入到文件系统时进行文本序列化，且每列用^A来区分，\n为换行符。用more命令查看时不容易看出分割符，可以使用: <a>sed -e 's/\x01/|/g' filename</a></em><em>来查看。</em></p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">2、导出数据到HDFS。</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="348" src="https://img-blog.csdnimg.cn/2018110617044147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dveHV5YW9oYW9oYW94dWV4aQ==,size_16,color_FFFFFF,t_70" width="750"></p>

<p> </p>

<ul><li><strong><a name="_Toc436149214"></a><a name="_Toc439081678"> 2.2.3SELECT</a></strong></li>
	<li>基本的Select操作</li>
</ul><ul><li>语法结构</li>
</ul><p style="margin-left:0cm;">SELECT [ALL | DISTINCT] select_expr, select_expr, ...</p>

<p style="margin-left:0cm;">FROM table_reference</p>

<p style="margin-left:0cm;">[WHERE where_condition]</p>

<p style="margin-left:0cm;">[GROUP BY col_list [HAVING condition]]</p>

<p style="margin-left:0cm;">[CLUSTER BY col_list</p>

<p style="margin-left:0cm;">  | [DISTRIBUTE BY col_list] [SORT BY| ORDER BY col_list]</p>

<p style="margin-left:0cm;">]</p>

<p style="margin-left:0cm;">[LIMIT number]</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><em>注：1</em><em>、order by </em><em>会对输入做全局排序，因此只有一个reducer</em><em>，会导致当输入规模较大时，需要较长的计算时间。</em></p>

<p style="margin-left:0cm;"><em>2</em><em>、sort by</em><em>不是全局排序，其在数据进入reducer</em><em>前完成排序。因此，如果用sort by</em><em>进行排序，并且设置mapred.reduce.tasks&gt;1</em><em>，则sort by</em><em>只保证每个reducer</em><em>的输出有序，不保证全局有序。</em></p>

<p style="margin-left:0cm;"><em>3</em><em>、distribute by</em><em>根据distribute by</em><em>指定的内容将数据分到同一个reducer</em><em>。</em></p>

<p style="margin-left:0cm;"><em>4</em><em>、Cluster by </em><em>除了具有Distribute by</em><em>的功能外，还会对该字段进行排序。因此，常常认为cluster by = distribute by + sort by</em></p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<ul><li>具体实例</li>
</ul><p style="margin-left:0cm;">1、获取年龄大的3个学生。</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="487" src="https://img-blog.csdnimg.cn/20181106170516413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dveHV5YW9oYW9oYW94dWV4aQ==,size_16,color_FFFFFF,t_70" width="771"></p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">2、查询学生信息按年龄，降序排序。</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="613" src="https://img-blog.csdnimg.cn/20181106170526331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dveHV5YW9oYW9oYW94dWV4aQ==,size_16,color_FFFFFF,t_70" width="786"></p>

<p style="margin-left:0cm;"><img alt="" class="has" height="705" src="https://img-blog.csdnimg.cn/2018110617053669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dveHV5YW9oYW9oYW94dWV4aQ==,size_16,color_FFFFFF,t_70" width="767"></p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><img alt="" class="has" height="707" src="https://img-blog.csdnimg.cn/20181106170546745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dveHV5YW9oYW9oYW94dWV4aQ==,size_16,color_FFFFFF,t_70" width="834"></p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">3、按学生名称汇总学生年龄。</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="735" src="https://img-blog.csdnimg.cn/20181106170555486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dveHV5YW9oYW9oYW94dWV4aQ==,size_16,color_FFFFFF,t_70" width="786"></p>

<p style="margin-left:0cm;"> </p>

<ul><li>
	<p style="margin-left:0cm;"><strong><a name="_Toc439081679">2.3 Hive Join</a></strong></p>
	</li>
	<li>语法结构</li>
</ul><p style="margin-left:0cm;">join_table:</p>

<p style="margin-left:0cm;">  table_reference JOIN table_factor [join_condition]</p>

<p style="margin-left:0cm;">  | table_reference {LEFT|RIGHT|FULL} [OUTER] JOIN table_reference join_condition</p>

<p style="margin-left:0cm;">  | table_reference LEFT SEMI JOIN table_reference join_condition</p>

<p style="margin-left:0cm;">Hive 支持等值连接（equality joins）、外连接（outer joins）和（left/right joins）。Hive <strong>不支持非等值的连接</strong>，因为非等值连接非常难转化到 map/reduce 任务。</p>

<p style="margin-left:0cm;">另外，Hive 支持多于 2 个表的连接。</p>

<p style="margin-left:0cm;">写 join 查询时，需要注意几个关键点：</p>

<p style="margin-left:0cm;"><strong>1. </strong><strong>只支持等值join</strong></p>

<p style="margin-left:0cm;">例如：</p>

<p style="margin-left:0cm;">  SELECT a.* FROM a JOIN b ON (a.id = b.id)</p>

<p style="margin-left:0cm;">  SELECT a.* FROM a JOIN b</p>

<p style="margin-left:0cm;">    ON (a.id = b.id AND a.department = b.department)</p>

<p style="margin-left:0cm;">是正确的，然而:</p>

<p style="margin-left:0cm;">  SELECT a.* FROM a JOIN b ON (a.id&gt;b.id)</p>

<p style="margin-left:0cm;">是错误的。</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><strong>2. </strong><strong>可以 join 多于 2 个表。</strong></p>

<p style="margin-left:18pt;">例如</p>

<p style="margin-left:0cm;">  SELECT a.val, b.val, c.val FROM a JOIN b</p>

<p style="margin-left:0cm;">    ON (a.key = b.key1) JOIN c ON (c.key = b.key2)</p>

<p style="margin-left:0cm;">如果join中多个表的 join key 是同一个，则 join 会被转化为单个 map/reduce 任务，例如：</p>

<p style="margin-left:0cm;">  SELECT a.val, b.val, c.val FROM a JOIN b</p>

<p style="margin-left:0cm;">    ON (a.key = b.key1) JOIN c</p>

<p style="margin-left:0cm;">    ON (c.key = b.key1)</p>

<p style="margin-left:0cm;">被转化为单个 map/reduce 任务，因为 join 中只使用了 b.key1 作为 join key。</p>

<p style="margin-left:0cm;">SELECT a.val, b.val, c.val FROM a JOIN b ON (a.key = b.key1)</p>

<p style="margin-left:0cm;">  JOIN c ON (c.key = b.key2)</p>

<p style="margin-left:0cm;">而这一 join 被转化为 2 个 map/reduce 任务。因为 b.key1 用于第一次 join 条件，而 b.key2 用于第二次 join。</p>

<p style="margin-left:0cm;">  </p>

<p style="margin-left:0cm;"><strong>3</strong><strong>．join 时，每次 map/reduce 任务的逻辑：</strong></p>

<p style="margin-left:0cm;">    reducer 会缓存 join 序列中除了最后一个表的所有表的记录，再通过最后一个表将结果序列化到文件系统。这一实现有助于在 reduce 端减少内存的使用量。实践中，应该把最大的那个表写在最后（否则会因为缓存浪费大量内存）。例如：</p>

<p style="margin-left:0cm;"> SELECT a.val, b.val, c.val FROM a</p>

<p style="margin-left:0cm;">    JOIN b ON (a.key = b.key1) JOIN c ON (c.key = b.key1)</p>

<p style="margin-left:0cm;">所有表都使用同一个 join key（使用 1 次 map/reduce 任务计算）。Reduce 端会缓存 a 表和 b 表的记录，然后每次取得一个 c 表的记录就计算一次 join 结果，类似的还有：</p>

<p style="margin-left:0cm;">  SELECT a.val, b.val, c.val FROM a</p>

<p style="margin-left:0cm;">    JOIN b ON (a.key = b.key1) JOIN c ON (c.key = b.key2)</p>

<p style="margin-left:0cm;">这里用了 2 次 map/reduce 任务。第一次缓存 a 表，用 b 表序列化；第二次缓存第一次 map/reduce 任务的结果，然后用 c 表序列化。</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><strong>4</strong><strong>．LEFT，RIGHT 和 FULL OUTER 关键字用于处理 join 中空记录的情况</strong></p>

<p style="margin-left:0cm;">例如：</p>

<p style="margin-left:0cm;">  SELECT a.val, b.val FROM</p>

<p style="margin-left:0cm;">a LEFT OUTER  JOIN b ON (a.key=b.key)</p>

<p style="margin-left:0cm;">对应所有 a 表中的记录都有一条记录输出。输出的结果应该是 a.val, b.val，当 a.key=b.key 时，而当 b.key 中找不到等值的 a.key 记录时也会输出:</p>

<p style="margin-left:0cm;">a.val, NULL</p>

<p style="margin-left:0cm;">所以 a 表中的所有记录都被保留了；</p>

<p style="margin-left:0cm;">“a RIGHT OUTER JOIN b”会保留所有 b 表的记录。</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><strong>Join </strong><strong>发生在 WHERE 子句之前</strong>。如果你想限制 join 的输出，应该在 WHERE 子句中写过滤条件——或是在 join 子句中写。这里面一个容易混淆的问题是表分区的情况：</p>

<p style="margin-left:0cm;">  SELECT a.val, b.val FROM a</p>

<p style="margin-left:0cm;">  LEFT OUTER JOIN b ON (a.key=b.key)</p>

<p style="margin-left:0cm;">  WHERE a.ds='2009-07-07' AND b.ds='2009-07-07'</p>

<p style="margin-left:0cm;">会 join a 表到 b 表（OUTER JOIN），列出 a.val 和 b.val 的记录。WHERE 从句中可以使用其他列作为过滤条件。但是，如前所述，如果 b 表中找不到对应 a 表的记录，b 表的所有列都会列出 NULL，<strong>包括 ds 列</strong>。也就是说，join 会过滤 b 表中不能找到匹配 a 表 join key 的所有记录。这样的话，LEFT OUTER 就使得查询结果与 WHERE 子句无关了。解决的办法是在 OUTER JOIN 时使用以下语法：</p>

<p style="margin-left:0cm;">  SELECT a.val, b.val FROM a LEFT OUTER JOIN b</p>

<p style="margin-left:0cm;">  ON (a.key=b.key AND</p>

<p style="margin-left:0cm;">      b.ds='2009-07-07' AND</p>

<p style="margin-left:0cm;">      a.ds='2009-07-07')</p>

<p style="margin-left:0cm;">这一查询的结果是预先在 join 阶段过滤过的，所以不会存在上述问题。这一逻辑也可以应用于 RIGHT 和 FULL 类型的 join 中。</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><strong>Join </strong><strong>是不能交换位置的。</strong>无论是 LEFT 还是 RIGHT join，都是左连接的。</p>

<p style="margin-left:0cm;">  SELECT a.val1, a.val2, b.val, c.val</p>

<p style="margin-left:0cm;">  FROM a</p>

<p style="margin-left:0cm;">  JOIN b ON (a.key = b.key)</p>

<p style="margin-left:0cm;">  LEFT OUTER JOIN c ON (a.key = c.key)</p>

<p style="margin-left:0cm;">先 join a 表到 b 表，丢弃掉所有 join key 中不匹配的记录，然后用这一中间结果和 c 表做 join。这一表述有一个不太明显的问题，就是当一个 key 在 a 表和 c 表都存在，但是 b 表中不存在的时候：整个记录在第一次 join，即 a JOIN b 的时候都被丢掉了（包括a.val1，a.val2和a.key），然后我们再和 c 表 join 的时候，如果 c.key 与 a.key 或 b.key 相等，就会得到这样的结果：NULL, NULL, NULL, c.val</p>

<p style="margin-left:0cm;"> </p>

<ul><li>具体实例</li>
</ul><p>1.获取已经分配班级的学生姓名。</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="536" src="https://img-blog.csdnimg.cn/20181106170625130.png" width="757"></p>

<p style="margin-left:0cm;"> </p>

<p>2.获取尚未分配班级的学生姓名。</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="519" src="https://img-blog.csdnimg.cn/20181106170727510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dveHV5YW9oYW9oYW94dWV4aQ==,size_16,color_FFFFFF,t_70" width="783"></p>

<p style="margin-left:0cm;"> </p>

<p>3.LEFT  SEMI  JOIN是IN/EXISTS的高效实现。</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="343" src="https://img-blog.csdnimg.cn/20181106170740813.png" width="895"></p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<ul><li>
	<p style="margin-left:0cm;"><strong><a name="_Toc439081680">三、</a><a name="_Toc436149219">Hive Shell</a>参数</strong></p>
	</li>
	<li style="margin-left:0cm;"><strong><a name="_Toc436149220"></a><a name="_Toc439081681">3.1 Hive</a>命令行</strong></li>
	<li>语法结构</li>
</ul><p style="margin-left:0cm;">hive [-hiveconf x=y]* [&lt;-i filename&gt;]* [&lt;-f filename&gt;|&lt;-e query-string&gt;] [-S]</p>

<p style="margin-left:0cm;">说明：</p>

<ol><li>-i 从文件初始化HQL。</li>
	<li>-e从命令行执行指定的HQL</li>
	<li>-f 执行HQL脚本</li>
	<li>-v 输出执行的HQL语句到控制台</li>
	<li>-p &lt;port&gt; connect to Hive Server on port number</li>
	<li>-hiveconf x=y Use this to set hive/hadoop configuration variables.</li>
</ol><ul><li>具体实例</li>
</ul><p style="margin-left:0cm;">1、运行一个查询。</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="486" src="https://img-blog.csdnimg.cn/20181106170805624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dveHV5YW9oYW9oYW94dWV4aQ==,size_16,color_FFFFFF,t_70" width="812"></p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">2、运行一个文件。</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="234" src="https://img-blog.csdnimg.cn/20181106170812143.png" width="824"></p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">3、运行参数文件。</p>

<p style="margin-left:0cm;"><img alt="" class="has" height="355" src="https://img-blog.csdnimg.cn/20181106170818127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dveHV5YW9oYW9oYW94dWV4aQ==,size_16,color_FFFFFF,t_70" width="855"></p>

<p> </p>

<p style="margin-left:0cm;"> </p>

<ul><li>
	<h3 style="margin-left:0cm;"><strong><a name="_Toc439081682">3.2 Hive</a>参数配置方式</strong></h3>
	</li>
</ul><p style="margin-left:0cm;"><em>Hive</em><em>参数大全：</em></p>

<p style="margin-left:0cm;"><em>https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties</em></p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">开发Hive应用时，不可避免地需要设定Hive的参数。设定Hive的参数可以调优HQL代码的执行效率，或帮助定位问题。然而实践中经常遇到的一个问题是，为什么设定的参数没有起作用？这通常是错误的设定方式导致的。</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><strong><span style="color:#000000;">对于一般参数，有以下三种设定方式：</span></strong></p>

<ol><li><span style="color:#000000;">配置文件</span></li>
	<li><span style="color:#000000;">命令行参数</span></li>
	<li><span style="color:#000000;">参数声明</span></li>
</ol><p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><strong>配置文件</strong>：Hive的配置文件包括</p>

<ol><li>用户自定义配置文件：$HIVE_CONF_DIR/hive-site.xml</li>
	<li>默认配置文件：$HIVE_CONF_DIR/hive-default.xml</li>
</ol><p style="margin-left:0cm;"><span style="color:#c00000;">用户自定义配置会覆盖默认配置。</span></p>

<p style="margin-left:0cm;">另外，Hive也会读入Hadoop的配置，因为Hive是作为Hadoop的客户端启动的，Hive的配置会覆盖Hadoop的配置。</p>

<p style="margin-left:0cm;">配置文件的设定对本机启动的所有Hive进程都有效。</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><strong>命令行参数</strong>：启动Hive（客户端或Server方式）时，可以在命令行添加-hiveconf param=value来设定参数，例如：</p>

<p style="margin-left:0cm;">bin/hive -hiveconf hive.root.logger=INFO,console</p>

<p style="margin-left:0cm;">这一设定对本次启动的Session（对于Server方式启动，则是所有请求的Sessions）有效。</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><strong>参数声明</strong>：可以在HQL中使用SET关键字设定参数，例如：</p>

<p style="margin-left:0cm;">set mapred.reduce.tasks=100;</p>

<p style="margin-left:0cm;">这一设定的作用域也是session级的。</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">上述三种设定方式的优先级依次递增。即参数声明覆盖命令行参数，命令行参数覆盖配置文件设定。注意某些系统级的参数，例如log4j相关的设定，必须用前两种方式设定，因为那些参数的读取在Session建立以前已经完成了。</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><a name="_Toc439081683"></a></p>

<p style="margin-left:0cm;"> </p>

<ul><li>
	<h1 style="margin-left:0cm;"><strong>4. Hive函数</strong></h1>
	</li>
	<li>
	<h2 style="margin-left:0cm;"><strong><a name="_Toc439081684">4.1 </a>内置运算符</strong></h2>
	</li>
</ul><p style="margin-left:0cm;"><em>内容较多</em></p>

<p style="margin-left:0cm;"> </p>

<ul><li>
	<h2 style="margin-left:0cm;"><strong><a name="_Toc439081685">4.2 </a>内置函数</strong></h2>
	</li>
</ul><p style="margin-left:0cm;"><em>内容较多</em></p>

<p style="margin-left:0cm;"> </p>

<ul><li>
	<h2 style="margin-left:0cm;"><strong><a name="_Toc436149222"></a><a name="_Toc439081686">4.3 Hive</a>自定义函数和<span style="color:#333333;">Transform</span></strong></h2>
	</li>
</ul><p style="margin-left:0cm;">当Hive提供的内置函数无法满足你的业务处理需要时，此时就可以考虑使用用户自定义函数（UDF：user-defined function）。</p>

<ul><li>
	<h3 style="margin-left:0cm;"><strong><a name="_Toc439081687"></a><a name="_Toc436149223">4.3.1 </a>自定义函数类别</strong></h3>
	</li>
</ul><p style="margin-left:0cm;">UDF  作用于单个数据行，产生一个数据行作为输出。（数学函数，字符串函数）</p>

<p style="margin-left:0cm;">UDAF（用户定义聚集函数）：接收多个输入数据行，并产生一个输出数据行。（count，max）</p>

<p style="margin-left:0cm;"><a name="_Toc436149225"></a></p>

<ul><li>
	<h3 style="margin-left:0cm;"><strong><a name="_Toc439081688">4.3.2 UDF</a>开发实例</strong></h3>
	</li>
</ul><p style="margin-left:0cm;">1、先开发一个java类，继承UDF，并重载evaluate方法</p>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:426.1pt;">
			<p style="margin-left:0cm;">package cn.itcast.bigdata.udf</p>

			<p style="margin-left:0cm;">import org.apache.hadoop.hive.ql.exec.UDF;</p>

			<p style="margin-left:0cm;">import org.apache.hadoop.io.Text;</p>

			<p style="margin-left:0cm;"> </p>

			<p style="margin-left:0cm;">public final class Lower extends UDF{</p>

			<p style="margin-left:0cm;">     public Text evaluate(final Text s){</p>

			<p style="margin-left:0cm;">          if(s==null){return null;}</p>

			<p style="margin-left:0cm;">          return new Text(s.toString().toLowerCase());</p>

			<p style="margin-left:0cm;">     }</p>

			<p style="margin-left:0cm;">}</p>
			</td>
		</tr></tbody></table><p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">2、打成jar包上传到服务器</p>

<p style="margin-left:0cm;">3、将jar包添加到hive的classpath</p>

<p style="margin-left:0cm;">hive&gt;add JAR /home/hadoop/udf.jar;</p>

<p>4、创建临时函数与开发好的java class关联</p>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:426.1pt;">
			<p style="margin-left:0cm;">Hive&gt;create temporary function toprovince as 'cn.itcast.bigdata.udf.ToProvince';</p>
			</td>
		</tr></tbody></table><p style="margin-left:0cm;"> </p>

<p>5、即可在hql中使用自定义的函数strip </p>

<p style="margin-left:0cm;">Select strip(name),age from t_test;</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<ul><li>
	<p style="margin-left:0cm;"><strong><a name="_Toc436149226"></a><a name="_Toc439081689">4.3.3 Transform</a>实现</strong></p>
	</li>
</ul><p style="margin-left:0cm;">Hive的 TRANSFORM 关键字<strong><em>提供了在</em></strong><strong><em>SQL</em></strong><strong><em>中调用自写脚本的功能</em></strong></p>

<p style="margin-left:0cm;">适合实现Hive中没有的功能又不想写UDF的情况</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">使用示例1：下面这句sql就是借用了<span style="color:#000000;">weekday_mapper.py</span><span style="color:#000000;">对数据进行了处理</span><span style="color:#000000;">.</span></p>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:426.1pt;">
			<p style="margin-left:0cm;">CREATE TABLE u_data_new (</p>

			<p style="margin-left:0cm;">  movieid INT,</p>

			<p style="margin-left:0cm;">  rating INT,</p>

			<p style="margin-left:0cm;">  weekday INT,</p>

			<p style="margin-left:0cm;">  userid INT)</p>

			<p style="margin-left:0cm;">ROW FORMAT DELIMITED</p>

			<p style="margin-left:0cm;">FIELDS TERMINATED BY '\t';</p>

			<p style="margin-left:0cm;"> </p>

			<p style="margin-left:0cm;">add FILE weekday_mapper.py;</p>

			<p style="margin-left:0cm;"> </p>

			<p style="margin-left:0cm;">INSERT OVERWRITE TABLE u_data_new</p>

			<p style="margin-left:0cm;">SELECT</p>

			<p style="margin-left:0cm;">  TRANSFORM (movieid, rating, unixtime,userid)</p>

			<p style="margin-left:0cm;">  USING 'python weekday_mapper.py'</p>

			<p style="margin-left:0cm;">  AS (movieid, rating, weekday,userid)</p>

			<p style="margin-left:0cm;">FROM u_data;</p>
			</td>
		</tr></tbody></table><p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"><span style="color:#000000;">其中weekday_mapper.py内容如下</span></p>

<table border="1" cellspacing="0" style="width:642px;"><tbody><tr><td style="vertical-align:top;width:426.1pt;">
			<p style="margin-left:0cm;">#!/bin/python</p>

			<p style="margin-left:0cm;">import sys</p>

			<p style="margin-left:0cm;">import datetime</p>

			<p style="margin-left:0cm;"> </p>

			<p style="margin-left:0cm;">for line in sys.stdin:</p>

			<p style="margin-left:0cm;">  line = line.strip()</p>

			<p style="margin-left:0cm;">  movieid, rating, unixtime,userid = line.split('\t')</p>

			<p style="margin-left:0cm;">  weekday = datetime.datetime.fromtimestamp(float(unixtime)).isoweekday()</p>

			<p style="margin-left:0cm;">  print '\t'.join([movieid, rating, str(weekday),userid])</p>
			</td>
		</tr></tbody></table><p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">使用示例2：下面的例子则是使用了shell的cat命令来处理数据</p>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:426.1pt;">
			<p style="margin-left:0cm;">FROM invites a INSERT OVERWRITE TABLE events SELECT TRANSFORM(a.foo, a.bar) AS (oof, rab) USING '/bin/cat' WHERE a.ds &gt; '2008-08-09';</p>
			</td>
		</tr></tbody></table><p> </p>

<ul><li style="margin-left:0cm;"><strong><a name="_Toc436149227"></a><a name="_Toc439081690"></a><a name="_Toc436149268"></a><a name="_Toc439081727">5. Hive</a>实战</strong></li>
	<li style="margin-left:0cm;"><strong><a name="_Toc439081728">Hive </a>实战案例1——数据ETL</strong></li>
	<li style="margin-left:0cm;"><strong><a name="_Toc439081729">需求：</a></strong></li>
	<li>对web点击流日志基础数据表进行etl（按照仓库模型设计）</li>
	<li>按各时间维度统计来源域名top10</li>
</ul><p style="margin-left:0cm;">已有数据表 “t_orgin_weblog” ：</p>

<table border="1" cellspacing="0" style="width:511px;"><tbody><tr><td style="vertical-align:top;width:426.1pt;">
			<p style="margin-left:0cm;">+------------------+------------+----------+--+</p>

			<p style="margin-left:0cm;">|     col_name     | data_type  | comment  |</p>

			<p style="margin-left:0cm;">+------------------+------------+----------+--+</p>

			<p style="margin-left:0cm;">| valid            | string     |          |</p>

			<p style="margin-left:0cm;">| remote_addr      | string     |          |</p>

			<p style="margin-left:0cm;">| remote_user      | string     |          |</p>

			<p style="margin-left:0cm;">| time_local       | string     |          |</p>

			<p style="margin-left:0cm;">| request          | string     |          |</p>

			<p style="margin-left:0cm;">| status           | string     |          |</p>

			<p style="margin-left:0cm;">| body_bytes_sent  | string     |          |</p>

			<p style="margin-left:0cm;">| http_referer     | string     |          |</p>

			<p style="margin-left:0cm;">| http_user_agent  | string     |          |</p>

			<p style="margin-left:0cm;">+------------------+------------+----------+--+</p>
			</td>
		</tr></tbody></table><p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<ul><li style="margin-left:0cm;"><strong><a name="_Toc439081730">数据示例：</a></strong></li>
</ul><table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:426.1pt;">
			<p style="margin-left:0cm;">| true|1.162.203.134| - | 18/Sep/2013:13:47:35| /images/my.jpg                        | 200| 19939 | "http://www.angularjs.cn/A0d9"                      | "Mozilla/5.0 (Windows   |</p>

			<p style="margin-left:0cm;"> </p>

			<p style="margin-left:0cm;">| true|1.202.186.37 | - | 18/Sep/2013:15:39:11| /wp-content/uploads/2013/08/windjs.png| 200| 34613 | "http://cnodejs.org/topic/521a30d4bee8d3cb1272ac0f" | "Mozilla/5.0 (Macintosh;|</p>
			</td>
		</tr></tbody></table><p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<ul><li style="margin-left:0cm;"><strong><a name="_Toc439081731">实现步骤：</a></strong></li>
</ul><p style="margin-left:0cm;">1、对原始数据进行抽取转换</p>

<p style="margin-left:0cm;">--将来访url分离出host  path  query  query id</p>

<table border="1" cellspacing="0" style="width:583px;"><tbody><tr><td style="vertical-align:top;width:426.1pt;">
			<p style="margin-left:0cm;">drop table if exists t_etl_referurl;</p>

			<p style="margin-left:0cm;">create table t_etl_referurl as</p>

			<p style="margin-left:0cm;">SELECT a.*,b.*</p>

			<p style="margin-left:0cm;">FROM t_orgin_weblog a LATERAL VIEW parse_url_tuple(regexp_replace(http_referer, "\"", ""), 'HOST', 'PATH','QUERY', 'QUERY:id') b as host, path, query, query_id</p>

			<p style="margin-left:0cm;"> </p>
			</td>
		</tr></tbody></table><p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">2、从前述步骤进一步分离出日期时间形成ETL明细表“t_etl_detail”    day tm  </p>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:426.1pt;">
			<p style="margin-left:0cm;">drop table if exists t_etl_detail;</p>

			<p style="margin-left:0cm;">create table t_etl_detail as</p>

			<p style="margin-left:0cm;">select b.*,substring(time_local,0,11) as daystr,</p>

			<p style="margin-left:0cm;">substring(time_local,13) as tmstr,</p>

			<p style="margin-left:0cm;">substring(time_local,4,3) as month,</p>

			<p style="margin-left:0cm;">substring(time_local,0,2) as day,</p>

			<p style="margin-left:0cm;">substring(time_local,13,2) as hour</p>

			<p style="margin-left:0cm;">from t_etl_referurl b;</p>

			<p style="margin-left:0cm;"> </p>
			</td>
		</tr></tbody></table><p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">3、对etl数据进行分区(包含所有数据的结构化信息)</p>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:426.1pt;">
			<p style="margin-left:0cm;">drop table t_etl_detail_prt;</p>

			<p style="margin-left:0cm;">create table t_etl_detail_prt(</p>

			<p style="margin-left:0cm;">valid                   string,</p>

			<p style="margin-left:0cm;">remote_addr            string,</p>

			<p style="margin-left:0cm;">remote_user            string,</p>

			<p style="margin-left:0cm;">time_local               string,</p>

			<p style="margin-left:0cm;">request                 string,</p>

			<p style="margin-left:0cm;">status                  string,</p>

			<p style="margin-left:0cm;">body_bytes_sent         string,</p>

			<p style="margin-left:0cm;">http_referer             string,</p>

			<p style="margin-left:0cm;">http_user_agent         string,</p>

			<p style="margin-left:0cm;">host                   string,</p>

			<p style="margin-left:0cm;">path                   string,</p>

			<p style="margin-left:0cm;">query                  string,</p>

			<p style="margin-left:0cm;">query_id               string,</p>

			<p style="margin-left:0cm;">daystr                 string,</p>

			<p style="margin-left:0cm;">tmstr                  string,</p>

			<p style="margin-left:0cm;">month                  string,</p>

			<p style="margin-left:0cm;">day                    string,</p>

			<p style="margin-left:0cm;">hour                   string)</p>

			<p style="margin-left:0cm;">partitioned by (mm string,dd string);</p>
			</td>
		</tr></tbody></table><p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">导入数据</p>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:426.1pt;">
			<p style="margin-left:0cm;">insert into table t_etl_detail_prt partition(mm='Sep',dd='18')</p>

			<p style="margin-left:0cm;">select * from t_etl_detail where daystr='18/Sep/2013';</p>

			<p style="margin-left:0cm;"> </p>

			<p style="margin-left:0cm;">insert into table t_etl_detail_prt partition(mm='Sep',dd='19')</p>

			<p style="margin-left:0cm;">select * from t_etl_detail where daystr='19/Sep/2013';</p>
			</td>
		</tr></tbody></table><p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">分个时间维度统计各referer_host的访问次数并排序</p>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:426.1pt;">
			<p style="margin-left:0cm;">create table t_refer_host_visit_top_tmp as</p>

			<p style="margin-left:0cm;">select referer_host,count(*) as counts,mm,dd,hh from t_display_referer_counts group by hh,dd,mm,referer_host order by hh asc,dd asc,mm asc,counts desc;</p>

			<p style="margin-left:0cm;"> </p>
			</td>
		</tr></tbody></table><p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">4、来源访问次数topn各时间维度URL</p>

<p style="margin-left:0cm;">取各时间维度的referer_host访问次数topn</p>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:426.1pt;">
			<p style="margin-left:0cm;">select * from (select referer_host,counts,concat(hh,dd),row_number() over (partition by concat(hh,dd) order by concat(hh,dd) asc) as od from t_refer_host_visit_top_tmp) t where od&lt;=3;</p>

			<p style="margin-left:0cm;"> </p>
			</td>
		</tr></tbody></table><p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p> </p>

<p style="margin-left:0cm;"> </p>

<ul><li style="margin-left:0cm;"><strong><a name="_Toc439081732">Hive </a>实战案例2——访问时长统计</strong></li>
	<li>
	<p style="margin-left:0cm;"><strong><a name="_Toc439081733">需求：</a></strong></p>
	</li>
</ul><p style="margin-left:0cm;">从web日志中统计每日访客平均停留时间</p>

<ul><li style="margin-left:0cm;"><strong><a name="_Toc439081734">实现步骤：</a></strong></li>
</ul><p>1.由于要从大量请求中分辨出用户的各次访问，逻辑相对复杂，通过hive直接实现有困难，因此编写一个mr程序来求出访客访问信息（详见代码）</p>

<p style="margin-left:0cm;">启动mr程序获取结果：</p>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:426.1pt;">
			<p style="margin-left:0cm;">[hadoop@hdp-node-01 ~]$ hadoop jar weblog.jar cn.itcast.bigdata.hive.mr.UserStayTime /weblog/input /weblog/stayout</p>
			</td>
		</tr></tbody></table><p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p>2.将mr的处理结果导入hive表</p>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:426.1pt;">
			<p style="margin-left:0cm;">drop table t_display_access_info_tmp;</p>

			<p style="margin-left:0cm;">create table t_display_access_info_tmp(remote_addr string,firt_req_time string,last_req_time string,stay_long bigint)</p>

			<p style="margin-left:0cm;">row format delimited fields terminated by '\t';</p>

			<p style="margin-left:0cm;"> </p>

			<p style="margin-left:0cm;">load data inpath '/weblog/stayout4' into table t_display_access_info_tmp;</p>
			</td>
		</tr></tbody></table><p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">3、得出访客访问信息表 "t_display_access_info"</p>

<p style="margin-left:0cm;">由于有一些访问记录是单条记录，mr程序处理处的结果给的时长是0，所以考虑给单次请求的停留时间一个默认市场30秒</p>

<table border="1" cellspacing="0" style="width:557px;"><tbody><tr><td style="vertical-align:top;width:426.1pt;">
			<p style="margin-left:0cm;">drop table t_display_access_info;</p>

			<p style="margin-left:0cm;">create table t_display_access_info as</p>

			<p style="margin-left:0cm;">select remote_addr,firt_req_time,last_req_time,</p>

			<p style="margin-left:0cm;">case stay_long</p>

			<p style="margin-left:0cm;">when 0 then 30000</p>

			<p style="margin-left:0cm;">else stay_long</p>

			<p style="margin-left:0cm;">end as stay_long</p>

			<p style="margin-left:0cm;">from t_display_access_info_tmp;</p>
			</td>
		</tr></tbody></table><p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">4、统计所有用户停留时间平均值</p>

<p style="margin-left:0cm;">select avg(stay_long) from t_display_access_info;</p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;"> </p>

<p> </p>

<p style="margin-left:0cm;"> </p>

<ul><li>
	<p style="margin-left:0cm;"><strong><a name="_Toc439081735">Hive</a>实战案例3——级联求和</strong></p>
	</li>
	<li>
	<p style="margin-left:0cm;"><strong><a name="_Toc439081736">需求：</a></strong></p>
	</li>
</ul><p style="margin-left:0cm;">有如下访客访问次数统计表 t_access_times</p>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:142pt;">
			<p style="margin-left:0cm;">访客</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">月份</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">访问次数</p>
			</td>
		</tr><tr><td style="vertical-align:top;width:142pt;">
			<p style="margin-left:0cm;">A</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">2015-01-02</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">5</p>
			</td>
		</tr><tr><td style="vertical-align:top;width:142pt;">
			<p style="margin-left:0cm;">A</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">2015-01-03</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">15</p>
			</td>
		</tr><tr><td style="vertical-align:top;width:142pt;">
			<p style="margin-left:0cm;">B</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">2015-01-01</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">5</p>
			</td>
		</tr><tr><td style="vertical-align:top;width:142pt;">
			<p style="margin-left:0cm;">A</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">2015-01-04</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">8</p>
			</td>
		</tr><tr><td style="vertical-align:top;width:142pt;">
			<p style="margin-left:0cm;">B</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">2015-01-05</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">25</p>
			</td>
		</tr><tr><td style="vertical-align:top;width:142pt;">
			<p style="margin-left:0cm;">A</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">2015-01-06</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">5</p>
			</td>
		</tr><tr><td style="vertical-align:top;width:142pt;">
			<p style="margin-left:0cm;">A</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">2015-02-02</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">4</p>
			</td>
		</tr><tr><td style="vertical-align:top;width:142pt;">
			<p style="margin-left:0cm;">A</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">2015-02-06</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">6</p>
			</td>
		</tr><tr><td style="vertical-align:top;width:142pt;">
			<p style="margin-left:0cm;">B</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">2015-02-06</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">10</p>
			</td>
		</tr><tr><td style="vertical-align:top;width:142pt;">
			<p style="margin-left:0cm;">B</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">2015-02-07</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">5</p>
			</td>
		</tr><tr><td style="vertical-align:top;width:142pt;">
			<p style="margin-left:0cm;">……</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">……</p>
			</td>
			<td style="vertical-align:top;width:142.05pt;">
			<p style="margin-left:0cm;">……</p>
			</td>
		</tr></tbody></table><p style="margin-left:0cm;"> </p>

<p style="margin-left:0cm;">需要输出报表：t_access_times_accumulate</p>

<table border="1" cellspacing="0" style="width:559px;"><tbody><tr><td style="vertical-align:top;width:85.2pt;">
			<p style="margin-left:0cm;">访客</p>
			</td>
			<td style="vertical-align:top;width:85.2pt;">
			<p style="margin-left:0cm;">月份</p>
			</td>
			<td style="vertical-align:top;width:111.45pt;">
			<p style="margin-left:0cm;">月访问总计</p>
			</td>
			<td style="vertical-align:top;width:5cm;">
			<p style="margin-left:0cm;">累计访问总计</p>
			</td>
		</tr><tr><td style="vertical-align:top;width:85.2pt;">
			<p style="margin-left:0cm;">A</p>
			</td>
			<td style="vertical-align:top;width:85.2pt;">
			<p style="margin-left:0cm;">2015-01</p>
			</td>
			<td style="vertical-align:top;width:111.45pt;">
			<p style="margin-left:0cm;">33</p>
			</td>
			<td style="vertical-align:top;width:5cm;">
			<p style="margin-left:0cm;">33</p>
			</td>
		</tr><tr><td style="vertical-align:top;width:85.2pt;">
			<p style="margin-left:0cm;">A</p>
			</td>
			<td style="vertical-align:top;width:85.2pt;">
			<p style="margin-left:0cm;">2015-02</p>
			</td>
			<td style="vertical-align:top;width:111.45pt;">
			<p style="margin-left:0cm;">10</p>
			</td>
			<td style="vertical-align:top;width:5cm;">
			<p style="margin-left:0cm;">43</p>
			</td>
		</tr><tr><td style="vertical-align:top;width:85.2pt;">
			<p style="margin-left:0cm;">…….</p>
			</td>
			<td style="vertical-align:top;width:85.2pt;">
			<p style="margin-left:0cm;">…….</p>
			</td>
			<td style="vertical-align:top;width:111.45pt;">
			<p style="margin-left:0cm;">…….</p>
			</td>
			<td style="vertical-align:top;width:5cm;">
			<p style="margin-left:0cm;">…….</p>
			</td>
		</tr><tr><td style="vertical-align:top;width:85.2pt;">
			<p style="margin-left:0cm;">B</p>
			</td>
			<td style="vertical-align:top;width:85.2pt;">
			<p style="margin-left:0cm;">2015-01</p>
			</td>
			<td style="vertical-align:top;width:111.45pt;">
			<p style="margin-left:0cm;">30</p>
			</td>
			<td style="vertical-align:top;width:5cm;">
			<p style="margin-left:0cm;">30</p>
			</td>
		</tr><tr><td style="vertical-align:top;width:85.2pt;">
			<p style="margin-left:0cm;">B</p>
			</td>
			<td style="vertical-align:top;width:85.2pt;">
			<p style="margin-left:0cm;">2015-02</p>
			</td>
			<td style="vertical-align:top;width:111.45pt;">
			<p style="margin-left:0cm;">15</p>
			</td>
			<td style="vertical-align:top;width:5cm;">
			<p style="margin-left:0cm;">45</p>
			</td>
		</tr><tr><td style="vertical-align:top;width:85.2pt;">
			<p style="margin-left:0cm;">…….</p>
			</td>
			<td style="vertical-align:top;width:85.2pt;">
			<p style="margin-left:0cm;">…….</p>
			</td>
			<td style="vertical-align:top;width:111.45pt;">
			<p style="margin-left:0cm;">…….</p>
			</td>
			<td style="vertical-align:top;width:5cm;">
			<p style="margin-left:0cm;">…….</p>
			</td>
		</tr></tbody></table><p style="margin-left:0cm;"> </p>

<ul><li style="margin-left:0cm;"><strong><a name="_Toc439081737">实现步骤</a></strong></li>
</ul><p style="margin-left:0cm;">可以用一个hql语句即可实现：</p>

<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:426.1pt;">
			<p style="margin-left:0cm;">select A.username,A.month,max(A.salary) as salary,sum(B.salary) as accumulate</p>

			<p style="margin-left:0cm;">from</p>

			<p style="margin-left:0cm;">(select username,month,sum(salary) as salary from t_access_times group by username,month) A</p>

			<p style="margin-left:0cm;">inner join</p>

			<p style="margin-left:0cm;">(select username,month,sum(salary) as salary from t_access_times group by username,month) B</p>

			<p style="margin-left:0cm;">on</p>

			<p style="margin-left:0cm;">A.username=B.username</p>

			<p style="margin-left:0cm;">where B.month &lt;= A.month</p>

			<p style="margin-left:0cm;">group by A.username,A.month</p>

			<p style="margin-left:0cm;">order by A.username,A.month;</p>
			</td>
		</tr></tbody></table><hr><p><a name="_msocom_1"></a></p>            </div>
                </div>