---
layout:     post
title:      HBase入门教程
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <div id="content_views" class="markdown_views prism-atom-one-dark">
							<!-- flowchart 箭头图标 勿删 -->
							<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path></svg>
							<h4><a id="httpsblogcsdnnetnosqlnotesarticledetails79647096_0"></a>转自：<a href="https://blog.csdn.net/nosqlnotes/article/details/79647096" rel="nofollow">https://blog.csdn.net/nosqlnotes/article/details/79647096</a></h4>
<article>
		<div id="article_content" class="article_content clearfix csdn-tracking-statistics">
								            
						<div class="htmledit_views">
                <p><span>这是HBase入门系列的第1篇文章，介绍HBase的数据模型、适用场景、集群关键角色、建表流程以及所涉及的HBase基础概念，本文内容基于HBase 2.0 beta2版本。本文既适用于HBase新手，也适用于已有一定经验的HBase开发人员。</span><span></span></p><p><span><br></span></p><div class="entry-content clearfix"><blockquote><p><span>一些常见的HBase新手问题</span></p><ol><li><span class="md-line md-end-block md-focus">什么样的数据适合用HBase来存储？</span></li><li><span class="md-line md-end-block">既然HBase也是一个数据库，能否用它将现有系统中昂贵的Oracle替换掉？</span></li><li><span class="md-line md-end-block">存放于HBase中的数据记录，为何不直接存放于HDFS之上？</span></li><li><span class="md-line md-end-block">能否直接使用HBase来存储文件数据？</span></li><li><span class="md-line md-end-block">Region(HBase中的数据分片)迁移后，数据是否也会被迁移？</span></li><li><span class="md-line md-end-block">为何基于Spark/Hive分析HBase数据时性能较差？</span></li></ol></blockquote><h2 class="md-end-block md-heading"><a></a><span>开篇</span></h2><p><span class="md-line md-end-block">用惯了Oracle/MySQL的同学们，心目中的数据表，应该是长成这样的：</span></p><p><img src="//img-blog.csdn.net/20180321221127212" alt=""><br></p><p><span class="md-line md-end-block">这种表结构规整，每一行都有固定的列构成，因此，非常适合结构化数据的存储。但在NoSQL领域，数据表的模样却往往换成了另外一种”画风”：</span></p><p><img src="//img-blog.csdn.net/20180321221148700" alt=""><br></p><p><span class="md-line md-end-block">行由看似”杂乱无章”的列组成，行与行之间也无须遵循一致的定义，而这种定义恰好符合半结构化数据或非结构化数据的特点。本文所要讲述的HBase，就属于该派系的一个典型代表。这些”杂乱无章”的列所构成的多行数据，被称之为一个”稀疏矩阵”，而上图中的每一个”黑块块”，在HBase中称之为一个KeyValue。</span></p><p><span class="md-line md-end-block">Apache HBase官方给出了这样的定义：</span></p><blockquote><p><span class="md-line md-end-block"><span><a href="http://www.apache.org/" rel="nofollow" target="_blank">Apache</a></span> HBase™ is the <span><a href="http://hadoop.apache.org/" rel="nofollow" target="_blank">Hadoop</a></span> database, a <span><span>distributed</span></span>, <span><span>scalable</span></span>, <span><span>big data store</span></span>.</span></p></blockquote><p><span class="md-line md-end-block">即：Apache HBase是基于Hadoop构建的一个<span><span>分布式</span></span>的、<span><span>可伸缩</span></span>的<span><span>海量数据存储系统</span></span>。</span></p><p><span class="md-line md-end-block">HBase常被用来存放一些结构简单，但数据量非常大的数据(通常在TB级别以上)，如历史订单记录，日志数据，监控Metris数据等等，HBase提供了简单的基于Key值的快速查询能力。</span></p><p><span class="md-line md-end-block">HBase在国内市场已经取得了非常广泛的应用，在搜索引擎中，也可以看出来，HBase在国内呈现出了逐年上升的势态：</span></p><p><img src="//img-blog.csdn.net/20180321221211111" alt=""><br></p><p><span class="md-line md-end-block">从Apache HBase所关联的github项目的commits统计信息来看，也可以看出来该项目非常活跃：</span></p><p><img src="//img-blog.csdn.net/20180321221225120" alt=""><br></p><p><span class="md-line md-end-block">(需要说明的一点：HBase中的每一次commit，都已经过社区Commiter成员严格的Review，在commit之前，一个Patch可能已经被修改了几十个版本)</span></p><p><span class="md-line md-end-block">令人欣喜的是，国内的开发者也积极参与到了HBase社区贡献中，而且被社区接纳了多名PMC以及Committer成员。</span></p><p><span class="md-line md-end-block"><span>本文将以</span><span><span>一条数据在HBase中的“旅程”</span></span><span>为线索，介绍HBase的核心概念与流程，几乎每一部分都可以展开成一篇独立的长文，但本文旨在让读者能够快速的了解HBase的架构轮廓，所以很多特性/流程被被一言带过，但这些特性在社区中往往经历了漫长的开发过程。至于讲什么以及讲到什么程度，本文都做了艰难的取舍，在讲解的过程中，将会穿插解答本文开始所提出的针对初学者的一些常见问题。</span></span></p><p><span class="md-line md-end-block">本文适用于HBase新手，而对于具备一定经验的HBase开发人员，相信本文也可以提供一些有价值的参考。本文内容基于HBase 2.0 beta 2版本，对比于1.0甚至是更早期的版本，2.0出现了大量变化，下面这些问题的答案与部分关键的变化相关（新手可以直接跳过这些问题）：</span></p><blockquote><ol class="ol-list"><li class="md-list-item"><p><span class="md-line md-end-block">HBase meta Region在哪里提供服务？</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">HBase是否可以保证单行操作的原子性？</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">Region中写WAL与写MemStore的顺序是怎样的？</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">你是否遇到过Region长时间处于RIT的状态？ 你认为旧版本中Assignment Manager的主要问题是什么？</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">在面对Full GC问题时，你尝试做过哪些优化？</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">你是否深究过HBase Compaction带来的“写放大”有多严重？</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">HBase的RPC框架存在什么问题？</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">导致查询时延毛刺的原因有哪些？</span></p></li></ol></blockquote><p><span class="md-line md-end-block">本系列文章的<span>整体行文思路</span>如下：</span></p><ol class="ol-list"><li class="md-list-item"><p><span class="md-line md-end-block">介绍HBase数据模型</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">基于数据模型介绍HBase的适用场景</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">快速介绍集群关键角色以及集群部署建议</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">示例数据介绍</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">写数据流程</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">读数据流程</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">数据更新</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">负载均衡机制</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">HBase如何存储小文件数据</span></p></li></ol><p><span class="md-line md-end-block">这些内容将会被拆成几篇文章。至于集群服务故障的处理机制，集群工具，周边生态，性能调优以及最佳实践等进阶内容，暂不放在本系列文章范畴内。</span></p><h2 class="md-end-block md-heading"><a></a>约定</h2><ol class="ol-list"><li class="md-list-item"><p><span class="md-line md-end-block">本文范围内针对一些关键特性/流程，使用了加粗以及加下划线的方式做了强调，如”<span><span><span>ProcedureV2</span></span></span>“。这些特性往往在本文中仅仅被粗浅提及，后续计划以独立的文章来介绍这些特性/流程。</span></p></li><li class="md-list-item"><span class="md-line md-end-block"><span><span>术语缩写</span></span>：对于一些进程/角色名称，在本文范围内可能通过缩写形式来表述：</span></li></ol><div><img src="//img-blog.csdn.net/20180321221246997" alt=""></div><h2 class="md-end-block md-heading"><a></a>数据模型</h2><h3 class="md-end-block md-heading"><a></a>RowKey</h3><p><span class="md-line md-end-block">用来表示唯一一行记录的<span><span>主键</span></span>，HBase的数据是按照RowKey的<span><span>字典顺序</span></span>进行全局排序的，所有的查询都只能依赖于这一个排序维度。</span></p><blockquote><p><span class="md-line md-end-block">通过下面一个例子来说明一下”<span><span>字典排序</span></span>“的原理：</span></p><p><span class="md-line md-end-block">RowKey {“abc”, “a”, “bdf”, “cdf”, “defg”}按字典排序后的结果为{“a”, “abc”, “bdf”, “cdf”, “defg”}</span></p><p><span class="md-line md-end-block">也就是说，当两个RowKey进行排序时，先对比两个RowKey的第一个字节，如果相同，则对比第二个字节，依此类推…如果在对比到第M个字节时，已经超出了其中一个RowKey的字节长度，那么，短的RowKey要被排在另外一个RowKey的前面</span></p></blockquote><h3 class="md-end-block md-heading"><a></a>稀疏矩阵</h3><p><span class="md-line md-end-block">参考了Bigtable，HBase中一个表的数据是按照稀疏矩阵的方式组织的，”开篇”部分给出了一张关于HBase数据表的<span><span>抽象图</span></span>，我们再结合下表来加深大家关于”稀疏矩阵”的印象：</span></p><p><img src="//img-blog.csdn.net/20180321221308195" alt=""><br></p><p><span class="md-line md-end-block">看的出来：<span><span>每一行中，列的组成都是灵活的，行与行之间并不需要遵循相同的列定义</span></span>， 也就是HBase数据表”<span><span>schema-less</span></span>“的特点。</span></p><h3 class="md-end-block md-heading"><a></a>Region</h3><p><span class="md-line md-end-block">区别于Cassandra/DynamoDB的”Hash分区”设计，HBase中采用了”Range分区”，将Key的完整区间切割成一个个的”Key Range” ，每一个”Key Range”称之为一个Region。</span></p><p><span class="md-line md-end-block">也可以这么理解：将HBase中拥有数亿行的一个大表，<span><span>横向切割</span></span>成一个个”<span><span>子表</span></span>“，这一个个”<span><span>子表</span></span>“就是<span><span>Region</span></span>：</span></p><p><img src="//img-blog.csdn.net/2018032122133316" alt=""><br></p><p><span class="md-line md-end-block">Region是HBase中负载均衡的基本单元，当一个Region增长到一定大小以后，会自动分裂成两个。</span></p><h3 class="md-end-block md-heading"><a></a>Column Family</h3><p><span class="md-line md-end-block">如果将Region看成是一个表的<span><span>横向切割</span></span>，那么，一个Region中的数据列的<span><span>纵向切割</span></span>，称之为一个<span><span>Column Family</span></span>。每一个列，都必须归属于一个Column Family，这个归属关系是在写数据时指定的，而不是建表时预先定义。</span></p><p><img src="//img-blog.csdn.net/20180321221348774" alt=""><br></p><h3 class="md-end-block md-heading"><a></a>KeyValue</h3><p><span class="md-line md-end-block">KeyValue的设计不是源自Bigtable，而是要追溯至论文”The log-structured merge-tree(LSM-Tree)”。每一行中的每一列数据，都被包装成独立的拥有<span><span>特定结构</span></span>的KeyValue，KeyValue中包含了丰富的自我描述信息:</span></p><p><img src="//img-blog.csdn.net/20180321221401755" alt=""><br></p><p><span class="md-line md-end-block">看的出来，KeyValue是支撑”稀疏矩阵”设计的一个关键点：一些Key相同的任意数量的独立KeyValue就可以构成一行数据。但这种设计带来的一个显而易见的缺点：<span><span>每一个KeyValue所携带的自我描述信息，会带来显著的数据膨胀</span></span>。</span></p><h2 class="md-end-block md-heading"><a></a>适用场景</h2><p><span class="md-line md-end-block">在介绍完了HBase的数据模型以后，我们可以回答本文一开始的前两个问题：</span></p><blockquote><ol class="ol-list"><li class="md-list-item"><p><span class="md-line md-end-block">什么样的数据适合用HBase来存储？</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">既然HBase也是一个数据库，能否用它将现有系统中昂贵的Oracle替换掉？</span></p></li></ol></blockquote><p><span class="md-line md-end-block">HBase的数据模型比较简单，数据按照RowKey排序存放，适合HBase存储的数据，可以简单总结如下：</span></p><ul class="ul-list"><li class="md-list-item"><p><span class="md-line md-end-block">以<span><span>实体</span></span>为中心的数据</span></p><p><span class="md-line md-end-block">实体可以包括但不限于如下几种：</span></p><ul class="ul-list"><li class="md-list-item"><p><span class="md-line md-end-block">自然人／账户／手机号／车辆相关数据</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">用户画像数据（含标签类数据）</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">图数据（关系类数据）</span></p></li></ul><p><span class="md-line md-end-block">描述这些实体的，可以有基础属性信息、实体关系(图数据)、所发生的事件(如交易记录、车辆轨迹点)等等。</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">以<span><span>事件</span></span>为中心的数据</span></p><ul class="ul-list"><li class="md-list-item"><p><span class="md-line md-end-block">监控数据</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">时序数据</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">实时位置类数据</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">消息/日志类数据</span></p></li></ul></li></ul><p><span class="md-line md-end-block">上面所描述的这些数据，有的是结构化数据，有的是半结构化或非结构化数据。HBase的“稀疏矩阵”设计，使其应对非结构化数据存储时能够得心应手，但在我们的实际用户场景中，结构化数据存储依然占据了比较重的比例。由于HBase仅提供了基于RowKey的单维度索引能力，在应对一些具体的场景时，依然还需要基于HBase之上构建一些专业的能力，如：</span></p><ul class="ul-list"><li class="md-list-item"><p><span class="md-line md-end-block"><span><span>OpenTSDB</span></span> 时序数据存储，提供基于Metrics+时间+标签的一些组合维度查询与聚合能力</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block"><span><span>GeoMesa</span></span> 时空数据存储，提供基于时间+空间范围的索引能力</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block"><span><span>JanusGraph</span></span> 图数据存储，提供基于属性、关系的图索引能力</span></p></li></ul><p><span class="md-line md-end-block">HBase擅长于存储结构简单的海量数据但索引能力有限，而Oracle等传统关系型数据库(RDBMS)能够提供丰富的查询能力，但却疲于应对TB级别的海量数据存储，HBase对传统的RDBMS并不是取代关系，而是一种补充。</span></p><h2 class="md-end-block md-heading"><a></a>HBase与HDFS</h2><p><span class="md-line md-end-block">我们都知道HBase的数据是存储于HDFS里面的，相信大家也都有这么的认知：</span></p><blockquote><p><span class="md-line md-end-block">HBase是一个<span><span>分布式数据库</span></span>，HDFS是一个<span><span>分布式文件系统</span></span></span></p></blockquote><p><span class="md-line md-end-block">理解了这一点，我们先来粗略回答本文已开始提出的其中两个问题：</span></p><blockquote><ol class="ol-list" start="3"><li class="md-list-item"><p><span class="md-line md-end-block"><span><span>HBase中的数据为何不直接存放于HDFS之上？</span></span></span></p></li></ol><p><span class="md-line md-end-block">HBase中存储的海量数据记录，通常在几百Bytes到KB级别，如果将这些数据直接存储于HDFS之上，会导致大量的小文件产生，为HDFS的元数据管理节点(NameNode)带来沉重的压力。</span></p><ol class="ol-list" start="4"><li class="md-list-item"><p><span class="md-line md-end-block"><span><span>文件能否直接存储于HBase里面？</span></span></span></p></li></ol><p><span class="md-line md-end-block">如果是几MB的文件，其实也可以直接存储于HBase里面，我们暂且将这类文件称之为小文件，HBase提供了一个名为MOB的特性来应对这类小文件的存储。但如果是更大的文件，强烈不建议用HBase来存储，关于这里更多的原因，希望你在详细读完本文所有内容之后能够自己解答。</span></p></blockquote><h2 class="md-end-block md-heading"><a></a>集群角色</h2><blockquote><p><span class="md-line md-end-block">关于集群环境，你可以使用国内外大数据厂商的平台，如Cloudera，Hontonworks以及国内的华为，都发行了自己的企业版大数据平台，另外，华为云、阿里云中也均推出了全托管式的HBase服务。</span></p></blockquote><p><span class="md-line md-end-block">我们假设集群环境已经Ready了，先来看一下集群中的<span><span>关键角色</span></span>：</span></p><p><img src="//img-blog.csdn.net/20180321221502649" alt=""><br></p><p><span class="md-line md-end-block">相信大部分人对这些角色都已经有了一定程度的了解，我们快速的介绍一下各个角色在集群中的<span><span>主要</span></span>职责(<span><span>注意</span></span>：这里不是列出所有的职责)：</span></p><ul class="ul-list"><li class="md-list-item"><p><span class="md-line md-end-block"><span><span>ZooKeeper</span></span></span></p><p><span class="md-line md-end-block">在一个拥有多个节点的分布式系统中，假设，只能有一个节点是主节点，如何快速的选举出一个主节点而且让所有的节点都认可这个主节点？这就是HBase集群中存在的一个最基础命题。</span></p><p><span class="md-line md-end-block">利用ZooKeeper就可以非常简单的实现这类”仲裁”需求，ZooKeeper还提供了基础的事件通知机制，所有的数据都以 ZNode的形式存在，它也称得上是一个”微型数据库”。</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block"><span><span>NameNode</span></span></span></p><p><span class="md-line md-end-block">HDFS作为一个分布式文件系统，自然需要文件目录树的<span><span>元数据</span></span>信息，另外，在HDFS中每一个文件都是按照Block存储的，文件与Block的关联也通过<span><span>元数据</span></span>信息来描述。NameNode提供了这些<span><span>元数据信息的存储</span></span>。</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block"><span><span>DataNode</span></span></span></p><p><span class="md-line md-end-block">HDFS的数据存放节点。</span></p></li></ul><ul class="ul-list"><li class="md-list-item"><p><span class="md-line md-end-block"><span><span>RegionServer</span></span></span></p><p><span class="md-line md-end-block">HBase的<span><span>数据服务节点</span></span>。</span></p></li></ul><ul class="ul-list"><li class="md-list-item"><p><span class="md-line md-end-block"><span><span>Master</span></span></span></p><p><span class="md-line md-end-block">HBase的管理节点，通常在一个集群中设置一个主Master，一个备Master，主备角色的”仲裁”由ZooKeeper实现。 Master<span><span>主要职责</span></span>：</span></p><ol class="ol-list"><li class="md-list-item"><p><span class="md-line md-end-block">负责管理所有的RegionServer</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">建表/修改表/删除表等DDL操作请求的服务端执行主体</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">管理所有的数据分片(Region)到RegionServer的分配</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">如果一个RegionServer宕机或进程故障，由Master负责将它原来所负责的Regions转移到其它的RegionServer上继续提供服务</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">Master自身也可以作为一个RegionServer提供服务，该能力是可配置的</span></p></li></ol></li></ul><h2 class="md-end-block md-heading"><a></a>集群部署建议</h2><p><span class="md-line md-end-block">如果基于物理机/虚拟机部署，通常建议：</span></p><ul class="ul-list"><li class="md-list-item"><p><span class="md-line md-end-block">RegionServer与DataNode联合部署，RegionServer与DataNode按1:1比例设置。</span></p><p><span class="md-line md-end-block">这种部署的优势在于，RegionServer中的数据文件可以存储一个副本于本机的DataNode节点中，从而在读取时可以利用HDFS中的”<span><span><span>短路径读取(Short Circuit)</span></span></span>“来绕过网络请求，降低读取时延。</span></p></li></ul><p><img src="//img-blog.csdn.net/20180321221521878" alt=""><br></p><ul class="ul-list"><li class="md-list-item"><p><span class="md-line md-end-block">管理节点独立于数据节点部署</span></p></li></ul><p><span class="md-line md-end-block">如果是基于物理机部署，每一台物理机节点上可以设置几个RegionServers/DataNodes来提升资源使用率。</span></p><p><span class="md-line md-end-block">也可以选择基于容器来部署，如在HBaseCon Asia 2017大会知乎的演讲主题中，就提到了知乎基于Kubernetes部署HBase服务的实践。</span></p><p><span class="md-line md-end-block">对于公有云HBase服务而言，为了降低总体拥有成本(<span><span>TCO</span></span>)，通常选择”<span><span>计算与存储物理分离</span></span>“的方式，从架构上来说，可能导致平均时延略有下降，但可以借助于共享存储底层的IO优化来做一些”弥补”。</span></p><p><span class="md-line md-end-block">HBase集群中的RegionServers可以按逻辑划分为多个Groups，一个表可以与一个指定的Group绑定，可以将RegionServer Group理解成将一个大的集群划分成了多个逻辑子集群，借此可以实现多租户间的隔离，这就是HBase中的<span><span><span>RegionServer Group</span></span></span>特性。</span></p><h2 class="md-end-block md-heading"><a></a>示例数据</h2><p><span class="md-line md-end-block">以我们日常生活都熟悉的手机通话记录的存储为例，先简单给出示例数据的字段定义：</span></p><p><img src="//img-blog.csdn.net/20180321221538504" alt=""><br></p><p><span class="md-line md-end-block">本文内容力求简洁，仅给出了几个简单字段。如下是”虚构”的样例数据：</span></p><p><img src="//img-blog.csdn.net/20180321221551685" alt=""><br></p><p><span class="md-line md-end-block">在本文大部分内容中所涉及的一条数据，是上面加粗的最后一行”<span><span>MSISDN1</span></span>“为”<span><span>13400006666</span></span>“这行记录。</span></p><p><span class="md-line md-end-block">在本系列文章的流程图中，我们将会使用一个<span><span>红色的五角星<img class="alignnone size-full wp-image-875" src="http://www.nosqlnotes.com/wp-content/uploads/2018/03/UserData.png" alt="UserData"></span></span>来表示该数据所在的位置。</span></p><h2 class="md-end-block md-heading"><a></a><span>写数据之前：建立连接</span></h2><h3 class="md-end-block md-heading"><a></a>Login</h3><p><span class="md-line md-end-block"><span>在启用了安全特性的前提下，Login阶段是为了完成</span><span><span><span>用户认证</span></span></span>(确定用户的合法身份)，这是后续一切<span><span>安全访问控制</span></span>的基础。</span></p><p><span class="md-line md-end-block">当前Hadoop/HBase仅支持基于Kerberos的用户认证，ZooKeeper除了Kerberos认证，还能支持简单的用户名/密码认证，但都基于静态的配置，无法动态新增用户。如果要支持其它第三方认证，需要对现有的安全框架做出比较大的改动。</span></p><h3 class="md-end-block md-heading"><a></a>创建Connection</h3><p><span class="md-line md-end-block">Connection可以理解为一个HBase集群连接的抽象，建议使用ConnectionFactory提供的工具方法来创建。因为HBase当前提供了两种连接模式：同步连接，异步连接，这两种连接模式下所创建的Connection也是不同的。我们给出ConnectionFactory中关于获取这两种连接的典型方法定义：</span></p><pre class="md-fences md-end-block"><span><span class="cm-variable">CompletableFuture</span><span class="cm-operator">&lt;</span><span class="cm-variable">AsyncConnection</span><span class="cm-operator">&gt;</span> <span class="cm-def">createAsyncConnection</span>(<span class="cm-variable">Configuration</span> <span class="cm-variable">conf</span>,</span>
<span>                 <span class="cm-variable">User</span> <span class="cm-variable">user</span>);</span>
<span>​</span>
<span><span class="cm-variable">Connection</span> <span class="cm-def">createConnection</span>(<span class="cm-variable">Configuration</span> <span class="cm-variable">conf</span>, <span class="cm-variable">ExecutorService</span> <span class="cm-variable">pool</span>, <span class="cm-variable">User</span> <span class="cm-variable">user</span>)</span>
<span>      <span class="cm-keyword">throws</span> <span class="cm-variable">IOException</span>;</span></pre><p><span class="md-line md-end-block">Connection中主要维护着两类共享的资源：</span></p><ul class="ul-list"><li class="md-list-item"><p><span class="md-line md-end-block">线程池</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">Socket连接</span></p></li></ul><p><span class="md-line md-end-block">这些资源都是在真正使用的时候才会被创建，因此，此时的连接还只是一个”虚拟连接”。</span></p><h2 class="md-end-block md-heading"><a></a>写数据之前：创建数据表</h2><h3 class="md-end-block md-heading"><a></a>DDL操作的抽象接口 – Admin</h3><p><span class="md-line md-end-block">Admin定义了常规的DDL接口，列举几个典型的接口：</span></p><pre class="md-fences md-end-block"><span><span class="cm-variable-3">void</span> <span class="cm-def">createNamespace</span>(<span class="cm-keyword">final</span> <span class="cm-variable">NamespaceDescriptor</span> <span class="cm-variable">descriptor</span>) <span class="cm-keyword">throws</span> <span class="cm-variable">IOException</span>;</span>
<span>​</span>
<span><span class="cm-variable-3">void</span> <span class="cm-def">createTable</span>(<span class="cm-keyword">final</span> <span class="cm-variable">HTableDescriptor</span> <span class="cm-variable">desc</span>, <span class="cm-variable-3">byte</span>[][] <span class="cm-variable">splitKeys</span>) <span class="cm-keyword">throws</span> <span class="cm-variable">IOException</span>;</span>
<span>​</span>
<span><span class="cm-variable">TableName</span>[] <span class="cm-def">listTableNames</span>() <span class="cm-keyword">throws</span> <span class="cm-variable">IOException</span>;</span></pre><h3 class="md-end-block md-heading"><a></a>预设合理的数据分片 – Region</h3><p><span class="md-line md-end-block">分片数量会给读写吞吐量带来直接的影响，因此，建表时通常建议由用户主动指定划分<span><span>Region分割点</span></span>，来设定Region的数量。</span></p><p><span class="md-line md-end-block">HBase中数据是按照RowKey的字典顺序排列的，为了能够划分出合理的Region分割点，需要依据如下几点信息：</span></p><ul class="ul-list"><li class="md-list-item"><p><span class="md-line md-end-block">Key的组成结构</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">Key的数据分布预估</span></p><p><span class="md-line md-end-block">如果不能基于Key的组成结构来预估数据分布的话，可能会导致数据在Region间的分布不均匀</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">读写并发度需求</span></p><p><span class="md-line md-end-block">依据读写并发度需求，设置合理的Region数量</span></p></li></ul><h3 class="md-end-block md-heading"><a></a>为表定义合理的Schema</h3><p><span class="md-line md-end-block">既然HBase号称”schema-less”的数据存储系统，那何来的是schema? 的确，在数据库范式的支持上，HBase非常弱，这里的Schema，主要指如下一些信息的设置：</span></p><ul class="ul-list"><li class="md-list-item"><p><span class="md-line md-end-block">NameSpace设置</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">Column Family的数量</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">每一个Column Family中所关联的一些<span><span>关键配置</span></span>：</span></p><ul class="ul-list"><li class="md-list-item"><p><span class="md-line md-end-block">Compression</span></p><p><span class="md-line md-end-block">HBase当前可以支持Snappy，GZ，LZO，LZ4，Bzip2以及ZSTD压缩算法</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">DataBlock Encoding</span></p><p><span class="md-line md-end-block">HBase针对自身的特殊数据模型所做的一种压缩编码</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">BloomFilter</span></p><p><span class="md-line md-end-block">可用来协助快速判断一条记录是否存在</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">TTL</span></p><p><span class="md-line md-end-block">指定数据的过期时间</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">StoragePolicy</span></p><p><span class="md-line md-end-block">指定Column Family的存储策略，可选配置有：</span></p><p><span class="md-line md-end-block">“ALL_SSD”，”ONE_SSD”，”HOT”，”WARM”，”COLD”，”LAZY_PERSIST”</span></p></li></ul></li></ul><p><span class="md-line md-end-block">HBase中并不需要预先设置Column定义信息，这就是HBase schema-less设计的核心。</span></p><h3 class="md-end-block md-heading"><a></a>Client发送建表请求到Master</h3><p><span class="md-line md-end-block">建表的请求是通过RPC的方式由Client发送到Master:</span></p><ul class="ul-list"><li class="md-list-item"><p><span class="md-line md-end-block">RPC接口基于Protocol Buffer定义</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">建表相关的描述参数，也由Protocol Buffer进行定义及序列化</span></p></li></ul><p><span class="md-line md-end-block">Client端侧调用了Master服务的什么接口，参数是什么，这些信息都被通过RPC通信传输到Master侧，Master再依据这些接口\参数描述信息决定要执行的操作。2.0版本中，HBase目前已经支持基于Netty的<span><span><span>异步RPC框架</span></span></span>。</span></p><blockquote><p><span class="md-line md-end-block"><span><span>关于HBase RPC框架</span></span></span></p><p><span class="md-line md-end-block">早期的HBase RPC框架，完全借鉴了Hadoop中的实现，那时，Netty项目尚不盛行。</span></p></blockquote><p><span class="md-line md-end-block">Master侧接收到Client侧的建表请求以后，一些主要操作包括：</span></p><ol class="ol-list"><li class="md-list-item"><p><span class="md-line md-end-block">生成每一个Region的描述信息对象HRegionInfo，这些描述信息包括：Region ID, Region名称，Key范围，表名称等信息</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">生成每一个Region在HDFS中的文件目录</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">将HRegionInfo信息写入到记录元数据的hbase:meta表中。</span></p></li></ol><blockquote><p><span class="md-line md-end-block"><span><span>说明</span></span></span></p><p><span class="md-line md-end-block">meta表位于名为”hbase”的namespace中，因此，它的全称为”hbase:meta”。</span></p><p><span class="md-line md-end-block">但在本系列文章范畴内，常将其缩写为”meta”。</span></p></blockquote><p><span class="md-line md-end-block">整个过程中，新表的状态也是记录在hbase:meta表中的，而不用再存储在ZooKeeper中。</span></p><p><span class="md-line md-end-block">如果建表执行了一半，Master进程挂掉了，如何处理？这里是由HBase自身提供的一个名为<span><span><span>Procedure(V2)</span></span></span>的框架来保障操作的事务性的，备Master接管服务以后，将会继续完成整个建表操作。</span></p><p><span class="md-line md-end-block">一个被创建成功的表，还可以被执行如下操作：</span></p><ul class="ul-list"><li class="md-list-item"><p><span class="md-line md-end-block"><span><span><span>Disable</span></span></span> 将所有的Region下线，该表暂停读写服务</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block"><span><span><span>Enable</span></span></span> 将一个Disable过的表重新Enable，也就是上线所有的Region来正常提供读写服务</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block"><span><span><span>Alter</span></span></span> 更改表或列族的描述信息</span></p></li></ul><h3 class="md-end-block md-heading"><a></a>Master分配Regions到各个RegionServers</h3><p><span class="md-line md-end-block">新创建的所有的Regions，通过<span><span><span>AssignmentManager</span></span></span>将这些Region按照轮询(Round-Robin)的方式分配到每一个RegionServer中，具体的分配计划是由<span><span><span>LoadBalancer</span></span></span>来提供的。</span></p><p><span class="md-line md-end-block">AssignmentManager负责所有Regions的分配/迁移操作，Master中有一个定时运行的线程，来检查集群中的Regions在各个RegionServer之间的负载是否是均衡的，如果不均衡，则通过LoadBalancer生成相应的Region迁移计划，HBase中支持多种负载均衡算法，有最简单的仅考虑各RegionServer上的Regions数目的负载均衡算法，有基于迁移代价的负载均衡算法，也有数据本地化率优先的负载均衡算法，因为这一部分已经提供了插件化机制，用户也可以自定义负载均衡算法。</span></p><h3><a></a>总结</h3><p><span class="md-line md-end-block">到目前为止，文章介绍了如下关键内容：</span></p><ol class="ol-list"><li class="md-list-item"><p><span class="md-line md-end-block">HBase项目概述，呈现了HBase社区的活跃度以及搜索引擎热度等信息</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">HBase数据模型部分，讲到了RowKey，稀疏矩阵，Region，Column Family，KeyValue等概念</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">基于HBase的数据模型，介绍了HBase的适合场景（以实体/事件为中心的简单结构的数据）</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">介绍了HBase与HDFS的关系</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">介绍了集群的关键角色：ZooKeeper, Master, RegionServer，NameNode, DataNode</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">集群部署建议</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">给出了一些示例数据</span></p></li><li class="md-list-item"><p><span class="md-line md-end-block">写数据之前的准备工作：建立集群连接，建表（建表时应该定义合理的Schema以及设置合理的Region数量），建表由Master处理，新创建的Regions由Region AssignmentManager负责分配到各个RegionServer。
</span></p></li></ol></div>
</div></div></article>
            </div>
						<link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-9e5741c4b9.css" rel="stylesheet">
                </div>