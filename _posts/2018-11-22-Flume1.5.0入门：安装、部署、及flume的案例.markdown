---
layout:     post
title:      Flume1.5.0入门：安装、部署、及flume的案例
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <div id="content_views" class="markdown_views prism-atom-one-dark">
							<!-- flowchart 箭头图标 勿删 -->
							<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path></svg>
							<p>问题导读 <br>
1.什么是flume <br>
2.flume的官方网站在哪里？ <br>
3.flume有哪些术语？ <br>
4.如何配置flume数据源码？</p>

<p>　　一、什么是Flume? <br>
　　flume 作为 cloudera 开发的实时日志收集系统，受到了业界的认可与广泛应用。Flume 初始的发行版本目前被统称为 Flume OG（original generation），属于 cloudera。但随着 FLume 功能的扩展，Flume OG 代码工程臃肿、核心组件设计不合理、核心配置不标准等缺点暴露出来，尤其是在 Flume OG 的最后一个发行版本 0.94.0 中，日志传输不稳定的现象尤为严重，为了解决这些问题，2011 年 10 月 22 号，cloudera 完成了 Flume-728，对 Flume 进行了里程碑式的改动：重构核心组件、核心配置以及代码架构，重构后的版本统称为 Flume NG（next generation）；改动的另一原因是将 Flume 纳入 apache 旗下，cloudera Flume 改名为 Apache Flume。</p>

<pre><code>    flume的特点：
</code></pre>

<p>　　flume是一个分布式、可靠、和高可用的海量日志采集、聚合和传输的系统。支持在日志系统中定制各类数据发送方，用于收集数据;同时，Flume提供对数据进行简单处理，并写到各种数据接受方(比如文本、HDFS、Hbase等)的能力 。 <br>
　　flume的数据流由事件(Event)贯穿始终。事件是Flume的基本数据单位，它携带日志数据(字节数组形式)并且携带有头信息，这些Event由Agent外部的Source生成，当Source捕获事件后会进行特定的格式化，然后Source会把事件推入(单个或多个)Channel中。你可以把Channel看作是一个缓冲区，它将保存事件直到Sink处理完该事件。Sink负责持久化日志或者把事件推向另一个Source。</p>

<pre><code>    flume的可靠性 
</code></pre>

<p>　　当节点出现故障时，日志能够被传送到其他节点上而不会丢失。Flume提供了三种级别的可靠性保障，从强到弱依次分别为：end-to-end（收到数据agent首先将event写到磁盘上，当数据传送成功后，再删除；如果数据发送失败，可以重新发送。），Store on failure（这也是scribe采用的策略，当数据接收方crash时，将数据写到本地，待恢复后，继续发送），Besteffort（数据发送到接收方后，不会进行确认）。</p>

<pre><code>    flume的可恢复性：
</code></pre>

<p>　　还是靠Channel。推荐使用FileChannel，事件持久化在本地文件系统里(性能较差)。 </p>

<p>　　flume的一些核心概念： <br>
Agent        使用JVM 运行Flume。每台机器运行一个agent，但是可以在一个agent中包含多个sources和sinks。 <br>
Client        生产数据，运行在一个独立的线程。 <br>
Source        从Client收集数据，传递给Channel。 <br>
Sink        从Channel收集数据，运行在一个独立线程。 <br>
Channel        连接 sources 和 sinks ，这个有点像一个队列。 <br>
Events        可以是日志记录、 avro 对象等。</p>

<p>　　Flume以agent为最小的独立运行单位。一个agent就是一个JVM。单agent由Source、Sink和Channel三大组件构成，如下图：</p>

<p>　　值得注意的是，Flume提供了大量内置的Source、Channel和Sink类型。不同类型的Source,Channel和Sink可以自由组合。组合方式基于用户设置的配置文件，非常灵活。比如：Channel可以把事件暂存在内存里，也可以持久化到本地硬盘上。Sink可以把日志写入HDFS, HBase，甚至是另外一个Source等等。Flume支持用户建立多级流，也就是说，多个agent可以协同工作，并且支持Fan-in、Fan-out、Contextual Routing、Backup Routes，这也正是NB之处。如下图所示:</p>

<p>　　二、flume的官方网站在哪里？ <br>
　　<a href="http://flume.apache.org/" rel="nofollow">http://flume.apache.org/</a></p>

<p>　　三、在哪里下载？ <br>
　　<a href="http://www.apache.org/dyn/closer.cgi/flume/1.5.0/apache-flume-1.5.0-bin.tar.gz" rel="nofollow">http://www.apache.org/dyn/closer.cgi/flume/1.5.0/apache-flume-1.5.0-bin.tar.gz</a></p>

<p>　　四、如何安装？ <br>
　　　　1)将下载的flume包，解压到/home/hadoop目录中，你就已经完成了50%：）简单吧 <br>
　　　　2)修改 flume-env.sh 配置文件,主要是JAVA_HOME变量设置</p>

<p>root@m1:/home/hadoop/flume-1.5.0-bin# cp conf/flume-env.sh.template conf/flume-env.sh <br>
root@m1:/home/hadoop/flume-1.5.0-bin# vi conf/flume-env.sh</p>



<h1 id="licensed-to-the-apache-software-foundation-asf-under-one">Licensed to the Apache Software Foundation (ASF) under one</h1>



<h1 id="or-more-contributor-license-agreements-see-the-notice-file">or more contributor license agreements.  See the NOTICE file</h1>



<h1 id="distributed-with-this-work-for-additional-information">distributed with this work for additional information</h1>



<h1 id="regarding-copyright-ownership-the-asf-licenses-this-file">regarding copyright ownership.  The ASF licenses this file</h1>



<h1 id="to-you-under-the-apache-license-version-20-the">to you under the Apache License, Version 2.0 (the</h1>



<h1 id="license-you-may-not-use-this-file-except-in-compliance">“License”); you may not use this file except in compliance</h1>



<h1 id="with-the-license-you-may-obtain-a-copy-of-the-license-at">with the License.  You may obtain a copy of the License at</h1>

<p>#</p>



<h1 id="httpwwwapacheorglicenseslicense-20"><a href="http://www.apache.org/licenses/LICENSE-2.0" rel="nofollow">http://www.apache.org/licenses/LICENSE-2.0</a></h1>

<p>#</p>



<h1 id="unless-required-by-applicable-law-or-agreed-to-in-writing-software">Unless required by applicable law or agreed to in writing, software</h1>



<h1 id="distributed-under-the-license-is-distributed-on-an-as-is-basis">distributed under the License is distributed on an “AS IS” BASIS,</h1>



<h1 id="without-warranties-or-conditions-of-any-kind-either-express-or-implied">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</h1>



<h1 id="see-the-license-for-the-specific-language-governing-permissions-and">See the License for the specific language governing permissions and</h1>



<h1 id="limitations-under-the-license">limitations under the License.</h1>



<h1 id="if-this-file-is-placed-at-flumeconfdirflume-envsh-it-will-be-sourced">If this file is placed at FLUME_CONF_DIR/flume-env.sh, it will be sourced</h1>



<h1 id="during-flume-startup">during Flume startup.</h1>



<h1 id="enviroment-variables-can-be-set-here">Enviroment variables can be set here.</h1>

<p>JAVA_HOME=/usr/lib/jvm/java-7-oracle</p>



<h1 id="give-flume-more-memory-and-pre-allocate-enable-remote-monitoring-via-jmx">Give Flume more memory and pre-allocate, enable remote monitoring via JMX</h1>



<h1 id="javaopts-xms100m-xmx200m-dcomsunmanagementjmxremote">JAVA_OPTS=”-Xms100m -Xmx200m -Dcom.sun.management.jmxremote”</h1>



<h1 id="note-that-the-flume-conf-directory-is-always-included-in-the-classpath">Note that the Flume conf directory is always included in the classpath.</h1>



<h1 id="flumeclasspath">FLUME_CLASSPATH=”“</h1>

<p>复制代码</p>

<pre><code>          3)验证是否安装成功
</code></pre>

<p>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng version <br>
Flume 1.5.0 <br>
Source code repository: <a href="https://git-wip-us.apache.org/repos/asf/flume.git" rel="nofollow">https://git-wip-us.apache.org/repos/asf/flume.git</a> <br>
Revision: 8633220df808c4cd0c13d1cf0320454a94f1ea97 <br>
Compiled by hshreedharan on Wed May  7 14:49:18 PDT 2014 <br>
From source with checksum a01fe726e4380ba0c9f7a7d222db961f <br>
root@m1:/home/hadoop# <br>
复制代码 <br>
　　　　出现上面的信息，表示安装成功了</p>

<p>　　五、flume的案例 <br>
　　　　1)案例1：Avro <br>
　　　　Avro可以发送一个给定的文件给Flume，Avro 源使用AVRO RPC机制。 <br>
　　　　　　a)创建agent配置文件</p>

<p>root@m1:/home/hadoop#vi /home/hadoop/flume-1.5.0-bin/conf/avro.conf</p>

<p>a1.sources = r1 <br>
a1.sinks = k1 <br>
a1.channels = c1</p>



<h1 id="describeconfigure-the-source">Describe/configure the source</h1>

<p>a1.sources.r1.type = avro <br>
a1.sources.r1.channels = c1 <br>
a1.sources.r1.bind = 0.0.0.0 <br>
a1.sources.r1.port = 4141</p>



<h1 id="describe-the-sink">Describe the sink</h1>

<p>a1.sinks.k1.type = logger</p>



<h1 id="use-a-channel-which-buffers-events-in-memory">Use a channel which buffers events in memory</h1>

<p>a1.channels.c1.type = memory <br>
a1.channels.c1.capacity = 1000 <br>
a1.channels.c1.transactionCapacity = 100</p>



<h1 id="bind-the-source-and-sink-to-the-channel">Bind the source and sink to the channel</h1>

<p>a1.sources.r1.channels = c1 <br>
a1.sinks.k1.channel = c1 <br>
复制代码</p>

<p>　　　　　　b)启动flume agent a1</p>

<p>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/avro.conf -n a1 -Dflume.root.logger=INFO,console <br>
复制代码</p>

<p>　　　　　　c)创建指定文件</p>

<p>root@m1:/home/hadoop# echo “hello world” &gt; /home/hadoop/flume-1.5.0-bin/log.00 <br>
复制代码</p>

<p>　　　　　　d)使用avro-client发送文件</p>

<p>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng avro-client -c . -H m1 -p 4141 -F /home/hadoop/flume-1.5.0-bin/log.00 <br>
复制代码</p>

<p>　　　　　　d)使用avro-client发送文件</p>

<p>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng avro-client -c . -H m1 -p 4141 -F / <br>
复制代码</p>

<p>　　　　　　f)在m1的控制台，可以看到以下信息，注意最后一行：</p>

<p>root@m1:/home/hadoop/flume-1.5.0-bin/conf# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/avro.conf -n a1 -Dflume.root.logger=INFO,console <br>
Info: Sourcing environment configuration script /home/hadoop/flume-1.5.0-bin/conf/flume-env.sh <br>
Info: Including Hadoop libraries found via (/home/hadoop/hadoop-2.2.0/bin/hadoop) for HDFS access <br>
Info: Excluding /home/hadoop/hadoop-2.2.0/share/hadoop/common/lib/slf4j-api-1.7.5.jar from classpath <br>
Info: Excluding /home/hadoop/hadoop-2.2.0/share/hadoop/common/lib/slf4j-log4j12-1.7.5.jar from classpath <br>
… <br>
2014-08-10 10:43:25,112 (New I/O  worker #1) [INFO - org.apache.avro.ipc.NettyServer<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-1-Frame" role="textbox" aria-readonly="true"><span class="math" id="MathJax-Span-1" style="vertical-align: -0.552em;"><span class="noError" id="MathJax-Span-2" style="display: inline-block;">NettyServerAvroHandler.handleUpstream(NettyServer.java:171)] [id: 0x92464c4f, /192.168.1.50:59850 :&gt; /192.168.1.50:4141] UNBOUND  <br>2014-08-10 10:43:25,112 (New I/O  worker #1) [INFO - org.apache.avro.ipc.NettyServer</span></span></span><script type="math/tex" id="MathJax-Element-1">NettyServerAvroHandler.handleUpstream(NettyServer.java:171)] [id: 0x92464c4f, /192.168.1.50:59850 :> /192.168.1.50:4141] UNBOUND  
2014-08-10 10:43:25,112 (New I/O  worker #1) [INFO - org.apache.avro.ipc.NettyServer</script>NettyServerAvroHandler.handleUpstream(NettyServer.java:171)] [id: 0x92464c4f, /192.168.1.50:59850 :&gt; /192.168.1.50:4141] CLOSED <br>
2014-08-10 10:43:25,112 (New I/O  worker #1) [INFO - org.apache.avro.ipc.NettyServer$NettyServerAvroHandler.channelClosed(NettyServer.java:209)] Connection to /192.168.1.50:59850 disconnected. <br>
2014-08-10 10:43:26,718 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 68 65 6C 6C 6F 20 77 6F 72 6C 64                hello world } <br>
复制代码</p>

<p>　　　　2)案例2：Spool <br>
　　　　Spool监测配置的目录下新增的文件，并将文件中的数据读取出来。需要注意两点： <br>
　　　　1) 拷贝到spool目录下的文件不可以再打开编辑。 <br>
　　　　2) spool目录下不可包含相应的子目录</p>

<p>　　　　　　a)创建agent配置文件</p>

<p>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/spool.conf</p>

<p>a1.sources = r1 <br>
a1.sinks = k1 <br>
a1.channels = c1</p>



<h1 id="describeconfigure-the-source-1">Describe/configure the source</h1>

<p>a1.sources.r1.type = spooldir <br>
a1.sources.r1.channels = c1 <br>
a1.sources.r1.spoolDir = /home/hadoop/flume-1.5.0-bin/logs <br>
a1.sources.r1.fileHeader = true</p>



<h1 id="describe-the-sink-1">Describe the sink</h1>

<p>a1.sinks.k1.type = logger</p>



<h1 id="use-a-channel-which-buffers-events-in-memory-1">Use a channel which buffers events in memory</h1>

<p>a1.channels.c1.type = memory <br>
a1.channels.c1.capacity = 1000 <br>
a1.channels.c1.transactionCapacity = 100</p>



<h1 id="bind-the-source-and-sink-to-the-channel-1">Bind the source and sink to the channel</h1>

<p>a1.sources.r1.channels = c1 <br>
a1.sinks.k1.channel = c1 <br>
复制代码</p>

<p>　　　　　　b)启动flume agent a1</p>

<p>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/spool.conf -n a1 -Dflume.root.logger=INFO,console <br>
复制代码</p>

<p>　　　　　　c)追加文件到/home/hadoop/flume-1.5.0-bin/logs目录</p>

<p>root@m1:/home/hadoop# echo “spool test1” &gt; /home/hadoop/flume-1.5.0-bin/logs/spool_text.log <br>
复制代码</p>

<p>　　　　　d)在m1的控制台，可以看到以下相关信息：</p>

<p>14/08/10 11:37:13 INFO source.SpoolDirectorySource: Spooling Directory Source runner has shutdown. <br>
14/08/10 11:37:13 INFO source.SpoolDirectorySource: Spooling Directory Source runner has shutdown. <br>
14/08/10 11:37:14 INFO avro.ReliableSpoolingFileEventReader: Preparing to move file /home/hadoop/flume-1.5.0-bin/logs/spool_text.log to /home/hadoop/flume-1.5.0-bin/logs/spool_text.log.COMPLETED <br>
14/08/10 11:37:14 INFO source.SpoolDirectorySource: Spooling Directory Source runner has shutdown. <br>
14/08/10 11:37:14 INFO source.SpoolDirectorySource: Spooling Directory Source runner has shutdown. <br>
14/08/10 11:37:14 INFO sink.LoggerSink: Event: { headers:{file=/home/hadoop/flume-1.5.0-bin/logs/spool_text.log} body: 73 70 6F 6F 6C 20 74 65 73 74 31                spool test1 } <br>
14/08/10 11:37:15 INFO source.SpoolDirectorySource: Spooling Directory Source runner has shutdown. <br>
14/08/10 11:37:15 INFO source.SpoolDirectorySource: Spooling Directory Source runner has shutdown. <br>
14/08/10 11:37:16 INFO source.SpoolDirectorySource: Spooling Directory Source runner has shutdown. <br>
14/08/10 11:37:16 INFO source.SpoolDirectorySource: Spooling Directory Source runner has shutdown. <br>
14/08/10 11:37:17 INFO source.SpoolDirectorySource: Spooling Directory Source runner has shutdown. <br>
复制代码</p>

<p>　　　　3)案例3：Exec <br>
　　　　EXEC执行一个给定的命令获得输出的源,如果要使用tail命令，必选使得file足够大才能看到输出内容</p>

<p>　　　　　　a)创建agent配置文件</p>

<p>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/exec_tail.conf</p>

<p>a1.sources = r1 <br>
a1.sinks = k1 <br>
a1.channels = c1</p>



<h1 id="describeconfigure-the-source-2">Describe/configure the source</h1>

<p>a1.sources.r1.type = exec <br>
a1.sources.r1.channels = c1 <br>
a1.sources.r1.command = tail -F /home/hadoop/flume-1.5.0-bin/log_exec_tail</p>



<h1 id="describe-the-sink-2">Describe the sink</h1>

<p>a1.sinks.k1.type = logger</p>



<h1 id="use-a-channel-which-buffers-events-in-memory-2">Use a channel which buffers events in memory</h1>

<p>a1.channels.c1.type = memory <br>
a1.channels.c1.capacity = 1000 <br>
a1.channels.c1.transactionCapacity = 100</p>



<h1 id="bind-the-source-and-sink-to-the-channel-2">Bind the source and sink to the channel</h1>

<p>a1.sources.r1.channels = c1 <br>
a1.sinks.k1.channel = c1 <br>
复制代码</p>

<p>　　　　　　b)启动flume agent a1</p>

<p>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/exec_tail.conf -n a1 -Dflume.root.logger=INFO,console <br>
复制代码</p>

<p>　　　　　　c)生成足够多的内容在文件里</p>

<p>root@m1:/home/hadoop# for i in {1..100};do echo “exec tail$i” &gt;&gt; /home/hadoop/flume-1.5.0-bin/log_ <br>
复制代码</p>

<p>　　　　　　e)在m1的控制台，可以看到以下信息：</p>

<p>2014-08-10 10:59:25,513 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 20 74 65 73 74       exec tail test } <br>
2014-08-10 10:59:34,535 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 20 74 65 73 74       exec tail test } <br>
2014-08-10 11:01:40,557 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 31                   exec tail1 } <br>
2014-08-10 11:01:41,180 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 32                   exec tail2 } <br>
2014-08-10 11:01:41,180 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 33                   exec tail3 } <br>
2014-08-10 11:01:41,181 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 34                   exec tail4 } <br>
2014-08-10 11:01:41,181 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 35                   exec tail5 } <br>
2014-08-10 11:01:41,181 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 36                   exec tail6 } <br>
…. <br>
…. <br>
…. <br>
2014-08-10 11:01:51,550 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 39 36                exec tail96 } <br>
2014-08-10 11:01:51,550 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 39 37                exec tail97 } <br>
2014-08-10 11:01:51,551 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 39 38                exec tail98 } <br>
2014-08-10 11:01:51,551 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 39 39                exec tail99 } <br>
2014-08-10 11:01:51,551 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 31 30 30             exec tail100 } <br>
复制代码</p>

<p>　　　　4)案例4：Syslogtcp <br>
　　　　Syslogtcp监听TCP的端口做为数据源</p>

<p>　　　　　　a)创建agent配置文件</p>

<p>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/syslog_tcp.conf</p>

<p>a1.sources = r1 <br>
a1.sinks = k1 <br>
a1.channels = c1</p>



<h1 id="describeconfigure-the-source-3">Describe/configure the source</h1>

<p>a1.sources.r1.type = syslogtcp <br>
a1.sources.r1.port = 5140 <br>
a1.sources.r1.host = localhost <br>
a1.sources.r1.channels = c1</p>



<h1 id="describe-the-sink-3">Describe the sink</h1>

<p>a1.sinks.k1.type = logger</p>



<h1 id="use-a-channel-which-buffers-events-in-memory-3">Use a channel which buffers events in memory</h1>

<p>a1.channels.c1.type = memory <br>
a1.channels.c1.capacity = 1000 <br>
a1.channels.c1.transactionCapacity = 100</p>



<h1 id="bind-the-source-and-sink-to-the-channel-3">Bind the source and sink to the channel</h1>

<p>a1.sources.r1.channels = c1 <br>
a1.sinks.k1.channel = c1 <br>
复制代码</p>

<p>　　　　　　b)启动flume agent a1</p>

<p>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/syslog_tcp.conf -n a1 -Dflume.root.logger=INFO,console <br>
复制代码</p>

<p>　　　　　　c)测试产生syslog</p>

<p>root@m1:/home/hadoop# echo “hello idoall.org syslog” | nc localhost 5140 <br>
复制代码</p>

<p>　　　　　　d)在m1的控制台，可以看到以下信息：</p>

<p>14/08/10 11:41:45 INFO node.PollingPropertiesFileConfigurationProvider: Reloading configuration file:/home/hadoop/flume-1.5.0-bin/conf/syslog_tcp.conf <br>
14/08/10 11:41:45 INFO conf.FlumeConfiguration: Added sinks: k1 Agent: a1 <br>
14/08/10 11:41:45 INFO conf.FlumeConfiguration: Processing:k1 <br>
14/08/10 11:41:45 INFO conf.FlumeConfiguration: Processing:k1 <br>
14/08/10 11:41:45 INFO conf.FlumeConfiguration: Post-validation flume configuration contains configuration for agents: [a1] <br>
14/08/10 11:41:45 INFO node.AbstractConfigurationProvider: Creating channels <br>
14/08/10 11:41:45 INFO channel.DefaultChannelFactory: Creating instance of channel c1 type memory <br>
14/08/10 11:41:45 INFO node.AbstractConfigurationProvider: Created channel c1 <br>
14/08/10 11:41:45 INFO source.DefaultSourceFactory: Creating instance of source r1, type syslogtcp <br>
14/08/10 11:41:45 INFO sink.DefaultSinkFactory: Creating instance of sink: k1, type: logger <br>
14/08/10 11:41:45 INFO node.AbstractConfigurationProvider: Channel c1 connected to [r1, k1] <br>
14/08/10 11:41:45 INFO node.Application: Starting new configuration:{ sourceRunners:{r1=EventDrivenSourceRunner: { source:org.apache.flume.source.SyslogTcpSource{name:r1,state:IDLE} }} sinkRunners:{k1=SinkRunner: { policy:org.apache.flume.sink.DefaultSinkProcessor@6538b14 counterGroup:{ name:null counters:{} } }} channels:{c1=org.apache.flume.channel.MemoryChannel{name: c1}} } <br>
14/08/10 11:41:45 INFO node.Application: Starting Channel c1 <br>
14/08/10 11:41:45 INFO instrumentation.MonitoredCounterGroup: Monitored counter group for type: CHANNEL, name: c1: Successfully registered new MBean. <br>
14/08/10 11:41:45 INFO instrumentation.MonitoredCounterGroup: Component type: CHANNEL, name: c1 started <br>
14/08/10 11:41:45 INFO node.Application: Starting Sink k1 <br>
14/08/10 11:41:45 INFO node.Application: Starting Source r1 <br>
14/08/10 11:41:45 INFO source.SyslogTcpSource: Syslog TCP Source starting… <br>
14/08/10 11:42:15 WARN source.SyslogUtils: Event created from Invalid Syslog data. <br>
14/08/10 11:42:15 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 68 65 6C 6C 6F 20 69 64 6F 61 6C 6C 2E 6F 72 67 hello idoall.org } <br>
复制代码</p>

<p>　　　　5)案例5：JSONHandler <br>
　　　　　　a)创建agent配置文件</p>

<p>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/post_json.conf</p>

<p>a1.sources = r1 <br>
a1.sinks = k1 <br>
a1.channels = c1</p>



<h1 id="describeconfigure-the-source-4">Describe/configure the source</h1>

<p>a1.sources.r1.type = org.apache.flume.source.http.HTTPSource <br>
a1.sources.r1.port = 8888 <br>
a1.sources.r1.channels = c1</p>



<h1 id="describe-the-sink-4">Describe the sink</h1>

<p>a1.sinks.k1.type = logger</p>



<h1 id="use-a-channel-which-buffers-events-in-memory-4">Use a channel which buffers events in memory</h1>

<p>a1.channels.c1.type = memory <br>
a1.channels.c1.capacity = 1000 <br>
a1.channels.c1.transactionCapacity = 100</p>



<h1 id="bind-the-source-and-sink-to-the-channel-4">Bind the source and sink to the channel</h1>

<p>a1.sources.r1.channels = c1 <br>
a1.sinks.k1.channel = c1 <br>
复制代码</p>

<p>　　　　　　b)启动flume agent a1</p>

<p>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/post_json.conf -n a1 -Dflume.root.logger=INFO,console <br>
复制代码</p>

<p>　　　　　　c)生成JSON 格式的POST request</p>

<p>root@m1:/home/hadoop# curl -X POST -d ‘[{ “headers” :{“a” : “a1”,”b” : “b1”},”body” : “idoall.org_body”}]’ <a href="http://localhost:8888" rel="nofollow">http://localhost:8888</a> <br>
复制代码</p>

<p>　　　　　　d)在m1的控制台，可以看到以下信息：</p>

<p>14/08/10 11:49:59 INFO node.Application: Starting Channel c1 <br>
14/08/10 11:49:59 INFO instrumentation.MonitoredCounterGroup: Monitored counter group for type: CHANNEL, name: c1: Successfully registered new MBean. <br>
14/08/10 11:49:59 INFO instrumentation.MonitoredCounterGroup: Component type: CHANNEL, name: c1 started <br>
14/08/10 11:49:59 INFO node.Application: Starting Sink k1 <br>
14/08/10 11:49:59 INFO node.Application: Starting Source r1 <br>
14/08/10 11:49:59 INFO mortbay.log: Logging to org.slf4j.impl.Log4jLoggerAdapter(org.mortbay.log) via org.mortbay.log.Slf4jLog <br>
14/08/10 11:49:59 INFO mortbay.log: jetty-6.1.26 <br>
14/08/10 11:50:00 INFO mortbay.log: Started SelectChannelConnector@0.0.0.0:8888 <br>
14/08/10 11:50:00 INFO instrumentation.MonitoredCounterGroup: Monitored counter group for type: SOURCE, name: r1: Successfully registered new MBean. <br>
14/08/10 11:50:00 INFO instrumentation.MonitoredCounterGroup: Component type: SOURCE, name: r1 started <br>
14/08/10 12:14:32 INFO sink.LoggerSink: Event: { headers:{b=b1, a=a1} body: 69 64 6F 61 6C 6C 2E 6F 72 67 5F 62 6F 64 79    idoall.org_body } <br>
复制代码</p>

<p>　　　　6)案例6：Hadoop sink <br>
　　　　　　a)创建agent配置文件</p>

<p>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/hdfs_sink.conf</p>

<p>a1.sources = r1 <br>
a1.sinks = k1 <br>
a1.channels = c1</p>



<h1 id="describeconfigure-the-source-5">Describe/configure the source</h1>

<p>a1.sources.r1.type = syslogtcp <br>
a1.sources.r1.port = 5140 <br>
a1.sources.r1.host = localhost <br>
a1.sources.r1.channels = c1</p>



<h1 id="describe-the-sink-5">Describe the sink</h1>

<p>a1.sinks.k1.type = hdfs <br>
a1.sinks.k1.channel = c1 <br>
a1.sinks.k1.hdfs.path = hdfs://m1:9000/user/flume/syslogtcp <br>
a1.sinks.k1.hdfs.filePrefix = Syslog <br>
a1.sinks.k1.hdfs.round = true <br>
a1.sinks.k1.hdfs.roundValue = 10 <br>
a1.sinks.k1.hdfs.roundUnit = minute</p>



<h1 id="use-a-channel-which-buffers-events-in-memory-5">Use a channel which buffers events in memory</h1>

<p>a1.channels.c1.type = memory <br>
a1.channels.c1.capacity = 1000 <br>
a1.channels.c1.transactionCapacity = 100</p>



<h1 id="bind-the-source-and-sink-to-the-channel-5">Bind the source and sink to the channel</h1>

<p>a1.sources.r1.channels = c1 <br>
a1.sinks.k1.channel = c1 <br>
复制代码</p>

<p>　　　　　　b)启动flume agent a1</p>

<p>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/hdfs_sink.conf -n a1 -Dflume.root.logger=INFO,console <br>
复制代码</p>

<p>　　　　　　c)测试产生syslog</p>

<p>root@m1:/home/hadoop# echo “hello idoall flume -&gt; hadoop testing one” | nc localhost 5140 <br>
复制代码</p>

<p>　　　　　　d)在m1的控制台，可以看到以下信息：</p>

<p>14/08/10 12:20:39 INFO instrumentation.MonitoredCounterGroup: Monitored counter group for type: CHANNEL, name: c1: Successfully registered new MBean. <br>
14/08/10 12:20:39 INFO instrumentation.MonitoredCounterGroup: Component type: CHANNEL, name: c1 started <br>
14/08/10 12:20:39 INFO node.Application: Starting Sink k1 <br>
14/08/10 12:20:39 INFO node.Application: Starting Source r1 <br>
14/08/10 12:20:39 INFO instrumentation.MonitoredCounterGroup: Monitored counter group for type: SINK, name: k1: Successfully registered new MBean. <br>
14/08/10 12:20:39 INFO instrumentation.MonitoredCounterGroup: Component type: SINK, name: k1 started <br>
14/08/10 12:20:39 INFO source.SyslogTcpSource: Syslog TCP Source starting… <br>
14/08/10 12:21:46 WARN source.SyslogUtils: Event created from Invalid Syslog data. <br>
14/08/10 12:21:49 INFO hdfs.HDFSSequenceFile: writeFormat = Writable, UseRawLocalFileSystem = false <br>
14/08/10 12:21:49 INFO hdfs.BucketWriter: Creating hdfs://m1:9000/user/flume/syslogtcp//Syslog.1407644509504.tmp <br>
14/08/10 12:22:20 INFO hdfs.BucketWriter: Closing hdfs://m1:9000/user/flume/syslogtcp//Syslog.1407644509504.tmp <br>
14/08/10 12:22:20 INFO hdfs.BucketWriter: Close tries incremented <br>
14/08/10 12:22:20 INFO hdfs.BucketWriter: Renaming hdfs://m1:9000/user/flume/syslogtcp/Syslog.1407644509504.tmp to hdfs://m1:9000/user/flume/syslogtcp/Syslog.1407644509504 <br>
14/08/10 12:22:20 INFO hdfs.HDFSEventSink: Writer callback called. <br>
复制代码</p>

<p>　　　　　　e)在m1上再打开一个窗口，去hadoop上检查文件是否生成</p>

<p>root@m1:/home/hadoop# /home/hadoop/hadoop-2.2.0/bin/hadoop fs -ls /user/flume/syslogtcp <br>
Found 1 items <br>
-rw-r–r–   3 root supergroup        155 2014-08-10 12:22 /user/flume/syslogtcp/Syslog.1407644509504 <br>
root@m1:/home/hadoop# /home/hadoop/hadoop-2.2.0/bin/hadoop fs -cat /user/flume/syslogtcp/Syslog.1407644509504 <br>
SEQ!org.apache.hadoop.io.LongWritable”org.apache.hadoop.io.BytesWritable^;&gt;Gv$hello idoall flume -&gt; hadoop testing one <br>
复制代码</p>

<p>　　　　7)案例7：File Roll Sink <br>
　　　　　　a)创建agent配置文件</p>

<p>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/file_roll.conf</p>

<p>a1.sources = r1 <br>
a1.sinks = k1 <br>
a1.channels = c1</p>



<h1 id="describeconfigure-the-source-6">Describe/configure the source</h1>

<p>a1.sources.r1.type = syslogtcp <br>
a1.sources.r1.port = 5555 <br>
a1.sources.r1.host = localhost <br>
a1.sources.r1.channels = c1</p>



<h1 id="describe-the-sink-6">Describe the sink</h1>

<p>a1.sinks.k1.type = file_roll <br>
a1.sinks.k1.sink.directory = /home/hadoop/flume-1.5.0-bin/logs</p>



<h1 id="use-a-channel-which-buffers-events-in-memory-6">Use a channel which buffers events in memory</h1>

<p>a1.channels.c1.type = memory <br>
a1.channels.c1.capacity = 1000 <br>
a1.channels.c1.transactionCapacity = 100</p>



<h1 id="bind-the-source-and-sink-to-the-channel-6">Bind the source and sink to the channel</h1>

<p>a1.sources.r1.channels = c1 <br>
a1.sinks.k1.channel = c1 <br>
复制代码</p>

<p>　　　　　　b)启动flume agent a1</p>

<p>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/file_roll.conf -n a1 -Dflume.root.logger=INFO,console <br>
复制代码</p>

<p>　　　　　　c)测试产生log</p>

<p>root@m1:/home/hadoop# echo “hello idoall.org syslog” | nc localhost 5555 <br>
root@m1:/home/hadoop# echo “hello idoall.org syslog 2” | nc localhost 5555 <br>
复制代码</p>

<p>　　　　　　d)查看/home/hadoop/flume-1.5.0-bin/logs下是否生成文件,默认每30秒生成一个新文件</p>

<p>root@m1:/home/hadoop# ll /home/hadoop/flume-1.5.0-bin/logs <br>
总用量 272 <br>
drwxr-xr-x 3 root root   4096 Aug 10 12:50 ./ <br>
drwxr-xr-x 9 root root   4096 Aug 10 10:59 ../ <br>
-rw-r–r– 1 root root     50 Aug 10 12:49 1407646164782-1 <br>
-rw-r–r– 1 root root      0 Aug 10 12:49 1407646164782-2 <br>
-rw-r–r– 1 root root      0 Aug 10 12:50 1407646164782-3 <br>
root@m1:/home/hadoop# cat /home/hadoop/flume-1.5.0-bin/logs/1407646164782-1 /home/hadoop/flume-1.5.0-bin/logs/1407646164782-2 <br>
hello idoall.org syslog <br>
hello idoall.org syslog 2 <br>
复制代码</p>

<p>　　　　8)案例8：Replicating Channel Selector <br>
　　　　Flume支持Fan out流从一个源到多个通道。有两种模式的Fan out，分别是复制和复用。在复制的情况下，流的事件被发送到所有的配置通道。在复用的情况下，事件被发送到可用的渠道中的一个子集。Fan out流需要指定源和Fan out通道的规则。</p>

<p>　　　　这次我们需要用到m1,m2两台机器</p>

<p>　　　　　　a)在m1创建replicating_Channel_Selector配置文件 <br>
root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/replicating_Channel_Selector.conf</p>

<p>a1.sources = r1 <br>
a1.sinks = k1 k2 <br>
a1.channels = c1 c2</p>



<h1 id="describeconfigure-the-source-7">Describe/configure the source</h1>

<p>a1.sources.r1.type = syslogtcp <br>
a1.sources.r1.port = 5140 <br>
a1.sources.r1.host = localhost <br>
a1.sources.r1.channels = c1 c2 <br>
a1.sources.r1.selector.type = replicating</p>



<h1 id="describe-the-sink-7">Describe the sink</h1>

<p>a1.sinks.k1.type = avro <br>
a1.sinks.k1.channel = c1 <br>
a1.sinks.k1.hostname = m1 <br>
a1.sinks.k1.port = 5555</p>

<p>a1.sinks.k2.type = avro <br>
a1.sinks.k2.channel = c2 <br>
a1.sinks.k2.hostname = m2 <br>
a1.sinks.k2.port = 5555</p>



<h1 id="use-a-channel-which-buffers-events-in-memory-7">Use a channel which buffers events in memory</h1>

<p>a1.channels.c1.type = memory <br>
a1.channels.c1.capacity = 1000 <br>
a1.channels.c1.transactionCapacity = 100</p>

<p>a1.channels.c2.type = memory <br>
a1.channels.c2.capacity = 1000 <br>
a1.channels.c2.transactionCapacity = 100 <br>
复制代码</p>

<p>　　　　　　b)在m1创建replicating_Channel_Selector_avro配置文件 <br>
root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/replicating_Channel_Selector_avro.conf</p>

<p>a1.sources = r1 <br>
a1.sinks = k1 <br>
a1.channels = c1</p>



<h1 id="describeconfigure-the-source-8">Describe/configure the source</h1>

<p>a1.sources.r1.type = avro <br>
a1.sources.r1.channels = c1 <br>
a1.sources.r1.bind = 0.0.0.0 <br>
a1.sources.r1.port = 5555</p>



<h1 id="describe-the-sink-8">Describe the sink</h1>

<p>a1.sinks.k1.type = logger</p>



<h1 id="use-a-channel-which-buffers-events-in-memory-8">Use a channel which buffers events in memory</h1>

<p>a1.channels.c1.type = memory <br>
a1.channels.c1.capacity = 1000 <br>
a1.channels.c1.transactionCapacity = 100</p>



<h1 id="bind-the-source-and-sink-to-the-channel-7">Bind the source and sink to the channel</h1>

<p>a1.sources.r1.channels = c1 <br>
a1.sinks.k1.channel = c1 <br>
复制代码</p>

<p>　　　　　　c)在m1上将2个配置文件复制到m2上一份 <br>
root@m1:/home/hadoop/flume-1.5.0-bin# scp -r /home/hadoop/flume-1.5.0-bin/conf/replicating_Channel_Selector.conf root@m2:/home/hadoop/flume-1.5.0-bin/conf/replicating_Channel_Selector.conf <br>
root@m1:/home/hadoop/flume-1.5.0-bin# scp -r /home/hadoop/flume-1.5.0-bin/conf/replicating_Channel_Selector_avro.conf root@m2:/home/hadoop/flume-1.5.0-bin/conf/replicating_Channel_Selector_avro.conf <br>
复制代码 <br>
　　　　　　d)打开4个窗口，在m1和m2上同时启动两个flume agent <br>
root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/replicating_Channel_Selector_avro.conf -n a1 -Dflume.root.logger=INFO,console <br>
root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/replicating_Channel_Selector.conf -n a1 -Dflume.root.logger=INFO,console <br>
复制代码</p>

<p>　　　　　　e)然后在m1或m2的任意一台机器上，测试产生syslog <br>
root@m1:/home/hadoop# echo “hello idoall.org syslog” | nc localhost 5140 <br>
复制代码</p>

<p>　　　　　　f)在m1和m2的sink窗口，分别可以看到以下信息,这说明信息得到了同步： <br>
14/08/10 14:08:18 INFO ipc.NettyServer: Connection to /192.168.1.51:46844 disconnected. <br>
14/08/10 14:08:52 INFO ipc.NettyServer: [id: 0x90f8fe1f, /192.168.1.50:35873 =&gt; /192.168.1.50:5555] OPEN <br>
14/08/10 14:08:52 INFO ipc.NettyServer: [id: 0x90f8fe1f, /192.168.1.50:35873 =&gt; /192.168.1.50:5555] BOUND: /192.168.1.50:5555 <br>
14/08/10 14:08:52 INFO ipc.NettyServer: [id: 0x90f8fe1f, /192.168.1.50:35873 =&gt; /192.168.1.50:5555] CONNECTED: /192.168.1.50:35873 <br>
14/08/10 14:08:59 INFO ipc.NettyServer: [id: 0xd6318635, /192.168.1.51:46858 =&gt; /192.168.1.50:5555] OPEN <br>
14/08/10 14:08:59 INFO ipc.NettyServer: [id: 0xd6318635, /192.168.1.51:46858 =&gt; /192.168.1.50:5555] BOUND: /192.168.1.50:5555 <br>
14/08/10 14:08:59 INFO ipc.NettyServer: [id: 0xd6318635, /192.168.1.51:46858 =&gt; /192.168.1.50:5555] CONNECTED: /192.168.1.51:46858 <br>
14/08/10 14:09:20 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 68 65 6C 6C 6F 20 69 64 6F 61 6C 6C 2E 6F 72 67 hello idoall.org } <br>
复制代码</p>

<p>　　　　9)案例9：Multiplexing Channel Selector <br>
　　　　　　a)在m1创建Multiplexing_Channel_Selector配置文件</p>

<p>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/Multiplexing_Channel_Selector.conf</p>

<p>a1.sources = r1 <br>
a1.sinks = k1 k2 <br>
a1.channels = c1 c2</p>



<h1 id="describeconfigure-the-source-9">Describe/configure the source</h1>

<p>a1.sources.r1.type = org.apache.flume.source.http.HTTPSource <br>
a1.sources.r1.port = 5140 <br>
a1.sources.r1.channels = c1 c2 <br>
a1.sources.r1.selector.type = multiplexing</p>

<p>a1.sources.r1.selector.header = type</p>



<h1 id="映射允许每个值通道可以重叠默认值可以包含任意数量的通道">映射允许每个值通道可以重叠。默认值可以包含任意数量的通道。</h1>

<p>a1.sources.r1.selector.mapping.baidu = c1 <br>
a1.sources.r1.selector.mapping.ali = c2 <br>
a1.sources.r1.selector.default = c1</p>



<h1 id="describe-the-sink-9">Describe the sink</h1>

<p>a1.sinks.k1.type = avro <br>
a1.sinks.k1.channel = c1 <br>
a1.sinks.k1.hostname = m1 <br>
a1.sinks.k1.port = 5555</p>

<p>a1.sinks.k2.type = avro <br>
a1.sinks.k2.channel = c2 <br>
a1.sinks.k2.hostname = m2 <br>
a1.sinks.k2.port = 5555</p>



<h1 id="use-a-channel-which-buffers-events-in-memory-9">Use a channel which buffers events in memory</h1>

<p>a1.channels.c1.type = memory <br>
a1.channels.c1.capacity = 1000 <br>
a1.channels.c1.transactionCapacity = 100</p>

<p>a1.channels.c2.type = memory <br>
a1.channels.c2.capacity = 1000 <br>
a1.channels.c2.transactionCapacity = 100 <br>
复制代码</p>

<p>　　　　　　b)在m1创建Multiplexing_Channel_Selector_avro配置文件 <br>
root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/Multiplexing_Channel_Selector_avro.conf</p>

<p>a1.sources = r1 <br>
a1.sinks = k1 <br>
a1.channels = c1</p>



<h1 id="describeconfigure-the-source-10">Describe/configure the source</h1>

<p>a1.sources.r1.type = avro <br>
a1.sources.r1.channels = c1 <br>
a1.sources.r1.bind = 0.0.0.0 <br>
a1.sources.r1.port = 5555</p>



<h1 id="describe-the-sink-10">Describe the sink</h1>

<p>a1.sinks.k1.type = logger</p>



<h1 id="use-a-channel-which-buffers-events-in-memory-10">Use a channel which buffers events in memory</h1>

<p>a1.channels.c1.type = memory <br>
a1.channels.c1.capacity = 1000 <br>
a1.channels.c1.transactionCapacity = 100</p>



<h1 id="bind-the-source-and-sink-to-the-channel-8">Bind the source and sink to the channel</h1>

<p>a1.sources.r1.channels = c1 <br>
a1.sinks.k1.channel = c1 <br>
复制代码</p>

<p>　　　　　　c)将2个配置文件复制到m2上一份 <br>
root@m1:/home/hadoop/flume-1.5.0-bin# scp -r /home/hadoop/flume-1.5.0-bin/conf/Multiplexing_Channel_Selector.conf  root@m2:/home/hadoop/flume-1.5.0-bin/conf/Multiplexing_Channel_Selector.conf <br>
root@m1:/home/hadoop/flume-1.5.0-bin# scp -r /home/hadoop/flume-1.5.0-bin/conf/Multiplexing_Channel_Selector_avro.conf root@m2:/home/hadoop/flume-1.5.0-bin/conf/Multiplexing_Channel_Selector_avro.conf <br>
复制代码</p>

<p>　　　　　　d)打开4个窗口，在m1和m2上同时启动两个flume agent <br>
root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/Multiplexing_Channel_Selector_avro.conf -n a1 -Dflume.root.logger=INFO,console <br>
root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/Multiplexing_Channel_Selector.conf -n a1 -Dflume.root.logger=INFO,console <br>
复制代码</p>

<p>　　　　　　e)然后在m1或m2的任意一台机器上，测试产生syslog <br>
root@m1:/home/hadoop# curl -X POST -d ‘[{ “headers” :{“type” : “baidu”},”body” : “idoall_TEST1”}]’ <a href="http://localhost:5140" rel="nofollow">http://localhost:5140</a> &amp;&amp; curl -X POST -d ‘[{ “headers” :{“type” : “ali”},”body” : “idoall_TEST2”}]’ <a href="http://localhost:5140" rel="nofollow">http://localhost:5140</a> &amp;&amp; curl -X POST -d ‘[{ “headers” :{“type” : “qq”},”body” : “idoall_TEST3”}]’ <a href="http://localhost:5140" rel="nofollow">http://localhost:5140</a> <br>
复制代码</p>

<p>　　　　　f)在m1的sink窗口，可以看到以下信息： <br>
14/08/10 14:32:21 INFO node.Application: Starting Sink k1 <br>
14/08/10 14:32:21 INFO node.Application: Starting Source r1 <br>
14/08/10 14:32:21 INFO source.AvroSource: Starting Avro source r1: { bindAddress: 0.0.0.0, port: 5555 }… <br>
14/08/10 14:32:21 INFO instrumentation.MonitoredCounterGroup: Monitored counter group for type: SOURCE, name: r1: Successfully registered new MBean. <br>
14/08/10 14:32:21 INFO instrumentation.MonitoredCounterGroup: Component type: SOURCE, name: r1 started <br>
14/08/10 14:32:21 INFO source.AvroSource: Avro source r1 started. <br>
14/08/10 14:32:36 INFO ipc.NettyServer: [id: 0xcf00eea6, /192.168.1.50:35916 =&gt; /192.168.1.50:5555] OPEN <br>
14/08/10 14:32:36 INFO ipc.NettyServer: [id: 0xcf00eea6, /192.168.1.50:35916 =&gt; /192.168.1.50:5555] BOUND: /192.168.1.50:5555 <br>
14/08/10 14:32:36 INFO ipc.NettyServer: [id: 0xcf00eea6, /192.168.1.50:35916 =&gt; /192.168.1.50:5555] CONNECTED: /192.168.1.50:35916 <br>
14/08/10 14:32:44 INFO ipc.NettyServer: [id: 0x432f5468, /192.168.1.51:46945 =&gt; /192.168.1.50:5555] OPEN <br>
14/08/10 14:32:44 INFO ipc.NettyServer: [id: 0x432f5468, /192.168.1.51:46945 =&gt; /192.168.1.50:5555] BOUND: /192.168.1.50:5555 <br>
14/08/10 14:32:44 INFO ipc.NettyServer: [id: 0x432f5468, /192.168.1.51:46945 =&gt; /192.168.1.50:5555] CONNECTED: /192.168.1.51:46945 <br>
14/08/10 14:34:11 INFO sink.LoggerSink: Event: { headers:{type=baidu} body: 69 64 6F 61 6C 6C 5F 54 45 53 54 31             idoall_TEST1 } <br>
14/08/10 14:34:57 INFO sink.LoggerSink: Event: { headers:{type=qq} body: 69 64 6F 61 6C 6C 5F 54 45 53 54 33             idoall_TEST3 } <br>
复制代码</p>

<p>　　　　　g)在m2的sink窗口，可以看到以下信息：</p>

<p>14/08/10 14:32:27 INFO node.Application: Starting Sink k1 <br>
14/08/10 14:32:27 INFO node.Application: Starting Source r1 <br>
14/08/10 14:32:27 INFO source.AvroSource: Starting Avro source r1: { bindAddress: 0.0.0.0, port: 5555 }… <br>
14/08/10 14:32:27 INFO instrumentation.MonitoredCounterGroup: Monitored counter group for type: SOURCE, name: r1: Successfully registered new MBean. <br>
14/08/10 14:32:27 INFO instrumentation.MonitoredCounterGroup: Component type: SOURCE, name: r1 started <br>
14/08/10 14:32:27 INFO source.AvroSource: Avro source r1 started. <br>
14/08/10 14:32:36 INFO ipc.NettyServer: [id: 0x7c2f0aec, /192.168.1.50:38104 =&gt; /192.168.1.51:5555] OPEN <br>
14/08/10 14:32:36 INFO ipc.NettyServer: [id: 0x7c2f0aec, /192.168.1.50:38104 =&gt; /192.168.1.51:5555] BOUND: /192.168.1.51:5555 <br>
14/08/10 14:32:36 INFO ipc.NettyServer: [id: 0x7c2f0aec, /192.168.1.50:38104 =&gt; /192.168.1.51:5555] CONNECTED: /192.168.1.50:38104 <br>
14/08/10 14:32:44 INFO ipc.NettyServer: [id: 0x3d36f553, /192.168.1.51:48599 =&gt; /192.168.1.51:5555] OPEN <br>
14/08/10 14:32:44 INFO ipc.NettyServer: [id: 0x3d36f553, /192.168.1.51:48599 =&gt; /192.168.1.51:5555] BOUND: /192.168.1.51:5555 <br>
14/08/10 14:32:44 INFO ipc.NettyServer: [id: 0x3d36f553, /192.168.1.51:48599 =&gt; /192.168.1.51:5555] CONNECTED: /192.168.1.51:48599 <br>
14/08/10 14:34:33 INFO sink.LoggerSink: Event: { headers:{type=ali} body: 69 64 6F 61 6C 6C 5F 54 45 53 54 32             idoall_TEST2 } <br>
复制代码</p>

<p>　　　　可以看到，根据header中不同的条件分布到不同的channel上</p>

<p>　　　　10)案例10：Flume Sink Processors <br>
　　　　failover的机器是一直发送给其中一个sink，当这个sink不可用的时候，自动发送到下一个sink。</p>

<p>　　　　　　a)在m1创建Flume_Sink_Processors配置文件</p>

<p>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/Flume_Sink_Processors.conf</p>

<p>a1.sources = r1 <br>
a1.sinks = k1 k2 <br>
a1.channels = c1 c2</p>



<h1 id="这个是配置failover的关键需要有一个sink-group">这个是配置failover的关键，需要有一个sink group</h1>

<p>a1.sinkgroups = g1 <br>
a1.sinkgroups.g1.sinks = k1 k2</p>



<h1 id="处理的类型是failover">处理的类型是failover</h1>

<p>a1.sinkgroups.g1.processor.type = failover</p>



<h1 id="优先级数字越大优先级越高每个sink的优先级必须不相同">优先级，数字越大优先级越高，每个sink的优先级必须不相同</h1>

<p>a1.sinkgroups.g1.processor.priority.k1 = 5 <br>
a1.sinkgroups.g1.processor.priority.k2 = 10</p>



<h1 id="设置为10秒当然可以根据你的实际状况更改成更快或者很慢">设置为10秒，当然可以根据你的实际状况更改成更快或者很慢</h1>

<p>a1.sinkgroups.g1.processor.maxpenalty = 10000</p>



<h1 id="describeconfigure-the-source-11">Describe/configure the source</h1>

<p>a1.sources.r1.type = syslogtcp <br>
a1.sources.r1.port = 5140 <br>
a1.sources.r1.channels = c1 c2 <br>
a1.sources.r1.selector.type = replicating</p>



<h1 id="describe-the-sink-11">Describe the sink</h1>

<p>a1.sinks.k1.type = avro <br>
a1.sinks.k1.channel = c1 <br>
a1.sinks.k1.hostname = m1 <br>
a1.sinks.k1.port = 5555</p>

<p>a1.sinks.k2.type = avro <br>
a1.sinks.k2.channel = c2 <br>
a1.sinks.k2.hostname = m2 <br>
a1.sinks.k2.port = 5555</p>



<h1 id="use-a-channel-which-buffers-events-in-memory-11">Use a channel which buffers events in memory</h1>

<p>a1.channels.c1.type = memory <br>
a1.channels.c1.capacity = 1000 <br>
a1.channels.c1.transactionCapacity = 100</p>

<p>a1.channels.c2.type = memory <br>
a1.channels.c2.capacity = 1000 <br>
a1.channels.c2.transactionCapacity = 100 <br>
复制代码</p>

<p>　　　　　　b)在m1创建Flume_Sink_Processors_avro配置文件 <br>
root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/Flume_Sink_Processors_avro.conf</p>

<p>a1.sources = r1 <br>
a1.sinks = k1 <br>
a1.channels = c1</p>



<h1 id="describeconfigure-the-source-12">Describe/configure the source</h1>

<p>a1.sources.r1.type = avro <br>
a1.sources.r1.channels = c1 <br>
a1.sources.r1.bind = 0.0.0.0 <br>
a1.sources.r1.port = 5555</p>



<h1 id="describe-the-sink-12">Describe the sink</h1>

<p>a1.sinks.k1.type = logger</p>



<h1 id="use-a-channel-which-buffers-events-in-memory-12">Use a channel which buffers events in memory</h1>

<p>a1.channels.c1.type = memory <br>
a1.channels.c1.capacity = 1000 <br>
a1.channels.c1.transactionCapacity = 100</p>



<h1 id="bind-the-source-and-sink-to-the-channel-9">Bind the source and sink to the channel</h1>

<p>a1.sources.r1.channels = c1 <br>
a1.sinks.k1.channel = c1 <br>
复制代码</p>

<p>　　　　　　c)将2个配置文件复制到m2上一份 <br>
root@m1:/home/hadoop/flume-1.5.0-bin# scp -r /home/hadoop/flume-1.5.0-bin/conf/Flume_Sink_Processors.conf  root@m2:/home/hadoop/flume-1.5.0-bin/conf/Flume_Sink_Processors.conf <br>
root@m1:/home/hadoop/flume-1.5.0-bin# scp -r /home/hadoop/flume-1.5.0-bin/conf/Flume_Sink_Processors_avro.conf root@m2:/home/hadoop/flume-1.5.0-bin/conf/Flume_Sink_Processors_avro.conf <br>
复制代码</p>

<p>　　　　　　d)打开4个窗口，在m1和m2上同时启动两个flume agent <br>
root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/Flume_Sink_Processors_avro.conf -n a1 -Dflume.root.logger=INFO,console <br>
root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/Flume_Sink_Processors.conf -n a1 -Dflume.root.logger=INFO,console <br>
复制代码</p>

<p>　　　　　　e)然后在m1或m2的任意一台机器上，测试产生log <br>
root@m1:/home/hadoop# echo “idoall.org test1 failover” | nc localhost 5140 <br>
复制代码</p>

<p>　　　　　　f)因为m2的优先级高，所以在m2的sink窗口，可以看到以下信息，而m1没有： <br>
14/08/10 15:02:46 INFO ipc.NettyServer: Connection to /192.168.1.51:48692 disconnected. <br>
14/08/10 15:03:12 INFO ipc.NettyServer: [id: 0x09a14036, /192.168.1.51:48704 =&gt; /192.168.1.51:5555] OPEN <br>
14/08/10 15:03:12 INFO ipc.NettyServer: [id: 0x09a14036, /192.168.1.51:48704 =&gt; /192.168.1.51:5555] BOUND: /192.168.1.51:5555 <br>
14/08/10 15:03:12 INFO ipc.NettyServer: [id: 0x09a14036, /192.168.1.51:48704 =&gt; /192.168.1.51:5555] CONNECTED: /192.168.1.51:48704 <br>
14/08/10 15:03:26 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 69 64 6F 61 6C 6C 2E 6F 72 67 20 74 65 73 74 31 idoall.org test1 } <br>
复制代码</p>

<p>　　　　　　g)这时我们停止掉m2机器上的sink(ctrl+c)，再次输出测试数据： <br>
root@m1:/home/hadoop# echo “idoall.org test2 failover” | nc localhost 5140 <br>
复制代码</p>

<p>　　　　　　h)可以在m1的sink窗口，看到读取到了刚才发送的两条测试数据： <br>
14/08/10 15:02:46 INFO ipc.NettyServer: Connection to /192.168.1.51:47036 disconnected. <br>
14/08/10 15:03:12 INFO ipc.NettyServer: [id: 0xbcf79851, /192.168.1.51:47048 =&gt; /192.168.1.50:5555] OPEN <br>
14/08/10 15:03:12 INFO ipc.NettyServer: [id: 0xbcf79851, /192.168.1.51:47048 =&gt; /192.168.1.50:5555] BOUND: /192.168.1.50:5555 <br>
14/08/10 15:03:12 INFO ipc.NettyServer: [id: 0xbcf79851, /192.168.1.51:47048 =&gt; /192.168.1.50:5555] CONNECTED: /192.168.1.51:47048 <br>
14/08/10 15:07:56 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 69 64 6F 61 6C 6C 2E 6F 72 67 20 74 65 73 74 31 idoall.org test1 } <br>
14/08/10 15:07:56 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 69 64 6F 61 6C 6C 2E 6F 72 67 20 74 65 73 74 32 idoall.org test2 } <br>
复制代码</p>

<p>　　　　　　i)我们再在m2的sink窗口中，启动sink： <br>
root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/Flume_Sink_Processors_avro.conf -n a1 -Dflume.root.logger=INFO,console <br>
复制代码</p>

<p>　　　　　　j)输入两批测试数据： <br>
root@m1:/home/hadoop# echo “idoall.org test3 failover” | nc localhost 5140 &amp;&amp; echo “idoall.org test4 failover” | nc localhost 5140 <br>
复制代码</p>

<p>　　　　　k)在m2的sink窗口，我们可以看到以下信息，因为优先级的关系，log消息会再次落到m2上： <br>
14/08/10 15:09:47 INFO node.Application: Starting Sink k1 <br>
14/08/10 15:09:47 INFO node.Application: Starting Source r1 <br>
14/08/10 15:09:47 INFO source.AvroSource: Starting Avro source r1: { bindAddress: 0.0.0.0, port: 5555 }… <br>
14/08/10 15:09:47 INFO instrumentation.MonitoredCounterGroup: Monitored counter group for type: SOURCE, name: r1: Successfully registered new MBean. <br>
14/08/10 15:09:47 INFO instrumentation.MonitoredCounterGroup: Component type: SOURCE, name: r1 started <br>
14/08/10 15:09:47 INFO source.AvroSource: Avro source r1 started. <br>
14/08/10 15:09:54 INFO ipc.NettyServer: [id: 0x96615732, /192.168.1.51:48741 =&gt; /192.168.1.51:5555] OPEN <br>
14/08/10 15:09:54 INFO ipc.NettyServer: [id: 0x96615732, /192.168.1.51:48741 =&gt; /192.168.1.51:5555] BOUND: /192.168.1.51:5555 <br>
14/08/10 15:09:54 INFO ipc.NettyServer: [id: 0x96615732, /192.168.1.51:48741 =&gt; /192.168.1.51:5555] CONNECTED: /192.168.1.51:48741 <br>
14/08/10 15:09:57 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 69 64 6F 61 6C 6C 2E 6F 72 67 20 74 65 73 74 32 idoall.org test2 } <br>
14/08/10 15:10:43 INFO ipc.NettyServer: [id: 0x12621f9a, /192.168.1.50:38166 =&gt; /192.168.1.51:5555] OPEN <br>
14/08/10 15:10:43 INFO ipc.NettyServer: [id: 0x12621f9a, /192.168.1.50:38166 =&gt; /192.168.1.51:5555] BOUND: /192.168.1.51:5555 <br>
14/08/10 15:10:43 INFO ipc.NettyServer: [id: 0x12621f9a, /192.168.1.50:38166 =&gt; /192.168.1.51:5555] CONNECTED: /192.168.1.50:38166 <br>
14/08/10 15:10:43 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 69 64 6F 61 6C 6C 2E 6F 72 67 20 74 65 73 74 33 idoall.org test3 } <br>
14/08/10 15:10:43 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 69 64 6F 61 6C 6C 2E 6F 72 67 20 74 65 73 74 34 idoall.org test4 } <br>
复制代码</p>

<p>　　　　11)案例11：Load balancing Sink Processor <br>
　　　　load balance type和failover不同的地方是，load balance有两个配置，一个是轮询，一个是随机。两种情况下如果被选择的sink不可用，就会自动尝试发送到下一个可用的sink上面。</p>

<p>　　　　　　a)在m1创建Load_balancing_Sink_Processors配置文件</p>

<p>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/Load_balancing_Sink_Processors.conf</p>

<p>a1.sources = r1 <br>
a1.sinks = k1 k2 <br>
a1.channels = c1</p>



<h1 id="这个是配置load-balancing的关键需要有一个sink-group">这个是配置Load balancing的关键，需要有一个sink group</h1>

<p>a1.sinkgroups = g1 <br>
a1.sinkgroups.g1.sinks = k1 k2 <br>
a1.sinkgroups.g1.processor.type = load_balance <br>
a1.sinkgroups.g1.processor.backoff = true <br>
a1.sinkgroups.g1.processor.selector = round_robin</p>



<h1 id="describeconfigure-the-source-13">Describe/configure the source</h1>

<p>a1.sources.r1.type = syslogtcp <br>
a1.sources.r1.port = 5140 <br>
a1.sources.r1.channels = c1</p>



<h1 id="describe-the-sink-13">Describe the sink</h1>

<p>a1.sinks.k1.type = avro <br>
a1.sinks.k1.channel = c1 <br>
a1.sinks.k1.hostname = m1 <br>
a1.sinks.k1.port = 5555</p>

<p>a1.sinks.k2.type = avro <br>
a1.sinks.k2.channel = c1 <br>
a1.sinks.k2.hostname = m2 <br>
a1.sinks.k2.port = 5555</p>



<h1 id="use-a-channel-which-buffers-events-in-memory-13">Use a channel which buffers events in memory</h1>

<p>a1.channels.c1.type = memory <br>
a1.channels.c1.capacity = 1000 <br>
a1.channels.c1.transactionCapacity = 100 <br>
复制代码</p>

<p>　　　　　　b)在m1创建Load_balancing_Sink_Processors_avro配置文件 <br>
root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/Load_balancing_Sink_Processors_avro.conf</p>

<p>a1.sources = r1 <br>
a1.sinks = k1 <br>
a1.channels = c1</p>



<h1 id="describeconfigure-the-source-14">Describe/configure the source</h1>

<p>a1.sources.r1.type = avro <br>
a1.sources.r1.channels = c1 <br>
a1.sources.r1.bind = 0.0.0.0 <br>
a1.sources.r1.port = 5555</p>



<h1 id="describe-the-sink-14">Describe the sink</h1>

<p>a1.sinks.k1.type = logger</p>



<h1 id="use-a-channel-which-buffers-events-in-memory-14">Use a channel which buffers events in memory</h1>

<p>a1.channels.c1.type = memory <br>
a1.channels.c1.capacity = 1000 <br>
a1.channels.c1.transactionCapacity = 100</p>



<h1 id="bind-the-source-and-sink-to-the-channel-10">Bind the source and sink to the channel</h1>

<p>a1.sources.r1.channels = c1 <br>
a1.sinks.k1.channel = c1 <br>
复制代码</p>

<p>　　　　　　c)将2个配置文件复制到m2上一份 <br>
root@m1:/home/hadoop/flume-1.5.0-bin# scp -r /home/hadoop/flume-1.5.0-bin/conf/Load_balancing_Sink_Processors.conf  root@m2:/home/hadoop/flume-1.5.0-bin/conf/Load_balancing_Sink_Processors.conf <br>
root@m1:/home/hadoop/flume-1.5.0-bin# scp -r /home/hadoop/flume-1.5.0-bin/conf/Load_balancing_Sink_Processors_avro.conf root@m2:/home/hadoop/flume-1.5.0-bin/conf/Load_balancing_Sink_Processors_avro.conf <br>
复制代码</p>

<p>　　　　　　d)打开4个窗口，在m1和m2上同时启动两个flume agent</p>

<p>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/Load_balancing_Sink_Processors_avro.conf -n a1 -Dflume.root.logger=INFO,console <br>
root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/Load_balancing_Sink_Processors.conf -n a1 -Dflume.root.logger=INFO,console <br>
复制代码</p>

<p>　　　　　　e)然后在m1或m2的任意一台机器上，测试产生log，一行一行输入，输入太快，容易落到一台机器上 <br>
root@m1:/home/hadoop# echo “idoall.org test1” | nc localhost 5140 <br>
root@m1:/home/hadoop# echo “idoall.org test2” | nc localhost 5140 <br>
root@m1:/home/hadoop# echo “idoall.org test3” | nc localhost 5140 <br>
root@m1:/home/hadoop# echo “idoall.org test4” | nc localhost 5140 <br>
复制代码</p>

<p>　　　　　　f)在m1的sink窗口，可以看到以下信息： <br>
14/08/10 15:35:29 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 69 64 6F 61 6C 6C 2E 6F 72 67 20 74 65 73 74 32 idoall.org test2 } <br>
14/08/10 15:35:33 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 69 64 6F 61 6C 6C 2E 6F 72 67 20 74 65 73 74 34 idoall.org test4 } <br>
复制代码</p>

<p>　　　　　　g)在m2的sink窗口，可以看到以下信息： <br>
14/08/10 15:35:27 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 69 64 6F 61 6C 6C 2E 6F 72 67 20 74 65 73 74 31 idoall.org test1 } <br>
14/08/10 15:35:29 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 69 64 6F 61 6C 6C 2E 6F 72 67 20 74 65 73 74 33 idoall.org test3 } <br>
复制代码</p>

<p>　　　　说明轮询模式起到了作用。</p>

<p>　　　　12)案例12：Hbase sink</p>

<p>　　　　　　a)在测试之前，请先参考《ubuntu12.04+hadoop2.2.0+zookeeper3.4.5+hbase0.96.2+hive0.13.1分布式环境部署》将hbase启动</p>

<p>　　　　　　b)然后将以下文件复制到flume中：</p>

<p>cp /home/hadoop/hbase-0.96.2-hadoop2/lib/protobuf-java-2.5.0.jar /home/hadoop/flume-1.5.0-bin/lib <br>
cp /home/hadoop/hbase-0.96.2-hadoop2/lib/hbase-client-0.96.2-hadoop2.jar /home/hadoop/flume-1.5.0-bin/lib <br>
cp /home/hadoop/hbase-0.96.2-hadoop2/lib/hbase-common-0.96.2-hadoop2.jar /home/hadoop/flume-1.5.0-bin/lib <br>
cp /home/hadoop/hbase-0.96.2-hadoop2/lib/hbase-protocol-0.96.2-hadoop2.jar /home/hadoop/flume-1.5.0-bin/lib <br>
cp /home/hadoop/hbase-0.96.2-hadoop2/lib/hbase-server-0.96.2-hadoop2.jar /home/hadoop/flume-1.5.0-bin/lib <br>
cp /home/hadoop/hbase-0.96.2-hadoop2/lib/hbase-hadoop2-compat-0.96.2-hadoop2.jar /home/hadoop/flume-1.5.0-bin/lib <br>
cp /home/hadoop/hbase-0.96.2-hadoop2/lib/hbase-hadoop-compat-0.96.2-hadoop2.jar /home/hadoop/flume-1.5.0-bin/lib@@@ <br>
cp /home/hadoop/hbase-0.96.2-hadoop2/lib/htrace-core-2.04.jar /home/hadoop/flume-1.5.0-bin/lib <br>
复制代码</p>

<p>　　　　　　c)确保test_idoall_org表在hbase中已经存在</p>

<p>　　　　　　d)在m1创建hbase_simple配置文件 <br>
root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/hbase_simple.conf</p>

<p>a1.sources = r1 <br>
a1.sinks = k1 <br>
a1.channels = c1</p>



<h1 id="describeconfigure-the-source-15">Describe/configure the source</h1>

<p>a1.sources.r1.type = syslogtcp <br>
a1.sources.r1.port = 5140 <br>
a1.sources.r1.host = localhost <br>
a1.sources.r1.channels = c1</p>



<h1 id="describe-the-sink-15">Describe the sink</h1>

<p>a1.sinks.k1.type = logger <br>
a1.sinks.k1.type = hbase <br>
a1.sinks.k1.table = test_idoall_org <br>
a1.sinks.k1.columnFamily = name <br>
a1.sinks.k1.column = idoall <br>
a1.sinks.k1.serializer =  org.apache.flume.sink.hbase.RegexHbaseEventSerializer <br>
a1.sinks.k1.channel = memoryChannel</p>



<h1 id="use-a-channel-which-buffers-events-in-memory-15">Use a channel which buffers events in memory</h1>

<p>a1.channels.c1.type = memory <br>
a1.channels.c1.capacity = 1000 <br>
a1.channels.c1.transactionCapacity = 100</p>



<h1 id="bind-the-source-and-sink-to-the-channel-11">Bind the source and sink to the channel</h1>

<p>a1.sources.r1.channels = c1 <br>
a1.sinks.k1.channel = c1 <br>
复制代码</p>

<p>　　　　　　e)启动flume agent <br>
/home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/hbase_simple.conf -n a1 -Dflume.root.logger=INFO,console <br>
复制代码</p>

<p>　　　　　　f)测试产生syslog <br>
root@m1:/home/hadoop# echo “hello idoall.org from flume” | nc localhost 5140 <br>
复制代码</p>

<p>　　　　　　g)这时登录到hbase中，可以发现新数据已经插入 <br>
root@m1:/home/hadoop# /home/hadoop/hbase-0.96.2-hadoop2/bin/hbase shell <br>
2014-08-10 16:09:48,984 INFO  [main] Configuration.deprecation: hadoop.native.lib is deprecated. Instead, use io.native.lib.available <br>
HBase Shell; enter ‘help’ for list of supported commands. <br>
Type “exit” to leave the HBase Shell <br>
Version 0.96.2-hadoop2, r1581096, Mon Mar 24 16:03:18 PDT 2014</p>

<p>hbase(main):001:0&gt; list <br>
TABLE <br>
SLF4J: Class path contains multiple SLF4J bindings. <br>
SLF4J: Found binding in [jar:file:/home/hadoop/hbase-0.96.2-hadoop2/lib/slf4j-log4j12-1.6.4.jar!/org/slf4j/impl/StaticLoggerBinder.class] <br>
SLF4J: Found binding in [jar:file:/home/hadoop/hadoop-2.2.0/share/hadoop/common/lib/slf4j-log4j12-1.7.5.jar!/org/slf4j/impl/StaticLoggerBinder.class] <br>
SLF4J: See <a href="http://www.slf4j.org/codes.html#multiple_bindings" rel="nofollow">http://www.slf4j.org/codes.html#multiple_bindings</a> for an explanation. <br>
hbase2hive_idoall <br>
hive2hbase_idoall <br>
test_idoall_org <br>
3 row(s) in 2.6880 seconds</p>

<p>=&gt; [“hbase2hive_idoall”, “hive2hbase_idoall”, “test_idoall_org”] <br>
hbase(main):002:0&gt; scan “test_idoall_org” <br>
ROW                                                    COLUMN+CELL <br>
10086                                                 column=name:idoall, timestamp=1406424831473, value=idoallvalue <br>
1 row(s) in 0.0550 seconds</p>

<p>hbase(main):003:0&gt; scan “test_idoall_org” <br>
ROW                                                    COLUMN+CELL <br>
10086                                                 column=name:idoall, timestamp=1406424831473, value=idoallvalue <br>
1407658495588-XbQCOZrKK8-0                            column=name:payload, timestamp=1407658498203, value=hello idoall.org from flume <br>
2 row(s) in 0.0200 seconds</p>

<p>hbase(main):004:0&gt; quit <br>
复制代码</p>

<p>经过这么多flume的例子测试，如果你全部做完后，会发现flume的功能真的很强大，可以进行各种搭配来完成你想要的工作，俗话说师傅领进门，修行在个人，如何能够结合你的产品业务，将flume更好的应用起来，快去动手实践吧。</p>

<p>迦壹 <br>
<a href="http://idoall.org/home.php?mod=s" rel="nofollow">http://idoall.org/home.php?mod=s</a> … ;do=blog&amp;id=550 <br>
<a href="http://www.aboutyun.com/thread-8917-1-1.html" rel="nofollow">http://www.aboutyun.com/thread-8917-1-1.html</a></p>            </div>
						<link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-9e5741c4b9.css" rel="stylesheet">
                </div>