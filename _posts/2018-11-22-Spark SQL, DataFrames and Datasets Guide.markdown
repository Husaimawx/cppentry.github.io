---
layout:     post
title:      Spark SQL, DataFrames and Datasets Guide
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								<div class="article-copyright">
					版权声明：本文为博主原创文章，未经博主允许不得转载。					https://blog.csdn.net/kwame211/article/details/80254413				</div>
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                <h1 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Overview<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#overview" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h1><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Spark SQL is a Spark module for structured data processing. Unlike the basic Spark RDD API, the interfaces provided by Spark SQL provide Spark with more information about the structure of both the data and the computation being performed. Internally, Spark SQL uses this extra information to perform extra optimizations. There are several ways to interact with Spark SQL including SQL and the Dataset API. When computing a result the same execution engine is used, independent of which API/language you are using to express the computation. This unification means that developers can easily switch back and forth between different APIs based on which provides the most natural way to express a given transformation.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">All of the examples on this page use sample data included in the Spark distribution and can be run in the <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark-shell</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">pyspark</code> shell, or <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">sparkR</code>shell.</p><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">SQL<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#sql" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">One use of Spark SQL is to execute SQL queries. Spark SQL can also be used to read data from an existing Hive installation. For more on how to configure this feature, please refer to the <a href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#hive-tables" rel="nofollow" style="color:rgb(0,136,204);">Hive Tables</a> section. When running SQL from within another programming language the results will be returned as a <a href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#datasets-and-dataframes" rel="nofollow" style="color:rgb(0,136,204);">Dataset/DataFrame</a>. You can also interact with the SQL interface using the <a href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#running-the-spark-sql-cli" rel="nofollow" style="color:rgb(0,136,204);">command-line</a> or over <a href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#running-the-thrift-jdbcodbc-server" rel="nofollow" style="color:rgb(0,136,204);">JDBC/ODBC</a>.</p><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Datasets and DataFrames<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#datasets-and-dataframes" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">A Dataset is a distributed collection of data. Dataset is a new interface added in Spark 1.6 that provides the benefits of RDDs (strong typing, ability to use powerful lambda functions) with the benefits of Spark SQL’s optimized execution engine. A Dataset can be <a href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#creating-datasets" rel="nofollow" style="color:rgb(0,136,204);">constructed</a> from JVM objects and then manipulated using functional transformations (<code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">map</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">flatMap</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">filter</code>, etc.). The Dataset API is available in <a href="http://spark.apache.org/docs/2.2.0/api/scala/index.html#org.apache.spark.sql.Dataset" rel="nofollow" style="color:rgb(0,136,204);">Scala</a> and <a href="http://spark.apache.org/docs/2.2.0/api/java/index.html?org/apache/spark/sql/Dataset.html" rel="nofollow" style="color:rgb(0,136,204);">Java</a>. Python does not have the support for the Dataset API. But due to Python’s dynamic nature, many of the benefits of the Dataset API are already available (i.e. you can access the field of a row by name naturally <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">row.columnName</code>). The case for R is similar.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">A DataFrame is a <em>Dataset</em> organized into named columns. It is conceptually equivalent to a table in a relational database or a data frame in R/Python, but with richer optimizations under the hood. DataFrames can be constructed from a wide array of <a href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#data-sources" rel="nofollow" style="color:rgb(0,136,204);">sources</a> such as: structured data files, tables in Hive, external databases, or existing RDDs. The DataFrame API is available in Scala, Java, <a href="http://spark.apache.org/docs/2.2.0/api/python/pyspark.sql.html#pyspark.sql.DataFrame" rel="nofollow" style="color:rgb(0,136,204);">Python</a>, and <a href="http://spark.apache.org/docs/2.2.0/api/R/index.html" rel="nofollow" style="color:rgb(0,136,204);">R</a>. In Scala and Java, a DataFrame is represented by a Dataset of <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">Row</code>s. In <a href="http://spark.apache.org/docs/2.2.0/api/scala/index.html#org.apache.spark.sql.Dataset" rel="nofollow" style="color:rgb(0,136,204);">the Scala API</a>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DataFrame</code> is simply a type alias of <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">Dataset[Row]</code>. While, in <a href="http://spark.apache.org/docs/2.2.0/api/java/index.html?org/apache/spark/sql/Dataset.html" rel="nofollow" style="color:rgb(0,136,204);">Java API</a>, users need to use <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">Dataset&lt;Row&gt;</code> to represent a <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DataFrame</code>.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Throughout this document, we will often refer to Scala/Java Datasets of <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">Row</code>s as DataFrames.</p><h1 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Getting Started<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#getting-started" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h1><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Starting Point: SparkSession<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#starting-point-sparksession" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_0" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_0" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_python" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_python_0" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Python</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_r" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_r_0" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>R</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><p style="margin-bottom:10px;">The entry point into all functionality in Spark is the <a href="http://spark.apache.org/docs/2.2.0/api/scala/index.html#org.apache.spark.sql.SparkSession" rel="nofollow" style="color:rgb(0,136,204);"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(0,136,204);background:#FFFFFF;border:none;">SparkSession</code></a> class. To create a basic <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SparkSession</code>, just use <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SparkSession.builder()</code>:</p><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><span class="k" style="color:rgb(0,112,32);font-weight:bold;">import</span> <span class="nn" style="color:rgb(14,132,181);font-weight:bold;">org.apache.spark.sql.SparkSession</span>

<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">spark</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">SparkSession</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">builder</span><span class="o" style="color:rgb(102,102,102);">()</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">appName</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"Spark SQL basic example"</span><span class="o" style="color:rgb(102,102,102);">)</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">config</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"spark.some.config.option"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"some-value"</span><span class="o" style="color:rgb(102,102,102);">)</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">getOrCreate</span><span class="o" style="color:rgb(102,102,102);">()</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// For implicit conversions like converting RDDs to DataFrames</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">import</span> <span class="nn" style="color:rgb(14,132,181);font-weight:bold;">spark.implicits._</span>
</pre></div><div><small style="font-size:11.9px;">Find full example code at "examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala" in the Spark repo.</small></div></div></div><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SparkSession</code> in Spark 2.0 provides builtin support for Hive features including the ability to write queries using HiveQL, access to Hive UDFs, and the ability to read data from Hive tables. To use these features, you do not need to have an existing Hive setup.</p><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Creating DataFrames<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#creating-dataframes" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_1" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_1" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_python" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_python_1" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Python</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_r" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_r_1" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>R</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><p style="margin-bottom:10px;">With a <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SparkSession</code>, applications can create DataFrames from an <a href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#interoperating-with-rdds" rel="nofollow" style="color:rgb(0,136,204);">existing <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(0,136,204);background:#FFFFFF;border:none;">RDD</code></a>, from a Hive table, or from <a href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#data-sources" rel="nofollow" style="color:rgb(0,136,204);">Spark data sources</a>.</p><p style="margin-bottom:10px;">As an example, the following creates a DataFrame based on the content of a JSON file:</p><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">df</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">read</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">json</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"examples/src/main/resources/people.json"</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Displays the content of the DataFrame to stdout</span>
<span class="n">df</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +----+-------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// | age|   name|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +----+-------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |null|Michael|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |  30|   Andy|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |  19| Justin|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +----+-------+</span>
</pre></div><div><small style="font-size:11.9px;">Find full example code at "examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala" in the Spark repo.</small></div></div></div><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Untyped Dataset Operations (aka DataFrame Operations)<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#untyped-dataset-operations-aka-dataframe-operations" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">DataFrames provide a domain-specific language for structured data manipulation in <a href="http://spark.apache.org/docs/2.2.0/api/scala/index.html#org.apache.spark.sql.Dataset" rel="nofollow" style="color:rgb(0,136,204);">Scala</a>, <a href="http://spark.apache.org/docs/2.2.0/api/java/index.html?org/apache/spark/sql/Dataset.html" rel="nofollow" style="color:rgb(0,136,204);">Java</a>, <a href="http://spark.apache.org/docs/2.2.0/api/python/pyspark.sql.html#pyspark.sql.DataFrame" rel="nofollow" style="color:rgb(0,136,204);">Python</a> and <a href="http://spark.apache.org/docs/2.2.0/api/R/SparkDataFrame.html" rel="nofollow" style="color:rgb(0,136,204);">R</a>.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">As mentioned above, in Spark 2.0, DataFrames are just Dataset of <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">Row</code>s in Scala and Java API. These operations are also referred as “untyped transformations” in contrast to “typed transformations” come with strongly typed Scala/Java Datasets.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Here we include some basic examples of structured data processing using Datasets:</p><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_2" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_2" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_python" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_python_2" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Python</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_r" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_r_2" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>R</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><span class="c1" style="color:rgb(96,160,176);font-style:italic;">// This import is needed to use the $-notation</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">import</span> <span class="nn" style="color:rgb(14,132,181);font-weight:bold;">spark.implicits._</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Print the schema in a tree format</span>
<span class="n">df</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">printSchema</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// root</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |-- age: long (nullable = true)</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |-- name: string (nullable = true)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Select only the "name" column</span>
<span class="n">df</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">select</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"name"</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +-------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |   name|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +-------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |Michael|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |   Andy|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// | Justin|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +-------+</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Select everybody, but increment the age by 1</span>
<span class="n">df</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">select</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">$</span><span class="s" style="color:rgb(64,112,160);">"name"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="n">$</span><span class="s" style="color:rgb(64,112,160);">"age"</span> <span class="o" style="color:rgb(102,102,102);">+</span> <span class="mi" style="color:rgb(64,160,112);">1</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +-------+---------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |   name|(age + 1)|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +-------+---------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |Michael|     null|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |   Andy|       31|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// | Justin|       20|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +-------+---------+</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Select people older than 21</span>
<span class="n">df</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">filter</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">$</span><span class="s" style="color:rgb(64,112,160);">"age"</span> <span class="o" style="color:rgb(102,102,102);">&gt;</span> <span class="mi" style="color:rgb(64,160,112);">21</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +---+----+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |age|name|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +---+----+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// | 30|Andy|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +---+----+</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Count people by age</span>
<span class="n">df</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">groupBy</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"age"</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">count</span><span class="o" style="color:rgb(102,102,102);">().</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +----+-----+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// | age|count|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +----+-----+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |  19|    1|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |null|    1|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |  30|    1|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +----+-----+</span>
</pre></div><div><small style="font-size:11.9px;">Find full example code at "examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala" in the Spark repo.</small></div><p style="margin-bottom:10px;">For a complete list of the types of operations that can be performed on a Dataset refer to the <a href="http://spark.apache.org/docs/2.2.0/api/scala/index.html#org.apache.spark.sql.Dataset" rel="nofollow" style="color:rgb(0,136,204);">API Documentation</a>.</p><p style="margin-bottom:10px;">In addition to simple column references and expressions, Datasets also have a rich library of functions including string manipulation, date arithmetic, common math operations and more. The complete list is available in the <a href="http://spark.apache.org/docs/2.2.0/api/scala/index.html#org.apache.spark.sql.functions%24" rel="nofollow" style="color:rgb(0,136,204);">DataFrame Function Reference</a>.</p></div></div><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Running SQL Queries Programmatically<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#running-sql-queries-programmatically" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_3" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_3" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_python" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_python_3" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Python</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_r" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_r_3" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>R</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><p style="margin-bottom:10px;">The <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">sql</code> function on a <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SparkSession</code> enables applications to run SQL queries programmatically and returns the result as a <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DataFrame</code>.</p><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Register the DataFrame as a SQL temporary view</span>
<span class="n">df</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">createOrReplaceTempView</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"people"</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">sqlDF</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">sql</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"SELECT * FROM people"</span><span class="o" style="color:rgb(102,102,102);">)</span>
<span class="n">sqlDF</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +----+-------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// | age|   name|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +----+-------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |null|Michael|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |  30|   Andy|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |  19| Justin|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +----+-------+</span>
</pre></div><div><small style="font-size:11.9px;">Find full example code at "examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala" in the Spark repo.</small></div></div></div><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Global Temporary View<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#global-temporary-view" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Temporary views in Spark SQL are session-scoped and will disappear if the session that creates it terminates. If you want to have a temporary view that is shared among all sessions and keep alive until the Spark application terminates, you can create a global temporary view. Global temporary view is tied to a system preserved database <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">global_temp</code>, and we must use the qualified name to refer it, e.g. <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SELECT * FROM global_temp.view1</code>.</p><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_4" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_4" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_python" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_python_4" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Python</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_sql" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_sql_4" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Sql</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Register the DataFrame as a global temporary view</span>
<span class="n">df</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">createGlobalTempView</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"people"</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Global temporary view is tied to a system preserved database `global_temp`</span>
<span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">sql</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"SELECT * FROM global_temp.people"</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +----+-------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// | age|   name|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +----+-------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |null|Michael|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |  30|   Andy|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |  19| Justin|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +----+-------+</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Global temporary view is cross-session</span>
<span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">newSession</span><span class="o" style="color:rgb(102,102,102);">().</span><span class="n">sql</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"SELECT * FROM global_temp.people"</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +----+-------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// | age|   name|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +----+-------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |null|Michael|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |  30|   Andy|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |  19| Justin|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +----+-------+</span>
</pre></div><div><small style="font-size:11.9px;">Find full example code at "examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala" in the Spark repo.</small></div></div></div><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Creating Datasets<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#creating-datasets" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Datasets are similar to RDDs, however, instead of using Java serialization or Kryo they use a specialized <a href="http://spark.apache.org/docs/2.2.0/api/scala/index.html#org.apache.spark.sql.Encoder" rel="nofollow" style="color:rgb(0,136,204);">Encoder</a> to serialize the objects for processing or transmitting over the network. While both encoders and standard serialization are responsible for turning an object into bytes, encoders are code generated dynamically and use a format that allows Spark to perform many operations like filtering, sorting and hashing without deserializing the bytes back into an object.</p><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_5" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_5" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Note: Case classes in Scala 2.10 can support only up to 22 fields. To work around this limit,</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// you can use custom classes that implement the Product interface</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">case</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">class</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">Person</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">name</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">String</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="n">age</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Long</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Encoders are created for case classes</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">caseClassDS</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">Seq</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="nc" style="color:rgb(14,132,181);font-weight:bold;">Person</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"Andy"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="mi" style="color:rgb(64,160,112);">32</span><span class="o" style="color:rgb(102,102,102);">)).</span><span class="n">toDS</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="n">caseClassDS</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +----+---+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |name|age|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +----+---+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |Andy| 32|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +----+---+</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Encoders for most common types are automatically provided by importing spark.implicits._</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">primitiveDS</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">Seq</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">1</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="mi" style="color:rgb(64,160,112);">2</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="mi" style="color:rgb(64,160,112);">3</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">toDS</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="n">primitiveDS</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">map</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">_</span> <span class="o" style="color:rgb(102,102,102);">+</span> <span class="mi" style="color:rgb(64,160,112);">1</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">collect</span><span class="o" style="color:rgb(102,102,102);">()</span> <span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Returns: Array(2, 3, 4)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// DataFrames can be converted to a Dataset by providing a class. Mapping will be done by name</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">path</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="s" style="color:rgb(64,112,160);">"examples/src/main/resources/people.json"</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">peopleDS</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">read</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">json</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">path</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">as</span><span class="o" style="color:rgb(102,102,102);">[</span><span class="kt" style="color:rgb(144,32,0);">Person</span><span class="o" style="color:rgb(102,102,102);">]</span>
<span class="n">peopleDS</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +----+-------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// | age|   name|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +----+-------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |null|Michael|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |  30|   Andy|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |  19| Justin|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +----+-------+</span>
</pre></div><div><small style="font-size:11.9px;">Find full example code at "examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala" in the Spark repo.</small></div></div></div><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Interoperating with RDDs<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#interoperating-with-rdds" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Spark SQL supports two different methods for converting existing RDDs into Datasets. The first method uses reflection to infer the schema of an RDD that contains specific types of objects. This reflection based approach leads to more concise code and works well when you already know the schema while writing your Spark application.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">The second method for creating Datasets is through a programmatic interface that allows you to construct a schema and then apply it to an existing RDD. While this method is more verbose, it allows you to construct Datasets when the columns and their types are not known until runtime.</p><h3 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);font-size:21px;">Inferring the Schema Using Reflection<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#inferring-the-schema-using-reflection" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h3><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_6" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_6" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_python" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_python_6" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Python</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><p style="margin-bottom:10px;">The Scala interface for Spark SQL supports automatically converting an RDD containing case classes to a DataFrame. The case class defines the schema of the table. The names of the arguments to the case class are read using reflection and become the names of the columns. Case classes can also be nested or contain complex types such as <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">Seq</code>s or <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">Array</code>s. This RDD can be implicitly converted to a DataFrame and then be registered as a table. Tables can be used in subsequent SQL statements.</p><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><span class="c1" style="color:rgb(96,160,176);font-style:italic;">// For implicit conversions from RDDs to DataFrames</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">import</span> <span class="nn" style="color:rgb(14,132,181);font-weight:bold;">spark.implicits._</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Create an RDD of Person objects from a text file, convert it to a Dataframe</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">peopleDF</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">sparkContext</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">textFile</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"examples/src/main/resources/people.txt"</span><span class="o" style="color:rgb(102,102,102);">)</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">map</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">_</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">split</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">","</span><span class="o" style="color:rgb(102,102,102);">))</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">map</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">attributes</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=&gt;</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">Person</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">attributes</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">0</span><span class="o" style="color:rgb(102,102,102);">),</span> <span class="n">attributes</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">1</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">trim</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">toInt</span><span class="o" style="color:rgb(102,102,102);">))</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">toDF</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Register the DataFrame as a temporary view</span>
<span class="n">peopleDF</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">createOrReplaceTempView</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"people"</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// SQL statements can be run by using the sql methods provided by Spark</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">teenagersDF</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">sql</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"SELECT name, age FROM people WHERE age BETWEEN 13 AND 19"</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// The columns of a row in the result can be accessed by field index</span>
<span class="n">teenagersDF</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">map</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">teenager</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=&gt;</span> <span class="s" style="color:rgb(64,112,160);">"Name: "</span> <span class="o" style="color:rgb(102,102,102);">+</span> <span class="n">teenager</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">0</span><span class="o" style="color:rgb(102,102,102);">)).</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +------------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |       value|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +------------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |Name: Justin|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +------------+</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// or by field name</span>
<span class="n">teenagersDF</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">map</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">teenager</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=&gt;</span> <span class="s" style="color:rgb(64,112,160);">"Name: "</span> <span class="o" style="color:rgb(102,102,102);">+</span> <span class="n">teenager</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">getAs</span><span class="o" style="color:rgb(102,102,102);">[</span><span class="kt" style="color:rgb(144,32,0);">String</span><span class="o" style="color:rgb(102,102,102);">](</span><span class="s" style="color:rgb(64,112,160);">"name"</span><span class="o" style="color:rgb(102,102,102);">)).</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +------------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |       value|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +------------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |Name: Justin|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +------------+</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// No pre-defined encoders for Dataset[Map[K,V]], define explicitly</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">implicit</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">mapEncoder</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">org</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">apache</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">sql</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="nc" style="color:rgb(14,132,181);font-weight:bold;">Encoders</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">kryo</span><span class="o" style="color:rgb(102,102,102);">[</span><span class="kt" style="color:rgb(144,32,0);">Map</span><span class="o" style="color:rgb(102,102,102);">[</span><span class="kt" style="color:rgb(144,32,0);">String</span>, <span class="kt" style="color:rgb(144,32,0);">Any</span><span class="o" style="color:rgb(102,102,102);">]]</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Primitive types and case classes can be also defined as</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// implicit val stringIntMapEncoder: Encoder[Map[String, Any]] = ExpressionEncoder()</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// row.getValuesMap[T] retrieves multiple columns at once into a Map[String, T]</span>
<span class="n">teenagersDF</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">map</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">teenager</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=&gt;</span> <span class="n">teenager</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">getValuesMap</span><span class="o" style="color:rgb(102,102,102);">[</span><span class="kt" style="color:rgb(144,32,0);">Any</span><span class="o" style="color:rgb(102,102,102);">](</span><span class="nc" style="color:rgb(14,132,181);font-weight:bold;">List</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"name"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"age"</span><span class="o" style="color:rgb(102,102,102);">))).</span><span class="n">collect</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Array(Map("name" -&gt; "Justin", "age" -&gt; 19))</span>
</pre></div><div><small style="font-size:11.9px;">Find full example code at "examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala" in the Spark repo.</small></div></div></div><h3 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);font-size:21px;">Programmatically Specifying the Schema<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#programmatically-specifying-the-schema" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h3><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_7" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_7" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_python" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_python_7" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Python</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><p style="margin-bottom:10px;">When case classes cannot be defined ahead of time (for example, the structure of records is encoded in a string, or a text dataset will be parsed and fields will be projected differently for different users), a <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DataFrame</code> can be created programmatically with three steps.</p><ol style="margin-bottom:10px;margin-left:25px;"><li style="line-height:20px;">Create an RDD of <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">Row</code>s from the original RDD;</li><li style="line-height:20px;">Create the schema represented by a <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">StructType</code> matching the structure of <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">Row</code>s in the RDD created in Step 1.</li><li style="line-height:20px;">Apply the schema to the RDD of <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">Row</code>s via <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">createDataFrame</code> method provided by <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SparkSession</code>.</li></ol><p style="margin-bottom:10px;">For example:</p><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><span class="k" style="color:rgb(0,112,32);font-weight:bold;">import</span> <span class="nn" style="color:rgb(14,132,181);font-weight:bold;">org.apache.spark.sql.types._</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Create an RDD</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">peopleRDD</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">sparkContext</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">textFile</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"examples/src/main/resources/people.txt"</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// The schema is encoded in a string</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">schemaString</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="s" style="color:rgb(64,112,160);">"name age"</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Generate the schema based on the string of schema</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">fields</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">schemaString</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">split</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">" "</span><span class="o" style="color:rgb(102,102,102);">)</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">map</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">fieldName</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=&gt;</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">StructField</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">fieldName</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">StringType</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="n">nullable</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="kc" style="color:rgb(0,112,32);font-weight:bold;">true</span><span class="o" style="color:rgb(102,102,102);">))</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">schema</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">StructType</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">fields</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Convert records of the RDD (people) to Rows</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">rowRDD</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">peopleRDD</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">map</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">_</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">split</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">","</span><span class="o" style="color:rgb(102,102,102);">))</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">map</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">attributes</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=&gt;</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">Row</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">attributes</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">0</span><span class="o" style="color:rgb(102,102,102);">),</span> <span class="n">attributes</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">1</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">trim</span><span class="o" style="color:rgb(102,102,102);">))</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Apply the schema to the RDD</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">peopleDF</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">createDataFrame</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">rowRDD</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="n">schema</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Creates a temporary view using the DataFrame</span>
<span class="n">peopleDF</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">createOrReplaceTempView</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"people"</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// SQL can be run over a temporary view created using DataFrames</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">results</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">sql</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"SELECT name FROM people"</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// The results of SQL queries are DataFrames and support all the normal RDD operations</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// The columns of a row in the result can be accessed by field index or by field name</span>
<span class="n">results</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">map</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">attributes</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=&gt;</span> <span class="s" style="color:rgb(64,112,160);">"Name: "</span> <span class="o" style="color:rgb(102,102,102);">+</span> <span class="n">attributes</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">0</span><span class="o" style="color:rgb(102,102,102);">)).</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +-------------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |        value|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +-------------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |Name: Michael|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |   Name: Andy|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// | Name: Justin|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +-------------+</span>
</pre></div><div><small style="font-size:11.9px;">Find full example code at "examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala" in the Spark repo.</small></div></div></div><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Aggregations<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#aggregations" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">The <a href="http://spark.apache.org/docs/2.2.0/api/scala/index.html#org.apache.spark.sql.functions%24" rel="nofollow" style="color:rgb(0,136,204);">built-in DataFrames functions</a> provide common aggregations such as <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">count()</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">countDistinct()</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">avg()</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">max()</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">min()</code>, etc. While those functions are designed for DataFrames, Spark SQL also has type-safe versions for some of them in <a href="http://spark.apache.org/docs/2.2.0/api/scala/index.html#org.apache.spark.sql.expressions.scalalang.typed%24" rel="nofollow" style="color:rgb(0,136,204);">Scala</a> and <a href="http://spark.apache.org/docs/2.2.0/api/java/org/apache/spark/sql/expressions/javalang/typed.html" rel="nofollow" style="color:rgb(0,136,204);">Java</a> to work with strongly typed Datasets. Moreover, users are not limited to the predefined aggregate functions and can create their own.</p><h3 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);font-size:21px;">Untyped User-Defined Aggregate Functions<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#untyped-user-defined-aggregate-functions" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h3><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_8" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_8" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><p style="margin-bottom:10px;">Users have to extend the <a href="http://spark.apache.org/docs/2.2.0/api/scala/index.html#org.apache.spark.sql.expressions.UserDefinedAggregateFunction" rel="nofollow" style="color:rgb(0,136,204);">UserDefinedAggregateFunction</a> abstract class to implement a custom untyped aggregate function. For example, a user-defined average can look like:</p><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><span class="k" style="color:rgb(0,112,32);font-weight:bold;">import</span> <span class="nn" style="color:rgb(14,132,181);font-weight:bold;">org.apache.spark.sql.expressions.MutableAggregationBuffer</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">import</span> <span class="nn" style="color:rgb(14,132,181);font-weight:bold;">org.apache.spark.sql.expressions.UserDefinedAggregateFunction</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">import</span> <span class="nn" style="color:rgb(14,132,181);font-weight:bold;">org.apache.spark.sql.types._</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">import</span> <span class="nn" style="color:rgb(14,132,181);font-weight:bold;">org.apache.spark.sql.Row</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">import</span> <span class="nn" style="color:rgb(14,132,181);font-weight:bold;">org.apache.spark.sql.SparkSession</span>

<span class="k" style="color:rgb(0,112,32);font-weight:bold;">object</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">MyAverage</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">extends</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">UserDefinedAggregateFunction</span> <span class="o" style="color:rgb(102,102,102);">{</span>
  <span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Data types of input arguments of this aggregate function</span>
  <span class="k" style="color:rgb(0,112,32);font-weight:bold;">def</span> <span class="n">inputSchema</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">StructType</span> <span class="o" style="color:rgb(102,102,102);">=</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">StructType</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="nc" style="color:rgb(14,132,181);font-weight:bold;">StructField</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"inputColumn"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">LongType</span><span class="o" style="color:rgb(102,102,102);">)</span> <span class="o" style="color:rgb(102,102,102);">::</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">Nil</span><span class="o" style="color:rgb(102,102,102);">)</span>
  <span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Data types of values in the aggregation buffer</span>
  <span class="k" style="color:rgb(0,112,32);font-weight:bold;">def</span> <span class="n">bufferSchema</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">StructType</span> <span class="o" style="color:rgb(102,102,102);">=</span> <span class="o" style="color:rgb(102,102,102);">{</span>
    <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">StructType</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="nc" style="color:rgb(14,132,181);font-weight:bold;">StructField</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"sum"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">LongType</span><span class="o" style="color:rgb(102,102,102);">)</span> <span class="o" style="color:rgb(102,102,102);">::</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">StructField</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"count"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">LongType</span><span class="o" style="color:rgb(102,102,102);">)</span> <span class="o" style="color:rgb(102,102,102);">::</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">Nil</span><span class="o" style="color:rgb(102,102,102);">)</span>
  <span class="o" style="color:rgb(102,102,102);">}</span>
  <span class="c1" style="color:rgb(96,160,176);font-style:italic;">// The data type of the returned value</span>
  <span class="k" style="color:rgb(0,112,32);font-weight:bold;">def</span> <span class="n">dataType</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">DataType</span> <span class="o" style="color:rgb(102,102,102);">=</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">DoubleType</span>
  <span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Whether this function always returns the same output on the identical input</span>
  <span class="k" style="color:rgb(0,112,32);font-weight:bold;">def</span> <span class="n">deterministic</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Boolean</span> <span class="o" style="color:rgb(102,102,102);">=</span> <span class="kc" style="color:rgb(0,112,32);font-weight:bold;">true</span>
  <span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Initializes the given aggregation buffer. The buffer itself is a `Row` that in addition to</span>
  <span class="c1" style="color:rgb(96,160,176);font-style:italic;">// standard methods like retrieving a value at an index (e.g., get(), getBoolean()), provides</span>
  <span class="c1" style="color:rgb(96,160,176);font-style:italic;">// the opportunity to update its values. Note that arrays and maps inside the buffer are still</span>
  <span class="c1" style="color:rgb(96,160,176);font-style:italic;">// immutable.</span>
  <span class="k" style="color:rgb(0,112,32);font-weight:bold;">def</span> <span class="n">initialize</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">buffer</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">MutableAggregationBuffer</span><span class="o" style="color:rgb(102,102,102);">)</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Unit</span> <span class="o" style="color:rgb(102,102,102);">=</span> <span class="o" style="color:rgb(102,102,102);">{</span>
    <span class="n">buffer</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">0</span><span class="o" style="color:rgb(102,102,102);">)</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="mi" style="color:rgb(64,160,112);">0L</span>
    <span class="n">buffer</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">1</span><span class="o" style="color:rgb(102,102,102);">)</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="mi" style="color:rgb(64,160,112);">0L</span>
  <span class="o" style="color:rgb(102,102,102);">}</span>
  <span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Updates the given aggregation buffer `buffer` with new input data from `input`</span>
  <span class="k" style="color:rgb(0,112,32);font-weight:bold;">def</span> <span class="n">update</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">buffer</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">MutableAggregationBuffer</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="n">input</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Row</span><span class="o" style="color:rgb(102,102,102);">)</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Unit</span> <span class="o" style="color:rgb(102,102,102);">=</span> <span class="o" style="color:rgb(102,102,102);">{</span>
    <span class="k" style="color:rgb(0,112,32);font-weight:bold;">if</span> <span class="o" style="color:rgb(102,102,102);">(!</span><span class="n">input</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">isNullAt</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">0</span><span class="o" style="color:rgb(102,102,102);">))</span> <span class="o" style="color:rgb(102,102,102);">{</span>
      <span class="n">buffer</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">0</span><span class="o" style="color:rgb(102,102,102);">)</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">buffer</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">getLong</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">0</span><span class="o" style="color:rgb(102,102,102);">)</span> <span class="o" style="color:rgb(102,102,102);">+</span> <span class="n">input</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">getLong</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">0</span><span class="o" style="color:rgb(102,102,102);">)</span>
      <span class="n">buffer</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">1</span><span class="o" style="color:rgb(102,102,102);">)</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">buffer</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">getLong</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">1</span><span class="o" style="color:rgb(102,102,102);">)</span> <span class="o" style="color:rgb(102,102,102);">+</span> <span class="mi" style="color:rgb(64,160,112);">1</span>
    <span class="o" style="color:rgb(102,102,102);">}</span>
  <span class="o" style="color:rgb(102,102,102);">}</span>
  <span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Merges two aggregation buffers and stores the updated buffer values back to `buffer1`</span>
  <span class="k" style="color:rgb(0,112,32);font-weight:bold;">def</span> <span class="n">merge</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">buffer1</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">MutableAggregationBuffer</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="n">buffer2</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Row</span><span class="o" style="color:rgb(102,102,102);">)</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Unit</span> <span class="o" style="color:rgb(102,102,102);">=</span> <span class="o" style="color:rgb(102,102,102);">{</span>
    <span class="n">buffer1</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">0</span><span class="o" style="color:rgb(102,102,102);">)</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">buffer1</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">getLong</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">0</span><span class="o" style="color:rgb(102,102,102);">)</span> <span class="o" style="color:rgb(102,102,102);">+</span> <span class="n">buffer2</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">getLong</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">0</span><span class="o" style="color:rgb(102,102,102);">)</span>
    <span class="n">buffer1</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">1</span><span class="o" style="color:rgb(102,102,102);">)</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">buffer1</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">getLong</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">1</span><span class="o" style="color:rgb(102,102,102);">)</span> <span class="o" style="color:rgb(102,102,102);">+</span> <span class="n">buffer2</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">getLong</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">1</span><span class="o" style="color:rgb(102,102,102);">)</span>
  <span class="o" style="color:rgb(102,102,102);">}</span>
  <span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Calculates the final result</span>
  <span class="k" style="color:rgb(0,112,32);font-weight:bold;">def</span> <span class="n">evaluate</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">buffer</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Row</span><span class="o" style="color:rgb(102,102,102);">)</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Double</span> <span class="o" style="color:rgb(102,102,102);">=</span> <span class="n">buffer</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">getLong</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">0</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">toDouble</span> <span class="o" style="color:rgb(102,102,102);">/</span> <span class="n">buffer</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">getLong</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">1</span><span class="o" style="color:rgb(102,102,102);">)</span>
<span class="o" style="color:rgb(102,102,102);">}</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Register the function to access it</span>
<span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">udf</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">register</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"myAverage"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">MyAverage</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">df</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">read</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">json</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"examples/src/main/resources/employees.json"</span><span class="o" style="color:rgb(102,102,102);">)</span>
<span class="n">df</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">createOrReplaceTempView</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"employees"</span><span class="o" style="color:rgb(102,102,102);">)</span>
<span class="n">df</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +-------+------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |   name|salary|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +-------+------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |Michael|  3000|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |   Andy|  4500|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// | Justin|  3500|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |  Berta|  4000|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +-------+------+</span>

<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">result</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">sql</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"SELECT myAverage(salary) as average_salary FROM employees"</span><span class="o" style="color:rgb(102,102,102);">)</span>
<span class="n">result</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +--------------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |average_salary|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +--------------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |        3750.0|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +--------------+</span>
</pre></div><div><small style="font-size:11.9px;">Find full example code at "examples/src/main/scala/org/apache/spark/examples/sql/UserDefinedUntypedAggregation.scala" in the Spark repo.</small></div></div></div><h3 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);font-size:21px;">Type-Safe User-Defined Aggregate Functions<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#type-safe-user-defined-aggregate-functions" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h3><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">User-defined aggregations for strongly typed Datasets revolve around the <a href="http://spark.apache.org/docs/2.2.0/api/scala/index.html#org.apache.spark.sql.expressions.Aggregator" rel="nofollow" style="color:rgb(0,136,204);">Aggregator</a> abstract class. For example, a type-safe user-defined average can look like:</p><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_9" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_9" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><span class="k" style="color:rgb(0,112,32);font-weight:bold;">import</span> <span class="nn" style="color:rgb(14,132,181);font-weight:bold;">org.apache.spark.sql.expressions.Aggregator</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">import</span> <span class="nn" style="color:rgb(14,132,181);font-weight:bold;">org.apache.spark.sql.Encoder</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">import</span> <span class="nn" style="color:rgb(14,132,181);font-weight:bold;">org.apache.spark.sql.Encoders</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">import</span> <span class="nn" style="color:rgb(14,132,181);font-weight:bold;">org.apache.spark.sql.SparkSession</span>

<span class="k" style="color:rgb(0,112,32);font-weight:bold;">case</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">class</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">Employee</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">name</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">String</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="n">salary</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Long</span><span class="o" style="color:rgb(102,102,102);">)</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">case</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">class</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">Average</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">var</span> <span class="n">sum</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Long</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">var</span> <span class="n">count</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Long</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="k" style="color:rgb(0,112,32);font-weight:bold;">object</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">MyAverage</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">extends</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">Aggregator</span><span class="o" style="color:rgb(102,102,102);">[</span><span class="kt" style="color:rgb(144,32,0);">Employee</span>, <span class="kt" style="color:rgb(144,32,0);">Average</span>, <span class="kt" style="color:rgb(144,32,0);">Double</span><span class="o" style="color:rgb(102,102,102);">]</span> <span class="o" style="color:rgb(102,102,102);">{</span>
  <span class="c1" style="color:rgb(96,160,176);font-style:italic;">// A zero value for this aggregation. Should satisfy the property that any b + zero = b</span>
  <span class="k" style="color:rgb(0,112,32);font-weight:bold;">def</span> <span class="n">zero</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Average</span> <span class="o" style="color:rgb(102,102,102);">=</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">Average</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">0L</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="mi" style="color:rgb(64,160,112);">0L</span><span class="o" style="color:rgb(102,102,102);">)</span>
  <span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Combine two values to produce a new value. For performance, the function may modify `buffer`</span>
  <span class="c1" style="color:rgb(96,160,176);font-style:italic;">// and return it instead of constructing a new object</span>
  <span class="k" style="color:rgb(0,112,32);font-weight:bold;">def</span> <span class="n">reduce</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">buffer</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Average</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="n">employee</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Employee</span><span class="o" style="color:rgb(102,102,102);">)</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Average</span> <span class="o" style="color:rgb(102,102,102);">=</span> <span class="o" style="color:rgb(102,102,102);">{</span>
    <span class="n">buffer</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">sum</span> <span class="o" style="color:rgb(102,102,102);">+=</span> <span class="n">employee</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">salary</span>
    <span class="n">buffer</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">count</span> <span class="o" style="color:rgb(102,102,102);">+=</span> <span class="mi" style="color:rgb(64,160,112);">1</span>
    <span class="n">buffer</span>
  <span class="o" style="color:rgb(102,102,102);">}</span>
  <span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Merge two intermediate values</span>
  <span class="k" style="color:rgb(0,112,32);font-weight:bold;">def</span> <span class="n">merge</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">b1</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Average</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="n">b2</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Average</span><span class="o" style="color:rgb(102,102,102);">)</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Average</span> <span class="o" style="color:rgb(102,102,102);">=</span> <span class="o" style="color:rgb(102,102,102);">{</span>
    <span class="n">b1</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">sum</span> <span class="o" style="color:rgb(102,102,102);">+=</span> <span class="n">b2</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">sum</span>
    <span class="n">b1</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">count</span> <span class="o" style="color:rgb(102,102,102);">+=</span> <span class="n">b2</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">count</span>
    <span class="n">b1</span>
  <span class="o" style="color:rgb(102,102,102);">}</span>
  <span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Transform the output of the reduction</span>
  <span class="k" style="color:rgb(0,112,32);font-weight:bold;">def</span> <span class="n">finish</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">reduction</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Average</span><span class="o" style="color:rgb(102,102,102);">)</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Double</span> <span class="o" style="color:rgb(102,102,102);">=</span> <span class="n">reduction</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">sum</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">toDouble</span> <span class="o" style="color:rgb(102,102,102);">/</span> <span class="n">reduction</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">count</span>
  <span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Specifies the Encoder for the intermediate value type</span>
  <span class="k" style="color:rgb(0,112,32);font-weight:bold;">def</span> <span class="n">bufferEncoder</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Encoder</span><span class="o" style="color:rgb(102,102,102);">[</span><span class="kt" style="color:rgb(144,32,0);">Average</span><span class="o" style="color:rgb(102,102,102);">]</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">Encoders</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">product</span>
  <span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Specifies the Encoder for the final output value type</span>
  <span class="k" style="color:rgb(0,112,32);font-weight:bold;">def</span> <span class="n">outputEncoder</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Encoder</span><span class="o" style="color:rgb(102,102,102);">[</span><span class="kt" style="color:rgb(144,32,0);">Double</span><span class="o" style="color:rgb(102,102,102);">]</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">Encoders</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">scalaDouble</span>
<span class="o" style="color:rgb(102,102,102);">}</span>

<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">ds</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">read</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">json</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"examples/src/main/resources/employees.json"</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">as</span><span class="o" style="color:rgb(102,102,102);">[</span><span class="kt" style="color:rgb(144,32,0);">Employee</span><span class="o" style="color:rgb(102,102,102);">]</span>
<span class="n">ds</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +-------+------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |   name|salary|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +-------+------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |Michael|  3000|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |   Andy|  4500|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// | Justin|  3500|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |  Berta|  4000|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +-------+------+</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Convert the function to a `TypedColumn` and give it a name</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">averageSalary</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">MyAverage</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">toColumn</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">name</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"average_salary"</span><span class="o" style="color:rgb(102,102,102);">)</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">result</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">ds</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">select</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">averageSalary</span><span class="o" style="color:rgb(102,102,102);">)</span>
<span class="n">result</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +--------------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |average_salary|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +--------------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |        3750.0|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +--------------+</span>
</pre></div><div><small style="font-size:11.9px;">Find full example code at "examples/src/main/scala/org/apache/spark/examples/sql/UserDefinedTypedAggregation.scala" in the Spark repo.</small></div></div></div><h1 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Data Sources<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#data-sources" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h1><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Spark SQL supports operating on a variety of data sources through the DataFrame interface. A DataFrame can be operated on using relational transformations and can also be used to create a temporary view. Registering a DataFrame as a temporary view allows you to run SQL queries over its data. This section describes the general methods for loading and saving data using the Spark Data Sources and then goes into specific options that are available for the built-in data sources.</p><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Generic Load/Save Functions<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#generic-loadsave-functions" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">In the simplest form, the default data source (<code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">parquet</code> unless otherwise configured by <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.sources.default</code>) will be used for all operations.</p><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_10" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_10" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_python" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_python_10" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Python</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_r" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_r_10" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>R</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">usersDF</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">read</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">load</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"examples/src/main/resources/users.parquet"</span><span class="o" style="color:rgb(102,102,102);">)</span>
<span class="n">usersDF</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">select</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"name"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"favorite_color"</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">write</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">save</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"namesAndFavColors.parquet"</span><span class="o" style="color:rgb(102,102,102);">)</span>
</pre></div><div><small style="font-size:11.9px;">Find full example code at "examples/src/main/scala/org/apache/spark/examples/sql/SQLDataSourceExample.scala" in the Spark repo.</small></div></div></div><h3 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);font-size:21px;">Manually Specifying Options<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#manually-specifying-options" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h3><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">You can also manually specify the data source that will be used along with any extra options that you would like to pass to the data source. Data sources are specified by their fully qualified name (i.e., <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">org.apache.spark.sql.parquet</code>), but for built-in sources you can also use their short names (<code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">json</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">parquet</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">jdbc</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">orc</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">libsvm</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">csv</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">text</code>). DataFrames loaded from any data source type can be converted into other types using this syntax.</p><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_11" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_11" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_python" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_python_11" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Python</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_r" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_r_11" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>R</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">peopleDF</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">read</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">format</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"json"</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">load</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"examples/src/main/resources/people.json"</span><span class="o" style="color:rgb(102,102,102);">)</span>
<span class="n">peopleDF</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">select</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"name"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"age"</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">write</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">format</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"parquet"</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">save</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"namesAndAges.parquet"</span><span class="o" style="color:rgb(102,102,102);">)</span>
</pre></div><div><small style="font-size:11.9px;">Find full example code at "examples/src/main/scala/org/apache/spark/examples/sql/SQLDataSourceExample.scala" in the Spark repo.</small></div></div></div><h3 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);font-size:21px;">Run SQL on files directly<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#run-sql-on-files-directly" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h3><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Instead of using read API to load a file into DataFrame and query it, you can also query that file directly with SQL.</p><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_12" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_12" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_python" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_python_12" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Python</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_r" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_r_12" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>R</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">sqlDF</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">sql</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"SELECT * FROM parquet.`examples/src/main/resources/users.parquet`"</span><span class="o" style="color:rgb(102,102,102);">)</span>
</pre></div><div><small style="font-size:11.9px;">Find full example code at "examples/src/main/scala/org/apache/spark/examples/sql/SQLDataSourceExample.scala" in the Spark repo.</small></div></div></div><h3 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);font-size:21px;">Save Modes<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#save-modes" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h3><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Save operations can optionally take a <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SaveMode</code>, that specifies how to handle existing data if present. It is important to realize that these save modes do not utilize any locking and are not atomic. Additionally, when performing an <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">Overwrite</code>, the data will be deleted before writing out the new data.</p><table class="table" style="max-width:100%;border-spacing:0px;width:913.6px;margin-bottom:20px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><tbody><tr><th style="line-height:20px;vertical-align:top;">Scala/Java</th><th style="line-height:20px;vertical-align:top;">Any Language</th><th style="line-height:20px;vertical-align:top;">Meaning</th></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SaveMode.ErrorIfExists</code>(default)</td><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">"error"</code>(default)</td><td style="line-height:20px;vertical-align:top;">When saving a DataFrame to a data source, if data already exists, an exception is expected to be thrown.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SaveMode.Append</code></td><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">"append"</code></td><td style="line-height:20px;vertical-align:top;">When saving a DataFrame to a data source, if data/table already exists, contents of the DataFrame are expected to be appended to existing data.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SaveMode.Overwrite</code></td><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">"overwrite"</code></td><td style="line-height:20px;vertical-align:top;">Overwrite mode means that when saving a DataFrame to a data source, if data/table already exists, existing data is expected to be overwritten by the contents of the DataFrame.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SaveMode.Ignore</code></td><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">"ignore"</code></td><td style="line-height:20px;vertical-align:top;">Ignore mode means that when saving a DataFrame to a data source, if data already exists, the save operation is expected to not save the contents of the DataFrame and to not change the existing data. This is similar to a <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">CREATE TABLE IF NOT EXISTS</code> in SQL.</td></tr></tbody></table><h3 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);font-size:21px;">Saving to Persistent Tables<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#saving-to-persistent-tables" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h3><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DataFrames</code> can also be saved as persistent tables into Hive metastore using the <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">saveAsTable</code> command. Notice that an existing Hive deployment is not necessary to use this feature. Spark will create a default local Hive metastore (using Derby) for you. Unlike the <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">createOrReplaceTempView</code>command, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">saveAsTable</code> will materialize the contents of the DataFrame and create a pointer to the data in the Hive metastore. Persistent tables will still exist even after your Spark program has restarted, as long as you maintain your connection to the same metastore. A DataFrame for a persistent table can be created by calling the <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">table</code> method on a <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SparkSession</code> with the name of the table.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">For file-based data source, e.g. text, parquet, json, etc. you can specify a custom table path via the <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">path</code> option, e.g. <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">df.write.option("path", "/some/path").saveAsTable("t")</code>. When the table is dropped, the custom table path will not be removed and the table data is still there. If no custom table path is specified, Spark will write data to a default table path under the warehouse directory. When the table is dropped, the default table path will be removed too.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Starting from Spark 2.1, persistent datasource tables have per-partition metadata stored in the Hive metastore. This brings several benefits:</p><ul style="margin-bottom:10px;margin-left:25px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li style="line-height:20px;">Since the metastore can return only necessary partitions for a query, discovering all the partitions on the first query to the table is no longer needed.</li><li style="line-height:20px;">Hive DDLs such as <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">ALTER TABLE PARTITION ... SET LOCATION</code> are now available for tables created with the Datasource API.</li></ul><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Note that partition information is not gathered by default when creating external datasource tables (those with a <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">path</code> option). To sync the partition information in the metastore, you can invoke <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">MSCK REPAIR TABLE</code>.</p><h3 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);font-size:21px;">Bucketing, Sorting and Partitioning<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#bucketing-sorting-and-partitioning" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h3><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">For file-based data source, it is also possible to bucket and sort or partition the output. Bucketing and sorting are applicable only to persistent tables:</p><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_13" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_13" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_python" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_python_13" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Python</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_sql" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_sql_13" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Sql</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><span class="n">peopleDF</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">write</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">bucketBy</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">42</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"name"</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">sortBy</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"age"</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">saveAsTable</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"people_bucketed"</span><span class="o" style="color:rgb(102,102,102);">)</span>
</pre></div><div><small style="font-size:11.9px;">Find full example code at "examples/src/main/scala/org/apache/spark/examples/sql/SQLDataSourceExample.scala" in the Spark repo.</small></div></div></div><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">while partitioning can be used with both <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">save</code> and <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">saveAsTable</code> when using the Dataset APIs.</p><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_14" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_14" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_python" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_python_14" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Python</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_sql" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_sql_14" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Sql</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><span class="n">usersDF</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">write</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">partitionBy</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"favorite_color"</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">format</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"parquet"</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">save</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"namesPartByColor.parquet"</span><span class="o" style="color:rgb(102,102,102);">)</span>
</pre></div><div><small style="font-size:11.9px;">Find full example code at "examples/src/main/scala/org/apache/spark/examples/sql/SQLDataSourceExample.scala" in the Spark repo.</small></div></div></div><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">It is possible to use both partitioning and bucketing for a single table:</p><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_15" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_15" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_python" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_python_15" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Python</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_sql" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_sql_15" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Sql</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><span class="n">peopleDF</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">write</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">partitionBy</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"favorite_color"</span><span class="o" style="color:rgb(102,102,102);">)</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">bucketBy</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">42</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"name"</span><span class="o" style="color:rgb(102,102,102);">)</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">saveAsTable</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"people_partitioned_bucketed"</span><span class="o" style="color:rgb(102,102,102);">)</span>
</pre></div><div><small style="font-size:11.9px;">Find full example code at "examples/src/main/scala/org/apache/spark/examples/sql/SQLDataSourceExample.scala" in the Spark repo.</small></div></div></div><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">partitionBy</code> creates a directory structure as described in the <a href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#partition-discovery" rel="nofollow" style="color:rgb(0,136,204);">Partition Discovery</a> section. Thus, it has limited applicability to columns with high cardinality. In contrast <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">bucketBy</code> distributes data across a fixed number of buckets and can be used when a number of unique values is unbounded.</p><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Parquet Files<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#parquet-files" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><a href="http://parquet.io/" rel="nofollow" style="color:rgb(0,136,204);">Parquet</a> is a columnar format that is supported by many other data processing systems. Spark SQL provides support for both reading and writing Parquet files that automatically preserves the schema of the original data. When writing Parquet files, all columns are automatically converted to be nullable for compatibility reasons.</p><h3 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);font-size:21px;">Loading Data Programmatically<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#loading-data-programmatically" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h3><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Using the data from the above example:</p><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_16" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_16" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_python" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_python_16" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Python</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_r" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_r_16" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>R</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_sql" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_sql_16" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Sql</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Encoders for most common types are automatically provided by importing spark.implicits._</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">import</span> <span class="nn" style="color:rgb(14,132,181);font-weight:bold;">spark.implicits._</span>

<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">peopleDF</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">read</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">json</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"examples/src/main/resources/people.json"</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// DataFrames can be saved as Parquet files, maintaining the schema information</span>
<span class="n">peopleDF</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">write</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">parquet</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"people.parquet"</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Read in the parquet file created above</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Parquet files are self-describing so the schema is preserved</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// The result of loading a Parquet file is also a DataFrame</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">parquetFileDF</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">read</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">parquet</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"people.parquet"</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Parquet files can also be used to create a temporary view and then used in SQL statements</span>
<span class="n">parquetFileDF</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">createOrReplaceTempView</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"parquetFile"</span><span class="o" style="color:rgb(102,102,102);">)</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">namesDF</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">sql</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"SELECT name FROM parquetFile WHERE age BETWEEN 13 AND 19"</span><span class="o" style="color:rgb(102,102,102);">)</span>
<span class="n">namesDF</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">map</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">attributes</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=&gt;</span> <span class="s" style="color:rgb(64,112,160);">"Name: "</span> <span class="o" style="color:rgb(102,102,102);">+</span> <span class="n">attributes</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">0</span><span class="o" style="color:rgb(102,102,102);">)).</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +------------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |       value|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +------------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |Name: Justin|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +------------+</span>
</pre></div><div><small style="font-size:11.9px;">Find full example code at "examples/src/main/scala/org/apache/spark/examples/sql/SQLDataSourceExample.scala" in the Spark repo.</small></div></div></div><h3 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);font-size:21px;">Partition Discovery<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#partition-discovery" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h3><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Table partitioning is a common optimization approach used in systems like Hive. In a partitioned table, data are usually stored in different directories, with partitioning column values encoded in the path of each partition directory. The Parquet data source is now able to discover and infer partitioning information automatically. For example, we can store all our previously used population data into a partitioned table using the following directory structure, with two extra columns, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">gender</code> and <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">country</code> as partitioning columns:</p><div class="highlight" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><code class="language-text" style="font-family:Menlo, 'Lucida Console', monospace;font-size:12px;color:inherit;background:transparent;border:0px;">path
└── to
    └── table
        ├── gender=male
        │   ├── ...
        │   │
        │   ├── country=US
        │   │   └── data.parquet
        │   ├── country=CN
        │   │   └── data.parquet
        │   └── ...
        └── gender=female
            ├── ...
            │
            ├── country=US
            │   └── data.parquet
            ├── country=CN
            │   └── data.parquet
            └── ...</code></pre></div><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">By passing <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">path/to/table</code> to either <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SparkSession.read.parquet</code> or <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SparkSession.read.load</code>, Spark SQL will automatically extract the partitioning information from the paths. Now the schema of the returned DataFrame becomes:</p><div class="highlight" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><code class="language-text" style="font-family:Menlo, 'Lucida Console', monospace;font-size:12px;color:inherit;background:transparent;border:0px;">root
|-- name: string (nullable = true)
|-- age: long (nullable = true)
|-- gender: string (nullable = true)
|-- country: string (nullable = true)</code></pre></div><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Notice that the data types of the partitioning columns are automatically inferred. Currently, numeric data types and string type are supported. Sometimes users may not want to automatically infer the data types of the partitioning columns. For these use cases, the automatic type inference can be configured by <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.sources.partitionColumnTypeInference.enabled</code>, which is default to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">true</code>. When type inference is disabled, string type will be used for the partitioning columns.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Starting from Spark 1.6.0, partition discovery only finds partitions under the given paths by default. For the above example, if users pass <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">path/to/table/gender=male</code> to either <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SparkSession.read.parquet</code> or <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SparkSession.read.load</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">gender</code> will not be considered as a partitioning column. If users need to specify the base path that partition discovery should start with, they can set <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">basePath</code> in the data source options. For example, when <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">path/to/table/gender=male</code> is the path of the data and users set <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">basePath</code> to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">path/to/table/</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">gender</code> will be a partitioning column.</p><h3 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);font-size:21px;">Schema Merging<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#schema-merging" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h3><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Like ProtocolBuffer, Avro, and Thrift, Parquet also supports schema evolution. Users can start with a simple schema, and gradually add more columns to the schema as needed. In this way, users may end up with multiple Parquet files with different but mutually compatible schemas. The Parquet data source is now able to automatically detect this case and merge schemas of all these files.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Since schema merging is a relatively expensive operation, and is not a necessity in most cases, we turned it off by default starting from 1.5.0. You may enable it by</p><ol style="margin-bottom:10px;margin-left:25px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li style="line-height:20px;">setting data source option <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">mergeSchema</code> to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">true</code> when reading Parquet files (as shown in the examples below), or</li><li style="line-height:20px;">setting the global SQL option <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.parquet.mergeSchema</code> to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">true</code>.</li></ol><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_17" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_17" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_python" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_python_17" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Python</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_r" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_r_17" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>R</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><span class="c1" style="color:rgb(96,160,176);font-style:italic;">// This is used to implicitly convert an RDD to a DataFrame.</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">import</span> <span class="nn" style="color:rgb(14,132,181);font-weight:bold;">spark.implicits._</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Create a simple DataFrame, store into a partition directory</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">squaresDF</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">sparkContext</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">makeRDD</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">1</span> <span class="n">to</span> <span class="mi" style="color:rgb(64,160,112);">5</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">map</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">i</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=&gt;</span> <span class="o" style="color:rgb(102,102,102);">(</span><span class="n">i</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="n">i</span> <span class="o" style="color:rgb(102,102,102);">*</span> <span class="n">i</span><span class="o" style="color:rgb(102,102,102);">)).</span><span class="n">toDF</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"value"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"square"</span><span class="o" style="color:rgb(102,102,102);">)</span>
<span class="n">squaresDF</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">write</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">parquet</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"data/test_table/key=1"</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Create another DataFrame in a new partition directory,</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// adding a new column and dropping an existing column</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">cubesDF</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">sparkContext</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">makeRDD</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="mi" style="color:rgb(64,160,112);">6</span> <span class="n">to</span> <span class="mi" style="color:rgb(64,160,112);">10</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">map</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">i</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=&gt;</span> <span class="o" style="color:rgb(102,102,102);">(</span><span class="n">i</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="n">i</span> <span class="o" style="color:rgb(102,102,102);">*</span> <span class="n">i</span> <span class="o" style="color:rgb(102,102,102);">*</span> <span class="n">i</span><span class="o" style="color:rgb(102,102,102);">)).</span><span class="n">toDF</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"value"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"cube"</span><span class="o" style="color:rgb(102,102,102);">)</span>
<span class="n">cubesDF</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">write</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">parquet</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"data/test_table/key=2"</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Read the partitioned table</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">mergedDF</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">read</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">option</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"mergeSchema"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"true"</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">parquet</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"data/test_table"</span><span class="o" style="color:rgb(102,102,102);">)</span>
<span class="n">mergedDF</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">printSchema</span><span class="o" style="color:rgb(102,102,102);">()</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// The final schema consists of all 3 columns in the Parquet files together</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// with the partitioning column appeared in the partition directory paths</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// root</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">//  |-- value: int (nullable = true)</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">//  |-- square: int (nullable = true)</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">//  |-- cube: int (nullable = true)</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">//  |-- key: int (nullable = true)</span>
</pre></div><div><small style="font-size:11.9px;">Find full example code at "examples/src/main/scala/org/apache/spark/examples/sql/SQLDataSourceExample.scala" in the Spark repo.</small></div></div></div><h3 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);font-size:21px;">Hive metastore Parquet table conversion<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#hive-metastore-parquet-table-conversion" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h3><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">When reading from and writing to Hive metastore Parquet tables, Spark SQL will try to use its own Parquet support instead of Hive SerDe for better performance. This behavior is controlled by the <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.hive.convertMetastoreParquet</code> configuration, and is turned on by default.</p><h4 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:20px;color:rgb(29,31,34);font-size:18px;">Hive/Parquet Schema Reconciliation<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#hiveparquet-schema-reconciliation" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h4><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">There are two key differences between Hive and Parquet from the perspective of table schema processing.</p><ol style="margin-bottom:10px;margin-left:25px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li style="line-height:20px;">Hive is case insensitive, while Parquet is not</li><li style="line-height:20px;">Hive considers all columns nullable, while nullability in Parquet is significant</li></ol><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Due to this reason, we must reconcile Hive metastore schema with Parquet schema when converting a Hive metastore Parquet table to a Spark SQL Parquet table. The reconciliation rules are:</p><ol style="margin-bottom:10px;margin-left:25px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li style="line-height:20px;"><p style="margin-bottom:10px;">Fields that have the same name in both schema must have the same data type regardless of nullability. The reconciled field should have the data type of the Parquet side, so that nullability is respected.</p></li><li style="line-height:20px;"><p style="margin-bottom:10px;">The reconciled schema contains exactly those fields defined in Hive metastore schema.</p><ul style="margin-bottom:0px;margin-left:25px;"><li style="line-height:20px;">Any fields that only appear in the Parquet schema are dropped in the reconciled schema.</li><li style="line-height:20px;">Any fields that only appear in the Hive metastore schema are added as nullable field in the reconciled schema.</li></ul></li></ol><h4 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:20px;color:rgb(29,31,34);font-size:18px;">Metadata Refreshing<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#metadata-refreshing" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h4><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Spark SQL caches Parquet metadata for better performance. When Hive metastore Parquet table conversion is enabled, metadata of those converted tables are also cached. If these tables are updated by Hive or other external tools, you need to refresh them manually to ensure consistent metadata.</p><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_18" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_18" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_python" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_python_18" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Python</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_sql" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_sql_18" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Sql</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><code class="language-scala" style="font-family:Menlo, 'Lucida Console', monospace;font-size:12px;color:inherit;background:transparent;border:0px;"><span class="c1" style="color:rgb(96,160,176);font-style:italic;">// spark is an existing SparkSession</span>
<span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">catalog</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">refreshTable</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"my_table"</span><span class="o" style="color:rgb(102,102,102);">)</span></code></pre></div></div></div><h3 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);font-size:21px;">Configuration<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#configuration" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h3><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Configuration of Parquet can be done using the <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">setConf</code> method on <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SparkSession</code> or by running <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SET key=value</code> commands using SQL.</p><table class="table" style="max-width:100%;border-spacing:0px;width:913.6px;margin-bottom:20px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><tbody><tr><th style="line-height:20px;vertical-align:top;">Property Name</th><th style="line-height:20px;vertical-align:top;">Default</th><th style="line-height:20px;vertical-align:top;">Meaning</th></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.parquet.binaryAsString</code></td><td style="line-height:20px;vertical-align:top;">false</td><td style="line-height:20px;vertical-align:top;">Some other Parquet-producing systems, in particular Impala, Hive, and older versions of Spark SQL, do not differentiate between binary data and strings when writing out the Parquet schema. This flag tells Spark SQL to interpret binary data as a string to provide compatibility with these systems.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.parquet.int96AsTimestamp</code></td><td style="line-height:20px;vertical-align:top;">true</td><td style="line-height:20px;vertical-align:top;">Some Parquet-producing systems, in particular Impala and Hive, store Timestamp into INT96. This flag tells Spark SQL to interpret INT96 data as a timestamp to provide compatibility with these systems.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.parquet.cacheMetadata</code></td><td style="line-height:20px;vertical-align:top;">true</td><td style="line-height:20px;vertical-align:top;">Turns on caching of Parquet schema metadata. Can speed up querying of static data.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.parquet.compression.codec</code></td><td style="line-height:20px;vertical-align:top;">snappy</td><td style="line-height:20px;vertical-align:top;">Sets the compression codec use when writing Parquet files. Acceptable values include: uncompressed, snappy, gzip, lzo.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.parquet.filterPushdown</code></td><td style="line-height:20px;vertical-align:top;">true</td><td style="line-height:20px;vertical-align:top;">Enables Parquet filter push-down optimization when set to true.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.hive.convertMetastoreParquet</code></td><td style="line-height:20px;vertical-align:top;">true</td><td style="line-height:20px;vertical-align:top;">When set to false, Spark SQL will use the Hive SerDe for parquet tables instead of the built in support.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.parquet.mergeSchema</code></td><td style="line-height:20px;vertical-align:top;">false</td><td style="line-height:20px;vertical-align:top;"><p style="margin-bottom:10px;">When true, the Parquet data source merges schemas collected from all data files, otherwise the schema is picked from the summary file or a random data file if no summary file is available.</p></td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.optimizer.metadataOnly</code></td><td style="line-height:20px;vertical-align:top;">true</td><td style="line-height:20px;vertical-align:top;"><p style="margin-bottom:10px;">When true, enable the metadata-only query optimization that use the table's metadata to produce the partition columns instead of table scans. It applies when all the columns scanned are partition columns and the query has an aggregate operator that satisfies distinct semantics.</p></td></tr></tbody></table><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">JSON Datasets<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#json-datasets" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_19" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_19" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_python" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_python_19" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Python</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_r" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_r_19" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>R</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_sql" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_sql_19" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Sql</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><p style="margin-bottom:10px;">Spark SQL can automatically infer the schema of a JSON dataset and load it as a <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">Dataset[Row]</code>. This conversion can be done using <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SparkSession.read.json()</code> on either a <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">Dataset[String]</code>, or a JSON file.</p><p style="margin-bottom:10px;">Note that the file that is offered as <em>a json file</em> is not a typical JSON file. Each line must contain a separate, self-contained valid JSON object. For more information, please see <a href="http://jsonlines.org/" rel="nofollow" style="color:rgb(0,136,204);">JSON Lines text format, also called newline-delimited JSON</a>.</p><p style="margin-bottom:10px;">For a regular multi-line JSON file, set the <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">multiLine</code> option to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">true</code>.</p><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Primitive types (Int, String, etc) and Product types (case classes) encoders are</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// supported by importing this when creating a Dataset.</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">import</span> <span class="nn" style="color:rgb(14,132,181);font-weight:bold;">spark.implicits._</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// A JSON dataset is pointed to by path.</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// The path can be either a single text file or a directory storing text files</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">path</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="s" style="color:rgb(64,112,160);">"examples/src/main/resources/people.json"</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">peopleDF</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">read</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">json</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">path</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// The inferred schema can be visualized using the printSchema() method</span>
<span class="n">peopleDF</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">printSchema</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// root</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">//  |-- age: long (nullable = true)</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">//  |-- name: string (nullable = true)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Creates a temporary view using the DataFrame</span>
<span class="n">peopleDF</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">createOrReplaceTempView</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"people"</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// SQL statements can be run by using the sql methods provided by spark</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">teenagerNamesDF</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">sql</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"SELECT name FROM people WHERE age BETWEEN 13 AND 19"</span><span class="o" style="color:rgb(102,102,102);">)</span>
<span class="n">teenagerNamesDF</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |  name|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |Justin|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +------+</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Alternatively, a DataFrame can be created for a JSON dataset represented by</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// a Dataset[String] storing one JSON object per string</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">otherPeopleDataset</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">createDataset</span><span class="o" style="color:rgb(102,102,102);">(</span>
  <span class="s" style="color:rgb(64,112,160);">"""{"name":"Yin","address":{"city":"Columbus","state":"Ohio"}}"""</span> <span class="o" style="color:rgb(102,102,102);">::</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">Nil</span><span class="o" style="color:rgb(102,102,102);">)</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">otherPeople</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">read</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">json</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">otherPeopleDataset</span><span class="o" style="color:rgb(102,102,102);">)</span>
<span class="n">otherPeople</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +---------------+----+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |        address|name|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +---------------+----+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |[Columbus,Ohio]| Yin|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +---------------+----+</span>
</pre></div><div><small style="font-size:11.9px;">Find full example code at "examples/src/main/scala/org/apache/spark/examples/sql/SQLDataSourceExample.scala" in the Spark repo.</small></div></div></div><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Hive Tables<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#hive-tables" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Spark SQL also supports reading and writing data stored in <a href="http://hive.apache.org/" rel="nofollow" style="color:rgb(0,136,204);">Apache Hive</a>. However, since Hive has a large number of dependencies, these dependencies are not included in the default Spark distribution. If Hive dependencies can be found on the classpath, Spark will load them automatically. Note that these Hive dependencies must also be present on all of the worker nodes, as they will need access to the Hive serialization and deserialization libraries (SerDes) in order to access data stored in Hive.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Configuration of Hive is done by placing your <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">hive-site.xml</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">core-site.xml</code> (for security configuration), and <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">hdfs-site.xml</code> (for HDFS configuration) file in <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">conf/</code>.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">When working with Hive, one must instantiate <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SparkSession</code> with Hive support, including connectivity to a persistent Hive metastore, support for Hive serdes, and Hive user-defined functions. Users who do not have an existing Hive deployment can still enable Hive support. When not configured by the <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">hive-site.xml</code>, the context automatically creates <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">metastore_db</code> in the current directory and creates a directory configured by <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.warehouse.dir</code>, which defaults to the directory <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark-warehouse</code> in the current directory that the Spark application is started. Note that the <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">hive.metastore.warehouse.dir</code> property in <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">hive-site.xml</code> is deprecated since Spark 2.0.0. Instead, use <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.warehouse.dir</code> to specify the default location of database in warehouse. You may need to grant write privilege to the user who starts the Spark application.</p><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_20" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_20" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_python" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_python_20" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Python</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_r" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_r_20" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>R</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><span class="k" style="color:rgb(0,112,32);font-weight:bold;">import</span> <span class="nn" style="color:rgb(14,132,181);font-weight:bold;">java.io.File</span>

<span class="k" style="color:rgb(0,112,32);font-weight:bold;">import</span> <span class="nn" style="color:rgb(14,132,181);font-weight:bold;">org.apache.spark.sql.Row</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">import</span> <span class="nn" style="color:rgb(14,132,181);font-weight:bold;">org.apache.spark.sql.SparkSession</span>

<span class="k" style="color:rgb(0,112,32);font-weight:bold;">case</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">class</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">Record</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">key</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Int</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="n">value</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">String</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// warehouseLocation points to the default location for managed databases and tables</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">warehouseLocation</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">new</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">File</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"spark-warehouse"</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">getAbsolutePath</span>

<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">spark</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">SparkSession</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">builder</span><span class="o" style="color:rgb(102,102,102);">()</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">appName</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"Spark Hive Example"</span><span class="o" style="color:rgb(102,102,102);">)</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">config</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"spark.sql.warehouse.dir"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="n">warehouseLocation</span><span class="o" style="color:rgb(102,102,102);">)</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">enableHiveSupport</span><span class="o" style="color:rgb(102,102,102);">()</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">getOrCreate</span><span class="o" style="color:rgb(102,102,102);">()</span>

<span class="k" style="color:rgb(0,112,32);font-weight:bold;">import</span> <span class="nn" style="color:rgb(14,132,181);font-weight:bold;">spark.implicits._</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">import</span> <span class="nn" style="color:rgb(14,132,181);font-weight:bold;">spark.sql</span>

<span class="n">sql</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"CREATE TABLE IF NOT EXISTS src (key INT, value STRING) USING hive"</span><span class="o" style="color:rgb(102,102,102);">)</span>
<span class="n">sql</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"LOAD DATA LOCAL INPATH 'examples/src/main/resources/kv1.txt' INTO TABLE src"</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Queries are expressed in HiveQL</span>
<span class="n">sql</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"SELECT * FROM src"</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +---+-------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |key|  value|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +---+-------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |238|val_238|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// | 86| val_86|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |311|val_311|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// ...</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Aggregation queries are also supported.</span>
<span class="n">sql</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"SELECT COUNT(*) FROM src"</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +--------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |count(1)|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +--------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |    500 |</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +--------+</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// The results of SQL queries are themselves DataFrames and support all normal functions.</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">sqlDF</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">sql</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"SELECT key, value FROM src WHERE key &lt; 10 ORDER BY key"</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// The items in DataFrames are of type Row, which allows you to access each column by ordinal.</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">stringsDS</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">sqlDF</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">map</span> <span class="o" style="color:rgb(102,102,102);">{</span>
  <span class="k" style="color:rgb(0,112,32);font-weight:bold;">case</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">Row</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">key</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">Int</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="n">value</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">String</span><span class="o" style="color:rgb(102,102,102);">)</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=&gt;</span> <span class="n">s</span><span class="s" style="color:rgb(64,112,160);">"Key: $key, Value: $value"</span>
<span class="o" style="color:rgb(102,102,102);">}</span>
<span class="n">stringsDS</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +--------------------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |               value|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +--------------------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |Key: 0, Value: val_0|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |Key: 0, Value: val_0|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |Key: 0, Value: val_0|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// ...</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// You can also use DataFrames to create temporary views within a SparkSession.</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">recordsDF</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">createDataFrame</span><span class="o" style="color:rgb(102,102,102);">((</span><span class="mi" style="color:rgb(64,160,112);">1</span> <span class="n">to</span> <span class="mi" style="color:rgb(64,160,112);">100</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">map</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">i</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=&gt;</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">Record</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">i</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="n">s</span><span class="s" style="color:rgb(64,112,160);">"val_$i"</span><span class="o" style="color:rgb(102,102,102);">)))</span>
<span class="n">recordsDF</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">createOrReplaceTempView</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"records"</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Queries can then join DataFrame data with data stored in Hive.</span>
<span class="n">sql</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"SELECT * FROM records r JOIN src s ON r.key = s.key"</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">show</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +---+------+---+------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |key| value|key| value|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// +---+------+---+------+</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |  2| val_2|  2| val_2|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |  4| val_4|  4| val_4|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// |  5| val_5|  5| val_5|</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// ...</span>
</pre></div><div><small style="font-size:11.9px;">Find full example code at "examples/src/main/scala/org/apache/spark/examples/sql/hive/SparkHiveExample.scala" in the Spark repo.</small></div></div></div><h3 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);font-size:21px;">Specifying storage format for Hive tables<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#specifying-storage-format-for-hive-tables" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h3><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">When you create a Hive table, you need to define how this table should read/write data from/to file system, i.e. the “input format” and “output format”. You also need to define how this table should deserialize the data to rows, or serialize rows to data, i.e. the “serde”. The following options can be used to specify the storage format(“serde”, “input format”, “output format”), e.g. <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">CREATE TABLE src(id int) USING hive OPTIONS(fileFormat 'parquet')</code>. By default, we will read the table files as plain text. Note that, Hive storage handler is not supported yet when creating table, you can create a table using storage handler at Hive side, and use Spark SQL to read it.</p><table class="table" style="max-width:100%;border-spacing:0px;width:913.6px;margin-bottom:20px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><tbody><tr><th style="line-height:20px;vertical-align:top;">Property Name</th><th style="line-height:20px;vertical-align:top;">Meaning</th></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">fileFormat</code></td><td style="line-height:20px;vertical-align:top;">A fileFormat is kind of a package of storage format specifications, including "serde", "input format" and "output format". Currently we support 6 fileFormats: 'sequencefile', 'rcfile', 'orc', 'parquet', 'textfile' and 'avro'.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">inputFormat, outputFormat</code></td><td style="line-height:20px;vertical-align:top;">These 2 options specify the name of a corresponding `InputFormat` and `OutputFormat` class as a string literal, e.g. `org.apache.hadoop.hive.ql.io.orc.OrcInputFormat`. These 2 options must be appeared in pair, and you can not specify them if you already specified the `fileFormat` option.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">serde</code></td><td style="line-height:20px;vertical-align:top;">This option specifies the name of a serde class. When the `fileFormat` option is specified, do not specify this option if the given `fileFormat` already include the information of serde. Currently "sequencefile", "textfile" and "rcfile" don't include the serde information and you can use this option with these 3 fileFormats.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">fieldDelim, escapeDelim, collectionDelim, mapkeyDelim, lineDelim</code></td><td style="line-height:20px;vertical-align:top;">These options can only be used with "textfile" fileFormat. They define how to read delimited files into rows.</td></tr></tbody></table><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">All other properties defined with <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">OPTIONS</code> will be regarded as Hive serde properties.</p><h3 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);font-size:21px;">Interacting with Different Versions of Hive Metastore<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#interacting-with-different-versions-of-hive-metastore" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h3><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">One of the most important pieces of Spark SQL’s Hive support is interaction with Hive metastore, which enables Spark SQL to access metadata of Hive tables. Starting from Spark 1.4.0, a single binary build of Spark SQL can be used to query different versions of Hive metastores, using the configuration described below. Note that independent of the version of Hive that is being used to talk to the metastore, internally Spark SQL will compile against Hive 1.2.1 and use those classes for internal execution (serdes, UDFs, UDAFs, etc).</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">The following options can be used to configure the version of Hive that is used to retrieve metadata:</p><table class="table" style="max-width:100%;border-spacing:0px;width:913.6px;margin-bottom:20px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><tbody><tr><th style="line-height:20px;vertical-align:top;">Property Name</th><th style="line-height:20px;vertical-align:top;">Default</th><th style="line-height:20px;vertical-align:top;">Meaning</th></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.hive.metastore.version</code></td><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">1.2.1</code></td><td style="line-height:20px;vertical-align:top;">Version of the Hive metastore. Available options are <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">0.12.0</code>through <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">1.2.1</code>.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.hive.metastore.jars</code></td><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">builtin</code></td><td style="line-height:20px;vertical-align:top;">Location of the jars that should be used to instantiate the HiveMetastoreClient. This property can be one of three options:<ol style="margin-bottom:10px;margin-left:25px;"><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">builtin</code>Use Hive 1.2.1, which is bundled with the Spark assembly when </li></ol><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">-Phive</code> is enabled. When this option is chosen, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.hive.metastore.version</code> must be either <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">1.2.1</code>or not defined.<code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">maven</code>Use Hive jars of specified version downloaded from Maven repositories. This configuration is not generally recommended for production deployments.A classpath in the standard format for the JVM. This classpath must include all of Hive and its dependencies, including the correct version of Hadoop. These jars only need to be present on the driver, but if you are running in yarn cluster mode then you must ensure they are packaged with your application.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.hive.metastore.sharedPrefixes</code></td><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">com.mysql.jdbc,<br>org.postgresql,<br>com.microsoft.sqlserver,<br>oracle.jdbc</code></td><td style="line-height:20px;vertical-align:top;"><p style="margin-bottom:10px;">A comma separated list of class prefixes that should be loaded using the classloader that is shared between Spark SQL and a specific version of Hive. An example of classes that should be shared is JDBC drivers that are needed to talk to the metastore. Other classes that need to be shared are those that interact with classes that are already shared. For example, custom appenders that are used by log4j.</p></td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.hive.metastore.barrierPrefixes</code></td><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">(empty)</code></td><td style="line-height:20px;vertical-align:top;"><p style="margin-bottom:10px;">A comma separated list of class prefixes that should explicitly be reloaded for each version of Hive that Spark SQL is communicating with. For example, Hive UDFs that are declared in a prefix that typically would be shared (i.e. <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">org.apache.spark.*</code>).</p></td></tr></tbody></table><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">JDBC To Other Databases<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#jdbc-to-other-databases" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Spark SQL also includes a data source that can read data from other databases using JDBC. This functionality should be preferred over using <a href="http://spark.apache.org/docs/2.2.0/api/scala/index.html#org.apache.spark.rdd.JdbcRDD" rel="nofollow" style="color:rgb(0,136,204);">JdbcRDD</a>. This is because the results are returned as a DataFrame and they can easily be processed in Spark SQL or joined with other data sources. The JDBC data source is also easier to use from Java or Python as it does not require the user to provide a ClassTag. (Note that this is different than the Spark SQL JDBC server, which allows other applications to run queries using Spark SQL).</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">To get started you will need to include the JDBC driver for you particular database on the spark classpath. For example, to connect to postgres from the Spark Shell you would run the following command:</p><div class="highlight" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><code class="language-bash" style="font-family:Menlo, 'Lucida Console', monospace;font-size:12px;color:inherit;background:transparent;border:0px;">bin/spark-shell --driver-class-path postgresql-9.4.1207.jar --jars postgresql-9.4.1207.jar</code></pre></div><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Tables from the remote database can be loaded as a DataFrame or Spark SQL temporary view using the Data Sources API. Users can specify the JDBC connection properties in the data source options. <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">user</code> and <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">password</code> are normally provided as connection properties for logging into the data sources. In addition to the connection properties, Spark also supports the following case-insensitive options:</p><table class="table" style="max-width:100%;border-spacing:0px;width:913.6px;margin-bottom:20px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><tbody><tr><th style="line-height:20px;vertical-align:top;">Property Name</th><th style="line-height:20px;vertical-align:top;">Meaning</th></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">url</code></td><td style="line-height:20px;vertical-align:top;">The JDBC URL to connect to. The source-specific connection properties may be specified in the URL. e.g., <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">jdbc:postgresql://localhost/test?user=fred&amp;password=secret</code></td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">dbtable</code></td><td style="line-height:20px;vertical-align:top;">The JDBC table that should be read. Note that anything that is valid in a <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">FROM</code> clause of a SQL query can be used. For example, instead of a full table you could also use a subquery in parentheses.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">driver</code></td><td style="line-height:20px;vertical-align:top;">The class name of the JDBC driver to use to connect to this URL.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">partitionColumn, lowerBound, upperBound</code></td><td style="line-height:20px;vertical-align:top;">These options must all be specified if any of them is specified. In addition, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">numPartitions</code> must be specified. They describe how to partition the table when reading in parallel from multiple workers. <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">partitionColumn</code> must be a numeric column from the table in question. Notice that <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">lowerBound</code> and <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">upperBound</code> are just used to decide the partition stride, not for filtering the rows in table. So all rows in the table will be partitioned and returned. This option applies only to reading.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">numPartitions</code></td><td style="line-height:20px;vertical-align:top;">The maximum number of partitions that can be used for parallelism in table reading and writing. This also determines the maximum number of concurrent JDBC connections. If the number of partitions to write exceeds this limit, we decrease it to this limit by calling <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">coalesce(numPartitions)</code> before writing.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">fetchsize</code></td><td style="line-height:20px;vertical-align:top;">The JDBC fetch size, which determines how many rows to fetch per round trip. This can help performance on JDBC drivers which default to low fetch size (eg. Oracle with 10 rows). This option applies only to reading.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">batchsize</code></td><td style="line-height:20px;vertical-align:top;">The JDBC batch size, which determines how many rows to insert per round trip. This can help performance on JDBC drivers. This option applies only to writing. It defaults to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">1000</code>.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">isolationLevel</code></td><td style="line-height:20px;vertical-align:top;">The transaction isolation level, which applies to current connection. It can be one of <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">NONE</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">READ_COMMITTED</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">READ_UNCOMMITTED</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">REPEATABLE_READ</code>, or <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SERIALIZABLE</code>, corresponding to standard transaction isolation levels defined by JDBC's Connection object, with default of <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">READ_UNCOMMITTED</code>. This option applies only to writing. Please refer the documentation in <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">java.sql.Connection</code>.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">truncate</code></td><td style="line-height:20px;vertical-align:top;">This is a JDBC writer related option. When <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SaveMode.Overwrite</code> is enabled, this option causes Spark to truncate an existing table instead of dropping and recreating it. This can be more efficient, and prevents the table metadata (e.g., indices) from being removed. However, it will not work in some cases, such as when the new data has a different schema. It defaults to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">false</code>. This option applies only to writing.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">createTableOptions</code></td><td style="line-height:20px;vertical-align:top;">This is a JDBC writer related option. If specified, this option allows setting of database-specific table and partition options when creating a table (e.g., <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">CREATE TABLE t (name string) ENGINE=InnoDB.</code>). This option applies only to writing.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">createTableColumnTypes</code></td><td style="line-height:20px;vertical-align:top;">The database column data types to use instead of the defaults, when creating the table. Data type information should be specified in the same format as CREATE TABLE columns syntax (e.g: <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">"name CHAR(64), comments VARCHAR(1024)")</code>. The specified types should be valid spark sql data types. This option applies only to writing.</td></tr></tbody></table><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_21" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_21" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_python" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_python_21" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Python</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_r" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_r_21" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>R</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_sql" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_sql_21" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Sql</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Note: JDBC loading and saving can be achieved via either the load/save or jdbc methods</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Loading data from a JDBC source</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">jdbcDF</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">read</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">format</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"jdbc"</span><span class="o" style="color:rgb(102,102,102);">)</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">option</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"url"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"jdbc:postgresql:dbserver"</span><span class="o" style="color:rgb(102,102,102);">)</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">option</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"dbtable"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"schema.tablename"</span><span class="o" style="color:rgb(102,102,102);">)</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">option</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"user"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"username"</span><span class="o" style="color:rgb(102,102,102);">)</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">option</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"password"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"password"</span><span class="o" style="color:rgb(102,102,102);">)</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">load</span><span class="o" style="color:rgb(102,102,102);">()</span>

<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">connectionProperties</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">new</span> <span class="nc" style="color:rgb(14,132,181);font-weight:bold;">Properties</span><span class="o" style="color:rgb(102,102,102);">()</span>
<span class="n">connectionProperties</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">put</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"user"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"username"</span><span class="o" style="color:rgb(102,102,102);">)</span>
<span class="n">connectionProperties</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">put</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"password"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"password"</span><span class="o" style="color:rgb(102,102,102);">)</span>
<span class="k" style="color:rgb(0,112,32);font-weight:bold;">val</span> <span class="n">jdbcDF2</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=</span> <span class="n">spark</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">read</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">jdbc</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"jdbc:postgresql:dbserver"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"schema.tablename"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="n">connectionProperties</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Saving data to a JDBC source</span>
<span class="n">jdbcDF</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">write</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">format</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"jdbc"</span><span class="o" style="color:rgb(102,102,102);">)</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">option</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"url"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"jdbc:postgresql:dbserver"</span><span class="o" style="color:rgb(102,102,102);">)</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">option</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"dbtable"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"schema.tablename"</span><span class="o" style="color:rgb(102,102,102);">)</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">option</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"user"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"username"</span><span class="o" style="color:rgb(102,102,102);">)</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">option</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"password"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"password"</span><span class="o" style="color:rgb(102,102,102);">)</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">save</span><span class="o" style="color:rgb(102,102,102);">()</span>

<span class="n">jdbcDF2</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">write</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">jdbc</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"jdbc:postgresql:dbserver"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"schema.tablename"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="n">connectionProperties</span><span class="o" style="color:rgb(102,102,102);">)</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Specifying create table column data types on write</span>
<span class="n">jdbcDF</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">write</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">option</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"createTableColumnTypes"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"name CHAR(64), comments VARCHAR(1024)"</span><span class="o" style="color:rgb(102,102,102);">)</span>
  <span class="o" style="color:rgb(102,102,102);">.</span><span class="n">jdbc</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"jdbc:postgresql:dbserver"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"schema.tablename"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="n">connectionProperties</span><span class="o" style="color:rgb(102,102,102);">)</span>
</pre></div><div><small style="font-size:11.9px;">Find full example code at "examples/src/main/scala/org/apache/spark/examples/sql/SQLDataSourceExample.scala" in the Spark repo.</small></div></div></div><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Troubleshooting<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#troubleshooting" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><ul style="margin-bottom:10px;margin-left:25px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li style="line-height:20px;">The JDBC driver class must be visible to the primordial class loader on the client session and on all executors. This is because Java’s DriverManager class does a security check that results in it ignoring all drivers not visible to the primordial class loader when one goes to open a connection. One convenient way to do this is to modify compute_classpath.sh on all worker nodes to include your driver JARs.</li><li style="line-height:20px;">Some databases, such as H2, convert all names to upper case. You’ll need to use upper case to refer to those names in Spark SQL.</li></ul><h1 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Performance Tuning<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#performance-tuning" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h1><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">For some workloads it is possible to improve performance by either caching data in memory, or by turning on some experimental options.</p><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Caching Data In Memory<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#caching-data-in-memory" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Spark SQL can cache tables using an in-memory columnar format by calling <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.catalog.cacheTable("tableName")</code> or <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">dataFrame.cache()</code>. Then Spark SQL will scan only required columns and will automatically tune compression to minimize memory usage and GC pressure. You can call <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.catalog.uncacheTable("tableName")</code> to remove the table from memory.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Configuration of in-memory caching can be done using the <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">setConf</code> method on <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SparkSession</code> or by running <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SET key=value</code> commands using SQL.</p><table class="table" style="max-width:100%;border-spacing:0px;width:913.6px;margin-bottom:20px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><tbody><tr><th style="line-height:20px;vertical-align:top;">Property Name</th><th style="line-height:20px;vertical-align:top;">Default</th><th style="line-height:20px;vertical-align:top;">Meaning</th></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.inMemoryColumnarStorage.compressed</code></td><td style="line-height:20px;vertical-align:top;">true</td><td style="line-height:20px;vertical-align:top;">When set to true Spark SQL will automatically select a compression codec for each column based on statistics of the data.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.inMemoryColumnarStorage.batchSize</code></td><td style="line-height:20px;vertical-align:top;">10000</td><td style="line-height:20px;vertical-align:top;">Controls the size of batches for columnar caching. Larger batch sizes can improve memory utilization and compression, but risk OOMs when caching data.</td></tr></tbody></table><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Other Configuration Options<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#other-configuration-options" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">The following options can also be used to tune the performance of query execution. It is possible that these options will be deprecated in future release as more optimizations are performed automatically.</p><table class="table" style="max-width:100%;border-spacing:0px;width:913.6px;margin-bottom:20px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><tbody><tr><th style="line-height:20px;vertical-align:top;">Property Name</th><th style="line-height:20px;vertical-align:top;">Default</th><th style="line-height:20px;vertical-align:top;">Meaning</th></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.files.maxPartitionBytes</code></td><td style="line-height:20px;vertical-align:top;">134217728 (128 MB)</td><td style="line-height:20px;vertical-align:top;">The maximum number of bytes to pack into a single partition when reading files.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.files.openCostInBytes</code></td><td style="line-height:20px;vertical-align:top;">4194304 (4 MB)</td><td style="line-height:20px;vertical-align:top;">The estimated cost to open a file, measured by the number of bytes could be scanned in the same time. This is used when putting multiple files into a partition. It is better to over estimated, then the partitions with small files will be faster than partitions with bigger files (which is scheduled first).</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.broadcastTimeout</code></td><td style="line-height:20px;vertical-align:top;">300</td><td style="line-height:20px;vertical-align:top;"><p style="margin-bottom:10px;">Timeout in seconds for the broadcast wait time in broadcast joins</p></td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.autoBroadcastJoinThreshold</code></td><td style="line-height:20px;vertical-align:top;">10485760 (10 MB)</td><td style="line-height:20px;vertical-align:top;">Configures the maximum size in bytes for a table that will be broadcast to all worker nodes when performing a join. By setting this value to -1 broadcasting can be disabled. Note that currently statistics are only supported for Hive Metastore tables where the command <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">ANALYZE TABLE &lt;tableName&gt; COMPUTE STATISTICS noscan</code> has been run.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.shuffle.partitions</code></td><td style="line-height:20px;vertical-align:top;">200</td><td style="line-height:20px;vertical-align:top;">Configures the number of partitions to use when shuffling data for joins or aggregations.</td></tr></tbody></table><h1 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Distributed SQL Engine<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#distributed-sql-engine" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h1><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Spark SQL can also act as a distributed query engine using its JDBC/ODBC or command-line interface. In this mode, end-users or applications can interact with Spark SQL directly to run SQL queries, without the need to write any code.</p><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Running the Thrift JDBC/ODBC server<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#running-the-thrift-jdbcodbc-server" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">The Thrift JDBC/ODBC server implemented here corresponds to the <a href="https://cwiki.apache.org/confluence/display/Hive/Setting+Up+HiveServer2" rel="nofollow" style="color:rgb(0,136,204);"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(0,136,204);background:#FFFFFF;border:none;">HiveServer2</code></a> in Hive 1.2.1 You can test the JDBC server with the beeline script that comes with either Spark or Hive 1.2.1.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">To start the JDBC/ODBC server, run the following in the Spark directory:</p><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;font-size:13px;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><code style="font-family:Menlo, 'Lucida Console', monospace;font-size:12px;color:inherit;background:transparent;border:0px;">./sbin/start-thriftserver.sh
</code></pre><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">This script accepts all <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">bin/spark-submit</code> command line options, plus a <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">--hiveconf</code> option to specify Hive properties. You may run <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">./sbin/start-thriftserver.sh --help</code> for a complete list of all available options. By default, the server listens on localhost:10000. You may override this behaviour via either environment variables, i.e.:</p><div class="highlight" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><code class="language-bash" style="font-family:Menlo, 'Lucida Console', monospace;font-size:12px;color:inherit;background:transparent;border:0px;"><span class="nb" style="color:rgb(0,112,32);">export </span><span class="nv" style="color:rgb(187,96,213);">HIVE_SERVER2_THRIFT_PORT</span><span class="o" style="color:rgb(102,102,102);">=</span>&lt;listening-port&gt;
<span class="nb" style="color:rgb(0,112,32);">export </span><span class="nv" style="color:rgb(187,96,213);">HIVE_SERVER2_THRIFT_BIND_HOST</span><span class="o" style="color:rgb(102,102,102);">=</span>&lt;listening-host&gt;
./sbin/start-thriftserver.sh <span class="se" style="color:rgb(64,112,160);font-weight:bold;">\</span>
  --master &lt;master-uri&gt; <span class="se" style="color:rgb(64,112,160);font-weight:bold;">\</span>
  ...</code></pre></div><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">or system properties:</p><div class="highlight" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><code class="language-bash" style="font-family:Menlo, 'Lucida Console', monospace;font-size:12px;color:inherit;background:transparent;border:0px;">./sbin/start-thriftserver.sh <span class="se" style="color:rgb(64,112,160);font-weight:bold;">\</span>
  --hiveconf hive.server2.thrift.port<span class="o" style="color:rgb(102,102,102);">=</span>&lt;listening-port&gt; <span class="se" style="color:rgb(64,112,160);font-weight:bold;">\</span>
  --hiveconf hive.server2.thrift.bind.host<span class="o" style="color:rgb(102,102,102);">=</span>&lt;listening-host&gt; <span class="se" style="color:rgb(64,112,160);font-weight:bold;">\</span>
  --master &lt;master-uri&gt;
  ...</code></pre></div><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Now you can use beeline to test the Thrift JDBC/ODBC server:</p><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;font-size:13px;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><code style="font-family:Menlo, 'Lucida Console', monospace;font-size:12px;color:inherit;background:transparent;border:0px;">./bin/beeline
</code></pre><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Connect to the JDBC/ODBC server in beeline with:</p><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;font-size:13px;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><code style="font-family:Menlo, 'Lucida Console', monospace;font-size:12px;color:inherit;background:transparent;border:0px;">beeline&gt; !connect jdbc:hive2://localhost:10000
</code></pre><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Beeline will ask you for a username and password. In non-secure mode, simply enter the username on your machine and a blank password. For secure mode, please follow the instructions given in the <a href="https://cwiki.apache.org/confluence/display/Hive/HiveServer2+Clients" rel="nofollow" style="color:rgb(0,136,204);">beeline documentation</a>.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Configuration of Hive is done by placing your <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">hive-site.xml</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">core-site.xml</code> and <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">hdfs-site.xml</code> files in <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">conf/</code>.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">You may also use the beeline script that comes with Hive.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Thrift JDBC server also supports sending thrift RPC messages over HTTP transport. Use the following setting to enable HTTP mode as system property or in <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">hive-site.xml</code> file in <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">conf/</code>:</p><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;font-size:13px;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><code style="font-family:Menlo, 'Lucida Console', monospace;font-size:12px;color:inherit;background:transparent;border:0px;">hive.server2.transport.mode - Set this to value: http
hive.server2.thrift.http.port - HTTP port number to listen on; default is 10001
hive.server2.http.endpoint - HTTP endpoint; default is cliservice
</code></pre><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">To test, use beeline to connect to the JDBC/ODBC server in http mode with:</p><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;font-size:13px;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><code style="font-family:Menlo, 'Lucida Console', monospace;font-size:12px;color:inherit;background:transparent;border:0px;">beeline&gt; !connect jdbc:hive2://&lt;host&gt;:&lt;port&gt;/&lt;database&gt;?hive.server2.transport.mode=http;hive.server2.thrift.http.path=&lt;http_endpoint&gt;
</code></pre><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Running the Spark SQL CLI<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#running-the-spark-sql-cli" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">The Spark SQL CLI is a convenient tool to run the Hive metastore service in local mode and execute queries input from the command line. Note that the Spark SQL CLI cannot talk to the Thrift JDBC server.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">To start the Spark SQL CLI, run the following in the Spark directory:</p><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;font-size:13px;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><code style="font-family:Menlo, 'Lucida Console', monospace;font-size:12px;color:inherit;background:transparent;border:0px;">./bin/spark-sql
</code></pre><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Configuration of Hive is done by placing your <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">hive-site.xml</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">core-site.xml</code> and <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">hdfs-site.xml</code> files in <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">conf/</code>. You may run <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">./bin/spark-sql --help</code> for a complete list of all available options.</p><h1 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Migration Guide<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#migration-guide" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h1><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Upgrading From Spark SQL 2.1 to 2.2<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#upgrading-from-spark-sql-21-to-22" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><ul style="margin-bottom:10px;margin-left:25px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li style="line-height:20px;">Spark 2.1.1 introduced a new configuration key: <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.hive.caseSensitiveInferenceMode</code>. It had a default setting of <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">NEVER_INFER</code>, which kept behavior identical to 2.1.0. However, Spark 2.2.0 changes this setting’s default value to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">INFER_AND_SAVE</code> to restore compatibility with reading Hive metastore tables whose underlying file schema have mixed-case column names. With the <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">INFER_AND_SAVE</code> configuration value, on first access Spark will perform schema inference on any Hive metastore table for which it has not already saved an inferred schema. Note that schema inference can be a very time consuming operation for tables with thousands of partitions. If compatibility with mixed-case column names is not a concern, you can safely set <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.hive.caseSensitiveInferenceMode</code> to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">NEVER_INFER</code> to avoid the initial overhead of schema inference. Note that with the new default <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">INFER_AND_SAVE</code> setting, the results of the schema inference are saved as a metastore key for future use. Therefore, the initial schema inference occurs only at a table’s first access.</li></ul><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Upgrading From Spark SQL 2.0 to 2.1<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#upgrading-from-spark-sql-20-to-21" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><ul style="margin-bottom:10px;margin-left:25px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li style="line-height:20px;">Datasource tables now store partition metadata in the Hive metastore. This means that Hive DDLs such as <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">ALTER TABLE PARTITION ... SET LOCATION</code> are now available for tables created with the Datasource API.<ul style="margin-bottom:0px;margin-left:25px;"><li style="line-height:20px;">Legacy datasource tables can be migrated to this format via the <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">MSCK REPAIR TABLE</code> command. Migrating legacy tables is recommended to take advantage of Hive DDL support and improved planning performance.</li><li style="line-height:20px;">To determine if a table has been migrated, look for the <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">PartitionProvider: Catalog</code> attribute when issuing <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DESCRIBE FORMATTED</code> on the table.</li></ul></li><li style="line-height:20px;">Changes to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">INSERT OVERWRITE TABLE ... PARTITION ...</code> behavior for Datasource tables.<ul style="margin-bottom:0px;margin-left:25px;"><li style="line-height:20px;">In prior Spark versions <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">INSERT OVERWRITE</code> overwrote the entire Datasource table, even when given a partition specification. Now only partitions matching the specification are overwritten.</li><li style="line-height:20px;">Note that this still differs from the behavior of Hive tables, which is to overwrite only partitions overlapping with newly inserted data.</li></ul></li></ul><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Upgrading From Spark SQL 1.6 to 2.0<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#upgrading-from-spark-sql-16-to-20" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><ul style="margin-bottom:10px;margin-left:25px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li style="line-height:20px;"><p style="margin-bottom:10px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SparkSession</code> is now the new entry point of Spark that replaces the old <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SQLContext</code> and <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">HiveContext</code>. Note that the old SQLContext and HiveContext are kept for backward compatibility. A new <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">catalog</code> interface is accessible from <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SparkSession</code> - existing API on databases and tables access such as <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">listTables</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">createExternalTable</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">dropTempView</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">cacheTable</code> are moved here.</p></li><li style="line-height:20px;"><p style="margin-bottom:10px;">Dataset API and DataFrame API are unified. In Scala, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DataFrame</code> becomes a type alias for <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">Dataset[Row]</code>, while Java API users must replace <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DataFrame</code> with <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">Dataset&lt;Row&gt;</code>. Both the typed transformations (e.g., <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">map</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">filter</code>, and <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">groupByKey</code>) and untyped transformations (e.g., <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">select</code>and <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">groupBy</code>) are available on the Dataset class. Since compile-time type-safety in Python and R is not a language feature, the concept of Dataset does not apply to these languages’ APIs. Instead, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DataFrame</code> remains the primary programing abstraction, which is analogous to the single-node data frame notion in these languages.</p></li><li style="line-height:20px;">Dataset and DataFrame API <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">unionAll</code> has been deprecated and replaced by <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">union</code></li><li style="line-height:20px;">Dataset and DataFrame API <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">explode</code> has been deprecated, alternatively, use <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">functions.explode()</code> with <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">select</code> or <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">flatMap</code></li><li style="line-height:20px;"><p style="margin-bottom:10px;">Dataset and DataFrame API <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">registerTempTable</code> has been deprecated and replaced by <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">createOrReplaceTempView</code></p></li><li style="line-height:20px;">Changes to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">CREATE TABLE ... LOCATION</code> behavior for Hive tables.<ul style="margin-bottom:0px;margin-left:25px;"><li style="line-height:20px;">From Spark 2.0, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">CREATE TABLE ... LOCATION</code> is equivalent to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">CREATE EXTERNAL TABLE ... LOCATION</code> in order to prevent accidental dropping the existing data in the user-provided locations. That means, a Hive table created in Spark SQL with the user-specified location is always a Hive external table. Dropping external tables will not remove the data. Users are not allowed to specify the location for Hive managed tables. Note that this is different from the Hive behavior.</li><li style="line-height:20px;">As a result, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DROP TABLE</code> statements on those tables will not remove the data.</li></ul></li></ul><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Upgrading From Spark SQL 1.5 to 1.6<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#upgrading-from-spark-sql-15-to-16" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><ul style="margin-bottom:10px;margin-left:25px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li style="line-height:20px;">From Spark 1.6, by default the Thrift server runs in multi-session mode. Which means each JDBC/ODBC connection owns a copy of their own SQL configuration and temporary function registry. Cached tables are still shared though. If you prefer to run the Thrift server in the old single-session mode, please set option <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.hive.thriftServer.singleSession</code> to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">true</code>. You may either add this option to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark-defaults.conf</code>, or pass it to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">start-thriftserver.sh</code> via <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">--conf</code>:</li></ul><div class="highlight" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><code class="language-bash" style="font-family:Menlo, 'Lucida Console', monospace;font-size:12px;color:inherit;background:transparent;border:0px;">./sbin/start-thriftserver.sh <span class="se" style="color:rgb(64,112,160);font-weight:bold;">\</span>
     --conf spark.sql.hive.thriftServer.singleSession<span class="o" style="color:rgb(102,102,102);">=</span><span class="nb" style="color:rgb(0,112,32);">true</span> <span class="se" style="color:rgb(64,112,160);font-weight:bold;">\</span>
     ...</code></pre></div><ul style="margin-bottom:10px;margin-left:25px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li style="line-height:20px;"><p style="margin-bottom:10px;">Since 1.6.1, withColumn method in sparkR supports adding a new column to or replacing existing columns of the same name of a DataFrame.</p></li><li style="line-height:20px;"><p style="margin-bottom:10px;">From Spark 1.6, LongType casts to TimestampType expect seconds instead of microseconds. This change was made to match the behavior of Hive 1.2 for more consistent type casting to TimestampType from numeric types. See <a href="https://issues.apache.org/jira/browse/SPARK-11724" rel="nofollow" style="color:rgb(0,136,204);">SPARK-11724</a> for details.</p></li></ul><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Upgrading From Spark SQL 1.4 to 1.5<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#upgrading-from-spark-sql-14-to-15" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><ul style="margin-bottom:10px;margin-left:25px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li style="line-height:20px;">Optimized execution using manually managed memory (Tungsten) is now enabled by default, along with code generation for expression evaluation. These features can both be disabled by setting <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.tungsten.enabled</code> to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">false</code>.</li><li style="line-height:20px;">Parquet schema merging is no longer enabled by default. It can be re-enabled by setting <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.parquet.mergeSchema</code> to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">true</code>.</li><li style="line-height:20px;">Resolution of strings to columns in python now supports using dots (<code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">.</code>) to qualify the column or access nested values. For example <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">df['table.column.nestedField']</code>. However, this means that if your column name contains any dots you must now escape them using backticks (e.g., <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">table.`column.with.dots`.nested</code>).</li><li style="line-height:20px;">In-memory columnar storage partition pruning is on by default. It can be disabled by setting<code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.inMemoryColumnarStorage.partitionPruning</code> to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">false</code>.</li><li style="line-height:20px;">Unlimited precision decimal columns are no longer supported, instead Spark SQL enforces a maximum precision of 38. When inferring schema from <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">BigDecimal</code> objects, a precision of (38, 18) is now used. When no precision is specified in DDL then the default remains <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">Decimal(10, 0)</code>.</li><li style="line-height:20px;">Timestamps are now stored at a precision of 1us, rather than 1ns</li><li style="line-height:20px;">In the <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">sql</code> dialect, floating point numbers are now parsed as decimal. HiveQL parsing remains unchanged.</li><li style="line-height:20px;">The canonical name of SQL/DataFrame functions are now lower case (e.g., sum vs SUM).</li><li style="line-height:20px;">JSON data source will not automatically load new files that are created by other applications (i.e. files that are not inserted to the dataset through Spark SQL). For a JSON persistent table (i.e. the metadata of the table is stored in Hive Metastore), users can use <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">REFRESH TABLE</code>SQL command or <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">HiveContext</code>’s <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">refreshTable</code> method to include those new files to the table. For a DataFrame representing a JSON dataset, users need to recreate the DataFrame and the new DataFrame will include new files.</li><li style="line-height:20px;">DataFrame.withColumn method in pySpark supports adding a new column or replacing existing columns of the same name.</li></ul><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Upgrading from Spark SQL 1.3 to 1.4<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#upgrading-from-spark-sql-13-to-14" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><h4 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:20px;color:rgb(29,31,34);font-size:18px;">DataFrame data reader/writer interface<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#dataframe-data-readerwriter-interface" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h4><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Based on user feedback, we created a new, more fluid API for reading data in (<code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SQLContext.read</code>) and writing data out (<code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DataFrame.write</code>), and deprecated the old APIs (e.g., <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SQLContext.parquetFile</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SQLContext.jsonFile</code>).</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">See the API docs for <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SQLContext.read</code> ( <a href="http://spark.apache.org/docs/2.2.0/api/scala/index.html#org.apache.spark.sql.SQLContext@read:DataFrameReader" rel="nofollow" style="color:rgb(0,136,204);">Scala</a>, <a href="http://spark.apache.org/docs/2.2.0/api/java/org/apache/spark/sql/SQLContext.html#read()" rel="nofollow" style="color:rgb(0,136,204);">Java</a>, <a href="http://spark.apache.org/docs/2.2.0/api/python/pyspark.sql.html#pyspark.sql.SQLContext.read" rel="nofollow" style="color:rgb(0,136,204);">Python</a> ) and <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DataFrame.write</code> ( <a href="http://spark.apache.org/docs/2.2.0/api/scala/index.html#org.apache.spark.sql.DataFrame@write:DataFrameWriter" rel="nofollow" style="color:rgb(0,136,204);">Scala</a>, <a href="http://spark.apache.org/docs/2.2.0/api/java/org/apache/spark/sql/DataFrame.html#write()" rel="nofollow" style="color:rgb(0,136,204);">Java</a>, <a href="http://spark.apache.org/docs/2.2.0/api/python/pyspark.sql.html#pyspark.sql.DataFrame.write" rel="nofollow" style="color:rgb(0,136,204);">Python</a> ) more information.</p><h4 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:20px;color:rgb(29,31,34);font-size:18px;">DataFrame.groupBy retains grouping columns<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#dataframegroupby-retains-grouping-columns" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h4><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Based on user feedback, we changed the default behavior of <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DataFrame.groupBy().agg()</code> to retain the grouping columns in the resulting <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DataFrame</code>. To keep the behavior in 1.3, set <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">spark.sql.retainGroupColumns</code> to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">false</code>.</p><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_22" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_22" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_python" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_python_22" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Python</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><code class="language-scala" style="font-family:Menlo, 'Lucida Console', monospace;font-size:12px;color:inherit;background:transparent;border:0px;"><span class="c1" style="color:rgb(96,160,176);font-style:italic;">// In 1.3.x, in order for the grouping column "department" to show up,</span>
<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// it must be included explicitly as part of the agg function call.</span>
<span class="n">df</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">groupBy</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"department"</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">agg</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">$</span><span class="s" style="color:rgb(64,112,160);">"department"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="n">max</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"age"</span><span class="o" style="color:rgb(102,102,102);">),</span> <span class="n">sum</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"expense"</span><span class="o" style="color:rgb(102,102,102);">))</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// In 1.4+, grouping column "department" is included automatically.</span>
<span class="n">df</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">groupBy</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"department"</span><span class="o" style="color:rgb(102,102,102);">).</span><span class="n">agg</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="n">max</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"age"</span><span class="o" style="color:rgb(102,102,102);">),</span> <span class="n">sum</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"expense"</span><span class="o" style="color:rgb(102,102,102);">))</span>

<span class="c1" style="color:rgb(96,160,176);font-style:italic;">// Revert to 1.3 behavior (not retaining grouping column) by:</span>
<span class="n">sqlContext</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">setConf</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"spark.sql.retainGroupColumns"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="s" style="color:rgb(64,112,160);">"false"</span><span class="o" style="color:rgb(102,102,102);">)</span></code></pre></div></div></div><h4 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:20px;color:rgb(29,31,34);font-size:18px;">Behavior change on DataFrame.withColumn<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#behavior-change-on-dataframewithcolumn" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h4><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Prior to 1.4, DataFrame.withColumn() supports adding a column only. The column will always be added as a new column with its specified name in the result DataFrame even if there may be any existing columns of the same name. Since 1.4, DataFrame.withColumn() supports adding a column of a different name from names of all existing columns or replacing existing columns of the same name.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Note that this change is only for Scala API, not for PySpark and SparkR.</p><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Upgrading from Spark SQL 1.0-1.2 to 1.3<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#upgrading-from-spark-sql-10-12-to-13" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">In Spark 1.3 we removed the “Alpha” label from Spark SQL and as part of this did a cleanup of the available APIs. From Spark 1.3 onwards, Spark SQL will provide binary compatibility with other releases in the 1.X series. This compatibility guarantee excludes APIs that are explicitly marked as unstable (i.e., DeveloperAPI or Experimental).</p><h4 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:20px;color:rgb(29,31,34);font-size:18px;">Rename of SchemaRDD to DataFrame<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#rename-of-schemardd-to-dataframe" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h4><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">The largest change that users will notice when upgrading to Spark SQL 1.3 is that <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SchemaRDD</code> has been renamed to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DataFrame</code>. This is primarily because DataFrames no longer inherit from RDD directly, but instead provide most of the functionality that RDDs provide though their own implementation. DataFrames can still be converted to RDDs by calling the <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">.rdd</code> method.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">In Scala there is a type alias from <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SchemaRDD</code> to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DataFrame</code> to provide source compatibility for some use cases. It is still recommended that users update their code to use <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DataFrame</code> instead. Java and Python users will need to update their code.</p><h4 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:20px;color:rgb(29,31,34);font-size:18px;">Unification of the Java and Scala APIs<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#unification-of-the-java-and-scala-apis" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h4><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Prior to Spark 1.3 there were separate Java compatible classes (<code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">JavaSQLContext</code> and <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">JavaSchemaRDD</code>) that mirrored the Scala API. In Spark 1.3 the Java API and Scala API have been unified. Users of either language should use <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SQLContext</code> and <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DataFrame</code>. In general theses classes try to use types that are usable from both languages (i.e. <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">Array</code> instead of language specific collections). In some cases where no common type exists (e.g., for passing in closures or Maps) function overloading is used instead.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Additionally the Java specific types API has been removed. Users of both Scala and Java should use the classes present in <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">org.apache.spark.sql.types</code> to describe schema programmatically.</p><h4 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:20px;color:rgb(29,31,34);font-size:18px;">Isolation of Implicit Conversions and Removal of dsl Package (Scala-only)<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#isolation-of-implicit-conversions-and-removal-of-dsl-package-scala-only" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h4><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Many of the code examples prior to Spark 1.3 started with <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">import sqlContext._</code>, which brought all of the functions from sqlContext into scope. In Spark 1.3 we have isolated the implicit conversions for converting <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">RDD</code>s into <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DataFrame</code>s into an object inside of the <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SQLContext</code>. Users should now write <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">import sqlContext.implicits._</code>.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Additionally, the implicit conversions now only augment RDDs that are composed of <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">Product</code>s (i.e., case classes or tuples) with a method <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">toDF</code>, instead of applying automatically.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">When using function inside of the DSL (now replaced with the <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DataFrame</code> API) users used to import <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">org.apache.spark.sql.catalyst.dsl</code>. Instead the public dataframe functions API should be used: <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">import org.apache.spark.sql.functions._</code>.</p><h4 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:20px;color:rgb(29,31,34);font-size:18px;">Removal of the type aliases in org.apache.spark.sql for DataType (Scala-only)<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#removal-of-the-type-aliases-in-orgapachesparksql-for-datatype-scala-only" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h4><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Spark 1.3 removes the type aliases that were present in the base sql package for <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DataType</code>. Users should instead import the classes in <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">org.apache.spark.sql.types</code></p><h4 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:20px;color:rgb(29,31,34);font-size:18px;">UDF Registration Moved to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">sqlContext.udf</code> (Java &amp; Scala)<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#udf-registration-moved-to-sqlcontextudf-java--scala" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h4><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Functions that are used to register UDFs, either for use in the DataFrame DSL or SQL, have been moved into the udf object in <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SQLContext</code>.</p><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_23" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_23" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><code class="language-scala" style="font-family:Menlo, 'Lucida Console', monospace;font-size:12px;color:inherit;background:transparent;border:0px;"><span class="n">sqlContext</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">udf</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">register</span><span class="o" style="color:rgb(102,102,102);">(</span><span class="s" style="color:rgb(64,112,160);">"strLen"</span><span class="o" style="color:rgb(102,102,102);">,</span> <span class="o" style="color:rgb(102,102,102);">(</span><span class="n">s</span><span class="k" style="color:rgb(0,112,32);font-weight:bold;">:</span> <span class="kt" style="color:rgb(144,32,0);">String</span><span class="o" style="color:rgb(102,102,102);">)</span> <span class="k" style="color:rgb(0,112,32);font-weight:bold;">=&gt;</span> <span class="n">s</span><span class="o" style="color:rgb(102,102,102);">.</span><span class="n">length</span><span class="o" style="color:rgb(102,102,102);">())</span></code></pre></div></div></div><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Python UDF registration is unchanged.</p><h4 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:20px;color:rgb(29,31,34);font-size:18px;">Python DataTypes No Longer Singletons<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#python-datatypes-no-longer-singletons" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h4><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">When using DataTypes in Python you will need to construct them (i.e. <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">StringType()</code>) instead of referencing a singleton.</p><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Compatibility with Apache Hive<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#compatibility-with-apache-hive" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Spark SQL is designed to be compatible with the Hive Metastore, SerDes and UDFs. Currently Hive SerDes and UDFs are based on Hive 1.2.1, and Spark SQL can be connected to different versions of Hive Metastore (from 0.12.0 to 2.1.1. Also see [Interacting with Different Versions of Hive Metastore] (#interacting-with-different-versions-of-hive-metastore)).</p><h4 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:20px;color:rgb(29,31,34);font-size:18px;">Deploying in Existing Hive Warehouses<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#deploying-in-existing-hive-warehouses" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h4><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">The Spark SQL Thrift JDBC server is designed to be “out of the box” compatible with existing Hive installations. You do not need to modify your existing Hive Metastore or change the data placement or partitioning of your tables.</p><h3 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);font-size:21px;">Supported Hive Features<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#supported-hive-features" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h3><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Spark SQL supports the vast majority of Hive features, such as:</p><ul style="margin-bottom:10px;margin-left:25px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li style="line-height:20px;">Hive query statements, including:<ul style="margin-bottom:0px;margin-left:25px;"><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SELECT</code></li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">GROUP BY</code></li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">ORDER BY</code></li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">CLUSTER BY</code></li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SORT BY</code></li></ul></li><li style="line-height:20px;">All Hive operators, including:<ul style="margin-bottom:0px;margin-left:25px;"><li style="line-height:20px;">Relational operators (<code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">=</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">⇔</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">==</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">&lt;&gt;</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">&lt;</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">&gt;</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">&gt;=</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">&lt;=</code>, etc)</li><li style="line-height:20px;">Arithmetic operators (<code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">+</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">-</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">*</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">/</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">%</code>, etc)</li><li style="line-height:20px;">Logical operators (<code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">AND</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">&amp;&amp;</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">OR</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">||</code>, etc)</li><li style="line-height:20px;">Complex type constructors</li><li style="line-height:20px;">Mathematical functions (<code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">sign</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">ln</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">cos</code>, etc)</li><li style="line-height:20px;">String functions (<code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">instr</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">length</code>, <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">printf</code>, etc)</li></ul></li><li style="line-height:20px;">User defined functions (UDF)</li><li style="line-height:20px;">User defined aggregation functions (UDAF)</li><li style="line-height:20px;">User defined serialization formats (SerDes)</li><li style="line-height:20px;">Window functions</li><li style="line-height:20px;">Joins<ul style="margin-bottom:0px;margin-left:25px;"><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">JOIN</code></li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">{LEFT|RIGHT|FULL} OUTER JOIN</code></li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">LEFT SEMI JOIN</code></li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">CROSS JOIN</code></li></ul></li><li style="line-height:20px;">Unions</li><li style="line-height:20px;">Sub-queries<ul style="margin-bottom:0px;margin-left:25px;"><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SELECT col FROM ( SELECT a + b AS col from t1) t2</code></li></ul></li><li style="line-height:20px;">Sampling</li><li style="line-height:20px;">Explain</li><li style="line-height:20px;">Partitioned tables including dynamic partition insertion</li><li style="line-height:20px;">View</li><li style="line-height:20px;">All Hive DDL Functions, including:<ul style="margin-bottom:0px;margin-left:25px;"><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">CREATE TABLE</code></li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">CREATE TABLE AS SELECT</code></li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">ALTER TABLE</code></li></ul></li><li style="line-height:20px;">Most Hive Data types, including:<ul style="margin-bottom:0px;margin-left:25px;"><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">TINYINT</code></li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SMALLINT</code></li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">INT</code></li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">BIGINT</code></li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">BOOLEAN</code></li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">FLOAT</code></li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DOUBLE</code></li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">STRING</code></li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">BINARY</code></li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">TIMESTAMP</code></li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DATE</code></li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">ARRAY&lt;&gt;</code></li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">MAP&lt;&gt;</code></li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">STRUCT&lt;&gt;</code></li></ul></li></ul><h3 style="margin-top:10px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);font-size:21px;">Unsupported Hive Functionality<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#unsupported-hive-functionality" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h3><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Below is a list of Hive features that we don’t support yet. Most of these features are rarely used in Hive deployments.</p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><strong>Major Hive Features</strong></p><ul style="margin-bottom:10px;margin-left:25px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li style="line-height:20px;">Tables with buckets: bucket is the hash partitioning within a Hive table partition. Spark SQL doesn’t support buckets yet.</li></ul><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><strong>Esoteric Hive Features</strong></p><ul style="margin-bottom:10px;margin-left:25px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">UNION</code> type</li><li style="line-height:20px;">Unique join</li><li style="line-height:20px;">Column statistics collecting: Spark SQL does not piggyback scans to collect column statistics at the moment and only supports populating the sizeInBytes field of the hive metastore.</li></ul><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><strong>Hive Input/Output Formats</strong></p><ul style="margin-bottom:10px;margin-left:25px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li style="line-height:20px;">File format for CLI: For results showing back to the CLI, Spark SQL only supports TextOutputFormat.</li><li style="line-height:20px;">Hadoop archive</li></ul><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><strong>Hive Optimizations</strong></p><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">A handful of Hive optimizations are not yet included in Spark. Some of these (such as indexes) are less important due to Spark SQL’s in-memory computational model. Others are slotted for future releases of Spark SQL.</p><ul style="margin-bottom:10px;margin-left:25px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li style="line-height:20px;">Block level bitmap indexes and virtual columns (used to build indexes)</li><li style="line-height:20px;">Automatically determine the number of reducers for joins and groupbys: Currently in Spark SQL, you need to control the degree of parallelism post-shuffle using “<code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">SET spark.sql.shuffle.partitions=[num_tasks];</code>”.</li><li style="line-height:20px;">Meta-data only query: For queries that can be answered by using only meta data, Spark SQL still launches tasks to compute the result.</li><li style="line-height:20px;">Skew data flag: Spark SQL does not follow the skew data flags in Hive.</li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">STREAMTABLE</code> hint in join: Spark SQL does not follow the <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">STREAMTABLE</code> hint.</li><li style="line-height:20px;">Merge multiple small files for query results: if the result output contains multiple small files, Hive can optionally merge the small files into fewer large files to avoid overflowing the HDFS metadata. Spark SQL does not support that.</li></ul><h1 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Reference<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#reference" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h1><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">Data Types<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#data-types" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">Spark SQL and DataFrames support the following data types:</p><ul style="margin-bottom:10px;margin-left:25px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li style="line-height:20px;">Numeric types<ul style="margin-bottom:0px;margin-left:25px;"><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">ByteType</code>: Represents 1-byte signed integer numbers. The range of numbers is from <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">-128</code> to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">127</code>.</li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">ShortType</code>: Represents 2-byte signed integer numbers. The range of numbers is from <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">-32768</code> to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">32767</code>.</li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">IntegerType</code>: Represents 4-byte signed integer numbers. The range of numbers is from <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">-2147483648</code> to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">2147483647</code>.</li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">LongType</code>: Represents 8-byte signed integer numbers. The range of numbers is from <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">-9223372036854775808</code> to <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">9223372036854775807</code>.</li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">FloatType</code>: Represents 4-byte single-precision floating point numbers.</li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DoubleType</code>: Represents 8-byte double-precision floating point numbers.</li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DecimalType</code>: Represents arbitrary-precision signed decimal numbers. Backed internally by <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">java.math.BigDecimal</code>. A <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">BigDecimal</code> consists of an arbitrary precision integer unscaled value and a 32-bit integer scale.</li></ul></li><li style="line-height:20px;">String type<ul style="margin-bottom:0px;margin-left:25px;"><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">StringType</code>: Represents character string values.</li></ul></li><li style="line-height:20px;">Binary type<ul style="margin-bottom:0px;margin-left:25px;"><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">BinaryType</code>: Represents byte sequence values.</li></ul></li><li style="line-height:20px;">Boolean type<ul style="margin-bottom:0px;margin-left:25px;"><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">BooleanType</code>: Represents boolean values.</li></ul></li><li style="line-height:20px;">Datetime type<ul style="margin-bottom:0px;margin-left:25px;"><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">TimestampType</code>: Represents values comprising values of fields year, month, day, hour, minute, and second.</li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">DateType</code>: Represents values comprising values of fields year, month, day.</li></ul></li><li style="line-height:20px;">Complex types<ul style="margin-bottom:0px;margin-left:25px;"><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">ArrayType(elementType, containsNull)</code>: Represents values comprising a sequence of elements with the type of <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">elementType</code>. <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">containsNull</code> is used to indicate if elements in a <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">ArrayType</code> value can have <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">null</code> values.</li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">MapType(keyType, valueType, valueContainsNull)</code>: Represents values comprising a set of key-value pairs. The data type of keys are described by <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">keyType</code> and the data type of values are described by <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">valueType</code>. For a <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">MapType</code> value, keys are not allowed to have <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">null</code>values. <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">valueContainsNull</code> is used to indicate if values of a <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">MapType</code> value can have <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">null</code> values.</li><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">StructType(fields)</code>: Represents values with the structure described by a sequence of <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">StructField</code>s (<code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">fields</code>).<ul style="margin-bottom:0px;margin-left:25px;"><li style="line-height:20px;"><code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">StructField(name, dataType, nullable)</code>: Represents a field in a <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">StructType</code>. The name of a field is indicated by <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">name</code>. The data type of a field is indicated by <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">dataType</code>. <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">nullable</code> is used to indicate if values of this fields can have <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">null</code> values.</li></ul></li></ul></li></ul><ul class="nav nav-tabs" style="margin-bottom:20px;list-style:none;border-bottom:1px solid rgb(221,221,221);color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li class="active" style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_scala" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_scala_24" rel="nofollow" style="color:rgb(0,136,204);padding:8px 12px;margin-right:2px;line-height:20px;border-width:1px;border-style:solid;border-color:rgb(221,221,221) rgb(221,221,221) transparent;background-color:rgb(255,255,255);"><strong>Scala</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_java" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_java_24" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Java</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_python" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_python_24" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>Python</strong></a></li><li style="line-height:20px;float:left;margin-bottom:-1px;"><a class="tab_r" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#tab_r_24" rel="nofollow" style="color:rgb(51,51,51);padding:8px 12px;margin-right:2px;line-height:20px;border:1px solid transparent;"><strong>R</strong></a></li></ul><div class="codetabs tab-content" style="color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><div class="tab-pane active"><p style="margin-bottom:10px;">All data types of Spark SQL are located in the package <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">org.apache.spark.sql.types</code>. You can access them by doing</p><div class="highlight"><pre style="padding:9.5px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(51,51,51);margin-bottom:10px;white-space:pre-wrap;background-color:rgb(245,245,245);border:1px solid rgba(0,0,0,.15);"><span class="k" style="color:rgb(0,112,32);font-weight:bold;">import</span> <span class="nn" style="color:rgb(14,132,181);font-weight:bold;">org.apache.spark.sql.types._</span>
</pre></div><div><small style="font-size:11.9px;">Find full example code at "examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala" in the Spark repo.</small></div><table class="table" style="max-width:100%;border-spacing:0px;width:913.6px;margin-bottom:20px;"><tbody><tr><th style="line-height:20px;vertical-align:top;width:166.4px;">Data type</th><th style="line-height:20px;vertical-align:top;width:348.8px;">Value type in Scala</th><th style="line-height:20px;vertical-align:top;">API to access or create a data type</th></tr><tr><td style="line-height:20px;vertical-align:top;"><strong>ByteType</strong></td><td style="line-height:20px;vertical-align:top;">Byte</td><td style="line-height:20px;vertical-align:top;">ByteType</td></tr><tr><td style="line-height:20px;vertical-align:top;"><strong>ShortType</strong></td><td style="line-height:20px;vertical-align:top;">Short</td><td style="line-height:20px;vertical-align:top;">ShortType</td></tr><tr><td style="line-height:20px;vertical-align:top;"><strong>IntegerType</strong></td><td style="line-height:20px;vertical-align:top;">Int</td><td style="line-height:20px;vertical-align:top;">IntegerType</td></tr><tr><td style="line-height:20px;vertical-align:top;"><strong>LongType</strong></td><td style="line-height:20px;vertical-align:top;">Long</td><td style="line-height:20px;vertical-align:top;">LongType</td></tr><tr><td style="line-height:20px;vertical-align:top;"><strong>FloatType</strong></td><td style="line-height:20px;vertical-align:top;">Float</td><td style="line-height:20px;vertical-align:top;">FloatType</td></tr><tr><td style="line-height:20px;vertical-align:top;"><strong>DoubleType</strong></td><td style="line-height:20px;vertical-align:top;">Double</td><td style="line-height:20px;vertical-align:top;">DoubleType</td></tr><tr><td style="line-height:20px;vertical-align:top;"><strong>DecimalType</strong></td><td style="line-height:20px;vertical-align:top;">java.math.BigDecimal</td><td style="line-height:20px;vertical-align:top;">DecimalType</td></tr><tr><td style="line-height:20px;vertical-align:top;"><strong>StringType</strong></td><td style="line-height:20px;vertical-align:top;">String</td><td style="line-height:20px;vertical-align:top;">StringType</td></tr><tr><td style="line-height:20px;vertical-align:top;"><strong>BinaryType</strong></td><td style="line-height:20px;vertical-align:top;">Array[Byte]</td><td style="line-height:20px;vertical-align:top;">BinaryType</td></tr><tr><td style="line-height:20px;vertical-align:top;"><strong>BooleanType</strong></td><td style="line-height:20px;vertical-align:top;">Boolean</td><td style="line-height:20px;vertical-align:top;">BooleanType</td></tr><tr><td style="line-height:20px;vertical-align:top;"><strong>TimestampType</strong></td><td style="line-height:20px;vertical-align:top;">java.sql.Timestamp</td><td style="line-height:20px;vertical-align:top;">TimestampType</td></tr><tr><td style="line-height:20px;vertical-align:top;"><strong>DateType</strong></td><td style="line-height:20px;vertical-align:top;">java.sql.Date</td><td style="line-height:20px;vertical-align:top;">DateType</td></tr><tr><td style="line-height:20px;vertical-align:top;"><strong>ArrayType</strong></td><td style="line-height:20px;vertical-align:top;">scala.collection.Seq</td><td style="line-height:20px;vertical-align:top;">ArrayType(<em>elementType</em>, [<em>containsNull</em>])<br><strong>Note:</strong> The default value of <em>containsNull</em> is <em>true</em>.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><strong>MapType</strong></td><td style="line-height:20px;vertical-align:top;">scala.collection.Map</td><td style="line-height:20px;vertical-align:top;">MapType(<em>keyType</em>, <em>valueType</em>, [<em>valueContainsNull</em>])<br><strong>Note:</strong> The default value of <em>valueContainsNull</em> is <em>true</em>.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><strong>StructType</strong></td><td style="line-height:20px;vertical-align:top;">org.apache.spark.sql.Row</td><td style="line-height:20px;vertical-align:top;">StructType(<em>fields</em>)<br><strong>Note:</strong> <em>fields</em> is a Seq of StructFields. Also, two fields with the same name are not allowed.</td></tr><tr><td style="line-height:20px;vertical-align:top;"><strong>StructField</strong></td><td style="line-height:20px;vertical-align:top;">The value type in Scala of the data type of this field (For example, Int for a StructField with the data type IntegerType)</td><td style="line-height:20px;vertical-align:top;">StructField(<em>name</em>, <em>dataType</em>, [<em>nullable</em>])<br><strong>Note:</strong> The default value of <em>nullable</em> is <em>true</em>.</td></tr></tbody></table></div></div><h2 style="margin-top:12px;margin-bottom:10px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:40px;color:rgb(29,31,34);">NaN Semantics<a class="anchorjs-link" href="http://spark.apache.org/docs/2.2.0/sql-programming-guide.html#nan-semantics" rel="nofollow" style="color:rgb(0,136,204);font-family:'anchorjs-icons';font-weight:normal;padding-left:.375em;"></a></h2><p style="margin-bottom:10px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;">There is specially handling for not-a-number (NaN) when dealing with <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">float</code> or <code style="padding:0px;font-family:Menlo, 'Lucida Console', monospace;color:rgb(68,68,68);background:#FFFFFF;border:none;">double</code> types that does not exactly match standard floating point semantics. Specifically:</p><ul style="margin-bottom:10px;margin-left:25px;color:rgb(29,31,34);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;"><li style="line-height:20px;">NaN = NaN returns true.</li><li style="line-height:20px;">In aggregations all NaN values are grouped together.</li><li style="line-height:20px;">NaN is treated as a normal value in join keys.</li><li style="line-height:20px;">NaN values go last when in ascending order, larger than any other numeric value.</li></ul>            </div>
                </div>