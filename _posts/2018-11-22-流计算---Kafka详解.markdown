---
layout:     post
title:      流计算---Kafka详解
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                <div style="padding:0px;margin:0px;font-size:14px;background-color:rgb(255,255,255);font-family:'-apple-system', BlinkMacSystemFont, 'PingFang SC', Helvetica, Tahoma, Arial, 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', SimSun, '宋体', Heiti, '黑体', sans-serif;color:rgb(57,57,57);line-height:1.75;white-space:pre-wrap;"><p>理解storm、spark streamming等流式计算的数据来源、理解JMS规范、理解Kafka核心组件、掌握Kakfa生产者API、掌握Kafka消费者API。对流式计算的生态环境有深入的了解，具备流式计算项目架构的能力。所以学习kafka要掌握以下几点：</p></div><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;"></blockquote><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;"></blockquote><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);font-family:'-apple-system', BlinkMacSystemFont, 'PingFang SC', Helvetica, Tahoma, Arial, 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', SimSun, '宋体', Heiti, '黑体', sans-serif;text-align:left;white-space:pre-wrap;">1、  kafka是什么？</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;"></blockquote><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);font-family:'-apple-system', BlinkMacSystemFont, 'PingFang SC', Helvetica, Tahoma, Arial, 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', SimSun, '宋体', Heiti, '黑体', sans-serif;text-align:left;white-space:pre-wrap;">2、  JMS规范是什么？</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;"></blockquote><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);font-family:'-apple-system', BlinkMacSystemFont, 'PingFang SC', Helvetica, Tahoma, Arial, 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', SimSun, '宋体', Heiti, '黑体', sans-serif;text-align:left;white-space:pre-wrap;">3、  为什么需要消息队列？</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;"></blockquote><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);font-family:'-apple-system', BlinkMacSystemFont, 'PingFang SC', Helvetica, Tahoma, Arial, 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', SimSun, '宋体', Heiti, '黑体', sans-serif;text-align:left;white-space:pre-wrap;">4、  Kafka核心组件</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;"></blockquote><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);font-family:'-apple-system', BlinkMacSystemFont, 'PingFang SC', Helvetica, Tahoma, Arial, 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', SimSun, '宋体', Heiti, '黑体', sans-serif;text-align:left;white-space:pre-wrap;">5、  Kafka安装部署</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;"></blockquote><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);font-family:'-apple-system', BlinkMacSystemFont, 'PingFang SC', Helvetica, Tahoma, Arial, 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', SimSun, '宋体', Heiti, '黑体', sans-serif;text-align:left;white-space:pre-wrap;">6、  Kafka生产者Java API</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;"></blockquote><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);font-family:'-apple-system', BlinkMacSystemFont, 'PingFang SC', Helvetica, Tahoma, Arial, 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', SimSun, '宋体', Heiti, '黑体', sans-serif;text-align:left;white-space:pre-wrap;">7、  Kafka消费者Java API</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);white-space:pre-wrap;font-family:'-apple-system', BlinkMacSystemFont, 'PingFang SC', Helvetica, Tahoma, Arial, 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', SimSun, '宋体', Heiti, '黑体', sans-serif;">8、  Kafka整体结构图</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);white-space:pre-wrap;font-family:'-apple-system', BlinkMacSystemFont, 'PingFang SC', Helvetica, Tahoma, Arial, 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', SimSun, '宋体', Heiti, '黑体', sans-serif;">9、  Consumer与topic关系</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);white-space:pre-wrap;font-family:'-apple-system', BlinkMacSystemFont, 'PingFang SC', Helvetica, Tahoma, Arial, 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', SimSun, '宋体', Heiti, '黑体', sans-serif;">10、  Kafka  Producer消息分发</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);white-space:pre-wrap;font-family:'-apple-system', BlinkMacSystemFont, 'PingFang SC', Helvetica, Tahoma, Arial, 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', SimSun, '宋体', Heiti, '黑体', sans-serif;">11、  Consumer 的负载均衡</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);white-space:pre-wrap;font-family:'-apple-system', BlinkMacSystemFont, 'PingFang SC', Helvetica, Tahoma, Arial, 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', SimSun, '宋体', Heiti, '黑体', sans-serif;">12、  Kafka文件存储机制</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="font-size:14px;background-color:rgb(255,255,255);font-family:'-apple-system', BlinkMacSystemFont, 'PingFang SC', Helvetica, Tahoma, Arial, 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', SimSun, '宋体', Heiti, '黑体', sans-serif;color:rgb(57,57,57);"><span style="white-space:pre-wrap;"><span>13、  Kafka自定义partition</span></span></span><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;"></blockquote><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;"></blockquote><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;"></blockquote><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;"></blockquote><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;"></blockquote><h1 style="padding:0px;color:rgb(57,57,57);line-height:1.75;background-color:rgb(255,255,255);font-family:'-apple-system', BlinkMacSystemFont, 'PingFang SC', Helvetica, Tahoma, Arial, 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', SimSun, '宋体', Heiti, '黑体', sans-serif;white-space:pre-wrap;"><a></a><span style="font-size:24px;"><span>（一）kafka简介</span><span style="color:rgb(79,79,79);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;"> </span></span><span style="font-size:16px;color:rgb(79,79,79);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;">     </span></h1><h2 style="padding:0px;background-color:rgb(255,255,255);"><a></a>1、简介</h2><p style="background-color:rgb(255,255,255);">        Kafka是一种分布式的、基于发布/订阅的消息系统。在流式计算中，Kafka一般用来缓存数据，Storm通过消费Kafka的数据进行计算（KAFKA + STORM+REDIS）。 Apache Kafka是一个开源<span style="font-weight:700;"><span style="color:rgb(255,0,0);">消息</span></span>系统，由Scala写成。是由Apache软件基金会开发的一个开源消息系统项目。它最初是由LinkedIn开发，并于2011年初开源。2012年10月从ApacheIncubator毕业。该项目的目标是为处理实时数据提供一个统一、高通量、低等待的平台。</p><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• 特点：</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><address style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">    <span style="font-style:normal;">– 消息持久化：通过O(1)的磁盘数据结构提供数据的持久化<br>    – 高吞吐量：每秒百万级的消息读写<br>    – 分布式：扩展能力强<br>    – 多客户端支持：java、php、python、c++ ……<br>    – 实时性：生产者生产的message立即被消费者可见<br>    -Kafka是一个分布式消息队列：生产者、消费者的功能。它提供了类似于JMS的特性，但是在设计实现上完全不同，此外它并不是JMS规范的实现。<br>    - Kafka对消息保存时根据Topic进行归类，发送消息者称为Producer,消息接受者称为Consumer,此外kafka集群有多个kafka实例组成，每个实例(server)成为<br>    -无论是kafka集群，还是producer和consumer都依赖于zookeeper集群保存一些meta信息，来保证系统可用性</span></address><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"></span><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"><span style="font-size:14px;color:rgb(51,51,51);">  </span></p><h2 style="padding:0px;background-color:rgb(255,255,255);"><a></a>2、JMS是什么</h2><h3 style="padding:0px;background-color:rgb(255,255,255);"><a></a>2.1、JMS的基础</h3><p style="background-color:rgb(255,255,255);">         JMS是什么：JMS是Java提供的一套技术规范</p><p style="background-color:rgb(255,255,255);">JMS干什么用：用来异构系统 集成通信，缓解系统瓶颈，提高系统的伸缩性增强系统用户体验，使得系统模块化和组件化变得可行并更加灵活</p><p style="background-color:rgb(255,255,255);">通过什么方式：生产消费者模式（生产者、服务器、消费者）</p><p style="background-color:rgb(255,255,255);"><img src="https://img-blog.csdn.net/20180322212800623" alt=""></p><p style="background-color:rgb(255,255,255);">jdk，kafka，activemq……</p><h3 style="padding:0px;background-color:rgb(255,255,255);"><a></a>2.2、JMS消息传输模型</h3><p style="background-color:rgb(255,255,255);">l 点对点模式<span style="font-weight:700;">（一对一，消费者主动<span style="color:rgb(255,0,0);">拉取</span>数据，消息收到后消息清除）</span></p><p style="background-color:rgb(255,255,255);">点对点模型通常是一个基于拉取或者轮询的消息传送模型，这种模型从队列中请求信息，而不是将消息推送到客户端。这个模型的特点是发送到队列的消息被<span style="font-weight:700;"><span style="color:rgb(255,0,0);">一个且只有一个接收者接收处理</span></span>，即使有多个消息监听者也是如此。</p><p style="background-color:rgb(255,255,255);">l 发布/订阅模式<span style="font-weight:700;">（一对多，数据生产后，<span style="color:rgb(255,0,0);">推送</span>给所有订阅者）</span></p><p style="background-color:rgb(255,255,255);">发布订阅模型则是一个基于推送的消息传送模型。发布订阅模型可以有多种不同的订阅者，临时订阅者只在主动监听主题时才接收消息，而持久订阅者则监听主题的所有消息，<span style="font-weight:700;"><span style="color:rgb(255,0,0);">即时当前订阅者不可用，处于离线状态</span></span>。</p><p style="background-color:rgb(255,255,255);"><img src="https://img-blog.csdn.net/20180322212823321" alt=""></p><p style="background-color:rgb(255,255,255);">queue.put（object）  数据生产</p><p style="background-color:rgb(255,255,255);">queue.take(object)   数据消费</p><h3 style="padding:0px;background-color:rgb(255,255,255);"><a></a>2.3、JMS核心组件</h3><p style="background-color:rgb(255,255,255);">l Destination：消息发送的目的地，也就是前面说的Queue和Topic。</p><p style="background-color:rgb(255,255,255);"><a>l  Message </a><a>[m1]</a> ：从字面上就可以看出是被发送的消息。</p><p style="background-color:rgb(255,255,255);">l Producer： 消息的生产者，要发送一个消息，必须通过这个生产者来发送。</p><p style="background-color:rgb(255,255,255);">l MessageConsumer： 与生产者相对应，这是消息的消费者或接收者，通过它来接收一个消息。</p><p style="background-color:rgb(255,255,255);"> </p><p align="center" style="background-color:rgb(255,255,255);"><img src="https://img-blog.csdn.net/20180322212837595" alt=""></p><p align="center" style="background-color:rgb(255,255,255);">通过与ConnectionFactory可以获得一个connection</p><p align="center" style="background-color:rgb(255,255,255);">通过connection可以获得一个session会话。</p><p align="center" style="text-align:left;background-color:rgb(255,255,255);"> 其中message又细分为如下几类</p><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">StreamMessage：Java 数据流消息，用标准流操作来顺序的填充和读取。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">MapMessage：一个Map类型的消息；名称为 string 类型，而值为 Java 的基本类型。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">TextMessage：普通字符串消息，包含一个String。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">ObjectMessage：对象消息，包含一个可序列化的Java 对象</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">BytesMessage：二进制数组消息，包含一个byte[]。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">XMLMessage:  一个XML类型的消息。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><div style="padding:0px;margin:0px;color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><p>最常用的是TextMessage和ObjectMessage。</p></div><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><h3 style="padding:0px;background-color:rgb(255,255,255);"><a></a>2.4、常见的类JMS消息服务器</h3><h4 style="padding:0px;background-color:rgb(255,255,255);">2.4.1、JMS消息服务器 ActiveMQ</h4><p style="background-color:rgb(255,255,255);">ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的。</p><p style="background-color:rgb(255,255,255);">主要特点：</p><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 多种语言和协议编写客户端。语言: Java, C, C++, C#, Ruby, Perl, Python, PHP。应用协议:OpenWire,Stomp REST,WS Notification,XMPP,AMQP</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 完全支持JMS1.1和J2EE 1.4规范 (持久化,XA消息,事务)</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 对Spring的支持,ActiveMQ可以很容易内嵌到使用Spring的系统里面去,而且也支持Spring2.0的特性</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 通过了常见J2EE服务器(如 Geronimo,JBoss 4, GlassFish,WebLogic)的测试,其中通过JCA 1.5resource adaptors的配置,可以让ActiveMQ可以自动的部署到任何兼容J2EE 1.4 商业服务器上</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 支持多种传送协议:in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 支持通过JDBC和journal提供高速的消息持久化</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 从设计上保证了高性能的集群,客户端-服务器,点对点</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 支持Ajax</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 支持与Axis的整合</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><p style="background-color:rgb(255,255,255);">l 可以很容易得调用内嵌JMS provider,进行测试</p><h4 style="padding:0px;background-color:rgb(255,255,255);">2.4.2、分布式消息中间件 Metamorphosis</h4><h4 style="padding:0px;background-color:rgb(255,255,255);"><a style="font-size:16px;font-weight:normal;"></a> <span style="font-size:16px;font-weight:normal;">Metamorphosis</span><span style="font-size:16px;font-weight:normal;">(MetaQ) 是一个高性能、高可用、可扩展的分布式消息中间件，类似于LinkedIn的Kafka，具有消息存储顺序写、吞吐量大和支持本地和XA事务等特性，适用于大吞吐量、顺序消息、广播和日志数据传输等场景，在淘宝和支付宝有着广泛的应用，现已开源。</span></h4><p style="background-color:rgb(255,255,255);">主要特点：</p><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 生产者、服务器和消费者都可分布</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 消息存储顺序写</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 性能极高,吞吐量大</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 支持消息顺序</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 支持本地和XA事务</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 客户端pull，随机读,利用sendfile系统调用，zero-copy ,批量拉数据</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 支持消费端事务</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 支持消息广播模式</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 支持异步发送消息</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 支持http协议</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 支持消息重试和recover</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 数据迁移、扩容对用户透明</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 消费状态保存在客户端</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 支持同步和异步复制两种HA</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><p style="background-color:rgb(255,255,255);">l 支持group commit</p><h4 style="padding:0px;background-color:rgb(255,255,255);">2.4.3、分布式消息中间件 RocketMQ</h4><p style="background-color:rgb(255,255,255);">RocketMQ 是一款分布式、队列模型的消息中间件，具有以下特点：</p><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 能够保证严格的消息顺序<br>l 提供丰富的消息拉取模式<br>l 高效的订阅者水平扩展能力<br>l 实时的消息订阅机制<br>l 亿级消息堆积能力<br></span><p style="background-color:rgb(255,255,255);"><span style="font-size:14px;">l Metaq3.0 版本改名，产品名称改为RocketMQ</span></p><h4 style="padding:0px;background-color:rgb(255,255,255);">2.4.4、其他MQ</h4><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l .NET消息中间件DotNetMQ</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l 基于HBase的消息队列 HQueue</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l Go 的 MQ 框架 KiteQ</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l AMQP消息服务器RabbitMQ</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><p style="background-color:rgb(255,255,255);">l MemcacheQ 是一个基于MemcacheDB 的消息队列服务器。</p><div style="padding:0px;margin:0px;color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><h3 style="padding:0px;"><a></a>3、为什么需要消息队列（重要）</h3><p>消息系统的核心作用就是三点：解耦，异步和并行</p><p>以用户注册的案列来说明消息系统的作用</p><h4 style="padding:0px;">3.1、用户注册的一般流程</h4><p><img src="https://img-blog.csdn.net/20180322215806217" alt=""></p><p><span style="font-weight:700;"><span style="color:rgb(255,0,0);">问题</span></span>：随着后端流程越来越多，每步流程都需要额外的耗费很多时间，从而会导致用户更长的等待延迟。</p><h4 style="padding:0px;">3.2、用户注册的并行执行</h4><p><img src="https://img-blog.csdn.net/20180322215812782" alt=""></p><p><span style="font-weight:700;"><span style="color:rgb(255,0,0);">问题</span></span>：系统并行的发起了4个请求，4个请求中，如果某一个环节执行1分钟，其他环节再快，用户也需要等待1分钟。如果其中一个环节异常之后，整个服务挂掉了。</p><p><img src="https://img-blog.csdn.net/20180322215827968" alt=""></p><h4 style="padding:0px;">3.3、用户注册的最终一致</h4><p><img src="https://img-blog.csdn.net/20180322215903725" alt=""></p><p>1、  <span style="font-weight:700;"><span style="color:rgb(255,0,0);">保证主流程的正常执行</span></span>、执行成功之后，发送MQ消息出去。</p><p>2、  需要这个destination的其他系统通过消费数据再执行，最终一致。</p><img src="https://img-blog.csdn.net/20180322215911976" alt=""><br></div><h1 style="padding:0px;background-color:rgb(255,255,255);"><a></a>（二）Kafka基本组件</h1><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• Broker：每一台机器叫一个Broker</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;"></blockquote><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• Producer：日志消息生产者，用来写数据</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;"></blockquote><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• Consumer：消息的消费者，用来读数据</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;"></blockquote><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• Topic：不同消费者去指定的Topic中读，不同的生产者往不同的Topic中写</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• Partition：在Topic基础上做了进一步区分分层</span><div style="padding:0px;margin:0px;font-size:14px;background-color:rgb(255,255,255);font-family:'-apple-system', BlinkMacSystemFont, 'PingFang SC', Helvetica, Tahoma, Arial, 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', SimSun, '宋体', Heiti, '黑体', sans-serif;color:rgb(57,57,57);line-height:1.75;white-space:pre-wrap;"><span style="font-weight:bold;"><img src="https://img-blog.csdn.net/20180322220150374" alt=""><br></span></div><div style="padding:0px;margin:0px;font-size:14px;background-color:rgb(255,255,255);font-family:'-apple-system', BlinkMacSystemFont, 'PingFang SC', Helvetica, Tahoma, Arial, 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', SimSun, '宋体', Heiti, '黑体', sans-serif;color:rgb(57,57,57);line-height:1.75;white-space:pre-wrap;"><span>• Kafka内部是分布式的、一个Kafka集群通常包括多个Broker<br>• 负载均衡：将Topic分成多个分区，每个Broker存储一个或多个Partition<br>• 多个Producer和Consumer同时生产和消费消息</span><span><span style="font-weight:700;"><br></span></span></div><div style="padding:0px;margin:0px;font-size:14px;background-color:rgb(255,255,255);font-family:'-apple-system', BlinkMacSystemFont, 'PingFang SC', Helvetica, Tahoma, Arial, 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', SimSun, '宋体', Heiti, '黑体', sans-serif;color:rgb(57,57,57);line-height:1.75;white-space:pre-wrap;"><span style="font-weight:bold;"><img src="https://img-blog.csdn.net/20180322220238148" alt=""><br></span></div><h2 style="padding:0px;color:rgb(57,57,57);line-height:1.75;background-color:rgb(255,255,255);font-family:'-apple-system', BlinkMacSystemFont, 'PingFang SC', Helvetica, Tahoma, Arial, 'Hiragino Sans GB', 'Microsoft YaHei', '微软雅黑', SimSun, '宋体', Heiti, '黑体', sans-serif;white-space:pre-wrap;"><a></a><span><span style="font-size:18px;">2.1 topic</span></span></h2><p style="background-color:rgb(255,255,255);"><img src="https://img-blog.csdn.net/20180322220451477" alt=""></p><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• 一个Topic是一个用于发布消息的分类或feed名，kafka集群使用分区的日志，每个分区都是有顺序且不变的消息序列。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;"></blockquote><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• commit的log可以不断追加。消息在每个分区中都分配了一个叫offset的id序列来唯一识别分区中的消息。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><p style="background-color:rgb(255,255,255);">• 举例：若创建topic1和topic2两个topic，且分别有13个和19个分区，则整个集群上会相应会生成共32个文件夹，如图</p><p style="background-color:rgb(255,255,255);"><img src="https://img-blog.csdn.net/20180322220543527" alt=""><br></p><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• 无论发布的消息是否被消费，kafka都会持久化一定时间（可配置）。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• 在每个消费者都持久化这个offset在日志中。通常消费者读消息时会使offset值线性的增长，但实际上其位置是由消费者控制，它可以按任意顺序来消费消息。比如复位到老的offset来重新处理。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><p style="background-color:rgb(255,255,255);">• 每个分区代表一个并行单元。</p><h2 style="padding:0px;background-color:rgb(255,255,255);"><a></a>2.2 message</h2><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">• </span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">message</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">（消息）是通信的基本单位，每个</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">producer</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">可以向一个</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">topic</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">（主题）发布一些消息。如果</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">consumer</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">订阅了这个主题，那么新发布的消息就会广播给这些</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">consumer</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">• </span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">DFS</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">的基本单位</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">:block</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">• </span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">F</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">lume</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">的基本单位</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">:event</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">• </span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">Hadoop task</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">进程</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">• </span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">Spark task/partition </span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">线程</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">• </span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">messageformat(</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">磁盘上的存储格式</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">)</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">：</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">    –  message length :4 bytes (value: 1+4+n)</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">    –  "magic"value : 1 byte</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">    –  crc : 4 bytes</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><div style="padding:0px;margin:0px;color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><p><span style="color:rgb(68,84,106);">    –  payload : n bytes</span></p></div><h2 style="padding:0px;background-color:rgb(255,255,255);"><a></a><span style="color:rgb(68,84,106);">2.3 Producer</span></h2><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">• </span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">生产者可以发布数据到它指定的</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">topic</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">中，并可以指定在</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">topic</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">里哪些消息分配到哪些分区（比如简单的轮流分发各个分区或通过指定分区语义分配</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">key</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">到对应分区）key%3(partition)</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">•  </span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">生产者直接把消息发送给对应分区的</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">broker</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);">，而不需要任何路由层。</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(68,84,106);"> </span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><p style="color:rgb(68,84,106);background-color:rgb(255,255,255);"><span>•  </span><span>批处理发送，当</span><span>message</span><span>积累到一定数量或等待一定时间后进行发送。<br></span></p><p style="background-color:rgb(255,255,255);"><span style="color:rgb(68,84,106);">生产者常用API：</span></p><p style="background-color:rgb(255,255,255);"><span style="color:rgb(68,84,106);"><img src="https://img-blog.csdn.net/20180322221913221" alt=""><br></span></p><h2 style="padding:0px;background-color:rgb(255,255,255);"><a></a>2.4 Consumer</h2><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• 一种更抽象的消费方式：消费组（consumer group）</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• 该方式包含了传统的queue和发布订阅方式</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">    – 首先消费者标记自己一个消费组名。消息将投递到每个消费组中的某一个消费者实例上。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">    – 如果所有的消费者实例都有相同的消费组，这样就像传统的queue方式。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">    – 如果所有的消费者实例都有不同的消费组，这样就像传统的发布订阅方式。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">    – 消费组就好比是个逻辑的订阅者，每个订阅者由许多消费者实例构成(用于扩展或容错)。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• 相对于传统的消息系统，kafka拥有更强壮的顺序保证。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><p style="background-color:rgb(255,255,255);">• 由于topic采用了分区，可在多Consumer进程操作时保证顺序性和负载均衡。</p><p style="background-color:rgb(255,255,255);"><img src="https://img-blog.csdn.net/20180322221107278" alt=""><br></p><p style="background-color:rgb(255,255,255);">消费者常用API：</p><p style="background-color:rgb(255,255,255);"><img src="https://img-blog.csdn.net/2018032222194468" alt=""><br></p><h1 style="padding:0px;background-color:rgb(255,255,255);"><a></a>（三）kafka core</h1><h2 style="padding:0px;background-color:rgb(255,255,255);"><a></a>3.1 持久化</h2><p style="background-color:rgb(255,255,255);">• Kafka存储布局简单：Topic的每个Partition对应一个逻辑日志（一个日志为相同大小的一组分段文件）<br>• 每次生产者发布消息到一个分区，代理就将消息追加到最后一个段文件中。当发布的消息数量达到设定值或者经过一定的时间后，段文件真正flush磁盘中。写入完成后，消息公开给消费者。<br>• 与传统的消息系统不同，Kafka系统中存储的消息没有明确的消息Id。<br>• 消息通过日志中的逻辑偏移量来公开。<br></p><p style="background-color:rgb(255,255,255);"><img src="https://img-blog.csdn.net/20180323231055205" alt=""><br></p><h2 style="padding:0px;background-color:rgb(255,255,255);"><a></a>3.2 传输效率</h2><span style="font-size:14px;color:rgb(102,102,102);background-color:rgb(255,255,255);">• 生产者提交一批消息作为一个请求。消费者虽然利用api遍历消息是一个一个的，但背后也是一次请求获取一批数据，从而减少网络请求数量。<br></span><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;"></blockquote><span style="font-size:14px;color:rgb(102,102,102);background-color:rgb(255,255,255);">• Kafka层采用无缓存设计，而是依赖于底层的文件系统</span><span style="font-size:14px;color:rgb(255,0,0);background-color:rgb(255,255,255);">页缓存</span><span style="font-size:14px;color:rgb(102,102,102);background-color:rgb(255,255,255);">。这有助于避免双重缓存，及即消息只缓存了一份在页缓存中。同时这在kafka重启后保持缓存warm也有额外的优势。因kafka根本不缓存消息在进程中，故gc开销也就很小<br>• zero-copy：kafka为了减少字节拷贝，采用了大多数系统都会提供的</span><span style="font-size:14px;color:rgb(255,0,0);background-color:rgb(255,255,255);">sendfile系统</span><span style="font-size:14px;color:rgb(102,102,102);background-color:rgb(255,255,255);">调用<br>• 太多小的IO操作（message）以及过多的字节拷贝<br></span><div style="padding:0px;margin:0px;color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><p><span style="font-size:14px;color:rgb(102,102,102);">    --sendfile：实现页缓存和</span></p></div><p style="background-color:rgb(255,255,255);"><span style="color:rgb(68,84,106);"><img src="https://img-blog.csdn.net/20180323231501976" alt=""><br></span></p><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);text-align:left;">传统方式：1、操作系统将数据从磁盘读到内核空间的页缓存</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);text-align:left;">                2、应用（application）将数据从内核空间读到用户空间的页缓存</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);text-align:left;">                3、application将数据用户空间写到 socket buffer中</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);text-align:left;">                4、操作系统将数据从socket缓存写到网卡缓存中</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);text-align:left;">Zero copy：1、操作系统将数据从磁盘读到内核空间的页缓存</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);text-align:left;">                  2、read buffer （内核页缓存）socket buffer</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);text-align:left;">                  3、socket buffer缓存到NIC buffer （网卡缓存）</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><p align="center" style="text-align:left;background-color:rgb(255,255,255);">页缓存和块缓存的区别：（内核为块设备提供的两个通用的方案）<span style="color:rgb(68,84,106);">为了加快到后端设备的IO效率   </span></p><h2 style="padding:0px;background-color:rgb(255,255,255);"><a></a><span><span style="color:rgb(89,89,89);">3.3无状态的</span><span style="color:rgb(89,89,89);">Broker</span></span></h2><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• Kafka代理是无状态的：意味着消费者必须维护已消费的状态信息。这些信息由消费者自己维护，代理完全不管。这种设计非常微妙，它本身包含了创新</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">– 从代理删除消息变得很棘手，因为代理并不知道消费者是否已经使用了该消息。Kafka创新性地解决了这个问题，它将一个简单的</span><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(255,0,0);">基于时间</span></span><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">的</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(255,0,0);">SLA协议</span><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">应用于保留策略。当消息在代理中超过一定时间后，将会被自动删除。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><p style="background-color:rgb(255,255,255);">– 这种创新设计有很大的好处，消费者可以故意<span><span style="color:rgb(255,0,0);">倒回到</span></span>老的偏移量再次消费数据。这违反了队列的常见约定，但被证明是许多消费者的基本特征。</p><h2 style="padding:0px;background-color:rgb(255,255,255);"><a></a>3.4 交付保证</h2><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• Kafka默认采用at least once的消息投递策略。即在消费者端的处理顺序是获得消息-&gt;处理消息-&gt;保存位置。这可能导致一旦客户端挂掉，新的客户端接管时处理前面客户端已处理过的消息。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• 三种保证策略：</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">    – At most once 消息可能会丢，但绝不会重复传输</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">    – At least one 消息绝不会丢，但可能会重复传输</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><p style="background-color:rgb(255,255,255);">    – Exactly once 每条消息肯定会被传输一次且仅传输一次</p><h2 style="padding:0px;background-color:rgb(255,255,255);"><a></a>3.5 副本管理</h2><p style="background-color:rgb(255,255,255);">• kafka将日志复制到指定多个服务器上。<br>• 复本的单元是partition。在正常情况下，每个分区有一个leader和0到多个follower。<br>• leader处理对应分区上所有的读写请求。分区可以多于broker数，leader也是分布式的。<br></p><p style="background-color:rgb(255,255,255);">• follower的日志和leader的日志是相同的， follower被动的复制leader。如果leader挂了，其中一个follower会自动变成新的leader.</p><p style="background-color:rgb(255,255,255);"><img src="https://img-blog.csdn.net/20180324144141768" alt=""><br></p><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• 和其他分布式系统一样，节点“活着” 定义在于我们能否处理一些失败情况。kafka需要两个条件保证是“活着”</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">    – 节点在zookeeper注册的session还在且可维护（基于zookeeper心跳机制）</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">    – 如果是slave则能够紧随leader的更新不至于落得太远。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• kafka采用in sync来代替“活着”</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">    – 如果follower挂掉或卡住或落得很远，则leader会移除同步列表中的in sync。至于落了多远才叫远由replica.lag.max.messages配置，而表示复本“卡住”由replica.lag.time.max.ms配置</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• 所谓一条消息是“提交”的，意味着所有in sync的复本也持久化到了他们的log中。这意味着消费者无需担心leader挂掉导致数据丢失。另一方面，生产者可以选择是否等待消息“提交”。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);">• kafka动态的维护了一组in-sync(ISR)的复本，表示已追上了leader,只有处于该状态的成员组才是能被选择为leader。这些ISR组会在发生变化时被持久化到zookeeper中。通过ISR模型和f+1复本，可以让kafka的topic支持最多f个节点挂掉而不会导致提交的数据丢失。</p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><h2 style="padding:0px;background-color:rgb(255,255,255);"><a></a>3.6 分布式协调</h2><p style="background-color:rgb(255,255,255);">• 由于kafka中一个topic中的不同分区只能被消费组中的一个消费者消费，就避免了多个消费者消费相同的分区时会导致额外的开销（如要协调哪个消费者消费哪个消息，还有锁及状态的开销）。kafka中消费进程只需要在代理和同组消费者有变化时时进行一次协调（这种协调不是经常性的，故可以忽略开销）。<br>• kafka使用zookeeper做以下事情：<br>    – 探测broker和consumer的添加或移除<br>    – 当1发生时触发每个消费者进程的重新负载。<br></p><p style="background-color:rgb(255,255,255);">    – 维护消费关系和追踪消费者在分区消费的消息的offset。</p><h2 style="padding:0px;background-color:rgb(255,255,255);"><a></a>3.7 与zookkeeper的使用</h2><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• Broker Node Registry</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">    • /brokers/ids/[0...N] --&gt; host:port (ephemeral node)</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">        – broker启动时在/brokers/ids下创建一个znode，把broker id写进去。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">        – 因为broker把自己注册到zookeeper中实用的是瞬时节点，所以这个注册是动态的，如果broker宕机或者没有响应该节点就会被删除。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• Broker Topic Registry</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">    • /brokers/topics/[topic]/[0...N] --&gt; nPartions (ephemeral node)</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">        – 每个broker把自己存储和维护的partion信息注册到该路径下。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• Consumers and Consumer Groups</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">    – consumers也把它们自己注册到zookeeper上，用以保持消费负载平衡和offset记录。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">    – group id相同的多个consumer构成一个消费租，共同消费一个topic，同一个组的consumer会尽量均匀的消费，其中的一个consumer只会消费一个partion的数据。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• Consumer Id Registry</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">    • /consumers/[group_id]/ids/[consumer_id] --&gt; {"topic1": #streams, ...,"topicN": #streams} (ephemeral node)</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">        – 每个consumer在/consumers/[group_id]/ids下创建一个瞬时的唯一的consumer_id，用来描述当前该group下有哪些consumer是alive的，如果消费进程挂掉对应的consumer_id就会从该节点删除。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• Consumer Offset Tracking</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">    • /consumers/[group_id]/offsets/[topic]/[partition_id] --&gt;offset_counter_value ((persistent node)</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">        – consumer把每个partition的消费offset记录保存在该节点下。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• Partition Owner registry</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">    • /consumers/[group_id]/owners/[topic]/[broker_id-partition_id] --&gt;consumer_node_id (ephemeral node)</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;"><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p>        – 该节点维护着partion与consumer之间的对应关系。</p></blockquote><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><h2 style="padding:0px;background-color:rgb(255,255,255);"><a></a>3.8 Kafka对比其他消息服务</h2><p style="background-color:rgb(255,255,255);">• LinkedIn团队做了个实验研究，对比Kafka与Apache ActiveMQ V5.4和RabbitMQ V2.4的性能。他们使用ActiveMQ默认的消息持久化库Kahadb。LinkedIn在两台Linux机器上运行他们的实验，每台机器的配置为8核2GHz、16GB内存，6个磁盘使用RAID10。两台机器通过1GB网络连接。一台机器作为代理，另一台作为生产者或者消费者。<br></p><p style="background-color:rgb(255,255,255);">• 生产者测试：<br></p><p style="background-color:rgb(255,255,255);">    – 对每个系统，运行一个生产者，总共发布1000万条消息，每条消息200字节。Kafka生产者以1和50批量方式发送消息。ActiveMQ和RabbitMQ似乎没有简单的办法来批量发送消息，LinkedIn假定它的批量值为1。结果如下图所示：</p><p style="background-color:rgb(255,255,255);"><img src="https://img-blog.csdn.net/20180324145429746" alt=""><br></p><p style="background-color:rgb(255,255,255);">Kafka 性能要好很多的主要原因包括：<br>1. Kafka不等待代理的确认，以代理能处理的最快速度发送消息。<br></p><p style="background-color:rgb(255,255,255);">2. Kafka有更高效的存储格式。平均而言，Kafka每条消息有9字节的开销，而ActiveMQ有144字节。其原因是JMS所需的沉重消息头，以及维护各种索引结构的开销。LinkedIn注意到ActiveMQ一个最忙的线程大部分时间都在存取B-Tree以维护消息元数据和状态。</p><p style="background-color:rgb(255,255,255);">• 消费者测试：<br></p><p style="background-color:rgb(255,255,255);">    – 为了做消费者测试，LinkedIn使用一个消费者获取总共1000万条消息。LinkedIn让所有系统每次读取请求都预获取大约相同数量的数据，最多1000条消息或者200KB。对ActiveMQ和RabbitMQ，LinkedIn设置消费者确认模型为自动。结果如图所示。</p><p style="background-color:rgb(255,255,255);"><img src="https://img-blog.csdn.net/20180324145753681" alt=""><br></p><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">Kafka 性能要好很多的主要原因包括：</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;"></blockquote><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">1. Kafka有更高效的存储格式，在Kafka中，从代理传输到消费者的字节更少。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><p style="background-color:rgb(255,255,255);">2. ActiveMQ和RabbitMQ两个容器中的代理必须维护每个消息的传输状态。LinkedIn团队注意到其中一个ActiveMQ线程在测试过程中，一直在将KahaDB页写入磁盘。与此相反，Kafka代理没有磁盘写入动作。最后，Kafka通过使用sendfileAPI降低了传输开销</p><h1 style="padding:0px;background-color:rgb(255,255,255);"><a></a>（四）Kafka整体结构图</h1><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l  Producer ：消息生产者，就是向kafka broker发消息的客户端。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l  Consumer ：消息消费者，向kafka broker取消息的客户端</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l  Topic ：咋们可以理解为一个队列。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l  Consumer Group （CG）：这是kafka用来实现一个topic消息的广播（发给所有的consumer）和单播（发给任意一个consumer）的手段。一个topic可以有多个CG。topic的消息会</span><a style="font-size:14px;background-color:rgb(255,255,255);"></a><a style="font-size:14px;background-color:rgb(255,255,255);">复制（不是真的复制，是概念上的）到所有的</a><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">CG，但每个partion只会把消息发给该CG中的一个consumer。如果需要实现广播，只要每个consumer有一个独立的CG就可以了。要实现单播只要所有的consumer在同一个CG。用CG还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l  Broker ：一台kafka服务器就是一个broker。一个集群由多个broker组成。一个broker可以容纳多个topic。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l  Partition：为了实现扩展性，一个非常大的topic可以分布到多个broker（即服务器）上，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。kafka只保证按一个partition中的顺序将消息发给consumer，不保证一个topic的整体（多个partition间）的顺序。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);">l  Offset：kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。当然the first offset就是00000000000.kafka</p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><h1 style="padding:0px;background-color:rgb(255,255,255);"><a></a>（五）Consumer与topic关系</h1><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">本质上kafka只支持Topic；</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l  每个group中可以有多个consumer，每个consumer属于一个consumergroup；</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">        通常情况下，一个group中会包含多个consumer，这样不仅可以提高topic中消息的并发消费能力，而且还能提高"故障容错"性，如果group中的某个consumer失效那么其消费的partitions将会有其他consumer自动接管。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l  对于Topic中的一条特定的消息，只会被订阅此Topic的每个group中的其中一个consumer消费，此消息不会发送给一个group的多个consumer；</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">        那么一个group中所有的consumer将会交错的消费整个Topic，每个group中consumer消息消费互相独立，我们可以认为一个group是一个"订阅"者。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l  在kafka中,一个partition中的消息只会被group中的一个consumer消费</span><span style="font-weight:700;color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(255,0,0);">(</span><span style="color:rgb(255,0,0);">同一时刻</span><span style="color:rgb(255,0,0);">)</span></span><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">；</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">        一个Topic中的每个partions，只会被一个"订阅者"中的一个consumer消费，不过一个consumer可以同时消费多个partitions中的消息。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l  kafka的设计原理决定,对于一个topic，同一个group中不能有多于partitions个数的consumer同时消费，否则将意味着某些consumer将无法得到消息。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;"><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p><span style="font-weight:700;"><span style="color:rgb(255,0,0);">kafka</span><span style="color:rgb(255,0,0);">只能保证一个</span><span style="color:rgb(255,0,0);">partition</span><span style="color:rgb(255,0,0);">中的消息被某个</span><span style="color:rgb(255,0,0);">consumer</span><span style="color:rgb(255,0,0);">消费时是顺序的；事实上，从</span><span style="color:rgb(255,0,0);">Topic</span><span style="color:rgb(255,0,0);">角度来说</span><span style="color:rgb(255,0,0);">,</span><span style="color:rgb(255,0,0);">当有多个</span><span style="color:rgb(255,0,0);">partitions</span><span style="color:rgb(255,0,0);">时</span><span style="color:rgb(255,0,0);">,</span><span style="color:rgb(255,0,0);">消息仍不是全局有序的。</span></span></p></blockquote><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><h1 style="padding:0px;background-color:rgb(255,255,255);"><a></a>（六）Kafka消息的分发</h1><h2 style="padding:0px;background-color:rgb(255,255,255);"><a></a><span style="color:rgb(255,0,0);">6.1、Producer</span><span style="color:rgb(255,0,0);">客户端负责消息的分发</span></h2><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l  kafka集群中的任何一个broker都可以向producer提供metadata信息,这些metadata中包含"集群中存活的servers列表"/"partitions leader列表"等信息；</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l  当producer获取到metadata信息之后,producer将会和Topic下所有partition leader保持socket连接；</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l  消息由producer直接通过socket发送到broker，中间不会经过任何"路由层"，事实上，消息被路由到哪个partition上由producer客户端决定；</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">比如可以采用"random""key-hash""轮询"等,</span><span style="font-weight:700;color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(255,0,0);">如果一个</span><span style="color:rgb(255,0,0);">topic</span><span style="color:rgb(255,0,0);">中有多个</span><span style="color:rgb(255,0,0);">partitions,</span><span style="color:rgb(255,0,0);">那么在</span><span style="color:rgb(255,0,0);">producer</span><span style="color:rgb(255,0,0);">端实现</span><span style="color:rgb(255,0,0);">"</span><span style="color:rgb(255,0,0);">消息均衡分发</span><span style="color:rgb(255,0,0);">"</span><span style="color:rgb(255,0,0);">是必要的。</span></span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><p style="background-color:rgb(255,255,255);">l  在producer端的配置文件中,开发者可以指定partition路由的方式。</p><h2 style="padding:0px;background-color:rgb(255,255,255);"><a></a>6.2、Producer消息发送的应答机制</h2><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">设置发送数据是否需要服务端的反馈,有三个值0,1,-1</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;">0: producer不会等待broker发送ack<br>1: 当leader接收到消息之后发送ack<p>-1: 当所有的follower都同步消息成功后发送ack</p></blockquote><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"> request.required.acks=0</p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><h1 style="padding:0px;background-color:rgb(255,255,255);"><a></a>（七）<span><span style="color:rgb(51,51,51);">Consumer</span><span style="color:rgb(51,51,51);">的负载均衡</span></span></h1><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">当一个group中,有consumer加入或者离开时,会触发partitions均衡.均衡的最终目的,是提升topic的并发消费能力，步骤如下：</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">1、   假如topic1,具有如下partitions: P0,P1,P2,P3</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">2、   加入group中,有如下consumer: C1,C2</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">3、   首先根据partition索引号对partitions排序: P0,P1,P2,P3</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">4、   根据consumer.id排序: C0,C1</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">5、   计算倍数: M = [P0,P1,P2,P3].size / [C0,C1].size,本例值M=2(向上取整)</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"><span style="font-weight:700;"><span style="color:rgb(51,51,51);"></span></span></p><p style="background-color:rgb(255,255,255);">6、   然后依次分配partitions: C0 = [P0,P1],C1=[P2,P3],即Ci = [P(i *M),P((i + 1) * M -1)]</p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"><span style="font-weight:700;"><span style="color:rgb(51,51,51);"><img src="https://img-blog.csdn.net/20180324154226353" alt=""><br></span></span></p><h1 style="padding:0px;background-color:rgb(255,255,255);"><a></a><span><span style="color:rgb(51,51,51);">（八）Kafka文件存<span>储机制</span></span></span></h1><p style="background-color:rgb(255,255,255);"><span style="font-weight:bold;"><span style="color:rgb(51,51,51);"><span style="color:rgb(0,0,0);"><span></span></span></span></span></p><h2 style="padding:0px;background-color:rgb(255,255,255);"><a></a>8.1、Kafka文件存储基本结构</h2><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">l  在Kafka文件存储中，同一个topic下有多个不同partition，每个partition为一个目录，partiton命名规则为topic名称+有序序号，第一个partiton序号从0开始，序号最大值为partitions数量减1。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"><span style="font-weight:bold;"><span style="color:rgb(51,51,51);"><span style="color:rgb(0,0,0);"><span></span></span></span></span></p><p style="background-color:rgb(255,255,255);">l  每个partion(目录)相当于一个巨型文件被平均分配到多个大小相等segment(段)数据文件中。<span style="font-weight:700;"><span style="color:rgb(255,0,0);">但每个段</span><span style="color:rgb(255,0,0);">segmentfile</span><span style="color:rgb(255,0,0);">消息数量不一定相等</span></span>，这种特性方便oldsegment file快速被删除。默认保留7天的数据。</p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"><span style="font-weight:bold;"><span style="color:rgb(51,51,51);"><span style="color:rgb(0,0,0);"><img src="https://img-blog.csdn.net/20180324154741867" alt=""></span></span></span></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"><span><span style="font-weight:700;"><span style="font-size:14px;color:rgb(102,102,102);"><span>l  </span>每个partiton只需要支持顺序读写就行了，segment文件生命周期由服务端配置参数决定。（什么时候创建，什么时候删除）</span></span></span></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"><span style="color:rgb(0,0,0);"><span style="font-weight:700;"><img src="https://img-blog.csdn.net/2018032415484977" alt=""><br></span></span></p><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">数据有序的讨论？</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">         一个partition的数据是否是有序的？          间隔性有序，不连续</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">         针对一个topic里面的数据，只能做到partition内部有序，不能做到全局有序。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">         特别加入消费者的场景后，如何保证消费者消费的数据全局有序的？伪命题。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;"><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p><span style="color:rgb(0,0,0);"><span style="font-weight:700;"></span></span></p><p> 只有一种情况下才能保证全局有序？就是只有一个partition。</p></blockquote><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"><span style="color:rgb(0,0,0);"><span style="font-weight:700;"></span></span></p><h2 style="padding:0px;background-color:rgb(255,255,255);"><a></a>8.2、Kafka Partition <span style="color:rgb(0,0,0);">Segment</span></h2><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(0,0,0);">l </span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(0,0,0);">Segment</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(0,0,0);"> file</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(0,0,0);">组成：由2</span><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">大部分组成，分别为index file和data file，此2个文件一一对应，成对出现，后缀".index"和“.log”分别表示为segment索引文件、数据文件。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(0,0,0);">l </span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(0,0,0);">Segment</span><span style="font-size:14px;background-color:rgb(255,255,255);color:rgb(0,0,0);">文件命名规则：partion</span><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset值。数值最大为64位long大小，19位数字字符长度，没有数字用0填充。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"><span style="color:rgb(0,0,0);"><span style="font-weight:700;"></span></span></p><p style="background:rgb(255,255,255);"><span style="color:rgb(0,0,0);">l </span><span style="color:rgb(62,62,62);">索引文件存储大量元数据，数据文件存储大量消息，索引文件中元数据指向对应数据文件中message</span>的物理偏移地址。</p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="text-align:center;background-color:rgb(255,255,255);"><span style="color:rgb(0,0,0);"><span style="font-weight:700;"><img src="https://img-blog.csdn.net/20180324155243910" alt=""></span></span></p><p style="text-align:center;background-color:rgb(255,255,255);"><span style="color:rgb(0,0,0);"><span style="font-weight:700;"><span style="color:rgb(62,62,62);">3</span><span style="color:rgb(62,62,62);">，497</span>：当前log文件中的第几条信息，存放在磁盘上的那个地方<br></span></span></p><blockquote style="padding:0px;margin-bottom:0px;margin-left:40px;background-color:rgb(255,255,255);border:none;"></blockquote><span style="color:rgb(62,62,62);font-family:'微软雅黑', sans-serif;font-size:11pt;background-color:rgb(255,255,255);">上述图中索引文件存储大量元数据，数据文件存储大量消息，索引文件中元数据指向对应数据文件中</span><span lang="en-us" xml:lang="en-us" style="color:rgb(62,62,62);font-family:'微软雅黑', sans-serif;font-size:11pt;background-color:rgb(255,255,255);">message</span><span style="color:rgb(62,62,62);font-family:'微软雅黑', sans-serif;font-size:11pt;background-color:rgb(255,255,255);">的物理偏移地址。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="text-align:left;background-color:rgb(255,255,255);"><span style="color:rgb(0,0,0);"><span style="font-weight:700;"></span></span></p><p style="margin:3.4pt 0cm;background:rgb(255,255,255);"><span style="font-size:11pt;font-family:'微软雅黑', sans-serif;color:rgb(62,62,62);">其中以索引文件中元数据<span lang="en-us" xml:lang="en-us">3,497</span>为例，依次在数据文件中表示第<span lang="en-us" xml:lang="en-us">3</span>个<span lang="en-us" xml:lang="en-us">message(</span>在全局<span lang="en-us" xml:lang="en-us">partiton</span>表示第<span lang="en-us" xml:lang="en-us">368772</span>个<span lang="en-us" xml:lang="en-us">message)</span>、以及该消息的物理偏移地址为<span lang="en-us" xml:lang="en-us">497</span>。</span></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="text-align:left;background-color:rgb(255,255,255);"><span><span style="font-weight:700;"></span></span></p><p style="color:rgb(0,0,0);text-align:center;background:rgb(255,255,255);"><span style="color:rgb(62,62,62);">l </span><span style="color:rgb(62,62,62);">segment data file</span><span style="color:rgb(62,62,62);">由许多message</span>组成， qq物理结构如下：</p><div style="padding:0px;margin:0px;font-size:14px;background-color:rgb(255,255,255);color:rgb(0,0,0);text-align:center;"><img src="https://img-blog.csdn.net/20180324155541117" alt=""></div><div style="padding:0px;margin:0px;color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);text-align:left;"><h2 style="padding:0px;"><a></a><span style="color:rgb(51,51,51);">8.3、Kafka <span>查找</span><span>message</span></span></h2><p style="color:rgb(0,0,0);">读取offset=368776的message，需要通过下面2个步骤查找。</p><h3 style="padding:0px;"><a></a><span style="color:rgb(51,51,51);">8.3.1、查找segment file</span></h3></div><span style="font-size:14px;color:rgb(0,0,0);background-color:rgb(255,255,255);">00000000000000000000.index表示最开始的文件，起始偏移量(offset)为0</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="font-size:14px;color:rgb(0,0,0);background-color:rgb(255,255,255);">00000000000000368769.index的消息量起始偏移量为368770= 368769 + 1</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="font-size:14px;color:rgb(0,0,0);background-color:rgb(255,255,255);">00000000000000737337.index的起始偏移量为737338=737337+ 1</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="font-size:14px;color:rgb(0,0,0);background-color:rgb(255,255,255);">其他后续文件依次类推。</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="text-align:left;background-color:rgb(255,255,255);"><span><span style="font-weight:700;"></span></span></p><div style="padding:0px;margin:0px;color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);text-align:left;"><p style="color:rgb(0,0,0);">以起始偏移量命名并排序这些文件，只要根据offset**二分查找**文件列表，就可以快速定位到具体文件。当offset=368776时定位到00000000000000368769.index和对应log文件。</p></div><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="text-align:left;background-color:rgb(255,255,255);"><span><span style="font-weight:700;"></span></span></p><div style="padding:0px;margin:0px;color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);text-align:left;"><h3 style="padding:0px;"><a></a><span style="color:rgb(51,51,51);">8.3.2、通过segment file查找message</span></h3></div><span style="font-size:14px;color:rgb(0,0,0);background-color:rgb(255,255,255);">当offset=368776时，依次定位到00000000000000368769.index的元数据物理位置和00000000000000368769.log的物理偏移地址</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="text-align:left;background-color:rgb(255,255,255);"><span><span style="font-weight:700;"></span></span></p><div style="padding:0px;margin:0px;color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);text-align:left;"><p style="color:rgb(0,0,0);">然后再通过00000000000000368769.log顺序查找直到offset=368776为止。</p></div><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="background-color:rgb(255,255,255);"></p><p style="text-align:left;background-color:rgb(255,255,255);"><span style="background-color:rgb(0,0,0);"><span style="font-weight:700;"></span></span></p><div style="padding:0px;margin:0px;color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);text-align:left;"><h1 style="padding:0px;"><a></a><span style="color:rgb(51,51,51);">（九）、Kafka自定义Partition</span></h1></div><div class="dp-highlighter bg_java" style="padding:1px 0px 0px;margin:0px 0px 24px;font-family:Consolas, 'Courier New', Courier, mono, serif;font-size:12px;background-color:rgb(231,229,220);width:704.883px;text-align:left;color:rgb(51,51,51);"><div class="bar" style="padding:0px 0px 0px 45px;margin:0px;"><div class="tools" style="padding:3px 8px 10px 10px;margin:0px;font-size:9px;line-height:normal;font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;color:#C0C0C0;background-color:rgb(248,248,248);border-left:3px solid rgb(108,226,108);border-right:1px solid rgb(231,229,220);"><span>[java]</span> <a href="https://blog.csdn.net/ForgetThatNight/article/details/79632413#" rel="nofollow" class="ViewSource" title="view plain" style='background-image:url("https://csdnimg.cn/release/phoenix/images/ico_plain.gif");background-position:left top;background-repeat:no-repeat;background-color:inherit;border:none;padding:1px;margin:0px 10px 0px 0px;font-size:9px;width:16px;height:16px;text-indent:-2000px;'>view plain</a><span> <a href="https://blog.csdn.net/ForgetThatNight/article/details/79632413#" rel="nofollow" class="CopyToClipboard" title="copy" style='background-image:url("https://csdnimg.cn/release/phoenix/images/ico_copy.gif");background-position:left top;background-repeat:no-repeat;background-color:inherit;border:none;padding:1px;margin:0px 10px 0px 0px;font-size:9px;width:16px;height:16px;text-indent:-2000px;'>copy</a></span><div style="padding:0px;margin:0px;width:16px;height:16px;"></div><div style="padding:0px;margin:0px;width:16px;height:16px;"></div><span></span></div></div><ol start="1" class="dp-j" style="border-top:none;border-right:1px solid rgb(231,229,220);border-bottom:none;border-left:none;background-color:rgb(255,255,255);color:rgb(92,92,92);"><li class="alt" style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;"><span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">package</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> cn.itcast;  </span></span></li><li style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);background-color:rgb(248,248,248);line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">  </span></li><li class="alt" style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;"><span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">import</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> kafka.javaapi.producer.Producer;  </span></span></li><li style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);background-color:rgb(248,248,248);line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;"><span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">import</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> kafka.producer.KeyedMessage;  </span></span></li><li class="alt" style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;"><span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">import</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> kafka.producer.ProducerConfig;  </span></span></li><li style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);background-color:rgb(248,248,248);line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;"><span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">import</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> java.util.Properties;  </span></span></li><li class="alt" style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">  </span></li><li style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);background-color:rgb(248,248,248);line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">  </span></li><li class="alt" style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;"><span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">public</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> </span><span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">class</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> MyKafkaProducer {  </span></span></li><li style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);background-color:rgb(248,248,248);line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">    <span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">public</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> </span><span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">static</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> </span><span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">void</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> main(String[] args) {  </span></span></li><li class="alt" style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">        Properties properties = <span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">new</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> Properties();  </span></span></li><li style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);background-color:rgb(248,248,248);line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">        properties.put(<span class="string" style="margin:0px;padding:0px;border:none;color:#0000FF;background-color:inherit;">"metadata.broker.list"</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;">,</span><span class="string" style="margin:0px;padding:0px;border:none;color:#0000FF;background-color:inherit;">"mini1:9092"</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;">);  </span></span></li><li class="alt" style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">  </span></li><li style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);background-color:rgb(248,248,248);line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">        <span class="comment" style="margin:0px;padding:0px;border:none;color:rgb(0,130,0);background-color:inherit;">// 默认的序列化为byte改为string</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;">  </span></span></li><li class="alt" style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">        properties.put(<span class="string" style="margin:0px;padding:0px;border:none;color:#0000FF;background-color:inherit;">"serializer.class"</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;">,</span><span class="string" style="margin:0px;padding:0px;border:none;color:#0000FF;background-color:inherit;">"kafka.serializer.StringEncoder"</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;">);  </span></span></li><li style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);background-color:rgb(248,248,248);line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">        <span class="comment" style="margin:0px;padding:0px;border:none;color:rgb(0,130,0);background-color:inherit;">/**</span> </span></li><li class="alt" style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;"><span class="comment" style="margin:0px;padding:0px;border:none;color:rgb(0,130,0);background-color:inherit;">         * 自定义parition的基本步骤</span> </span></li><li style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);background-color:rgb(248,248,248);line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;"><span class="comment" style="margin:0px;padding:0px;border:none;color:rgb(0,130,0);background-color:inherit;">         * 1、实现partition类</span> </span></li><li class="alt" style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;"><span class="comment" style="margin:0px;padding:0px;border:none;color:rgb(0,130,0);background-color:inherit;">         * 2、加一个构造器，MyPartitioner(VerifiableProperties properties)</span> </span></li><li style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);background-color:rgb(248,248,248);line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;"><span class="comment" style="margin:0px;padding:0px;border:none;color:rgb(0,130,0);background-color:inherit;">         * 3、将自定义的parititoner加入到properties中</span> </span></li><li class="alt" style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;"><span class="comment" style="margin:0px;padding:0px;border:none;color:rgb(0,130,0);background-color:inherit;">         *    properties.put("partitioner.class","cn.itcast.MyPartitioner")</span> </span></li><li style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);background-color:rgb(248,248,248);line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;"><span class="comment" style="margin:0px;padding:0px;border:none;color:rgb(0,130,0);background-color:inherit;">         * 4、producer.send方法中必须指定一个paritionKey</span> </span></li><li class="alt" style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;"><span class="comment" style="margin:0px;padding:0px;border:none;color:rgb(0,130,0);background-color:inherit;">         */</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;">  </span></span></li><li style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);background-color:rgb(248,248,248);line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">        properties.put(<span class="string" style="margin:0px;padding:0px;border:none;color:#0000FF;background-color:inherit;">"partitioner.class"</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;">,</span><span class="string" style="margin:0px;padding:0px;border:none;color:#0000FF;background-color:inherit;">"cn.itcast.MyPartitioner"</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;">);  </span></span></li><li class="alt" style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">        Producer producer = <span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">new</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> Producer(</span><span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">new</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> ProducerConfig(properties));  </span></span></li><li style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);background-color:rgb(248,248,248);line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">        <span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">while</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> (</span><span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">true</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;">){  </span></span></li><li class="alt" style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">            producer.send(<span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">new</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> KeyedMessage(</span><span class="string" style="margin:0px;padding:0px;border:none;color:#0000FF;background-color:inherit;">"order4"</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;">,</span><span class="string" style="margin:0px;padding:0px;border:none;color:#0000FF;background-color:inherit;">"zhang"</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;">,</span><span class="string" style="margin:0px;padding:0px;border:none;color:#0000FF;background-color:inherit;">"我爱我的祖国"</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;">));  </span></span></li><li style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);background-color:rgb(248,248,248);line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;"><span class="comment" style="margin:0px;padding:0px;border:none;color:rgb(0,130,0);background-color:inherit;">//            producer.send(new KeyedMessage("order","我爱我的祖国"));</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;">  </span></span></li><li class="alt" style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">        }  </span></li><li style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);background-color:rgb(248,248,248);line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">    }  </span></li><li class="alt" style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">}  </span></li><li style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);background-color:rgb(248,248,248);line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;"><span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">package</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> cn.itcast;  </span></span></li><li class="alt" style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">  </span></li><li style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);background-color:rgb(248,248,248);line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;"><span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">import</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> kafka.producer.Partitioner;  </span></span></li><li class="alt" style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;"><span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">import</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> kafka.utils.VerifiableProperties;  </span></span></li><li style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);background-color:rgb(248,248,248);line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">  </span></li><li class="alt" style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">  </span></li><li style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);background-color:rgb(248,248,248);line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;"><span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">public</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> </span><span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">class</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> MyPartitioner </span><span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">implements</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> Partitioner {  </span></span></li><li class="alt" style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">    <span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">public</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> MyPartitioner(VerifiableProperties properties) {  </span></span></li><li style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);background-color:rgb(248,248,248);line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">    }  </span></li><li class="alt" style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">    <span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">public</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> </span><span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">int</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> partition(Object key, </span><span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">int</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> numPartitions) {  </span></span></li><li style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);background-color:rgb(248,248,248);line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">        <span class="keyword" style="margin:0px;padding:0px;border:none;color:rgb(0,102,153);background-color:inherit;font-weight:bold;">return</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> </span><span class="number" style="margin:0px;padding:0px;border:none;color:rgb(192,0,0);background-color:inherit;">2</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;">;  </span></span></li><li class="alt" style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);color:inherit;line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">    }  </span></li><li style="border-top:none;border-right:none;border-bottom:none;border-left:3px solid rgb(108,226,108);background-color:rgb(248,248,248);line-height:18px;padding:0px 3px 0px 10px;margin-right:0px;margin-bottom:0px;list-style-position:outside;"><span style="margin:0px;padding:0px;border:none;color:#000000;background-color:inherit;">}  </span></li></ol></div><h1 style="padding:0px;background-color:rgb(255,255,255);"><a></a>（十一）、Kafka常用操作命令</h1><p style="background-color:rgb(255,255,255);">• 查看当前服务器中的所有topic</p><p style="background-color:rgb(255,255,255);">bin/kafka-topics.sh --list --zookeeper  zk01:2181</p><p style="background-color:rgb(255,255,255);">• 创建topic</p><p style="background-color:rgb(255,255,255);">./kafka-topics.sh --create --zookeeper mini1:2181--replication-factor 1 --partitions 3 --topic first</p><p style="background-color:rgb(255,255,255);">• 删除topic</p><p style="background-color:rgb(255,255,255);">sh bin/kafka-topics.sh --delete --zookeeper zk01:2181 --topic test</p><p style="background-color:rgb(255,255,255);">    – 注意：如果kafaka启动时加载的配置文件中server.properties没有配置delete.topic.enable=true，那么此时的删除并不是真正的删除，而是把topic标记为：marked for deletion<br>    – 此时你若想真正删除它，可以登录zookeeper客户端，进入终端后，删除相应节点</p><p style="background-color:rgb(255,255,255);">• 通过shell命令发送消息</p><p style="background-color:rgb(255,255,255);">kafka-console-producer.sh --broker-list kafka01:9092--topic itheima</p><p style="background-color:rgb(255,255,255);">• 通过shell消费消息</p><p style="background-color:rgb(255,255,255);">sh bin/kafka-console-consumer.sh --zookeeper zk01:2181--from-beginning --topic test1</p><p style="background-color:rgb(255,255,255);">• 查看消费位置</p><p style="background-color:rgb(255,255,255);">sh kafka-run-class.sh kafka.tools.ConsumerOffsetChecker --zookeeperzk01:2181 --group testGroup</p><p style="background-color:rgb(255,255,255);">•  查看某个Topic的详情</p><p style="background-color:rgb(255,255,255);">sh kafka-topics.sh --topic test --describe --zookeeper zk01:2181</p><p style="background-color:rgb(255,255,255);"> 12、Flume&amp;Kafka结合应用</p><p style="background-color:rgb(255,255,255);">• 启动ＦＬｕｍｅ<br></p><div style="padding:0px;margin:0px;color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);text-align:left;">–  ./bin/flume-ng agent --conf conf --conf-file ./conf/flume.conf -name producer -Dflume.root.logger=DEBUG,console</div><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• 启动Zookeeper</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">    – 略</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><address style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);text-align:left;">• <span style="font-style:normal;">启动<span>Kafka Server</span></span></address><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">     ./bin/kafka-server-start.sh config/server.properties</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• 发送消息</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">     # echo 'XXXX' | nc -u master 8285</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">• 启动Consumer进行数据监控</span><br style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;background-color:rgb(255,255,255);">    –  bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test --from-beginning</span>            </div>
                </div>