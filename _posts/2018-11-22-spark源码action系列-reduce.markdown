---
layout:     post
title:      spark源码action系列-reduce
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								<div class="article-copyright">
					版权声明：本文为博主原创文章，未经博主允许不得转载。					https://blog.csdn.net/u014393917/article/details/50607485				</div>
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                
<h3></h3>
<h3>RDD.reduce</h3>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">这个action的作用:</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">在reduce中,是把rdd中所有的task中的结果合并成一个结果,最终输出这个结果.这个类似于一个count操作.在reduce中,传入的函数传入两个T类型的参数(T类型是RDD中KV的类型),这个函数返回值也是一个T类型的结果.</span><span style="color:#000000;background:rgb(255,255,255);">注意,很多同学会把这个跟hadoop中的map reduce中的reduce进行等同看待,其实不是的,在map reduce中的reduce更像是spark中的一个groupByKey的操作,spark中的reduce只返回一个值,这个值是执行REDUCE操作的RDD中KV的类型.</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">在reduce的实现内部,定义了两个函数来进行处理.</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);"> </span></p>
<p style="background:rgb(255,255,255);"><span style="background:rgb(228,228,255);">def</span><span style="background:rgb(255,255,255);"> </span><span style="color:#000000;background:rgb(255,255,255);">reduce(f: (</span><span style="color:#20999d;background:rgb(255,255,255);">T</span><span style="color:#cc7832;background:rgb(255,255,255);">, </span><span style="color:#20999d;background:rgb(255,255,255);">T</span><span style="color:#000000;background:rgb(255,255,255);">) =&gt; </span><span style="color:#20999d;background:rgb(255,255,255);">T</span><span style="color:#000000;background:rgb(255,255,255);">): </span><span style="color:#20999d;background:rgb(255,255,255);">T </span><span style="color:#000000;background:rgb(255,255,255);">= </span><span style="color:#000000;background:rgb(228,228,255);">withScope {</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(228,228,255);"> </span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(228,228,255);">1,这里定义了每个partition的task的执行函数,主要是对iterator进行迭代,</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(228,228,255);">1,先计算f(a1,a2) ,其中f是一个函数,得到一个T类型的值tmpa..</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(228,228,255);">2,接着根据迭代,计算 tmpa与a3的值,得到一个T类型的值tmpa,,,以后按这个方法一直做,直到iterator迭代完成.</span><span style="color:#000000;background:rgb(228,228,255);"><br></span><span style="color:#000000;background:rgb(228,228,255);">  </span><span style="background:rgb(228,228,255);">val </span><span style="color:#000000;background:rgb(228,228,255);">cleanF = sc.clean(f)</span><span style="color:#000000;background:rgb(228,228,255);"><br></span><span style="color:#000000;background:rgb(228,228,255);">  </span><span style="background:rgb(228,228,255);">val </span><span style="color:#000000;background:rgb(228,228,255);">reducePartition: Iterator[T] =&gt; Option[T] = iter =&gt; {</span><span style="color:#000000;background:rgb(228,228,255);"><br></span><span style="color:#000000;background:rgb(228,228,255);">    </span><span style="background:rgb(228,228,255);">if </span><span style="color:#000000;background:rgb(228,228,255);">(iter.hasNext) {</span><span style="color:#000000;background:rgb(228,228,255);"><br></span><span style="color:#000000;background:rgb(228,228,255);">      Some(iter.reduceLeft(cleanF))</span><span style="color:#000000;background:rgb(228,228,255);"><br></span><span style="color:#000000;background:rgb(228,228,255);">    } </span><span style="background:rgb(228,228,255);">else </span><span style="color:#000000;background:rgb(228,228,255);">{</span><span style="color:#000000;background:rgb(228,228,255);"><br></span><span style="color:#000000;background:rgb(228,228,255);">      None</span><span style="color:#000000;background:rgb(228,228,255);"><br></span><span style="color:#000000;background:rgb(228,228,255);">    }</span><span style="color:#000000;background:rgb(228,228,255);"><br></span><span style="color:#000000;background:rgb(228,228,255);">  }</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(228,228,255);"> </span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(228,228,255);">这个函数是driver端的resultHandler函数,用于把所有的task返回的T类型的值进行合并,合并的方法一样,还是通过上面定义的f函数来进行.</span><span style="color:#000000;background:rgb(228,228,255);"><br></span><span style="color:#000000;background:rgb(228,228,255);">  </span><span style="background:rgb(228,228,255);">var </span><span style="color:#000000;background:rgb(228,228,255);">jobResult: Option[T] = None</span><span style="color:#000000;background:rgb(228,228,255);"><br></span><span style="color:#000000;background:rgb(228,228,255);">  </span><span style="background:rgb(228,228,255);">val </span><span style="color:#000000;background:rgb(228,228,255);">mergeResult = (index: Int</span><span style="color:#cc7832;background:rgb(228,228,255);">, </span><span style="color:#000000;background:rgb(228,228,255);">taskResult: Option[T]) =&gt; {</span><span style="color:#000000;background:rgb(228,228,255);"><br></span><span style="color:#000000;background:rgb(228,228,255);">    </span><span style="background:rgb(228,228,255);">if </span><span style="color:#000000;background:rgb(228,228,255);">(taskResult.isDefined) {</span><span style="color:#000000;background:rgb(228,228,255);"><br></span><span style="color:#000000;background:rgb(228,228,255);">      jobResult = jobResult </span><span style="background:rgb(228,228,255);">match </span><span style="color:#000000;background:rgb(228,228,255);">{</span><span style="color:#000000;background:rgb(228,228,255);"><br></span><span style="color:#000000;background:rgb(228,228,255);">        </span><span style="background:rgb(228,228,255);">case </span><span style="color:#000000;background:rgb(228,228,255);">Some(value) =&gt; Some(f(value</span><span style="color:#cc7832;background:rgb(228,228,255);">, </span><span style="color:#000000;background:rgb(228,228,255);">taskResult.get))</span><span style="color:#000000;background:rgb(228,228,255);"><br></span><span style="color:#000000;background:rgb(228,228,255);">        </span><span style="background:rgb(228,228,255);">case </span><span style="color:#000000;background:rgb(228,228,255);">None =&gt; taskResult</span><span style="color:#000000;background:rgb(228,228,255);"><br></span><span style="color:#000000;background:rgb(228,228,255);">      }</span><span style="color:#000000;background:rgb(228,228,255);"><br></span><span style="color:#000000;background:rgb(228,228,255);">    }</span><span style="color:#000000;background:rgb(228,228,255);"><br></span><span style="color:#000000;background:rgb(228,228,255);">  }</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(228,228,255);">这里是执行这个任务</span><span style="color:#000000;background:rgb(228,228,255);"><br></span><span style="color:#000000;background:rgb(228,228,255);">  sc.runJob(</span><span style="background:rgb(228,228,255);">this</span><span style="color:#cc7832;background:rgb(228,228,255);">, </span><span style="color:#000000;background:rgb(228,228,255);">reducePartition</span><span style="color:#cc7832;background:rgb(228,228,255);">, </span><span style="color:#000000;background:rgb(228,228,255);">mergeResult)</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(228,228,255);"> </span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(228,228,255);">最后,返回合并的T类型的值,所有的task都合并成一个值,如果这个值是null,会出错.</span><span style="color:#000000;background:rgb(228,228,255);">也就是说,如果要执行reduce操作,那么这个RDD中必须是一个有数据集的RDD.</span><span style="color:#000000;background:rgb(228,228,255);"><br></span><span style="color:#000000;background:rgb(228,228,255);">  </span><span style="color:#808080;background:rgb(228,228,255);">// Get the final result out of our Option, or throw an exception if the RDD was </span></p>
<p style="background:rgb(255,255,255);"><span style="color:#808080;background:rgb(228,228,255);">      empty</span><span style="color:#808080;background:rgb(228,228,255);"><br></span><span style="color:#808080;background:rgb(228,228,255);">  </span><span style="color:#000000;background:rgb(228,228,255);">jobResult.getOrElse(</span><span style="background:rgb(228,228,255);">throw new </span><span style="color:#000000;background:rgb(228,228,255);">UnsupportedOperationException(</span><span style="background:rgb(228,228,255);">"empty collection"</span><span style="color:#000000;background:rgb(228,228,255);">))</span><span style="color:#000000;background:rgb(228,228,255);"><br></span><span style="color:#000000;background:rgb(228,228,255);">}</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(228,228,255);"> </span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(228,228,255);">操作示例:</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(228,228,255);">Rdd中存储的key的类型为用户名称,value是访问过的站点,现在要计算用户是张三这哥们的访问所有站点的总次数,只返回张三这哥们的总次数(这哥们比较NB),其它的用户不统计.</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(228,228,255);">Rdd.filter(kv =&gt; kv._1 == 张三).map(kv =&gt; kv._1 -&gt; 1).reduce((kv1,kv2) =&gt; {</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(228,228,255);">  kv1._2 += kv2._2</span></p>
<p><span style="color:#000000;background:rgb(228,228,255);">})</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(228,228,255);"></span></p>
            </div>
                </div>