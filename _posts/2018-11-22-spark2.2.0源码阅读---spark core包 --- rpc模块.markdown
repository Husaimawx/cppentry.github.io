---
layout:     post
title:      spark2.2.0源码阅读---spark core包 --- rpc模块
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                <p><img src="https://img-blog.csdn.net/20180515161413416?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RpYW5saWFs/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><img src="https://img-blog.csdn.net/20180515162406406?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RpYW5saWFs/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><img src="https://img-blog.csdn.net/2018051516245223?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RpYW5saWFs/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h1><strong>1、本文目标以及其它说明：</strong></h1><p>        本文或者本次系列主要是弄清楚spark.2.2.0版本中，spark core 包下rpc通信情况。从源代码上面看到，底层通信是用的netty，因为本系列以及本文是专项学习spark，故netty只会涉及到不会去讲解。在读源码前考虑到spark的体系结构有spark core / spark sql / spark streaming / spark machinelearning / spark graphx ，所有的都是依赖于spark core ，所以先从spark core 开始研究，又因为看源码的过程中脑子里老是在想底层通信是怎么回事，故首先就是从一个子项目的底层模块一个一个地突破。整体研究思路是模块中的数据结构，以及数据结构之间是什么关系，以及数据结构之间的算法。即（软件 = 数据结构 + 算法）</p><h1><strong>2、rpc 包下面的数据结构说明</strong></h1><p>        研究思路说明： 因为软件 = 数据结构+算法。算法是基于数据结构，所以会先研究数据结构。先从包里面最简单的数据结构开始，由简单到复杂的数据结构。包括数据结构签名、作用、以及封装抽象的类型等等。</p><p>       <strong><span style="font-size:16px;color:#33ccff;">a: 样例类 <span style="background-color:rgb(255,255,255);font-family:'Courier New';">RpcAddress：封装的是 IP+端口。</span></span></strong></p><p><strong><span style="font-size:16px;color:#33ccff;"><span style="background-color:rgb(255,255,255);font-family:'Courier New';">联想计算机网络：</span></span></strong></p><p><strong><span style="font-size:16px;color:#33ccff;"><span style="background-color:rgb(255,255,255);font-family:'Courier New';">    1 、由计算机网络可以知道，通过IP+端口我们就能够定位到网络中具体的某个进程，并能够和她通信，建立联系。</span></span></strong></p><p><strong><span style="font-size:16px;color:#33ccff;"><span style="background-color:rgb(255,255,255);font-family:'Courier New';">    2、因为是spark的RPC，通信用的协议是spark专有的。类比于HTTP协议</span></span></strong></p><p><strong><span style="background-color:rgb(255,255,255);font-family:'Courier New';"></span></strong></p><pre style="color:rgb(51,204,255);font-size:12pt;background-color:rgb(255,255,255);font-family:'Courier New';"><span style="color:#000080;"><strong>private</strong></span>[spark] <span style="color:#000080;"><strong>case class </strong></span>RpcAddress(host: <span style="color:#20999d;">String</span>, port: Int) {

  <span style="color:#000080;"><strong>def </strong></span>hostPort: <span style="color:#20999d;">String </span>= host + <span style="color:#008000;"><strong>":" </strong></span>+ port

  <span style="color:#808080;"><em>/** Returns a string in the form of "spark://host:port". */
</em></span><span style="color:#808080;"><em>  </em></span><span style="color:#000080;"><strong>def </strong></span>toSparkURL: <span style="color:#20999d;">String </span>= <span style="color:#008000;"><strong>"spark://" </strong></span>+ hostPort

  <span style="color:#000080;"><strong>override def </strong></span>toString: <span style="color:#20999d;">String </span>= hostPort
}</pre><pre style="background-color:rgb(255,255,255);font-family:'Courier New';"><span style="font-size:18px;color:rgb(51,204,255);">b:样例类 </span><span style="font-size:18px;color:#66cccc;">RpcEndpointAddress </span></pre><pre style="background-color:rgb(255,255,255);font-family:'Courier New';"><span style="font-size:18px;color:#66cccc;">  </span><span style="font-size:16px;color:#66cccc;">1、封装了RpcAddress以及Endpoint，通过本类即可定位到远端spark应用中的Endpoint.也就是说</span></pre><pre style="background-color:rgb(255,255,255);font-family:'Courier New';"><span style="font-size:16px;color:#66cccc;">通过RpcAddress定位到应用进程，通过本类定位到具体的通信组件。Endpoint后续会了解</span></pre><pre style="background-color:rgb(255,255,255);font-family:'Courier New';font-size:12pt;"><span style="color:#000080;"><strong>private</strong></span>[spark] <span style="color:#000080;"><strong>case class </strong></span>RpcEndpointAddress(rpcAddress: RpcAddress, name: <span style="color:#20999d;">String</span>)</pre><pre style="background-color:rgb(255,255,255);font-family:'Courier New';"><strong><span style="color:#00cccc;"><span style="font-size:16px;">c:接口类 RpcCallContext</span></span></strong></pre><pre style="background-color:rgb(255,255,255);font-family:'Courier New';"><strong><span style="color:#00cccc;"><span style="font-size:16px;">   1、在ask rpc通信过程中，消息发送到远端的endpoint后，需要对方通过回调的方式应答，那么回答就</span></span></strong></pre><p><span style="font-size:16px;color:#66cccc;"><strong>需要用到本数据结构。会通过调用发送消息端endpoint的receive方法作为回复。</strong></span></p><p><span style="font-size:16px;color:#66cccc;"><strong></strong></span></p><pre style="background-color:rgb(255,255,255);font-family:'Courier New';font-size:12pt;"><span style="color:#000080;"><strong>private</strong></span>[spark] <span style="color:#000080;"><strong>trait </strong></span>RpcCallContext {
  <span style="color:#808080;"><em>/**
</em></span><span style="color:#808080;"><em>   * Reply a message to the sender. If the sender is </em></span><span style="background-color:#e2ffe2;">[[</span><span style="color:#808080;"><em>RpcEndpoint</em></span><span style="background-color:#e2ffe2;">]]</span><span style="color:#808080;"><em>, its </em></span><span style="background-color:#e2ffe2;">[[</span><span style="color:#808080;"><em>RpcEndpoint.receive</em></span><span style="background-color:#e2ffe2;">]]</span>
   <span style="color:#808080;"><em>* will be called.
</em></span><span style="color:#808080;"><em>   */
</em></span><span style="color:#808080;"><em>  </em></span><span style="color:#000080;"><strong>def </strong></span>reply(response: Any): Unit
  <span style="color:#808080;"><em>/**
</em></span><span style="color:#808080;"><em>   * Report a failure to the sender.
</em></span><span style="color:#808080;"><em>   */
</em></span><span style="color:#808080;"><em>  </em></span><span style="color:#000080;"><strong>def </strong></span>sendFailure(e: <span style="color:#20999d;">Throwable</span>): Unit
  <span style="color:#808080;"><em>/**
</em></span><span style="color:#808080;"><em>   * The sender of this message.
</em></span><span style="color:#808080;"><em>   */
</em></span><span style="color:#808080;"><em>  </em></span><span style="color:#000080;"><strong>def </strong></span>senderAddress: RpcAddress
}</pre><pre style="background-color:rgb(255,255,255);font-family:'Courier New';"><span style="font-size:16px;color:#66cccc;"><strong>d:RpcEndpoint 这个是RPC通信的终端数据结构，消息到这里了就会进行处理。</strong></span></pre><p><span style="font-size:16px;color:#66cccc;"><strong>       1、有个字段是RpcEnv,Rpc通信的环境。RpcEndpoint会到环境里面注册，并返回对应的RpcEndpointRef</strong></span></p><p><span style="font-size:16px;color:#66cccc;"><strong>        2、消息到了这里，更多的是消费以及回复（receive,receiveAndReply方法）以及包括连接、其它生命周期方法</strong></span></p><p><span style="font-size:16px;color:#66cccc;"><strong>   e:RpcEndpointRef 对于远端endpoint的引用，方便用来对远端的对应endpoint节点通信,线程安全的</strong></span></p><p><span style="font-size:16px;color:#66cccc;"><strong>      1、name(String) 字段是对应endpoint的名称，address(RpcAddress)</strong></span></p><p><span style="font-size:16px;color:#66cccc;"><strong>      2、用来发送消息。send() / ask ，一个不需要回复，一个需要，另外等待回复的有同步异步ask方法</strong></span></p><p><span style="font-size:16px;color:#66cccc;"><strong>   f：RpcEnv rpc通信的环境父类， 封装了通信是时需要用到的数据结构</strong></span></p><p><span style="font-size:16px;color:#66cccc;"><strong>     1、本类是注册rpcendpoint 并且返回rpcendpointref 。 </strong></span></p><p><span style="font-size:16px;color:#66cccc;"><strong>     2、将endpointref或者远端发来的消息路由到相应的endpoint上去，</strong></span></p><p><span style="font-size:16px;color:#66cccc;"><strong>     3、捕获异常(RpcCallContext.sendFailure)，将异常发送回sender</strong></span></p><p><span style="font-size:16px;color:#66cccc;"><strong>   g：Dispatcher ,将消息路由到对应的endpoint上面</strong></span></p><p><span style="font-size:16px;color:#66cccc;"><strong>   h：Inbox，每个endpoint实例对应一个Inbox实例，里面装有endpoint,以及对应ref的引用，装的就是InboxMessage消息</strong></span></p><p><span style="font-size:16px;color:#66cccc;"><strong>说直白点就是让endpoint消费消息的容器。</strong></span></p><p><span style="font-size:16px;color:#66cccc;"><strong>   i：NettyRpcEnv，继承了RpcEnv,在此基础上，维护了&lt;RpcAddress, OutBox&gt;键值对。</strong></span></p><p><span style="font-size:16px;color:#66cccc;"><strong>     1、本类用来发送消息，send/ask方法。去本地的话调用的是dispatcher,然后放到Inbox里面，去远端的话是放在远端的outbox里面。然后由Outbox的发送方法发送，最后其实是调用的消息的自己的endwith方法，里面又是调用的TransportClient的发送方法。</strong></span></p><p><span style="font-size:16px;color:#66cccc;"><strong>   j：NettyStreamManager，主要是用来维护了由SparkContext提交到RpcEnv里面的文件、jar、和目录。</strong></span></p><p><span style="font-size:16px;color:#66cccc;"><strong></strong></span></p><pre style="background-color:rgb(255,255,255);font-family:'Courier New';font-size:12pt;"><span style="color:#000080;"><strong>private val </strong></span><span style="color:#660e7a;"><em>files </em></span>= <span style="color:#000080;"><strong>new </strong></span>ConcurrentHashMap[<span style="color:#20999d;">String</span>, File]()
<span style="color:#000080;"><strong>private val </strong></span><span style="color:#660e7a;"><em>jars </em></span>= <span style="color:#000080;"><strong>new </strong></span>ConcurrentHashMap[<span style="color:#20999d;">String</span>, File]()
<span style="color:#000080;"><strong>private val </strong></span><span style="color:#660e7a;"><em>dirs </em></span>= <span style="color:#000080;"><strong>new </strong></span>ConcurrentHashMap[<span style="color:#20999d;">String</span>, File]()</pre><p><span style="font-size:16px;color:#66cccc;"><strong>   k：Outbox，每个远端地址对应一个。当发送消息时候，讲消息存放到对应Outbox里面，最后由TransportClient发送过去即可。</strong></span></p><p><span style="font-size:16px;color:#66cccc;"><strong>   l：RpcEndpointVerifier，只用来查看远端是否存在对应的endpoint，而且这个是存放在Dispatcher数据结构里面</strong></span></p>            </div>
                </div>