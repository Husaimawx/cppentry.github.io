---
layout:     post
title:      kafka 在windows 平台的搭建和简单实用
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                <p><strong>一、安装</strong></p><p>      1、kafka 需要java环境；</p><p>      2、kafka 最新版本内置了 zookeeper，所以不需要安装zookeeper；</p><p>      3、下载kafka最新版本，<a href="https://www.apache.org/dyn/closer.cgi?path=/kafka/1.1.0/kafka_2.11-1.1.0.tgz" rel="nofollow">点击下载</a>，因为下载的是tgz文件，所以不需要安装，解压到相应的地方就可以了。</p><p>      4、bin 目录下放的是启动kafka的文件，conf目录下放的是kafka的各种配置文件。<br></p><p><strong>二、运行</strong></p><p>      简单demo测试，不需要修改任何配置文件，只需要知道 zookeeper的默认端口是2181，生产者的默认端口是9092。</p><p>      1、启动zookeeper</p><pre><code class="language-plain">bin\windows\zookeeper-server-start.bat config\zookeeper.properties</code></pre><img src="https://img-blog.csdn.net/20180607155814588" alt=""><br><p>      2、启动kafka</p><pre><code class="language-plain">bin\windows\kafka-server-start.bat config\server.properties</code></pre><img src="https://img-blog.csdn.net/20180607160118790" alt=""><br><p>      3、创建主题topic，topic = demo</p><pre><code class="language-plain">bin\windows\kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</code></pre>-- 查看创建的topic<br><pre><code class="language-plain">bin\windows\kafka-topics.bat --list --zookeeper localhost:2181</code></pre><img src="https://img-blog.csdn.net/20180607160443804" alt=""><br><p>      4、启动生产者 producer<br></p><pre><code class="language-plain">bin\windows\kafka-console-producer.bat --broker-list localhost:9092 --topic demo</code></pre><p><img src="https://img-blog.csdn.net/2018060716065471" alt=""><br></p><p>启动生产者之后进入编辑页面，发送了 "nihao"，</p><p>       5、启动消费者 customer</p><pre><code class="language-plain">bin\windows\kafka-console-consumer.bat --zookeeper localhost:2181 --topic demo --from-beginning</code></pre><p><img src="https://img-blog.csdn.net/20180607161002356" alt=""></p><p>当消费者启动之后，收到了之前生产者发送的 “nihao”。</p><p><br></p><p><strong>三、参考</strong>  <a href="https://www.cnblogs.com/hei12138/p/7805475.html" rel="nofollow">https://www.cnblogs.com/hei12138/p/7805475.html</a></p><p></p><h1 class="postTitle" style="margin-top:0px;margin-bottom:0px;padding:0px 0px 0px 5px;float:left;line-height:1.5;width:1516.11px;clear:both;font-size:14px;color:rgb(0,0,0);font-family:Verdana, Arial, Helvetica, sans-serif;text-align:left;background-color:rgb(254,254,242);"><a class="postTitle2" href="https://www.cnblogs.com/hei12138/p/7805475.html" rel="nofollow" style="margin:0px;padding:0px;color:rgb(7,93,179);">kafka实战</a></h1><div class="clear" style="margin:0px;padding:0px;clear:both;color:rgb(0,0,0);font-family:Verdana, Arial, Helvetica, sans-serif;font-size:12px;text-align:left;background-color:rgb(254,254,242);"></div><div class="postBody" style="margin:5px 0px 0px;padding:5px 2px 5px 5px;line-height:1.5;color:rgb(0,0,0);font-size:13px;font-family:Verdana, Arial, Helvetica, sans-serif;text-align:left;background-color:rgb(254,254,242);"><div class="blogpost-body" style="margin:0px 0px 20px;padding:0px;"><div style="margin:0px;padding:0px;"><h2 style="margin-top:10px;margin-bottom:10px;padding:0px;font-size:21px;line-height:1.5;">1.       kafka介绍</h2></div><p class="HeadingBar" style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"> </p><h3 style="margin-top:10px;margin-bottom:10px;padding:0px;font-size:16px;line-height:1.5;">1.1.       主要功能</h3><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">根据官网的介绍，ApacheKafka®是<span style="margin:0px;padding:0px;">一个分布式流媒体平台</span>，它主要有3种功能：</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　1：It lets you publish and subscribe to streams of records.发布和订阅消息流，这个功能类似于消息队列，这也是kafka归类为消息队列框架的原因</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　2：It lets you store streams of records in a fault-tolerant way.以容错的方式记录消息流，kafka以文件的方式来存储消息流</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　3：It lets you process streams of records as they occur.可以再消息发布的时候进行处理</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"> </p><p class="HeadingBar" style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"> </p><h3 style="margin-top:10px;margin-bottom:10px;padding:0px;font-size:16px;line-height:1.5;">1.2.       使用场景</h3><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">1：Building real-time streaming data pipelines that reliably get data between systems or applications.在系统或应用程序之间构建可靠的用于传输实时数据的管道，消息队列功能</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">2：Building real-time streaming applications that transform or react to the streams of data。构建实时的流数据处理程序来变换或处理数据流，数据处理功能</p><p class="HeadingBar" style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"> </p><h3 style="margin-top:10px;margin-bottom:10px;padding:0px;font-size:16px;line-height:1.5;">1.3.       详细介绍</h3><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">Kafka目前主要作为一个分布式的发布订阅式的消息系统使用，下面简单介绍一下kafka的基本机制</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><span style="margin:0px;padding:0px;">　　1.3.1 消息传输流程</span></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><img src="https://images2017.cnblogs.com/blog/760273/201711/760273-20171108181426763-1692750478.png" alt="" style="padding:0px;border:0px;max-width:900px;"></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"> </p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　　　<span style="margin:0px;padding:0px;">Producer</span>即生产者，向Kafka集群发送消息，在发送消息之前，会对消息进行分类，即Topic，上图展示了两个producer发送了分类为topic1的消息，另外一个发送了topic2的消息。</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　　　<span style="margin:0px;padding:0px;">Topic</span>即主题，通过对消息指定主题可以将消息分类，消费者可以只关注自己需要的Topic中的消息</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　　　<span style="margin:0px;padding:0px;">Consumer</span>即消费者，消费者通过与kafka集群建立长连接的方式，不断地从集群中拉取消息，然后可以对这些消息进行处理。</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　　　从上图中就可以看出同一个Topic下的消费者和生产者的数量并不是对应的。</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><span style="margin:0px;padding:0px;">　　1.3.2 kafka服务器消息存储策略</span></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"> <img src="https://images2017.cnblogs.com/blog/760273/201711/760273-20171108181503075-2011721824.png" alt="" style="padding:0px;border:0px;max-width:900px;"></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　　　谈到kafka的存储，就不得不提到分区，即partitions，创建一个topic时，同时可以指定分区数目，分区数越多，其吞吐量也越大，但是需要的资源也越多，同时也会导致更高的不可用性，kafka在接收到生产者发送的消息之后，会根据均衡策略将消息存储到不同的分区中。</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"> <img src="https://images2017.cnblogs.com/blog/760273/201711/760273-20171108181534809-1489003398.png" alt="" style="padding:0px;border:0px;max-width:900px;"></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　在每个分区中，消息以顺序存储，最晚接收的的消息会最后被消费。</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><span style="margin:0px;padding:0px;">　　1.3.3 与生产者的交互</span></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"> <img src="https://images2017.cnblogs.com/blog/760273/201711/760273-20171108181730059-1009703405.png" alt="" style="padding:0px;border:0px;max-width:900px;"></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　　　生产者在向kafka集群发送消息的时候，可以通过指定分区来发送到指定的分区中</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　　　也可以通过指定均衡策略来将消息发送到不同的分区中</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　　　如果不指定，就会采用默认的随机均衡策略，将消息随机的存储到不同的分区中</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><span style="margin:0px;padding:0px;">　　1.3.4  与消费者的交互</span></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"> <img src="https://images2017.cnblogs.com/blog/760273/201711/760273-20171108181923325-686894915.png" alt="" style="padding:0px;border:0px;max-width:900px;"> </p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　　　在消费者消费消息时，kafka使用offset来记录当前消费的位置</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　　　在kafka的设计中，可以有多个不同的group来同时消费同一个topic下的消息，如图，我们有两个不同的group同时消费，他们的的消费的记录位置offset各不项目，不互相干扰。</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　　　对于一个group而言，消费者的数量不应该多余分区的数量，因为在一个group中，每个分区至多只能绑定到一个消费者上，即一个消费者可以消费多个分区，一个分区只能给一个消费者消费</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　　　因此，若一个group中的消费者数量大于分区数量的话，多余的消费者将不会收到任何消息。</p><div style="margin:0px;padding:0px;"><h2 style="margin-top:10px;margin-bottom:10px;padding:0px;font-size:21px;line-height:1.5;">2.       Kafka安装与使用</h2></div><p class="HeadingBar" style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"> </p><h3 style="margin-top:10px;margin-bottom:10px;padding:0px;font-size:16px;line-height:1.5;">2.1.       下载</h3><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　你可以在kafka官网 <a href="http://kafka.apache.org/downloads" rel="nofollow" style="margin:0px;padding:0px;color:rgb(7,93,179);">http://kafka.apache.org/downloads</a>下载到最新的kafka安装包，选择下载二进制版本的tgz文件，根据网络状态可能需要fq，这里我们选择的版本是0.11.0.1，目前的最新版</p><p class="HeadingBar" style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"> </p><h3 style="margin-top:10px;margin-bottom:10px;padding:0px;font-size:16px;line-height:1.5;">2.2.       安装</h3><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　Kafka是使用scala编写的运行与jvm虚拟机上的程序，虽然也可以在windows上使用，但是kafka基本上是运行在linux服务器上，因此我们这里也使用linux来开始今天的实战。</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　首先确保你的机器上安装了jdk，kafka需要java运行环境，以前的kafka还需要zookeeper，新版的kafka已经内置了一个zookeeper环境，所以我们可以直接使用</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　说是安装，如果只需要进行最简单的尝试的话我们只需要解压到任意目录即可，这里我们将kafka压缩包解压到/home目录</p><p class="HeadingBar" style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"> </p><h3 style="margin-top:10px;margin-bottom:10px;padding:0px;font-size:16px;line-height:1.5;">2.3.       配置</h3><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　在kafka解压目录下下有一个config的文件夹，里面放置的是我们的配置文件</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　consumer.properites 消费者配置，这个配置文件用于配置于2.5节中开启的消费者，此处我们使用默认的即可</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　producer.properties 生产者配置，这个配置文件用于配置于2.5节中开启的生产者，此处我们使用默认的即可</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　server.properties kafka服务器的配置，此配置文件用来配置kafka服务器，目前仅介绍几个最基础的配置</p><ol style="margin-bottom:0px;padding-left:40px;"><li style="margin:0px 0px 1em;padding:0px;list-style:none;"><ol style="margin-bottom:0px;padding-left:40px;"><li style="margin:0px 0px 1em;padding:0px;">broker.id 申明当前kafka服务器在集群中的唯一ID，需配置为integer,并且集群中的每一个kafka服务器的id都应是唯一的，我们这里采用默认配置即可</li><li style="margin:0px 0px 1em;padding:0px;">listeners 申明此kafka服务器需要监听的端口号，如果是在本机上跑虚拟机运行可以不用配置本项，默认会使用localhost的地址，如果是在远程服务器上运行则必须配置，例如：</li></ol></li></ol><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　　　　　　　　　listeners=PLAINTEXT:// 192.168.180.128:9092。并确保服务器的9092端口能够访问</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　　　　　3.zookeeper.connect 申明kafka所连接的zookeeper的地址 ，需配置为zookeeper的地址，由于本次使用的是kafka高版本中自带zookeeper，使用默认配置即可</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　　　　　　　　　zookeeper.connect=localhost:2181</p><h3 style="margin-top:10px;margin-bottom:10px;padding:0px;font-size:16px;line-height:1.5;">2.4.       运行</h3><ol style="margin-bottom:0px;padding-left:40px;"><li style="margin:0px 0px 1em;padding:0px;">启动zookeeper</li></ol><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">cd进入kafka解压目录，输入</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><code style="margin:0px;padding:0px;">bin/zookeeper-server-start.sh config/zookeeper.properties</code></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><code style="margin:0px;padding:0px;">启动zookeeper成功后会看到如下的输出</code></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><img src="https://images2017.cnblogs.com/blog/760273/201711/760273-20171108182511122-1998907932.png" alt="" style="padding:0px;border:0px;max-width:900px;"></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　　　2.启动kafka</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">cd进入kafka解压目录，输入</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><code style="margin:0px;padding:0px;">bin/kafka-server-start.sh config/server.properties</code></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><code style="margin:0px;padding:0px;">启动kafka成功后会看到如下的输出</code></p><p class="HeadingBar" style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"> <img src="https://images2017.cnblogs.com/blog/760273/201711/760273-20171108182550794-999428192.png" alt="" style="padding:0px;border:0px;max-width:900px;"></p><h3 style="margin-top:10px;margin-bottom:10px;padding:0px;font-size:16px;line-height:1.5;">2.5.       第一个消息</h3><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　　2.5.1   创建一个topic</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　　　Kafka通过topic对同一类的数据进行管理，同一类的数据使用同一个topic可以在处理数据时更加的便捷</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　　　在kafka解压目录打开终端，输入</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><code style="margin:0px;padding:0px;">　　　　bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic </code><code style="margin:0px;padding:0px;">test</code></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><code style="margin:0px;padding:0px;">　　　　创建一个名为test的topic</code></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"> <img src="https://images2017.cnblogs.com/blog/760273/201711/760273-20171108182719091-1211225701.png" alt="" style="padding:0px;border:0px;max-width:900px;"></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">        　在创建topic后可以通过输入</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">            <code style="margin:0px;padding:0px;">bin/kafka-topics.sh --list --zookeeper localhost:2181</code></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><code style="margin:0px;padding:0px;">   </code><code style="margin:0px;padding:0px;">来查看已经创建的topic</code></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><code style="margin:0px;padding:0px;">　　2.4.2   </code><code style="margin:0px;padding:0px;">创建一个消息消费者</code></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><code style="margin:0px;padding:0px;">　　　在kafka解压目录打开终端，输入</code></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><code style="margin:0px;padding:0px;">　　　　bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic </code><code style="margin:0px;padding:0px;">test</code> <code style="margin:0px;padding:0px;">--from-beginning</code></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><code style="margin:0px;padding:0px;">　　　可以创建一个用于消费topic为test的消费者</code></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"> <img src="https://images2017.cnblogs.com/blog/760273/201711/760273-20171108182821481-1641650194.png" alt="" style="padding:0px;border:0px;max-width:900px;"></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"> </p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">         消费者创建完成之后，因为还没有发送任何数据，因此这里在执行后没有打印出任何数据</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">         不过别着急，不要关闭这个终端，打开一个新的终端，接下来我们创建第一个消息生产者</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　2.4.3         创建一个消息生产者</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　　　在kafka解压目录打开一个新的终端，输入</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><code style="margin:0px;padding:0px;">　　　　bin/kafka-console-producer.sh --broker-list localhost:9092 --topic </code><code style="margin:0px;padding:0px;">test</code></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><code style="margin:0px;padding:0px;">　　　　在执行完毕后会进入的编辑器页面</code></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><code style="margin:0px;padding:0px;"><img src="https://images2017.cnblogs.com/blog/760273/201711/760273-20171108182905559-858539154.png" alt="" style="padding:0px;border:0px;max-width:900px;"></code></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"> </p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">在发送完消息之后，可以回到我们的消息消费者终端中，可以看到，终端中已经打印出了我们刚才发送的消息</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><img src="https://images2017.cnblogs.com/blog/760273/201711/760273-20171108182938653-179427239.png" alt="" style="padding:0px;border:0px;max-width:900px;"></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"> </p><div style="margin:0px;padding:0px;"><h2 style="margin-top:10px;margin-bottom:10px;padding:0px;font-size:21px;line-height:1.5;">3.       使用java程序</h2></div><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　　　跟上节中一样，我们现在在java程序中尝试使用kafka</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　　　<span style="margin:0px;padding:0px;">3.1  创建Topic</span></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">public static void main(String[] args) {<br style="margin:0px;padding:0px;">    //创建topic<br style="margin:0px;padding:0px;">    Properties props = new Properties();<br style="margin:0px;padding:0px;">    props.put("bootstrap.servers", "192.168.180.128:9092");<br style="margin:0px;padding:0px;">    AdminClient adminClient = AdminClient.<span style="margin:0px;padding:0px;">create</span>(props);<br style="margin:0px;padding:0px;">    ArrayList&lt;NewTopic&gt; topics = new ArrayList&lt;NewTopic&gt;();<br style="margin:0px;padding:0px;">    NewTopic newTopic = new NewTopic("topic-test", 1, (short) 1);<br style="margin:0px;padding:0px;">    topics.add(newTopic);<br style="margin:0px;padding:0px;">    CreateTopicsResult result = adminClient.createTopics(topics);<br style="margin:0px;padding:0px;">    try {<br style="margin:0px;padding:0px;">        result.all().get();<br style="margin:0px;padding:0px;">    } catch (InterruptedException e) {<br style="margin:0px;padding:0px;">        e.printStackTrace();<br style="margin:0px;padding:0px;">    } catch (ExecutionException e) {<br style="margin:0px;padding:0px;">        e.printStackTrace();<br style="margin:0px;padding:0px;">    }<br style="margin:0px;padding:0px;">}</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">　　使用AdminClient API可以来控制对kafka服务器进行配置，我们这里使用NewTopic(String name, int numPartitions, short 　　replicationFactor)的构造方法来创建了一个名为“topic-test”，分区数为1，复制因子为1的Topic.</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><span style="margin:0px;padding:0px;">3.2  Producer生产者发送消息</span></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">public static void main(String[] args){<br style="margin:0px;padding:0px;">    Properties props = new Properties();<br style="margin:0px;padding:0px;">    props.put("bootstrap.servers", "192.168.180.128:9092");<br style="margin:0px;padding:0px;">    props.put("acks", "all");<br style="margin:0px;padding:0px;">    props.put("retries", 0);<br style="margin:0px;padding:0px;">    props.put("batch.size", 16384);<br style="margin:0px;padding:0px;">    props.put("linger.ms", 1);<br style="margin:0px;padding:0px;">    props.put("buffer.memory", 33554432);<br style="margin:0px;padding:0px;">    props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");<br style="margin:0px;padding:0px;">    props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");<br style="margin:0px;padding:0px;"><br style="margin:0px;padding:0px;">    Producer&lt;String, String&gt; producer = new KafkaProducer&lt;String, String&gt;(props);<br style="margin:0px;padding:0px;">    for (int i = 0; i &lt; 100; i++)<br style="margin:0px;padding:0px;">        producer.send(new ProducerRecord&lt;String, String&gt;("topic-test", Integer.<span style="margin:0px;padding:0px;">toString</span>(i), Integer.<span style="margin:0px;padding:0px;">toString</span>(i)));<br style="margin:0px;padding:0px;"><br style="margin:0px;padding:0px;">    producer.close();<br style="margin:0px;padding:0px;"><br style="margin:0px;padding:0px;">}</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">使用producer发送完消息可以通过2.5中提到的服务器端消费者监听到消息。也可以使用接下来介绍的java消费者程序来消费消息</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><span style="margin:0px;padding:0px;">3.3 Consumer消费者消费消息</span></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">public static void main(String[] args){<br style="margin:0px;padding:0px;">    Properties props = new Properties();<br style="margin:0px;padding:0px;">    props.put("bootstrap.servers", "192.168.12.65:9092");<br style="margin:0px;padding:0px;">    props.put("group.id", "test");<br style="margin:0px;padding:0px;">    props.put("enable.auto.commit", "true");<br style="margin:0px;padding:0px;">    props.put("auto.commit.interval.ms", "1000");<br style="margin:0px;padding:0px;">    props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");<br style="margin:0px;padding:0px;">    props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");<br style="margin:0px;padding:0px;">    final KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;String,String&gt;(props);<br style="margin:0px;padding:0px;">    consumer.subscribe(Arrays.<span style="margin:0px;padding:0px;">asList</span>("topic-test"),new ConsumerRebalanceListener() {<br style="margin:0px;padding:0px;">        public void onPartitionsRevoked(Collection&lt;TopicPartition&gt; collection) {<br style="margin:0px;padding:0px;">        }<br style="margin:0px;padding:0px;">        public void onPartitionsAssigned(Collection&lt;TopicPartition&gt; collection) {<br style="margin:0px;padding:0px;">            //将偏移设置到最开始<br style="margin:0px;padding:0px;">            consumer.seekToBeginning(collection);<br style="margin:0px;padding:0px;">        }<br style="margin:0px;padding:0px;">    });<br style="margin:0px;padding:0px;">    while (true) {<br style="margin:0px;padding:0px;">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(100);<br style="margin:0px;padding:0px;">        for (ConsumerRecord&lt;String, String&gt; record : records)<br style="margin:0px;padding:0px;">            System.<span style="margin:0px;padding:0px;">out</span>.printf("offset = %d, key = %s, value = %s%n", record.offset(), record.key(), record.value());<br style="margin:0px;padding:0px;">    }<br style="margin:0px;padding:0px;">}</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">这里我们使用Consume API 来创建了一个普通的java消费者程序来监听名为“topic-test”的Topic，每当有生产者向kafka服务器发送消息，我们的消费者就能收到发送的消息。</p><div style="margin:0px;padding:0px;"><h2 style="margin-top:10px;margin-bottom:10px;padding:0px;font-size:21px;line-height:1.5;">4.       使用spring-kafka</h2></div><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">Spring-kafka是正处于孵化阶段的一个spring子项目，能够使用spring的特性来让我们更方便的使用kafka</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><span style="margin:0px;padding:0px;">4.1   基本配置信息</span></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">与其他spring的项目一样，总是离不开配置，这里我们使用java配置来配置我们的kafka消费者和生产者。</p><ol style="margin-bottom:0px;padding-left:40px;"><li style="margin:0px 0px 1em;padding:0px;">引入pom文件</li></ol><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">&lt;!--kafka start--&gt;<br style="margin:0px;padding:0px;">&lt;dependency&gt;<br style="margin:0px;padding:0px;">    &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;<br style="margin:0px;padding:0px;">    &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;<br style="margin:0px;padding:0px;">    &lt;version&gt;0.11.0.1&lt;/version&gt;<br style="margin:0px;padding:0px;">&lt;/dependency&gt;<br style="margin:0px;padding:0px;">&lt;dependency&gt;<br style="margin:0px;padding:0px;">    &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;<br style="margin:0px;padding:0px;">    &lt;artifactId&gt;kafka-streams&lt;/artifactId&gt;<br style="margin:0px;padding:0px;">    &lt;version&gt;0.11.0.1&lt;/version&gt;<br style="margin:0px;padding:0px;">&lt;/dependency&gt;<br style="margin:0px;padding:0px;">&lt;dependency&gt;<br style="margin:0px;padding:0px;">    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;<br style="margin:0px;padding:0px;">    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;<br style="margin:0px;padding:0px;">    &lt;version&gt;1.3.0.RELEASE&lt;/version&gt;<br style="margin:0px;padding:0px;">&lt;/dependency&gt;</p><ol style="margin-bottom:0px;padding-left:40px;"><li style="margin:0px 0px 1em;padding:0px;">创建配置类</li></ol><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">我们在主目录下新建名为KafkaConfig的类</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">@Configuration<br style="margin:0px;padding:0px;">@EnableKafka<br style="margin:0px;padding:0px;">public class KafkaConfig {<br style="margin:0px;padding:0px;"><br style="margin:0px;padding:0px;">}</p><ol style="margin-bottom:0px;padding-left:40px;"><li style="margin:0px 0px 1em;padding:0px;">配置Topic</li></ol><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">在kafkaConfig类中添加配置</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">//topic config Topic的配置开始<br style="margin:0px;padding:0px;">    @Bean<br style="margin:0px;padding:0px;">    public KafkaAdmin admin() {<br style="margin:0px;padding:0px;">        Map&lt;String, Object&gt; configs = new HashMap&lt;String, Object&gt;();<br style="margin:0px;padding:0px;">        configs.put(AdminClientConfig.<span style="margin:0px;padding:0px;">BOOTSTRAP_SERVERS_CONFIG</span>,"192.168.180.128:9092");<br style="margin:0px;padding:0px;">        return new KafkaAdmin(configs);<br style="margin:0px;padding:0px;">    }<br style="margin:0px;padding:0px;"><br style="margin:0px;padding:0px;">    @Bean<br style="margin:0px;padding:0px;">    public NewTopic topic1() {<br style="margin:0px;padding:0px;">        return new NewTopic("foo", 10, (short) 2);<br style="margin:0px;padding:0px;">    }<br style="margin:0px;padding:0px;">//topic的配置结束</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"> </p><ol style="margin-bottom:0px;padding-left:40px;"><li style="margin:0px 0px 1em;padding:0px;">配置生产者Factort及Template</li></ol><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">//producer config start<br style="margin:0px;padding:0px;">    @Bean<br style="margin:0px;padding:0px;">    public ProducerFactory&lt;Integer, String&gt; producerFactory() {<br style="margin:0px;padding:0px;">        return new DefaultKafkaProducerFactory&lt;Integer,String&gt;(producerConfigs());<br style="margin:0px;padding:0px;">    }<br style="margin:0px;padding:0px;">    @Bean<br style="margin:0px;padding:0px;">    public Map&lt;String, Object&gt; producerConfigs() {<br style="margin:0px;padding:0px;">        Map&lt;String, Object&gt; props = new HashMap&lt;String,Object&gt;();<br style="margin:0px;padding:0px;">        props.put(ProducerConfig.<span style="margin:0px;padding:0px;">BOOTSTRAP_SERVERS_CONFIG</span>, "192.168.180.128:9092");<br style="margin:0px;padding:0px;">        props.put("acks", "all");<br style="margin:0px;padding:0px;">        props.put("retries", 0);<br style="margin:0px;padding:0px;">        props.put("batch.size", 16384);<br style="margin:0px;padding:0px;">        props.put("linger.ms", 1);<br style="margin:0px;padding:0px;">        props.put("buffer.memory", 33554432);<br style="margin:0px;padding:0px;">        props.put("key.serializer", "org.apache.kafka.common.serialization.IntegerSerializer");<br style="margin:0px;padding:0px;">        props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");<br style="margin:0px;padding:0px;">        return props;<br style="margin:0px;padding:0px;">    }<br style="margin:0px;padding:0px;">    @Bean<br style="margin:0px;padding:0px;">    public KafkaTemplate&lt;Integer, String&gt; kafkaTemplate() {<br style="margin:0px;padding:0px;">        return new KafkaTemplate&lt;Integer, String&gt;(producerFactory());<br style="margin:0px;padding:0px;">    }<br style="margin:0px;padding:0px;">//producer config end</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">5.配置ConsumerFactory</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">//consumer config start<br style="margin:0px;padding:0px;">    @Bean<br style="margin:0px;padding:0px;">    public ConcurrentKafkaListenerContainerFactory&lt;Integer,String&gt; kafkaListenerContainerFactory(){<br style="margin:0px;padding:0px;">        ConcurrentKafkaListenerContainerFactory&lt;Integer, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;Integer, String&gt;();<br style="margin:0px;padding:0px;">        factory.setConsumerFactory(consumerFactory());<br style="margin:0px;padding:0px;">        return factory;<br style="margin:0px;padding:0px;">    }<br style="margin:0px;padding:0px;"><br style="margin:0px;padding:0px;">    @Bean<br style="margin:0px;padding:0px;">    public ConsumerFactory&lt;Integer,String&gt; consumerFactory(){<br style="margin:0px;padding:0px;">        return new DefaultKafkaConsumerFactory&lt;Integer, String&gt;(consumerConfigs());<br style="margin:0px;padding:0px;">    }<br style="margin:0px;padding:0px;"><br style="margin:0px;padding:0px;"><br style="margin:0px;padding:0px;">    @Bean<br style="margin:0px;padding:0px;">    public Map&lt;String,Object&gt; consumerConfigs(){<br style="margin:0px;padding:0px;">        HashMap&lt;String, Object&gt; props = new HashMap&lt;String, Object&gt;();<br style="margin:0px;padding:0px;">        props.put("bootstrap.servers", "192.168.180.128:9092");<br style="margin:0px;padding:0px;">        props.put("group.id", "test");<br style="margin:0px;padding:0px;">        props.put("enable.auto.commit", "true");<br style="margin:0px;padding:0px;">        props.put("auto.commit.interval.ms", "1000");<br style="margin:0px;padding:0px;">        props.put("key.deserializer", "org.apache.kafka.common.serialization.IntegerDeserializer");<br style="margin:0px;padding:0px;">        props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");<br style="margin:0px;padding:0px;">        return props;<br style="margin:0px;padding:0px;">    }<br style="margin:0px;padding:0px;">//consumer config end</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"> </p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"> </p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><span style="margin:0px;padding:0px;">4.2  创建消息生产者</span></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">//使用spring-kafka的template发送一条消息 发送多条消息只需要循环多次即可<br style="margin:0px;padding:0px;">public static void main(String[] args) throws ExecutionException, InterruptedException {<br style="margin:0px;padding:0px;">    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(KafkaConfig.class);<br style="margin:0px;padding:0px;">    KafkaTemplate&lt;Integer, String&gt; kafkaTemplate = (KafkaTemplate&lt;Integer, String&gt;) ctx.getBean("kafkaTemplate");<br style="margin:0px;padding:0px;">        String data="this is a test message";<br style="margin:0px;padding:0px;">        ListenableFuture&lt;SendResult&lt;Integer, String&gt;&gt; send = kafkaTemplate.send("topic-test", 1, data);<br style="margin:0px;padding:0px;">        send.addCallback(new ListenableFutureCallback&lt;SendResult&lt;Integer, String&gt;&gt;() {<br style="margin:0px;padding:0px;">            public void onFailure(Throwable throwable) {<br style="margin:0px;padding:0px;"><br style="margin:0px;padding:0px;">            }<br style="margin:0px;padding:0px;"><br style="margin:0px;padding:0px;">            public void onSuccess(SendResult&lt;Integer, String&gt; integerStringSendResult) {<br style="margin:0px;padding:0px;"><br style="margin:0px;padding:0px;">            }<br style="margin:0px;padding:0px;">        });<br style="margin:0px;padding:0px;">}</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"> </p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;"><span style="margin:0px;padding:0px;">4.3    创建消息消费者</span></p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">我们首先创建一个一个用于消息监听的类，当名为”topic-test”的topic接收到消息之后，我们的这个listen方法就会调用。</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">public class SimpleConsumerListener {<br style="margin:0px;padding:0px;">    private final static Logger <span style="margin:0px;padding:0px;">logger </span>= LoggerFactory.<span style="margin:0px;padding:0px;">getLogger</span>(SimpleConsumerListener.class);<br style="margin:0px;padding:0px;">    private final CountDownLatch latch1 = new CountDownLatch(1);<br style="margin:0px;padding:0px;"><br style="margin:0px;padding:0px;">    @KafkaListener(id = "foo", topics = "topic-test")<br style="margin:0px;padding:0px;">    public void listen(byte[] records) {<br style="margin:0px;padding:0px;">        //do something here<br style="margin:0px;padding:0px;">        this.latch1.countDown();<br style="margin:0px;padding:0px;">    }<br style="margin:0px;padding:0px;">}</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">         我们同时也需要将这个类作为一个Bean配置到KafkaConfig中</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">@Bean<br style="margin:0px;padding:0px;">public SimpleConsumerListener simpleConsumerListener(){<br style="margin:0px;padding:0px;">    return new SimpleConsumerListener();<br style="margin:0px;padding:0px;">}</p><p style="margin:10px auto;line-height:1.5;color:rgb(0,0,0);font-size:13px;">默认spring-kafka会为每一个监听方法创建一个线程来向kafka服务器拉取消息</p></div></div><br>            </div>
                </div>