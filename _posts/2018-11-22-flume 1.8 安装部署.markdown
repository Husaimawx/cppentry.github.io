---
layout:     post
title:      flume 1.8 安装部署
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                <p>环境</p><p>centos：7.2</p><p>JDK:1.8</p><p>Flume:1.8</p><p><br></p><p></p><p><strong>一、Flume 安装</strong></p><p>1)        下载</p><p>wget <a href="http://mirrors.tuna.tsinghua.edu.cn/apache/flume/1.8.0/apache-flume-1.8.0-bin.tar.gz" rel="nofollow"><span>http://mirrors.tuna.tsinghua.edu.cn/apache/flume/1.8.0/apache-flume-1.8.0-bin.tar.gz</span></a></p><p>2)        解压</p><p>tar –zxvf apache-flume-1.8.0-bin.tar.gz</p><p>mv apache-flume-1.8.0-bin /usr/local/flume</p><p>3)        设置环境变量</p><p>Vim /etc/profile.d/flume.sh</p><p><img src="https://img-blog.csdn.net/20180509165633949?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTYwNzIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>Source /etc/profile</p><p> </p><p>4)        配置java_home</p><p>cp flume-env.sh.template flume-env.sh</p><p>vim flume-env.sh</p><p><img src="https://img-blog.csdn.net/20180509165649353?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTYwNzIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>5) 配置详解</p><p></p><p>       主要介绍poolingDirectory Source，HDFS Sink，MemoryChannel，<span style="white-space:pre;">	</span>File Channel 四种，其他请参考官方文档。</p><p></p><ol><li>spoolingDirectory Source</li></ol><p>Spooling Directory Source可以获取硬盘上“spooling”目录的数据，这个Source将监视指定目录是否有新文件，如果有新文件的话，就解析这个新文件。事件的解析逻辑是可插拔的。在文件的内容所有的都读取到Channel之后，Spooling Directory Source会重名或者是删除该文件以表示文件已经读取完成。</p><p>不像Exec Source，这个Source是可靠的，且不会丢失数据。即使Flume重启或者被Kill。但是需要注意如下两点:</p><p></p><ul><li>  如果文件在放入spooling目录之后还在写，那么Flume会打印错误日志，并且停止处理该文件。</li><li> 如果文件之后重复使用，Flume将打印错误日志，并且停止处理。</li></ul><p>为了避免以上问题，我们可以使用唯一的标识符来命令文件，例如：时间戳。</p><p></p><table border="0" cellspacing="0" cellpadding="0" width="100%"><tbody><tr><td style="background:rgb(219,229,241);"><p align="center">属性名</p></td>  <td style="background:rgb(219,229,241);"><p align="center">默认</p></td>  <td style="background:rgb(219,229,241);"><p align="center">描述</p></td> </tr><tr><td style="background:#FFFFFF;"><p align="left">channels</p></td>  <td style="background:#FFFFFF;"><p align="left">–</p></td>  <td style="background:#FFFFFF;"><p align="left">　</p></td> </tr><tr><td><p align="left">type</p></td>  <td><p align="left">–</p></td>  <td><p align="left">组件名：spooldir.</p></td> </tr><tr><td style="background:#FFFFFF;"><p align="left">spoolDir</p></td>  <td style="background:#FFFFFF;"><p align="left">–</p></td>  <td style="background:#FFFFFF;"><p align="left">读取文件的目录。</p></td> </tr><tr><td><p align="left">fileSuffix</p></td>  <td><p align="left">.COMPLETED</p></td>  <td><p align="left">Spooling读取过的文件，添加的后缀。</p></td> </tr><tr><td style="background:#FFFFFF;"><p align="left">deletePolicy</p></td>  <td style="background:#FFFFFF;"><p align="left">never</p></td>  <td style="background:#FFFFFF;"><p align="left">完成后的文件是否删除。never：不删除 或 immediate：立即删除</p></td> </tr><tr><td><p align="left">fileHeader</p></td>  <td><p align="left">FALSE</p></td>  <td><p align="left">是不把路径加入到Heander</p></td> </tr><tr><td style="background:#FFFFFF;"><p align="left">fileHeaderKey</p></td>  <td style="background:#FFFFFF;"><p align="left">file</p></td>  <td style="background:#FFFFFF;"><p align="left">路径加入到Header的Key是什么</p></td> </tr><tr><td><p align="left">basenameHeader</p></td>  <td><p align="left">FALSE</p></td>  <td><p align="left">是不把文件名加入到Heander</p></td> </tr><tr><td style="background:#FFFFFF;"><p align="left">basenameHeaderKey</p></td>  <td style="background:#FFFFFF;"><p align="left">basename</p></td>  <td style="background:#FFFFFF;"><p align="left">文件名加入到Header的Key是什么</p></td> </tr><tr><td><p align="left">ignorePattern</p></td>  <td><p align="left">^$</p></td>  <td><p align="left">采用正则表达是去过滤一些文件。只有符合正则表达式的文件才会被使用。</p></td> </tr><tr><td style="background:#FFFFFF;"><p align="left">trackerDir</p></td>  <td style="background:#FFFFFF;"><p align="left">.flumespool</p></td>  <td style="background:#FFFFFF;"><p align="left">被处理文件的元数据的存储目录，如果不是绝对路径，就被会解析到spoolDir目录下。</p></td> </tr><tr><td><p align="left">consumeOrder</p></td>  <td><p align="left">oldest</p></td>  <td><p align="left">消费spooling目录文件的规则，分别有：oldest，youngest和random。在oldest 和 youngest的情况下，通过文件的最后修改时间来比较文件。如果最后修改时间相同，就根据字典的序列从小开始。在随机的情况下，就随意读取文件。如果文件列表很长，采用oldest/youngest可能会很慢，因为用oldest/youngest要扫描文件。但是如果采用random的话，就可能造成新的文件消耗的很快，老的文件一直都没有被消费。</p></td> </tr><tr><td style="background:#FFFFFF;"><p align="left">maxBackoff</p></td>  <td style="background:#FFFFFF;"><p align="left">4000</p></td>  <td style="background:#FFFFFF;"><p align="left">如果Channel已经满了，那么该Source连续尝试写入该Channel的最长时间（单位：毫秒）。</p></td> </tr><tr><td><p align="left">batchSize</p></td>  <td><p align="left">100</p></td>  <td><p align="left">批量传输到Channel的粒度。</p></td> </tr><tr><td style="background:#FFFFFF;"><p align="left">inputCharset</p></td>  <td style="background:#FFFFFF;"><p align="left">UTF-8</p></td>  <td style="background:#FFFFFF;"><p align="left">字符集</p></td> </tr><tr><td><p align="left">decodeErrorPolicy</p></td>  <td><p align="left">FAIL</p></td>  <td><p align="left">在文件中有不可解析的字符时的解析策略。FAIL: 抛出一个异常，并且不能解析该文件。REPLACE: 取代不可解析的字符，通常用Unicode U+FFFD. IGNORE: 丢弃不可能解析字符序列。</p></td> </tr><tr><td style="background:#FFFFFF;"><p align="left">deserializer</p></td>  <td style="background:#FFFFFF;"><p align="left">LINE</p></td>  <td style="background:#FFFFFF;"><p align="left">自定序列化的方式，自定的话，必须实现EventDeserializer.Builder.</p></td> </tr><tr><td><p align="left">deserializer.*</p></td>  <td><p align="left">　</p></td>  <td><p align="left">　</p></td> </tr><tr><td style="background:#FFFFFF;"><p align="left">bufferMaxLines</p></td>  <td style="background:#FFFFFF;"><p align="left">–</p></td>  <td style="background:#FFFFFF;"><p align="left">已废弃。</p></td> </tr><tr><td><p align="left">bufferMaxLineLength</p></td>  <td><p align="left">5000</p></td>  <td><p align="left">(不推荐使用) 一行中最大的长度，可以使用deserializer.maxLineLength代替。</p></td> </tr><tr><td style="background:#FFFFFF;"><p align="left">selector.type</p></td>  <td style="background:#FFFFFF;"><p align="left">replicating</p></td>  <td style="background:#FFFFFF;"><p align="left">replicating（复制） 或 multiplexing（复用）</p></td> </tr><tr><td><p align="left">selector.*</p></td>  <td><p align="left">　</p></td>  <td><p align="left">取决于selector.type的值</p></td> </tr><tr><td style="background:#FFFFFF;"><p align="left">interceptors</p></td>  <td style="background:#FFFFFF;"><p align="left">–</p></td>  <td style="background:#FFFFFF;"><p align="left">空格分割的interceptor列表。</p></td> </tr><tr><td><p align="left">interceptors.*</p></td>  <td><p align="left">　</p></td>  <td><p align="left">　</p></td> </tr></tbody></table><br><p>2.HDFS Sink</p><p></p><table border="0" cellspacing="0" cellpadding="0" width="100%"><tbody><tr><td style="background:rgb(219,229,241);"><p align="center">属性名 </p></td>  <td style="background:rgb(219,229,241);"><p align="center">默认值 </p></td>  <td style="background:rgb(219,229,241);"><p align="center">描述</p></td> </tr><tr><td><p align="left">channel</p></td>  <td><p align="left">–</p></td>  <td><p align="left">　</p></td> </tr><tr><td><p align="left">type</p></td>  <td><p align="left">–</p></td>  <td><p align="left">组件的名称，必须为：HDFS</p></td> </tr><tr><td><p align="left">hdfs.path</p></td>  <td><p align="left">–</p></td>  <td><p align="left">HDFS目录路径，例如：hdfs://namenode/flume/webdata/</p></td> </tr><tr><td><p align="left">hdfs.filePrefix</p></td>  <td><p align="left">FlumeData</p></td>  <td><p align="left">HDFS目录中，由Flume创建的文件前缀。</p></td> </tr><tr><td><p align="left">hdfs.fileSuffix</p></td>  <td><p align="left">–</p></td>  <td><p align="left">追加到文件的后缀，例如：.txt</p></td> </tr><tr><td><p align="left">hdfs.inUsePrefix</p></td>  <td><p align="left">–</p></td>  <td><p align="left">文件正在写入时的前缀。</p></td> </tr><tr><td><p align="left">hdfs.inUseSuffix</p></td>  <td><p align="left">.tmp</p></td>  <td><p align="left">文件正在写入时的后缀。</p></td> </tr><tr><td><p align="left">hdfs.rollInterval</p></td>  <td><p align="left">30</p></td>  <td><p align="left">当前写入的文件滚动间隔，默认30秒生成一个新的文件 (0 = 不滚动)</p></td> </tr><tr><td><p align="left">hdfs.rollSize</p></td>  <td><p align="left">1024</p></td>  <td><p align="left">以文件大小触发文件滚动，单位字节(0 = 不滚动)</p></td> </tr><tr><td><p align="left">hdfs.rollCount</p></td>  <td><p align="left">10</p></td>  <td nowrap><p align="left">以写入的事件数触发文件滚动。(0 = 不滚动)</p></td> </tr><tr><td><p align="left">hdfs.idleTimeout</p></td>  <td><p align="left">0</p></td>  <td><p align="left">超时多久以后关闭无效的文件。(0 = 禁用自动关闭的空闲文件)但是还是可能因为网络等多种原因导致，正在写的文件始终没有关闭，从而产生tmp文件</p></td> </tr><tr><td><p align="left">hdfs.batchSize</p></td>  <td><p align="left">100</p></td>  <td><p align="left">有多少Event后，写到文件才刷新到HDFS。</p></td> </tr><tr><td><p align="left">hdfs.codeC</p></td>  <td><p align="left">–</p></td>  <td><p align="left">压缩编解码器，可以使用：gzip, bzip2, lzo, lzop, snappy</p></td> </tr><tr><td><p align="left">hdfs.fileType</p></td>  <td><p align="left">SequenceFile</p></td>  <td><p align="left">文件格式：通常使用SequenceFile（默认）, DataStream 或者 CompressedStream<br>  (1)DataStream不能压缩输出文件，请不用设置hdfs.codeC编码解码器。<br>  (2)CompressedStream要求设置hdfs.codeC来制定一个有效的编码解码器。</p></td> </tr><tr><td><p align="left">hdfs.maxOpenFiles</p></td>  <td><p align="left">5000</p></td>  <td><p align="left">HDFS中允许打开文件的数据，如果数量超过了，最老的文件将被关闭。</p></td> </tr><tr><td><p align="left">hdfs.callTimeout</p></td>  <td><p align="left">10000</p></td>  <td><p align="left">允许HDFS操作的毫秒数，例如：open，write, flush, close。如果很多HFDS操作超时，这个配置应该增大。</p></td> </tr><tr><td><p align="left">hdfs.threadsPoolSize</p></td>  <td><p align="left">10</p></td>  <td><p align="left">每个HDFS sink的HDFS的IO操作线程数（例如：open，write）</p></td> </tr><tr><td><p align="left">hdfs.rollTimerPoolSize</p></td>  <td><p align="left">1</p></td>  <td><p align="left">每个HDFS sink调度定时文件滚动的线程数。</p></td> </tr><tr><td><p align="left">hdfs.kerberosPrincipal</p></td>  <td><p align="left">–</p></td>  <td><p align="left">安全访问HDFS Kerberos的主用户。</p></td> </tr><tr><td><p align="left">hdfs.kerberosKeytab</p></td>  <td><p align="left">–</p></td>  <td><p align="left">安全访问HDFS Kerberos keytab</p></td> </tr><tr><td><p align="left">hdfs.proxyUser</p></td>  <td><p align="left">　</p></td>  <td><p align="left">　</p></td> </tr><tr><td><p align="left">hdfs.round</p></td>  <td><p align="left">FALSE</p></td>  <td><p align="left">时间戳应该被四舍五入。(如果为true，会影响所有的时间，除了t%)</p></td> </tr><tr><td><p align="left">hdfs.roundValue</p></td>  <td><p align="left">1</p></td>  <td><p align="left">四舍五入的最高倍数（单位配置在hdfs.roundUnit），但是要小于当前时间。</p></td> </tr><tr><td><p align="left">hdfs.roundUnit</p></td>  <td><p align="left">second</p></td>  <td><p align="left">四舍五入的单位，包含：second, minute or hour.</p></td> </tr><tr><td><p align="left">hdfs.timeZone</p></td>  <td><p align="left">Local Time</p></td>  <td><p align="left">时区的名称，主要用来解决目录路径。例如：America/Los_Angeles</p></td> </tr><tr><td><p align="left">hdfs.useLocalTimeStamp</p></td>  <td><p align="left">FALSE</p></td>  <td><p align="left">使用本地时间替换转义字符。 (而不是event header的时间戳)</p></td> </tr><tr><td><p align="left">hdfs.closeTries</p></td>  <td><p align="left">0</p></td>  <td><p align="left">在发起一个关闭命令后，HDFS sink必须尝试重命名文件的次数。如果设置为1，重命名失败后，HDFS sink不会再次尝试重命名该文件，这个文件处于打开状态，并且用.tmp作为扩展名。如果为0，Sink会一直尝试重命名，直至重命名成功。如果文件 失败，这个文件可能一直保持打开状态，但是这种情况下数据是完整的。文件将会在Flume下次重启时被关闭。</p></td> </tr><tr><td><p align="left">hdfs.retryInterval</p></td>  <td><p align="left">180</p></td>  <td><p align="left">在几秒钟之间连续尝试关闭文件。每个关闭请求都会有多个RPC往返Namenode，因此设置的太低可能导致Namenode超负荷，如果设置0或者更小，如果第一次尝试失败的话，该Sink将不会尝试关闭文件。并且把文件打开，或者用“.tmp”作为扩展名。</p></td> </tr><tr><td><p align="left">serializer</p></td>  <td><p align="left">TEXT</p></td>  <td><p align="left">可能的选项包括avro_event或继承了EventSerializer.Builder接口的类名。</p></td> </tr><tr><td><p align="left">serializer.*</p></td>  <td><p align="left">　</p></td>  <td><p align="left">　</p></td> </tr></tbody></table><br><p>3.MemoryChannel</p><p>事件存储在具有可配置的最大大小的内存队列中。对于需要更高吞吐量的流程来说是理想的，并且在代理失败的情况下准备丢失阶段数据。<br></p><p></p><table border="1" cellspacing="0" cellpadding="0" width="603"><tbody><tr><td style="background:rgb(219,229,241);"><p align="center">属性名</p></td>  <td style="background:rgb(219,229,241);"><p align="center">默认值</p></td>  <td style="background:rgb(219,229,241);"><p align="center">描述</p></td> </tr><tr><td valign="top"><p>type</p></td>  <td valign="top"><p>-</p></td>  <td valign="top"><p>memory</p></td> </tr><tr><td valign="top"><p>capacity</p></td>  <td valign="top"><p>100</p></td>  <td valign="top"><p>MemroyChannel的容量</p></td> </tr><tr><td valign="top"><p>transactionCapacity</p></td>  <td valign="top"><p>100</p></td>  <td valign="top"><p align="left">每个事务最大的容量，也就是每个事务能够获取的最大Event数量。默认也是100</p></td> </tr><tr><td valign="top"><p>Keep-alive</p></td>  <td valign="top"><p>3</p></td>  <td valign="top"><p>增加和删除一个Event的超时时间（单位：秒）</p></td> </tr><tr><td valign="top"><p>byteCapacityBufferPercentage</p></td>  <td valign="top"><p>20</p></td>  <td valign="top"><p align="left">义Channle中Event所占的百分比，需要考虑在Header中的数据。</p></td> </tr></tbody></table><p>4.File Channel</p><p></p><table border="0" cellspacing="0" cellpadding="0" width="100%"><tbody><tr><td><p align="center">属性名</p></td>  <td><p align="center">默认值</p></td>  <td><p align="center">描述</p></td> </tr><tr><td style="background:#FFFFFF;"><p align="left"><strong><span style="color:#000000;">type</span></strong></p></td>  <td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">–</span></p></td>  <td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">f</span><span style="color:#000000;">ile</span></p></td> </tr><tr><td><p align="left"><span style="color:#000000;">checkpointDir</span></p></td>  <td><p align="left"><span style="color:#000000;">~/.flume/file-channel/checkpoint</span></p></td>  <td><p align="left"><span style="color:#000000;">存储文件检查点目录</span></p></td> </tr><tr><td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">useDualCheckpoints</span></p></td>  <td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">FALSE</span></p></td>  <td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">备份检查点</span><span style="color:#000000;">. </span><span style="color:#000000;">如果为</span><span style="color:#000000;">t</span><span style="color:#000000;">rue</span><span style="color:#000000;">, </span><span style="color:#000000;">backupCheckpointDir</span><span style="color:#000000;"> </span><strong><span style="color:#000000;">必填</span></strong></p></td> </tr><tr><td><p align="left"><span style="color:#000000;">backupCheckpointDir</span></p></td>  <td><p align="left"><span style="color:#000000;">–</span></p></td>  <td><p align="left"><span style="color:#000000;">文件检查点的备份目录，不能和</span><span style="color:#000000;">checkpointDir</span><span style="color:#000000;">相同。</span></p></td> </tr><tr><td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">dataDirs</span></p></td>  <td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">~/.flume/file-channel/data</span></p></td>  <td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">用于存储日志文件目录，多目录用逗号分隔。</span></p></td> </tr><tr><td><p align="left"><span style="color:#000000;">transactionCapacity</span></p></td>  <td><p align="left"><span style="color:#000000;">10000</span></p></td>  <td><p align="left"><span style="color:#000000;">通道支持的事务的最大大小。</span></p></td> </tr><tr><td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">checkpointInterval</span></p></td>  <td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">30000</span></p></td>  <td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">检查点时间间隔（毫秒）</span></p></td> </tr><tr><td><p align="left"><span style="color:#000000;">maxFileSize</span></p></td>  <td><p align="left"><span style="color:#000000;">2146435071</span></p></td>  <td><p align="left"><span style="color:#000000;">单个文件最大大小（字节）</span></p></td> </tr><tr><td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">minimumRequiredSpace</span></p></td>  <td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">524288000</span></p></td>  <td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">最小需要的自由空间（以字节为单位）。为了避免数据损坏，当空闲空间低于该值时，文件通道停止接受“取</span><span style="color:#000000;">/</span><span style="color:#000000;">放”请求。</span></p></td> </tr><tr><td><p align="left"><span style="color:#000000;">capacity</span></p></td>  <td><p align="left"><span style="color:#000000;">1000000</span></p></td>  <td><p align="left"><span style="color:#000000;">信道最大容量</span></p></td> </tr><tr><td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">keep-alive</span></p></td>  <td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">3</span></p></td>  <td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">等待放置操作时间（秒）</span></p></td> </tr><tr><td><p align="left"><span style="color:#000000;">use-log-replay-v1</span></p></td>  <td><p align="left"><span style="color:#000000;">FALSE</span></p></td>  <td><p align="left"><span style="color:#000000;">Expert:  </span><span style="color:#000000;">使用旧的回放逻辑</span></p></td> </tr><tr><td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">use-fast-replay</span></p></td>  <td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">FALSE</span></p></td>  <td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">Expert:  </span><span style="color:#000000;">不使用队列回放</span></p></td> </tr><tr><td><p align="left"><span style="color:#000000;">checkpointOnClose</span></p></td>  <td><p align="left"><span style="color:#000000;">TRUE</span></p></td>  <td><p align="left"><span style="color:#000000;">控制是否在关闭通道时创建检查点。在关闭时创建检查点通过避免重放加速文件通道的后续启动</span><span style="color:#000000;">.</span></p></td> </tr><tr><td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">encryption.activeKey</span></p></td>  <td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">–</span></p></td>  <td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">用于加密新数据的密钥名称</span></p></td> </tr><tr><td><p align="left"><span style="color:#000000;">encryption.cipherProvider</span></p></td>  <td><p align="left"><span style="color:#000000;">–</span></p></td>  <td><p align="left"><span style="color:#000000;">密钥提供者类型：</span><span style="color:#000000;">AESCTRNOPADDING</span></p></td> </tr><tr><td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">encryption.keyProvider</span></p></td>  <td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">–</span></p></td>  <td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">密钥提供程序类型</span><span style="color:#000000;">:  JCEKSFILE</span></p></td> </tr><tr><td><p align="left"><span style="color:#000000;">encryption.keyProvider.keyStoreFile</span></p></td>  <td><p align="left"><span style="color:#000000;">–</span></p></td>  <td><p align="left"><span style="color:#000000;">密钥存储文件路径</span></p></td> </tr><tr><td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">encrpytion.keyProvider.keyStorePasswordFile</span></p></td>  <td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">–</span></p></td>  <td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">密钥存储密码文件路径</span></p></td> </tr><tr><td><p align="left"><span style="color:#000000;">encryption.keyProvider.keys</span></p></td>  <td><p align="left"><span style="color:#000000;">–</span></p></td>  <td><p align="left"><span style="color:#000000;">所有密钥列表</span><span style="color:#000000;">  (e.g. history of the activeKey setting)</span></p></td> </tr><tr><td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">encyption.keyProvider.keys.*.passwordFile</span></p></td>  <td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">–</span></p></td>  <td style="background:#FFFFFF;"><p align="left"><span style="color:#000000;">可选密钥密码文件的路径</span></p></td> </tr></tbody></table><br><p>6) 验证</p><p>l  查看版本：</p><p><img src="https://img-blog.csdn.net/20180509165719848?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTYwNzIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p><p>l  执行测试命令：</p><p align="left" style="background:#FFFFFF;"><span style="color:#444444;">&gt;cd /usr/local/flume/conf/</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#444444;">&gt;cp flume-conf.properties.templateflume-conf.properties</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#444444;"> &gt;flume-ng agent –conf conf –conf-file  flume-conf.properties –name a1</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#444444;">-Dflume.root.logger=INFO,console</span></p><p>l  出现错误：</p><p>Warning:No configuration directory set! Use --conf &lt;dir&gt; to override.</p><p>Warning:JAVA_HOME is not set!</p><p>Info:Including Hive libraries found via () for Hive access</p><p>+ exec/usr/local/jdk1.8/bin/java -Xmx20m -cp '/usr/local/flume/lib/*:/lib/*'-Djava.library.path= org.apache.flume.node.Application -n a1 -fexample-conf.properties</p><p>log4j:WARNNo appenders could be found for logger (org.apache.flume.node.Application).</p><p>log4j:WARNPlease initialize the log4j system properly.</p><p>log4j:WARN Seehttp://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.</p><p>命令格式错误,应改为如下：</p><p align="left" style="background:#FFFFFF;"><span style="color:#444444;">&gt;flume-ngagent --conf /usr/local/flume/conf –-conf-file  /usr/local/flume/flume-conf.properties -–namea1</span></p><p><span style="color:#444444;">-Dflume.root.logger=INFO,console</span></p>            </div>
                </div>