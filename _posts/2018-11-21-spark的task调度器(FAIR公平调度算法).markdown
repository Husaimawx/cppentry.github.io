---
layout:     post
title:      spark的task调度器(FAIR公平调度算法)
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								<div class="article-copyright">
					版权声明：本文为博主原创文章，未经博主允许不得转载。					https://blog.csdn.net/u014393917/article/details/50619208				</div>
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                
<h2>FAIR<span style="font-family:SimSun;">公平调度器</span></h2>
<h3>代码流程</h3>
<p style="background:rgb(255,255,255);"><span style="color:#FF0000;background:rgb(255,255,255);">在fair调度器实例生成时</span><span style="color:#000000;background:rgb(255,255,255);">,与fifo的调度器生成时有些许的区别,首先看看fair调度器生成时,需要的流程,由类</span><span style="color:#000000;background:rgb(228,228,255);">FairSchedulableBuilder</span><span style="color:#000000;background:rgb(255,255,255);">进行的调度器的实现:</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">在使用fair的调度器时,schedulableBuilder的实现为</span><span style="color:#000000;background:rgb(228,228,255);">FairSchedulableBuilder</span><span style="color:#000000;background:rgb(255,255,255);">.</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(228,228,255);">schedulableBuilder</span><span style="color:#000000;background:rgb(255,255,255);">.buildPools()</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);"> </span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">接下来看看这个函数的内部实现:</span></p>
<p style="background:rgb(255,255,255);"><span style="background:rgb(255,255,255);">override def </span><span style="color:#000000;background:rgb(255,255,255);">buildPools() {</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">读取</span><span style="background:rgb(255,255,255);">spark.scheduler.allocation.file</span><span style="color:#000000;background:rgb(255,255,255);">配置项配置的fair调度器的配置文件路径.这个配置必须是xml配置文件.</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">如果这个配置没有配置,默认从class path中读取</span><span style="background:rgb(255,255,255);">fairscheduler.xml</span><span style="color:#000000;background:rgb(255,255,255);">配置文件.</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">var </span><span style="color:#000000;background:rgb(255,255,255);">is: Option[InputStream] = None</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">try </span><span style="color:#000000;background:rgb(255,255,255);">{</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">    is = </span><span style="color:#000000;background:rgb(255,255,255);">Option </span><span style="color:#000000;background:rgb(255,255,255);">{</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">      </span><span style="background:rgb(255,255,255);">schedulerAllocFile</span><span style="color:#000000;background:rgb(255,255,255);">.map { f =&gt;</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">        </span><span style="background:rgb(255,255,255);">new </span><span style="color:#000000;background:rgb(255,255,255);">FileInputStream(f)</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">      }.getOrElse {</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">        Utils.</span><span style="color:#000000;background:rgb(255,255,255);">getSparkClassLoader</span><span style="color:#000000;background:rgb(255,255,255);">.getResourceAsStream(</span><span style="background:rgb(255,255,255);">DEFAULT_SCHEDULER_FILE</span><span style="color:#000000;background:rgb(255,255,255);">)</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">      }</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">    }</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">这里解析配置文件中的内容,解析文件过程(这个过程可能没有,没读取到配置文件),可以配置多个,这里会迭代生成:</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">1,先解析根路径pool,解析这个路径的name属性,得到这个属性的值为poolName.</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">2,根据pool路径下的子路径</span><span style="background:rgb(255,255,255);">schedulingMode</span><span style="color:#000000;background:rgb(255,255,255);">,并得到配置的text的值.默认值FIFO,</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">3,读取pool路径下的子路径</span><span style="background:rgb(255,255,255);">minShare</span><span style="color:#000000;background:rgb(255,255,255);">.并得到配置的text的值,默认为0.</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">4,读取pool路径下的子路径</span><span style="background:rgb(255,255,255);">weight</span><span style="color:#000000;background:rgb(255,255,255);">,并得到配置的text的值,默认值为1.</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">5,根据上面读取到的配置信息,再生成一个Pool实例,并添加到初始的Pool实例中,当成一个子的调度器(FIFO时,子调度器就是TaskSetManager)</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">    is.foreach { i =&gt; buildFairSchedulerPool(i) }</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  } </span><span style="background:rgb(255,255,255);">finally </span><span style="color:#000000;background:rgb(255,255,255);">{</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">最后关闭文件的读取流.</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">    is.foreach(_.close())</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  }</span><span style="color:#000000;background:rgb(255,255,255);"><br></span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">生成一个默认的Pool实例.</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">通过default为poolName,检查初始的Pool实例中是否存在这个名称的实例,如果没有,生成一个,并添加到初始的Pool实例中.默认的Pool实例中:</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">poolName=default,调度算法=FIFO,minShare=0,weight=1</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="color:#808080;background:rgb(255,255,255);">// finally create "default" pool</span><span style="color:#808080;background:rgb(255,255,255);"><br></span><span style="color:#808080;background:rgb(255,255,255);">  </span><span style="color:#000000;background:rgb(255,255,255);">buildDefaultPool()</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">}</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);"> </span></p>
<p style="background:rgb(255,255,255);"><span style="color:#FF0000;background:rgb(255,255,255);">在TaskSchedulerImpl进行submitTasks操作时,调用addTaskSetManager函数时</span><span style="color:#000000;background:rgb(255,255,255);">:</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">下面看看在Fair的调度器中,在submitTasks时addTaskSetManager函数的实现流程.</span></p>
<p style="background:rgb(255,255,255);"><span style="background:rgb(255,255,255);">override def </span><span style="color:#000000;background:rgb(255,255,255);">addTaskSetManager(manager: Schedulable</span><span style="color:#cc7832;background:rgb(255,255,255);">, </span><span style="color:#000000;background:rgb(255,255,255);">properties: Properties) {</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">1,先取出默认的的default为poolName的调度器,</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">var </span><span style="color:#000000;background:rgb(255,255,255);">poolName = </span><span style="background:rgb(255,255,255);">DEFAULT_POOL_NAME</span><span style="background:rgb(255,255,255);"><br></span><span style="background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">var </span><span style="color:#000000;background:rgb(255,255,255);">parentPool = rootPool.getSchedulableByName(poolName)</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">if </span><span style="color:#000000;background:rgb(255,255,255);">(properties != </span><span style="background:rgb(255,255,255);">null</span><span style="color:#000000;background:rgb(255,255,255);">) {</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">如果传入的properties中,包含有</span><span style="background:rgb(255,255,255);">spark.scheduler.pool</span><span style="color:#000000;background:rgb(255,255,255);">配置时,得到配置的poolName的名称.</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">通过这个poolName得到对应的调度器,如果这个poolName对应的调度器实例不存在时,根据这个poolName生成一个FIFO的调度器.</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">如果需要一个任务中每一个action中对应的调度器都不相同时,在每个action操作前,可以通过如下的代码来实现对每个action前的poolName的修改:</span><span style="background:rgb(255,255,255);">saprkContext.</span><span style="background:rgb(228,228,255);">setLocalProperty</span><span style="color:#000000;background:rgb(255,255,255);">.</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">    poolName = properties.getProperty(</span><span style="background:rgb(255,255,255);">FAIR_SCHEDULER_PROPERTIES</span><span style="color:#cc7832;background:rgb(255,255,255);">, </span><span style="background:rgb(255,255,255);">DEFAULT_POOL_NAME</span><span style="color:#000000;background:rgb(255,255,255);">)</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">    parentPool = rootPool.getSchedulableByName(poolName)</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">    </span><span style="background:rgb(255,255,255);">if </span><span style="color:#000000;background:rgb(255,255,255);">(parentPool == </span><span style="background:rgb(255,255,255);">null</span><span style="color:#000000;background:rgb(255,255,255);">) {</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">      </span><span style="color:#808080;background:rgb(255,255,255);">// we will create a new pool that user has configured in app</span><span style="color:#808080;background:rgb(255,255,255);"><br></span><span style="color:#808080;background:rgb(255,255,255);">      // instead of being defined in xml file</span><span style="color:#808080;background:rgb(255,255,255);"><br></span><span style="color:#808080;background:rgb(255,255,255);">      </span><span style="color:#000000;background:rgb(255,255,255);">parentPool = </span><span style="background:rgb(255,255,255);">new </span><span style="color:#000000;background:rgb(255,255,255);">Pool(poolName</span><span style="color:#cc7832;background:rgb(255,255,255);">, </span><span style="background:rgb(255,255,255);">DEFAULT_SCHEDULING_MODE</span><span style="color:#cc7832;background:rgb(255,255,255);">,</span><span style="color:#cc7832;background:rgb(255,255,255);"><br></span><span style="color:#cc7832;background:rgb(255,255,255);">        </span><span style="background:rgb(255,255,255);">DEFAULT_MINIMUM_SHARE</span><span style="color:#cc7832;background:rgb(255,255,255);">, </span><span style="background:rgb(255,255,255);">DEFAULT_WEIGHT</span><span style="color:#000000;background:rgb(255,255,255);">)</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">      rootPool.addSchedulable(parentPool)</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">      logInfo(</span><span style="background:rgb(255,255,255);">"Created pool %s, schedulingMode: %s, minShare: %d, weight: %d"</span><span style="color:#000000;background:rgb(255,255,255);">.format(</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">        poolName</span><span style="color:#cc7832;background:rgb(255,255,255);">, </span><span style="background:rgb(255,255,255);">DEFAULT_SCHEDULING_MODE</span><span style="color:#cc7832;background:rgb(255,255,255);">, </span><span style="background:rgb(255,255,255);">DEFAULT_MINIMUM_SHARE</span><span style="color:#cc7832;background:rgb(255,255,255);">, </span><span style="background:rgb(255,255,255);">DEFAULT_WEIGHT</span><span style="color:#000000;background:rgb(255,255,255);">))</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">    }</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  }</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">根据poolName得到的调度器实例(子实例通常是一个Pool实例),调用其addSchedulable把manager添加到调度器的队列中.</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  parentPool.addSchedulable(manager)</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  logInfo(</span><span style="background:rgb(255,255,255);">"Added task set " </span><span style="color:#000000;background:rgb(255,255,255);">+ manager.name + </span><span style="background:rgb(255,255,255);">" tasks to pool " </span><span style="color:#000000;background:rgb(255,255,255);">+ poolName)</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">}</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);"> </span></p>
<p style="background:rgb(255,255,255);"><span style="color:#FF0000;background:rgb(255,255,255);">接下来看看Fair调度器的算法如何实现对TaskSetManager的排序</span><span style="color:#000000;background:rgb(255,255,255);">:</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">这个在task向executor通知执行时,进行的操作.会调用Pool实例中的getSortedTaskSetQueue函数,这个函数根据调度算法来得到一组需要进行调度的TaskSetManager.</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">使用的计算排序的算法</span><span style="color:#000000;background:rgb(228,228,255);">FairSchedulingAlgorithm</span><span style="color:#000000;background:rgb(228,228,255);">,下面看看这个代码的实现</span><span style="color:#000000;background:rgb(255,255,255);">:</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">在fair的调度器中,传入的s1,s2这两个Schedulable的实例在第一次调用时为Pool实例,第二次递归调用getSortedTaskSetQueue函数时,s1,s2对应的实例才是TaskSetManager的实例.</span></p>
<p style="background:rgb(255,255,255);"><span style="background:rgb(255,255,255);">override def </span><span style="color:#000000;background:rgb(255,255,255);">comparator(s1: Schedulable</span><span style="color:#cc7832;background:rgb(255,255,255);">, </span><span style="color:#000000;background:rgb(255,255,255);">s2: Schedulable): </span><span style="color:#cc7832;background:rgb(255,255,255);">Boolean </span><span style="color:#000000;background:rgb(255,255,255);">= {</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">这里得到的minShare的值,默认为0,除非通过fair的配置文件进行了配置指定.</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">val </span><span style="color:#000000;background:rgb(255,255,255);">minShare1 = s1.minShare</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">val </span><span style="color:#000000;background:rgb(255,255,255);">minShare2 = s2.minShare</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">这到这两个调度器中正在运行的task的个数,如果是TaskSetManager时,就是taskSet中运行的task的个数,如果是Pool实例是表示是所有使用这个poolName的所有的TaskSetManager正在运行的task的个数.</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">val </span><span style="color:#000000;background:rgb(255,255,255);">runningTasks1 = s1.runningTasks</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">val </span><span style="color:#000000;background:rgb(255,255,255);">runningTasks2 = s2.runningTasks</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);"> </span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">这里的比较,只有在minShare在fair的配置文件中显示配置,同时大于正在运行的task的个数时,才会为true.</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">val </span><span style="color:#000000;background:rgb(255,255,255);">s1Needy = runningTasks1 &lt; minShare1</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">val </span><span style="color:#000000;background:rgb(255,255,255);">s2Needy = runningTasks2 &lt; minShare2</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);"> </span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">得到运行的task的个数针对于minShare的比重,</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">val </span><span style="color:#000000;background:rgb(255,255,255);">minShareRatio1 = runningTasks1.toDouble / math.</span><span style="color:#000000;background:rgb(255,255,255);">max</span><span style="color:#000000;background:rgb(255,255,255);">(minShare1</span><span style="color:#cc7832;background:rgb(255,255,255);">, </span><span style="background:rgb(255,255,255);">1.0</span><span style="color:#000000;background:rgb(255,255,255);">).toDouble</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">val </span><span style="color:#000000;background:rgb(255,255,255);">minShareRatio2 = runningTasks2.toDouble / math.</span><span style="color:#000000;background:rgb(255,255,255);">max</span><span style="color:#000000;background:rgb(255,255,255);">(minShare2</span><span style="color:#cc7832;background:rgb(255,255,255);">, </span><span style="background:rgb(255,255,255);">1.0</span><span style="color:#000000;background:rgb(255,255,255);">).toDouble</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);"> </span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">得到正在运行的task个数针对于pool的weight的比重.</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">val </span><span style="color:#000000;background:rgb(255,255,255);">taskToWeightRatio1 = runningTasks1.toDouble / s1.weight.toDouble</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">val </span><span style="color:#000000;background:rgb(255,255,255);">taskToWeightRatio2 = runningTasks2.toDouble / s2.weight.toDouble</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">var </span><span style="color:#000000;background:rgb(255,255,255);">compare: </span><span style="color:#cc7832;background:rgb(255,255,255);">Int </span><span style="color:#000000;background:rgb(255,255,255);">= </span><span style="background:rgb(255,255,255);">0</span><span style="background:rgb(255,255,255);"><br></span></p>
<p style="background:rgb(255,255,255);"><span style="background:rgb(255,255,255);">这里首先根据正在运行的task的个数是否已经达到调度队列中最小的分片的个数来进行排序,如果s1中运行运行的个数小于s1的pool的配置的minShare,返回true,表示s1排序在前面.</span></p>
<p style="background:rgb(255,255,255);"><span style="background:rgb(255,255,255);">如果s2中运行的task的个数小于s2的pool中配置的minShare(最小分片数)的值,表示s1小于s2,这时s2排序应该靠前.</span><span style="background:rgb(255,255,255);"><br></span><span style="background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">if </span><span style="color:#000000;background:rgb(255,255,255);">(s1Needy &amp;&amp; !s2Needy) {</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">    </span><span style="background:rgb(255,255,255);">return true</span><span style="background:rgb(255,255,255);"><br></span><span style="background:rgb(255,255,255);">  </span><span style="color:#000000;background:rgb(255,255,255);">} </span><span style="background:rgb(255,255,255);">else if </span><span style="color:#000000;background:rgb(255,255,255);">(!s1Needy &amp;&amp; s2Needy) {</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">    </span><span style="background:rgb(255,255,255);">return false</span><span style="background:rgb(255,255,255);"><br></span><span style="background:rgb(255,255,255);">  </span><span style="color:#000000;background:rgb(255,255,255);">} </span><span style="background:rgb(255,255,255);">else if </span><span style="color:#000000;background:rgb(255,255,255);">(s1Needy &amp;&amp; s2Needy) {</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">这种情况表示s1与s2两个队列中,正在运行的task的个数都已经大于(不小于)了两个子调度器中配置的minShare的个数时,根据两个子调度器队列中正在运行的task的个数对应此调度器中最小分片的值所占的比重最小的一个排序更靠前.</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">    compare = minShareRatio1.compareTo(minShareRatio2)</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  } </span><span style="background:rgb(255,255,255);">else </span><span style="color:#000000;background:rgb(255,255,255);">{</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">这种情况表示s1与s2两个子调度器的队列中,正在运行的task的个数都还没有达到配置的最小分片的个数的情况,比较两个队列中正在运行的task的个数对应调度器队列的weigth的占比,最小的一个排序更靠前.</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">    compare = taskToWeightRatio1.compareTo(taskToWeightRatio2)</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  }</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  </span><span style="background:rgb(255,255,255);">if </span><span style="color:#000000;background:rgb(255,255,255);">(compare &lt; </span><span style="background:rgb(255,255,255);">0</span><span style="color:#000000;background:rgb(255,255,255);">) {</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">    </span><span style="background:rgb(255,255,255);">true</span><span style="background:rgb(255,255,255);"><br></span><span style="background:rgb(255,255,255);">  </span><span style="color:#000000;background:rgb(255,255,255);">} </span><span style="background:rgb(255,255,255);">else if </span><span style="color:#000000;background:rgb(255,255,255);">(compare &gt; </span><span style="background:rgb(255,255,255);">0</span><span style="color:#000000;background:rgb(255,255,255);">) {</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">    </span><span style="background:rgb(255,255,255);">false</span><span style="background:rgb(255,255,255);"><br></span><span style="background:rgb(255,255,255);">  </span><span style="color:#000000;background:rgb(255,255,255);">} </span><span style="background:rgb(255,255,255);">else </span><span style="color:#000000;background:rgb(255,255,255);">{</span></p>
<p style="background:rgb(255,255,255);"><span style="color:#000000;background:rgb(255,255,255);">如果两个根据上面的计算,排序值都相同,就看看这两个调度器的名称,按名称的字节序来排序了.</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">    s1.name &lt; s2.name</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">  }</span><span style="color:#000000;background:rgb(255,255,255);"><br></span><span style="color:#000000;background:rgb(255,255,255);">}</span></p>
            </div>
                </div>