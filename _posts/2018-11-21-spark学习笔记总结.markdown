---
layout:     post
title:      spark学习笔记总结
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								<div class="article-copyright">
					版权声明：本文为博主原创文章，出处为 http://blog.csdn.net/silentwolfyh					https://blog.csdn.net/silentwolfyh/article/details/51579035				</div>
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                
<p align="center"><span style="font-size:24px;"><strong>Spark<span style="font-family:'宋体';">简介</span></strong></span></p>
<p align="center"><span style="font-family:'宋体';"><br></span></p>
<p>spark <span style="font-family:'宋体';">可以很容易和</span><span style="font-family:Calibri;">yarn</span><span style="font-family:'宋体';">结合，直接调用</span><span style="font-family:Calibri;">HDFS</span><span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">Hbase</span><span style="font-family:'宋体';">上面的数据，和</span><span style="font-family:Calibri;">hadoop</span><span style="font-family:'宋体';">结合。配置很容易。</span></p>
<p>spark<span style="font-family:'宋体';">发展迅猛，框架比</span><span style="font-family:Calibri;">hadoop</span><span style="font-family:'宋体';">更加灵活实用。减少了延时处理，提高性能效率实用灵活性。也可以与</span><span style="font-family:Calibri;">hadoop</span><span style="font-family:'宋体';">切实相互结合。</span></p>
<p>spark<span style="font-family:'宋体';">核心部分分为</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">。</span><span style="font-family:Calibri;">Spark SQL</span><span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">Spark Streaming</span><span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">MLlib</span><span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">GraphX</span><span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">Spark R</span><span style="font-family:'宋体';">等核心组件解决了很多的大数据问题，其完美的框架日受欢迎。其相应的生态环境包括</span><span style="font-family:Calibri;">zepplin</span><span style="font-family:'宋体';">等可视化方面，正日益壮大。大型公司争相实用</span><span style="font-family:Calibri;">spark</span><span style="font-family:'宋体';">来代替原有</span><span style="font-family:Calibri;">hadoop</span><span style="font-family:'宋体';">上相应的功能模块。</span><span style="font-family:Calibri;">Spark</span><span style="font-family:'宋体';">读写过程不像</span><span style="font-family:Calibri;">hadoop</span><span style="font-family:'宋体';">溢出写入磁盘，都是基于内存，因此速度很快。另外</span><span style="font-family:Calibri;">DAG</span><span style="font-family:'宋体';">作业调度系统的宽窄依赖让</span><span style="font-family:Calibri;">Spark</span><span style="font-family:'宋体';">速度提高。</span></p>
<p> </p>
<p><span style="font-size:18px;"><strong>Spark<span style="font-family:'宋体';">核心组成</span></strong></span></p>
<p><strong><span style="font-size:14px;">1<span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">RDD</span></span></strong></p>
<p>是弹性分布式数据集，完全弹性的，如果数据丢失一部分还可以重建。有自动容错、位置感知调度和可伸缩性，通过数据检查点和记录数据更新金象容错性检查。通过<span style="font-family:Calibri;">SparkContext.textFile()</span><span style="font-family:'宋体';">加载文件变成</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">，然后通过</span><span style="font-family:Calibri;">transformation</span><span style="font-family:'宋体';">构建新的</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">，通过</span><span style="font-family:Calibri;">action</span><span style="font-family:'宋体';">将</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">存储到外部系统。</span></p>
<p>RDD<span style="font-family:'宋体';">使用延迟加载，也就是懒加载，只有当用到的时候才加载数据。如果加载存储所有的中间过程会浪费空间。因此要延迟加载。一旦</span><span style="font-family:Calibri;">spark</span><span style="font-family:'宋体';">看到整个变换链，他可以计算仅需的结果数据，如果下面的函数不需要数据那么数据也不会再加载。转换</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">是惰性的，只有在动作中才可以使用它们。</span></p>
<p>Spark<span style="font-family:'宋体';">分为</span><span style="font-family:Calibri;">driver</span><span style="font-family:'宋体';">和</span><span style="font-family:Calibri;">executor</span><span style="font-family:'宋体';">，</span><span style="font-family:Calibri;">driver</span><span style="font-family:'宋体';">提交作业，</span><span style="font-family:Calibri;">executor</span><span style="font-family:'宋体';">是</span><span style="font-family:Calibri;">application</span><span style="font-family:'宋体';">早</span><span style="font-family:Calibri;">worknode</span><span style="font-family:'宋体';">上的进程，运行</span><span style="font-family:Calibri;">task</span><span style="font-family:'宋体';">，</span><span style="font-family:Calibri;">driver</span><span style="font-family:'宋体';">对应为</span><span style="font-family:Calibri;">sparkcontext</span><span style="font-family:'宋体';">。</span><span style="font-family:Calibri;">Spark</span><span style="font-family:'宋体';">的</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">操作有</span><span style="font-family:Calibri;">transformation</span><span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">action</span><span style="font-family:'宋体';">。</span><span style="font-family:Calibri;">Transformation</span><span style="font-family:'宋体';">对</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">进行依赖包装，</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">所对应的依赖都进行</span><span style="font-family:Calibri;">DAG</span><span style="font-family:'宋体';">的构建并保存，在</span><span style="font-family:Calibri;">worknode</span><span style="font-family:'宋体';">挂掉之后除了通过备份恢复还可以通过元数据对其保存的依赖再计算一次得到。当作业提交也就是调用</span><span style="font-family:Calibri;">runJob</span><span style="font-family:'宋体';">时，</span><span style="font-family:Calibri;">spark</span><span style="font-family:'宋体';">会根据</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">构建</span><span style="font-family:Calibri;">DAG</span><span style="font-family:'宋体';">图，提交给</span><span style="font-family:Calibri;">DAGScheduler</span><span style="font-family:'宋体';">，这个</span><span style="font-family:Calibri;">DAGScheduler</span><span style="font-family:'宋体';">是在</span><span style="font-family:Calibri;">SparkContext</span><span style="font-family:'宋体';">创建时一同初始化的，他会对作业进行调度处理。当依赖图构建好以后，从</span><span style="font-family:Calibri;">action</span><span style="font-family:'宋体';">开始进行解析，每一个操作作为一个</span><span style="font-family:Calibri;">task</span><span style="font-family:'宋体';">，每遇到</span><span style="font-family:Calibri;">shuffle</span><span style="font-family:'宋体';">就切割成为一个</span><span style="font-family:Calibri;">taskSet</span><span style="font-family:'宋体';">，并把数据输出到磁盘，如果不是</span><span style="font-family:Calibri;">shuffle</span><span style="font-family:'宋体';">数据还在内存中存储。就这样再往前推进，直到没有算子，然后运行从前面开始，如果没有</span><span style="font-family:Calibri;">action</span><span style="font-family:'宋体';">的算子在这里不会执行，直到遇到</span><span style="font-family:Calibri;">action</span><span style="font-family:'宋体';">为止才开始运行，这就形成了</span><span style="font-family:Calibri;">spark</span><span style="font-family:'宋体';">的懒加载，</span><span style="font-family:Calibri;">taskset</span><span style="font-family:'宋体';">提交给</span><span style="font-family:Calibri;">TaskSheduler</span><span style="font-family:'宋体';">生成</span><span style="font-family:Calibri;">TaskSetManager</span><span style="font-family:'宋体';">并且提交给</span><span style="font-family:Calibri;">Executor</span><span style="font-family:'宋体';">运行，运行结束后反馈给</span><span style="font-family:Calibri;">DAGScheduler</span><span style="font-family:'宋体';">完成一个</span><span style="font-family:Calibri;">taskSet</span><span style="font-family:'宋体';">，之后再提交下一个，当</span><span style="font-family:Calibri;">TaskSet</span><span style="font-family:'宋体';">运行失败时就返回</span><span style="font-family:Calibri;">DAGScheduler</span><span style="font-family:'宋体';">并重新再次创建。一个</span><span style="font-family:Calibri;">job</span><span style="font-family:'宋体';">里面可能有多个</span><span style="font-family:Calibri;">TaskSet</span><span style="font-family:'宋体';">，一个</span><span style="font-family:Calibri;">application</span><span style="font-family:'宋体';">可能包含多个</span><span style="font-family:Calibri;">job</span><span style="font-family:'宋体';">。</span></p>
<p><span style="font-size:14px;"><strong>2、Spark Streaming</strong></span></p>
<p>通过对<span style="font-family:Calibri;">kafka</span><span style="font-family:'宋体';">数据读取，将</span><span style="font-family:Calibri;">Stream</span><span style="font-family:'宋体';">数据分成小的时间片段（几秒），以类似</span><span style="font-family:Calibri;">batch</span><span style="font-family:'宋体';">批处理的方式来处理这一部分小数据，</span>每个时间片生成一个RDD<span style="font-family:'宋体';">，</span>有高效的容错性，对小批量数据可以兼容批量实时数据处理的逻辑算法，用一些历史数据和实时数据联合进行分析，比如分类算法等。也可以对小批量的<span style="font-family:Calibri;">stream</span><span style="font-family:'宋体';">进行</span><span style="font-family:Calibri;">mapreduce</span><span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">join</span><span style="font-family:'宋体';">等操作，而保证其实时性。针对数据流时间要求不到毫秒级的工程性问题都可以。</span></p>
<p>Spark Streaming<span style="font-family:'宋体';">也有一个</span><span style="font-family:Calibri;">StreamingContext</span><span style="font-family:'宋体';">，其核心是</span><span style="font-family:Calibri;">DStream</span><span style="font-family:'宋体';">，是通过以组时间序列上的连续</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">来组成的，包含一个有</span><span style="font-family:Calibri;">Time</span><span style="font-family:'宋体';">作为</span><span style="font-family:Calibri;">key</span><span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">作为</span><span style="font-family:Calibri;">value</span><span style="font-family:'宋体';">的结构体，每一个</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">都包含特定时间间隔的数据流，可以通过</span><span style="font-family:Calibri;">persist</span><span style="font-family:'宋体';">将其持久化。在接受不断的数据流后，在</span><span style="font-family:Calibri;">blockGenerator</span><span style="font-family:'宋体';">中维护一个队列，将流数据放到队列中，等处理时间间隔到来后将其中的所有数据合并成为一个</span><span style="font-family:Calibri;">RDD(</span><span style="font-family:'宋体';">这一间隔中的数据</span><span style="font-family:Calibri;">)</span><span style="font-family:'宋体';">。其作业提交和</span><span style="font-family:Calibri;">spark</span><span style="font-family:'宋体';">相似，只不过在提交时拿到</span><span style="font-family:Calibri;">DStream</span><span style="font-family:'宋体';">内部的</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">并产生</span><span style="font-family:Calibri;">Job</span><span style="font-family:'宋体';">提交，</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">在</span><span style="font-family:Calibri;">action</span><span style="font-family:'宋体';">触发之后，将</span><span style="font-family:Calibri;">job</span><span style="font-family:'宋体';">提交给</span><span style="font-family:Calibri;">jobManager</span><span style="font-family:'宋体';">中的</span><span style="font-family:Calibri;">JobQueue</span><span style="font-family:'宋体';">，又</span><span style="font-family:Calibri;">jobScheduler</span><span style="font-family:'宋体';">调度，</span><span style="font-family:Calibri;">JobScheduler</span><span style="font-family:'宋体';">将</span><span style="font-family:Calibri;">job</span><span style="font-family:'宋体';">提交到</span><span style="font-family:Calibri;">spark</span><span style="font-family:'宋体';">的</span><span style="font-family:Calibri;">job</span><span style="font-family:'宋体';">调度器，然后将</span><span style="font-family:Calibri;">job</span><span style="font-family:'宋体';">转换成为大量的任务分发给</span><span style="font-family:Calibri;">spark</span><span style="font-family:'宋体';">集群执行。</span><span style="font-family:Calibri;">Job</span><span style="font-family:'宋体';">从</span><span style="font-family:Calibri;">outputStream</span><span style="font-family:'宋体';">中生成的，然后触发反向回溯执行</span><span style="font-family:Calibri;">DStreamDAG</span><span style="font-family:'宋体';">。在流数据处理的过程中，一般节点失效的处理比离线数据要复杂。</span><span style="font-family:Calibri;">Spark streamin</span><span style="font-family:'宋体';">在</span><span style="font-family:Calibri;">1.3</span><span style="font-family:'宋体';">之后可以周期性的将</span><span style="font-family:Calibri;">DStream</span><span style="font-family:'宋体';">写入</span><span style="font-family:Calibri;">HDFS</span><span style="font-family:'宋体';">，同时将</span><span style="font-family:Calibri;">offset</span><span style="font-family:'宋体';">也进行存储，避免写到</span><span style="font-family:Calibri;">zk</span><span style="font-family:'宋体';">。一旦主节点失效，会通过</span><span style="font-family:Calibri;">checkpoint</span><span style="font-family:'宋体';">的方式读取之前的数据。当</span><span style="font-family:Calibri;">worknode</span><span style="font-family:'宋体';">节点失效，如果</span><span style="font-family:Calibri;">HDFS</span><span style="font-family:'宋体';">或文件作为输入源那</span><span style="font-family:Calibri;">Spark</span><span style="font-family:'宋体';">会根据依赖关系重新计算数据，如果是基于</span><span style="font-family:Calibri;">Kafka</span><span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">Flume</span><span style="font-family:'宋体';">等网络数据源</span><span style="font-family:Calibri;">spark</span><span style="font-family:'宋体';">会将手机的数据源在集群中的不同节点进行备份，一旦有一个工作节点失效，系统能够根据另一份还存在的数据重新计算，但是如果接受节点失效会丢失一部分数据，同时接受线程会在其他的节点上重新启动并接受数据。</span></p>
<p><span style="font-size:14px;"><strong>3、Graphx</strong></span></p>
<p>主要用于图的计算。核心算法有<span style="font-family:Calibri;">PageRank</span><span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">SVD</span><span style="font-family:'宋体';">奇异矩阵、</span><span style="font-family:Calibri;">TriangleConut</span><span style="font-family:'宋体';">等。</span></p>
<p><span style="font-size:14px;"><strong>4、Spark SQL</strong></span></p>
<p>是<span style="font-family:Calibri;">Spark</span><span style="font-family:'宋体';">新推出的交互式大数据</span><span style="font-family:Calibri;">SQL</span><span style="font-family:'宋体';">技术。把</span><span style="font-family:Calibri;">sql</span><span style="font-family:'宋体';">语句翻译成</span><span style="font-family:Calibri;">Spark</span><span style="font-family:'宋体';">上的</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">操作可以支持</span><span style="font-family:Calibri;">Hive</span><span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">Json</span><span style="font-family:'宋体';">等类型的数据。</span></p>
<p><span style="font-size:14px;"><strong>5、Spark R</strong></span></p>
<p>通过<span style="font-family:Calibri;">R</span><span style="font-family:'宋体';">语言调用</span><span style="font-family:Calibri;">spark</span><span style="font-family:'宋体';">，目前不会拥有像</span><span style="font-family:Calibri;">Scala</span><span style="font-family:'宋体';">或者</span><span style="font-family:Calibri;">java</span><span style="font-family:'宋体';">那样广泛的</span><span style="font-family:Calibri;">API</span><span style="font-family:'宋体';">，</span><span style="font-family:Calibri;">Spark</span><span style="font-family:'宋体';">通过</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">类提供</span><span style="font-family:Calibri;">Spark API</span><span style="font-family:'宋体';">，并且允许用户使用</span><span style="font-family:Calibri;">R</span><span style="font-family:'宋体';">交互式方式在集群中运行任务。同时集成了</span><span style="font-family:Calibri;">MLlib</span><span style="font-family:'宋体';">机器学习类库。</span></p>
<p><span style="font-size:14px;"><strong>6、MLBase</strong></span></p>
<p>从上到下包括了<span style="font-family:Calibri;">MLOptimizer</span><span style="font-family:'宋体';">（给使用者）、</span><span style="font-family:Calibri;">MLI</span><span style="font-family:'宋体';">（给算法使用者）、</span><span style="font-family:Calibri;">MLlib</span><span style="font-family:'宋体';">（给算法开发者）、</span><span style="font-family:Calibri;">Spark</span><span style="font-family:'宋体';">。也可以直接使用</span><span style="font-family:Calibri;">MLlib</span><span style="font-family:'宋体';">。</span><span style="font-family:Calibri;">ML Optimizer</span><span style="font-family:'宋体';">，一个优化机器学习选择更合适的算法和相关参数的模块，还有</span><span style="font-family:Calibri;">MLI</span><span style="font-family:'宋体';">进行特征抽取和高级</span><span style="font-family:Calibri;">ML</span><span style="font-family:'宋体';">编程 抽象算法实现</span><span style="font-family:Calibri;">API</span><span style="font-family:'宋体';">平台，</span><span style="font-family:Calibri;">MLlib</span><span style="font-family:'宋体';">分布式机器学习库，可以不断扩充算法。</span><span style="font-family:Calibri;">MLRuntime</span><span style="font-family:'宋体';">基于</span><span style="font-family:Calibri;">spark</span><span style="font-family:'宋体';">计算框架，将</span><span style="font-family:Calibri;">Spark</span><span style="font-family:'宋体';">的分布式计算应用到机器学习领域。</span><span style="font-family:Calibri;">MLBase</span><span style="font-family:'宋体';">提供了一个简单的声明方法指定机器学习任务，并且动态地选择最优的学习算法。</span></p>
<p><span style="font-size:14px;"><strong>7、Tachyon</strong></span></p>
<p>高容错的分布式文件系统。宣称其性能是<span style="font-family:Calibri;">HDFS</span><span style="font-family:'宋体';">的</span><span style="font-family:Calibri;">3000</span><span style="font-family:'宋体';">多倍。有类似</span><span style="font-family:Calibri;">java</span><span style="font-family:'宋体';">的接口，也实现了</span><span style="font-family:Calibri;">HDFS</span><span style="font-family:'宋体';">接口，所以</span><span style="font-family:Calibri;">Spark</span><span style="font-family:'宋体';">和</span><span style="font-family:Calibri;">MR</span><span style="font-family:'宋体';">程序不需要任何的修改就可以运行。目前支持</span><span style="font-family:Calibri;">HDFS</span><span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">S3</span><span style="font-family:'宋体';">等。</span></p>
<p><span style="font-size:14px;"><strong>8、Spark<span style="font-family:'宋体';">算子</span></strong></span></p>
<p></p>
<p><strong style="background-color:inherit;"><span style="color:#ff0000;background-color:inherit;">大致可以分为三大类算子。</span></strong></p>
<p>1）Value数据类型的Transformation算子，这种变换并不触发提交作业，针对处理的数据项是Value型的数据。</p>
<p>2）Key-Value数据类型的Transfromation算子，这种变换并不触发提交作业，针对处理的数据项是Key-Value型的数据对。</p>
<p>3）Action算子，这类算子会触发SparkContext提交Job作业。</p>
<p><br style="background-color:inherit;"></p>
<p><span style="font-family:'微软雅黑';font-size:14px;background-color:rgb(255,255,255);font-style:normal;text-align:left;"><strong style="background-color:inherit;"><span style="color:#ff0000;background-color:inherit;">1）Value数据类型的Transformation算子</span></strong></span><br style="background-color:inherit;"></p>
<p>1、Map<span style="font-family:'宋体';background-color:inherit;">。对原数据进行处理，类似于遍历操作，转换成</span><span style="font-family:Calibri;background-color:inherit;">MappedRDD</span><span style="font-family:'宋体';background-color:inherit;">，原分区不变。</span></p>
<p>2、flatMap<span style="font-family:'宋体';background-color:inherit;">。将原来的</span><span style="font-family:Calibri;background-color:inherit;">RDD</span><span style="font-family:'宋体';background-color:inherit;">中的每一个元素通过函数转换成新的元素，将</span><span style="font-family:Calibri;background-color:inherit;">RDD</span><span style="font-family:'宋体';background-color:inherit;">的每个集合中的元素合并成一个集合。比如一个元素里面多个</span><span style="font-family:Calibri;background-color:inherit;">list</span><span style="font-family:'宋体';background-color:inherit;">，通过这个函数都合并成一个大的</span><span style="font-family:Calibri;background-color:inherit;">list</span><span style="font-family:'宋体';background-color:inherit;">，最经典的就是</span><span style="font-family:Calibri;background-color:inherit;">wordcount</span><span style="font-family:'宋体';background-color:inherit;">中将每一行元素进行分词以后成为，通过</span><span style="font-family:Calibri;background-color:inherit;">flapMap</span><span style="font-family:'宋体';background-color:inherit;">变成一个个的单词，</span><span style="font-family:Calibri;background-color:inherit;">line.flapMap(_.split(</span>“ ”)).map((_,1))<span style="font-family:'宋体';background-color:inherit;">如果通过</span><span style="font-family:Calibri;background-color:inherit;">map</span><span style="font-family:'宋体';background-color:inherit;">就会将一行的单词变成一个</span><span style="font-family:Calibri;background-color:inherit;">list</span><span style="font-family:'宋体';background-color:inherit;">。</span></p>
<p>3、mapPartitions<span style="font-family:'宋体';background-color:inherit;">。对每个分区进行迭代，生成</span><span style="font-family:Calibri;background-color:inherit;">MapPartitionsRDD</span><span style="font-family:'宋体';background-color:inherit;">。</span></p>
<p><span style="font-family:'宋体';background-color:inherit;">4、glom 函数将每个分区形成一个数组，内部实现是放回的GlommedRDD。</span></p>
<p>5、Union<span style="font-family:'宋体';background-color:inherit;">。是将两个</span><span style="font-family:Calibri;background-color:inherit;">RDD</span><span style="font-family:'宋体';background-color:inherit;">合并成一个。使用这个函数要保证两个</span><span style="font-family:Calibri;background-color:inherit;">RDD</span><span style="font-family:'宋体';background-color:inherit;">元素的数据类型相同，返回的</span><span style="font-family:Calibri;background-color:inherit;">RDD</span><span style="font-family:'宋体';background-color:inherit;">的数据类型和被合并的</span><span style="font-family:Calibri;background-color:inherit;">RDD</span><span style="font-family:'宋体';background-color:inherit;">数据类型相同。</span></p>
<p><span style="font-family:'宋体';background-color:inherit;">6、cartesian 对两个RDD内所有的元素进行笛卡尔积操作。</span></p>
<p><span style="font-family:'宋体';background-color:inherit;">7、groupBy：将元素通过函数生成相应的Key，数据就转化为Key-Value，之后将Key相同的元素分为一组。</span></p>
<p><span style="background-color:inherit;line-height:1.5;">8、Filter</span><span style="font-family:'宋体';background-color:inherit;line-height:1.5;">。其功能是对元素进行过滤，对每个元素调用</span><span style="font-family:Calibri;background-color:inherit;line-height:1.5;">f</span><span style="font-family:'宋体';background-color:inherit;line-height:1.5;">函数，返回值为</span><span style="font-family:Calibri;background-color:inherit;line-height:1.5;">true</span><span style="font-family:'宋体';background-color:inherit;line-height:1.5;">的元素就保留在</span><span style="font-family:Calibri;background-color:inherit;line-height:1.5;">RDD</span><span style="font-family:'宋体';background-color:inherit;line-height:1.5;">中。</span></p>
<p>9、Distinct<span style="font-family:'宋体';background-color:inherit;">。对</span><span style="font-family:Calibri;background-color:inherit;">RDD</span><span style="font-family:'宋体';background-color:inherit;">中元素进行去重操作。</span></p>
<p>10、Subtract<span style="font-family:'宋体';background-color:inherit;">。对</span><span style="font-family:Calibri;background-color:inherit;">RDD1</span><span style="font-family:'宋体';background-color:inherit;">中取出</span><span style="font-family:Calibri;background-color:inherit;">RDD1</span><span style="font-family:'宋体';background-color:inherit;">与</span><span style="font-family:Calibri;background-color:inherit;">RDD2</span><span style="font-family:'宋体';background-color:inherit;">交集中的所有元素。</span></p>
<p>11、Sample<span style="font-family:'宋体';background-color:inherit;">。对</span><span style="font-family:Calibri;background-color:inherit;">RDD</span><span style="font-family:'宋体';background-color:inherit;">中的集合内元素进行采样，第一个参数</span><span style="font-family:Calibri;background-color:inherit;">withReplacement</span><span style="font-family:'宋体';background-color:inherit;">是</span><span style="font-family:Calibri;background-color:inherit;">true</span><span style="font-family:'宋体';background-color:inherit;">表示有放回取样，</span><span style="font-family:Calibri;background-color:inherit;">false</span><span style="font-family:'宋体';background-color:inherit;">表示无放回。第二个参数表示比例，第三个参数是随机种子。如</span><span style="font-family:Calibri;background-color:inherit;">data.sample(true, 0.3,new Random().nextInt())</span><span style="font-family:'宋体';background-color:inherit;">。</span></p>
<p>12、takeSample<span style="font-family:'宋体';background-color:inherit;">。和</span><span style="font-family:Calibri;background-color:inherit;">sample</span><span style="font-family:'宋体';background-color:inherit;">用法相同，只不第二个参数换成了个数。返回也不是</span><span style="font-family:Calibri;background-color:inherit;">RDD</span><span style="font-family:'宋体';background-color:inherit;">，而是</span><span style="font-family:Calibri;background-color:inherit;">collect</span><span style="font-family:'宋体';background-color:inherit;">。</span></p>
<p>13、Cache<span style="font-family:'宋体';background-color:inherit;">。将</span><span style="font-family:Calibri;background-color:inherit;">RDD</span><span style="font-family:'宋体';background-color:inherit;">缓存到内存中。相当于</span><span style="font-family:Calibri;background-color:inherit;">persist</span><span style="font-family:'宋体';background-color:inherit;">（</span><span style="font-family:Calibri;background-color:inherit;">MEMORY_ONLY</span><span style="font-family:'宋体';background-color:inherit;">）。可以通过参数设置缓存和运行内存之间的比例，如果数据量大于</span><span style="font-family:Calibri;background-color:inherit;">cache</span><span style="font-family:'宋体';background-color:inherit;">内存则会丢失。</span></p>
<p>14、Persist<span style="font-family:'宋体';background-color:inherit;">。里面参数可以选择</span><span style="font-family:Calibri;background-color:inherit;">DISK_ONLY/MEMORY_ONLY/MEMORY_AND_DISK</span><span style="font-family:'宋体';background-color:inherit;">等，其中的</span><span style="font-family:Calibri;background-color:inherit;">MEMORY_AND_DISK</span><span style="font-family:'宋体';background-color:inherit;">当缓存空间满了后自动溢出到磁盘。</span></p>
<p><span style="font-family:'宋体';background-color:inherit;"><br></span></p>
<p><span style="font-family:'宋体';background-color:inherit;"><span style="font-family:'微软雅黑';font-size:14px;background-color:rgb(255,255,255);font-style:normal;text-align:left;"><strong style="background-color:inherit;"><span style="color:#ff0000;background-color:inherit;">2）Key-Value数据类型的Transfromation算子</span></strong></span><br style="background-color:inherit;"></span></p>
<p>1、MapValues<span style="font-family:'宋体';background-color:inherit;">。针对</span><span style="font-family:Calibri;background-color:inherit;">KV</span><span style="font-family:'宋体';background-color:inherit;">数据，对数据中的</span><span style="font-family:Calibri;background-color:inherit;">value</span><span style="font-family:'宋体';background-color:inherit;">进行</span><span style="font-family:Calibri;background-color:inherit;">map</span><span style="font-family:'宋体';background-color:inherit;">操作，而不对</span><span style="font-family:Calibri;background-color:inherit;">key</span><span style="font-family:'宋体';background-color:inherit;">进行处理。</span></p>
<p>2、reduceByKey<span style="font-family:'宋体';background-color:inherit;">。针对</span><span style="font-family:Calibri;background-color:inherit;">KV</span><span style="font-family:'宋体';background-color:inherit;">数据将相同</span><span style="font-family:Calibri;background-color:inherit;">key</span><span style="font-family:'宋体';background-color:inherit;">的</span><span style="font-family:Calibri;background-color:inherit;">value</span><span style="font-family:'宋体';background-color:inherit;">聚合到一起。与</span><span style="font-family:Calibri;background-color:inherit;">groupByKey</span><span style="font-family:'宋体';background-color:inherit;">不同，会进行一个类似</span><span style="font-family:Calibri;background-color:inherit;">mapreduce</span><span style="font-family:'宋体';background-color:inherit;">中的</span><span style="font-family:Calibri;background-color:inherit;">combine</span><span style="font-family:'宋体';background-color:inherit;">操作，减少相应的数据</span><span style="font-family:Calibri;background-color:inherit;">IO</span><span style="font-family:'宋体';background-color:inherit;">操作，加快效率。如果想进行一些非叠加操作，我们可以将</span><span style="font-family:Calibri;background-color:inherit;">value</span><span style="font-family:'宋体';background-color:inherit;">组合成字符串或其他格式将相同</span><span style="font-family:Calibri;background-color:inherit;">key</span><span style="font-family:'宋体';background-color:inherit;">的</span><span style="font-family:Calibri;background-color:inherit;">value</span><span style="font-family:'宋体';background-color:inherit;">组合在一起，再通过迭代，组合的数据拆开操作。</span></p>
<p>3、partitionBy<span style="font-family:'宋体';background-color:inherit;">。可以将</span><span style="font-family:Calibri;background-color:inherit;">RDD</span><span style="font-family:'宋体';background-color:inherit;">进行分区，重新生成一个</span><span style="font-family:Calibri;background-color:inherit;">ShuffleRDD</span><span style="font-family:'宋体';background-color:inherit;">，进行一个</span><span style="font-family:Calibri;background-color:inherit;">shuffle</span><span style="font-family:'宋体';background-color:inherit;">操作，对后面进行频繁的</span><span style="font-family:Calibri;background-color:inherit;">shuffle</span><span style="font-family:'宋体';background-color:inherit;">操作可以加快效率。</span></p>
<p>4、randomSplit<span style="font-family:'宋体';background-color:inherit;">。对</span><span style="font-family:Calibri;background-color:inherit;">RDD</span><span style="font-family:'宋体';background-color:inherit;">进行随机切分。如</span><span style="font-family:Calibri;background-color:inherit;">data</span>.randomSplit(new double[]{0.7, 0.3})返回一个<span style="font-family:Calibri;background-color:inherit;">RDD</span><span style="font-family:'宋体';background-color:inherit;">的数组。</span></p>
<p>5、Cogroup<span style="font-family:'宋体';background-color:inherit;">。对两个</span><span style="font-family:Calibri;background-color:inherit;">RDD</span><span style="font-family:'宋体';background-color:inherit;">中的</span><span style="font-family:Calibri;background-color:inherit;">KV</span><span style="font-family:'宋体';background-color:inherit;">元素，每个</span><span style="font-family:Calibri;background-color:inherit;">RDD</span><span style="font-family:'宋体';background-color:inherit;">中相同</span><span style="font-family:Calibri;background-color:inherit;">key</span><span style="font-family:'宋体';background-color:inherit;">中的元素分别聚合成一个集合。与</span><span style="font-family:Calibri;background-color:inherit;">reduceByKey</span><span style="font-family:'宋体';background-color:inherit;">不同的是针对两个</span><span style="font-family:Calibri;background-color:inherit;">RDD</span><span style="font-family:'宋体';background-color:inherit;">中相同的</span><span style="font-family:Calibri;background-color:inherit;">key</span><span style="font-family:'宋体';background-color:inherit;">的元素进行合并。</span></p>
<p>6、Join<span style="font-family:'宋体';background-color:inherit;">。相当于</span><span style="font-family:Calibri;background-color:inherit;">inner join</span><span style="font-family:'宋体';background-color:inherit;">。对两个需要连接的</span><span style="font-family:Calibri;background-color:inherit;">RDD</span><span style="font-family:'宋体';background-color:inherit;">进行</span><span style="font-family:Calibri;background-color:inherit;">cogroup</span><span style="font-family:'宋体';background-color:inherit;">，然后对每个</span><span style="font-family:Calibri;background-color:inherit;">key</span><span style="font-family:'宋体';background-color:inherit;">下面的</span><span style="font-family:Calibri;background-color:inherit;">list</span><span style="font-family:'宋体';background-color:inherit;">进行笛卡尔积的操作，输出两两相交的两个集合作为</span><span style="font-family:Calibri;background-color:inherit;">value</span><span style="font-family:'宋体';background-color:inherit;">。 相当于</span><span style="font-family:Calibri;background-color:inherit;">sql</span><span style="font-family:'宋体';background-color:inherit;">中</span><span style="font-family:Calibri;background-color:inherit;">where a.key=b.key</span><span style="font-family:'宋体';background-color:inherit;">。</span></p>
<p>7、leftOutJoin<span style="font-family:'宋体';background-color:inherit;">，</span><span style="font-family:Calibri;background-color:inherit;">rightOutJoin</span><span style="font-family:'宋体';background-color:inherit;">。在<a title="MySQL知识库" href="http://lib.csdn.net/base/14" rel="nofollow" style="background-color:inherit;color:rgb(223,52,52);font-weight:bold;">数据库</a>中左连接以左表为坐标将表中所有的数据列出来，右面不存在的用</span><span style="font-family:Calibri;background-color:inherit;">null</span><span style="font-family:'宋体';background-color:inherit;">填充。在这里面对</span><span style="font-family:Calibri;background-color:inherit;">join</span><span style="font-family:'宋体';background-color:inherit;">的基础上判断左侧的</span><span style="font-family:Calibri;background-color:inherit;">RDD</span><span style="font-family:'宋体';background-color:inherit;">元素是否是空，如果是空则填充。右连接则相反。</span></p>
<p><span style="font-family:'宋体';background-color:inherit;"><br></span></p>
<p><span style="font-family:'宋体';background-color:inherit;"><span style="font-family:'微软雅黑';font-size:14px;background-color:rgb(255,255,255);font-style:normal;text-align:left;"><strong style="background-color:inherit;"><span style="color:#ff0000;background-color:inherit;">3）Action算子</span></strong></span><br style="background-color:inherit;"></span></p>
<p><span style="font-family:'宋体';background-color:inherit;"><span style="font-family:'微软雅黑';font-size:14px;background-color:rgb(255,255,255);font-style:normal;text-align:left;">1、foreach 对RDD中每个元素都应用f函数操作，不返回RDD和Array，而是返回Unit。</span></span></p>
<p>2、saveAsTestFile<span style="font-family:'宋体';background-color:inherit;">。将数据输出到</span><span style="font-family:Calibri;background-color:inherit;">HDFS</span><span style="font-family:'宋体';background-color:inherit;">的指定目录。</span></p>
<p>3、saveAsObjectFile<span style="font-family:'宋体';background-color:inherit;">。写入</span><span style="font-family:Calibri;background-color:inherit;">HDFS</span><span style="font-family:'宋体';background-color:inherit;">为</span><span style="font-family:Calibri;background-color:inherit;">SequenceFile</span><span style="font-family:'宋体';background-color:inherit;">格式。</span></p>
<p>4、Collect<span style="font-family:'宋体';background-color:inherit;">、</span><span style="font-family:Calibri;background-color:inherit;">collectAsMap</span><span style="font-family:'宋体';background-color:inherit;">。将</span><span style="font-family:Calibri;background-color:inherit;">RDD</span><span style="font-family:'宋体';background-color:inherit;">转换成</span><span style="font-family:Calibri;background-color:inherit;">list</span><span style="font-family:'宋体';background-color:inherit;">或者</span><span style="font-family:Calibri;background-color:inherit;">Map</span><span style="font-family:'宋体';background-color:inherit;">。结果以</span><span style="font-family:Calibri;background-color:inherit;">List</span><span style="font-family:'宋体';background-color:inherit;">或者</span><span style="font-family:Calibri;background-color:inherit;">HashMap</span><span style="font-family:'宋体';background-color:inherit;">的方式输出。</span></p>
<p><span style="font-family:'宋体';background-color:inherit;">5、reduceByKeyLocally 实现的是先reduce再collectAsMap的功能，先对RDD的整体进行reduce操作，然后再收集所有结果返回为一个HashMap。</span></p>
<p>6、Count<span style="font-family:'宋体';background-color:inherit;">。对</span><span style="font-family:Calibri;background-color:inherit;">RDD</span><span style="font-family:'宋体';background-color:inherit;">的元素进行统计，返回个数。</span></p>
<p>7、Top<span style="font-family:'宋体';background-color:inherit;">（</span><span style="font-family:Calibri;background-color:inherit;">k</span><span style="font-family:'宋体';background-color:inherit;">）。返回最大的</span><span style="font-family:Calibri;background-color:inherit;">k</span><span style="font-family:'宋体';background-color:inherit;">个元素，返回</span><span style="font-family:Calibri;background-color:inherit;">List</span><span style="font-family:'宋体';background-color:inherit;">的形式。</span></p>
<p><span style="font-family:'宋体';background-color:inherit;"><span style="font-family:'微软雅黑';font-size:14px;color:#000000;background-color:rgb(255,255,255);font-style:normal;font-weight:normal;text-align:left;">8、Take</span><span style="font-family:'宋体';font-size:14px;color:#000000;background-color:rgb(255,255,255);font-style:normal;font-weight:normal;text-align:left;">返回数据的前</span><span style="font-family:Calibri;font-size:14px;color:#000000;background-color:rgb(255,255,255);font-style:normal;font-weight:normal;text-align:left;">k</span><span style="font-family:'宋体';font-size:14px;color:#000000;background-color:rgb(255,255,255);font-style:normal;font-weight:normal;text-align:left;">个元素。</span><br style="background-color:inherit;"></span></p>
<p><span style="font-family:'宋体';background-color:inherit;"><span style="font-family:'宋体';font-size:14px;color:#000000;background-color:rgb(255,255,255);font-style:normal;font-weight:normal;text-align:left;"><span style="font-family:'微软雅黑';font-size:14px;color:#000000;background-color:rgb(255,255,255);font-style:normal;font-weight:normal;text-align:left;">9、takeOrdered</span><span style="font-family:'宋体';font-size:14px;color:#000000;background-color:rgb(255,255,255);font-style:normal;font-weight:normal;text-align:left;">。返回数据的最小的</span><span style="font-family:Calibri;font-size:14px;color:#000000;background-color:rgb(255,255,255);font-style:normal;font-weight:normal;text-align:left;">k</span><span style="font-family:'宋体';font-size:14px;color:#000000;background-color:rgb(255,255,255);font-style:normal;font-weight:normal;text-align:left;">个元素，并在返回中保持元素的顺序。</span><br style="background-color:inherit;"></span></span></p>
<p><span style="font-family:'宋体';background-color:inherit;">10、reduce函数相当于对RDD中的元素进行reduceLeft函数的操作。</span></p>
<p>11、fold，fold和reduce原理相同，但是与reduce不同，相当于每个reduce时，迭代器取的第一个元素是zeroValue。</p>
<p>12、aggregate，先对每个分区的所有元素进行aggregate操作，再对分区的结果进行fold操作。</p>
<br><p><span style="font-family:'宋体';"></span></p>
<p><span style="font-size:14px;"><strong>9<span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">Tips</span></strong></span></p>
<p>1<span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">RDD.repartition(n)</span><span style="font-family:'宋体';">可以在最初对</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">进行分区操作，这个操作实际上是一个</span><span style="font-family:Calibri;">shuffle</span><span style="font-family:'宋体';">，可能比较耗时，但是如果之后的</span><span style="font-family:Calibri;">action</span><span style="font-family:'宋体';">比较多的话，可以减少下面操作的时间。其中的</span><span style="font-family:Calibri;">n</span><span style="font-family:'宋体';">值看</span><span style="font-family:Calibri;">cpu</span><span style="font-family:'宋体';">的个数，一般大于</span><span style="font-family:Calibri;">2</span><span style="font-family:'宋体';">倍</span><span style="font-family:Calibri;">cpu</span><span style="font-family:'宋体';">，小于</span><span style="font-family:Calibri;">1000</span><span style="font-family:'宋体';">。</span></p>
<p>2<span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">Action</span><span style="font-family:'宋体';">不能够太多，每一次的</span><span style="font-family:Calibri;">action</span><span style="font-family:'宋体';">都会将以上的</span><span style="font-family:Calibri;">taskset</span><span style="font-family:'宋体';">划分一个</span><span style="font-family:Calibri;">job</span><span style="font-family:'宋体';">，这样当</span><span style="font-family:Calibri;">job</span><span style="font-family:'宋体';">增多，而其中</span><span style="font-family:Calibri;">task</span><span style="font-family:'宋体';">并不释放，会占用更多的内存，使得</span><span style="font-family:Calibri;">gc</span><span style="font-family:'宋体';">拉低效率。</span></p>
<p>3<span style="font-family:'宋体';">、在</span><span style="font-family:Calibri;">shuffle</span><span style="font-family:'宋体';">前面进行一个过滤，减少</span><span style="font-family:Calibri;">shuffle</span><span style="font-family:'宋体';">数据，并且过滤掉</span><span style="font-family:Calibri;">null</span><span style="font-family:'宋体';">值，以及空值。</span></p>
<p>4<span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">groupBy</span><span style="font-family:'宋体';">尽量通过</span><span style="font-family:Calibri;">reduceBy</span><span style="font-family:'宋体';">替代。</span><span style="font-family:Calibri;">reduceBy</span><span style="font-family:'宋体';">会在</span><span style="font-family:Calibri;">work</span><span style="font-family:'宋体';">节点做一次</span><span style="font-family:Calibri;">reduce</span><span style="font-family:'宋体';">，在整体进行</span><span style="font-family:Calibri;">reduce</span><span style="font-family:'宋体';">，相当于做了一次</span><span style="font-family:Calibri;">hadoop</span><span style="font-family:'宋体';">中的</span><span style="font-family:Calibri;">combine</span><span style="font-family:'宋体';">操作，而</span><span style="font-family:Calibri;">combine</span><span style="font-family:'宋体';">操作和</span><span style="font-family:Calibri;">reduceBy</span><span style="font-family:'宋体';">逻辑一致，这个</span><span style="font-family:Calibri;">groupBy</span><span style="font-family:'宋体';">不能保证。</span></p>
<p>5<span style="font-family:'宋体';">、做</span><span style="font-family:Calibri;">join</span><span style="font-family:'宋体';">的时候，尽量用小</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">去</span><span style="font-family:Calibri;">join</span><span style="font-family:'宋体';">大</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">，用大</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">去</span><span style="font-family:Calibri;">join</span><span style="font-family:'宋体';">超大的</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">。</span></p>
<p>6<span style="font-family:'宋体';">、避免</span><span style="font-family:Calibri;">collect</span><span style="font-family:'宋体';">的使用。因为</span><span style="font-family:Calibri;">collect</span><span style="font-family:'宋体';">如果数据集超大的时候，会通过各个</span><span style="font-family:Calibri;">work</span><span style="font-family:'宋体';">进行收集，</span><span style="font-family:Calibri;">io</span><span style="font-family:'宋体';">增多，拉低性能，因此当数据集很大时要</span><span style="font-family:Calibri;">save</span><span style="font-family:'宋体';">到</span><span style="font-family:Calibri;">HDFS</span><span style="font-family:'宋体';">。</span></p>
<p>7<span style="font-family:'宋体';">、</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">如果后面使用迭代，建议</span><span style="font-family:Calibri;">cache</span><span style="font-family:'宋体';">，但是一定要估计好数据的大小，避免比</span><span style="font-family:Calibri;">cache</span><span style="font-family:'宋体';">设定的内存还要大，如果大过内存就会删除之前存储的</span><span style="font-family:Calibri;">cache</span><span style="font-family:'宋体';">，可能导致计算错误，如果想要完全的存储可以使用</span><span style="font-family:Calibri;">persist</span><span style="font-family:'宋体';">（</span><span style="font-family:Calibri;">MEMORY_AND_DISK</span><span style="font-family:'宋体';">），因为</span><span style="font-family:Calibri;">cache</span><span style="font-family:'宋体';">就是</span><span style="font-family:Calibri;">persist</span><span style="font-family:'宋体';">（</span><span style="font-family:Calibri;">MEMORY_ONLY</span><span style="font-family:'宋体';">）。</span></p>
<p>8<span style="font-family:'宋体';">、设置</span><span style="font-family:Calibri;">spark.cleaner.ttl</span><span style="font-family:'宋体';">，定时清除</span><span style="font-family:Calibri;">task</span><span style="font-family:'宋体';">，因为</span><span style="font-family:Calibri;">job</span><span style="font-family:'宋体';">的原因可能会缓存很多执行过去的</span><span style="font-family:Calibri;">task</span><span style="font-family:'宋体';">，所以定时回收可能避免集中</span><span style="font-family:Calibri;">gc</span><span style="font-family:'宋体';">操作拉低性能。</span></p>
<p>9<span style="font-family:'宋体';">、适当</span><span style="font-family:Calibri;">pre-partition</span><span style="font-family:'宋体';">，通过</span><span style="font-family:Calibri;">partitionBy</span><span style="font-family:'宋体';">（）设定，每次</span><span style="font-family:Calibri;">partitionBy</span><span style="font-family:'宋体';">会生成一个</span><span style="font-family:Calibri;">RDD</span><span style="font-family:'宋体';">。</span></p>
            </div>
                </div>