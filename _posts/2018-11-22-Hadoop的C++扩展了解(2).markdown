---
layout:     post
title:      Hadoop的C++扩展了解(2)
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                
 
<table style="table-layout:fixed;"><tbody><tr><td>
<div class="cnt" id="blog_text">
<p><span>Hadoop</span><span style="font-family:'宋体';">是一个软件平台，是</span><span>Apache</span><span style="font-family:'宋体';">开源组织的一个分布式计算开源框架，可以让你很容易地开发和运行处理海量数据的应用。</span><span>Hadoop</span><span style="font-family:'宋体';">框架中最核心的设计就是：</span><span>MapReduce</span><span style="font-family:'宋体';">和</span><span>HDFS</span><span style="font-family:'宋体';">，也可以说是</span><span>Hadoop</span><span style="font-family:'宋体';">是基于分布式文件系统（</span><span>HDFS</span><span style="font-family:'宋体';">）的</span><span>MapReduce</span><span style="font-family:'宋体';">的实现。</span><span></span></p>
<p><span> </span></p>
<p><strong><span style="font-family:'宋体';">分布式文件系统（</span><span>HDFS</span><span style="font-family:'宋体';">）</span><span></span></strong></p>
<p><span>HDFS</span><span style="font-family:'宋体';color:#000000;">采用</span><span>master/slave</span><span style="font-family:'宋体';color:#000000;">架构。一个</span><span>HDFS</span><span style="font-family:'宋体';color:#000000;">集群是由一个</span><span>Namenode</span><span style="font-family:'宋体';color:#000000;">和一定数目的</span><span>Datanodes</span><span style="font-family:'宋体';color:#000000;">组成。</span><span>Namenode</span><span style="font-family:'宋体';color:#000000;">是一个中心服务器，负责管理文件系统的名字空间</span><span>(namespace)</span><span style="font-family:'宋体';color:#000000;">以及客户端对文件的访问。集群中的</span><span>Datanode</span><span style="font-family:'宋体';color:#000000;">一般是一个节点一个，负责管理它所在节点上的存储。</span><span>HDFS</span><span style="font-family:'宋体';color:#000000;">暴露了文件系统的名字空间，用户能够以文件的形式在上面存储数据。从内部看，一个文件其实被分成一个或多个数据块，这些块存储在一组</span><span>Datanode</span><span style="font-family:'宋体';color:#000000;">上。</span><span>Namenode</span><span style="font-family:'宋体';color:#000000;">执行文件系统的名字空间操作，比如打开、关闭、重命名文件或目录。它也负责确定数据块到具体</span><span>Datanode</span><span style="font-family:'宋体';color:#000000;">节点的映射。</span><span>Datanode</span><span style="font-family:'宋体';color:#000000;">负责处理文件系统客户端的读写请求。在</span><span>Namenode</span><span style="font-family:'宋体';color:#000000;">的统一调度下进行数据块的创建、删除和复制。</span><span></span></p>
<p><span> </span></p>
<p><strong><span>MapReduce</span></strong></p>
<p><span>MapReduce</span><span style="font-family:'宋体';">任务是用来处理键</span><span>/</span><span style="font-family:'宋体';">值对的。该框架将转换每个输入的记录成一个键</span><span>/</span><span style="font-family:'宋体';">值对，每对数据会被输入给</span><span>Map</span><span style="font-family:'宋体';">作业。</span><span>Map</span><span style="font-family:'宋体';">任务的输出是一套键</span><span>/</span><span style="font-family:'宋体';">值对，原则上，输入是一个键</span><span>/</span><span style="font-family:'宋体';">值对，但是，输出可以是多个键</span><span>/</span><span style="font-family:'宋体';">值对。然后，它对</span><span>Map</span><span style="font-family:'宋体';">输出键</span><span>/</span><span style="font-family:'宋体';">值对分组和排序。然后，对排序的每个键值对调用一次</span><span>Reduce</span><span style="font-family:'宋体';">方法，它的输出是一个键值和一套关联的数据值。</span><span>Reduce</span><span style="font-family:'宋体';">方法可以输出任意数量的键</span><span>/</span><span style="font-family:'宋体';">值对，这将被写入工作输出目录下的输出文件。如果</span><span>Reduce</span><span style="font-family:'宋体';">输出键值保持和</span><span>Reduce</span><span style="font-family:'宋体';">输入键值一致，最终的输出仍然保持排序。</span><span></span></p>
<p><span> </span></p>
<p><span style="font-family:'宋体';">该框架提供了两个处理过程来管理</span><span>MapReduce</span><span style="font-family:'宋体';">作业：</span><span></span></p>
<p><span style="font-family:'宋体';">•</span><span>TaskTracker</span><span style="font-family:'宋体';">在集群中的计算节点上管理和执行各个</span><span>Map</span><span style="font-family:'宋体';">和</span><span>Reduce</span><span style="font-family:'宋体';">作业。</span><span> </span></p>
<p><span style="font-family:'宋体';">•</span><span>JobTracker</span><span style="font-family:'宋体';">接受作业提交，提供作业的监测和控制，管理任务，以及分配作业到</span><span>TaskTracker</span><span style="font-family:'宋体';">节点上。</span><span></span></p>
<p><span style="font-family:'宋体';">一般来说，每个集群有一个</span><span>JobTracker</span><span style="font-family:'宋体';">进程，集群中的每个节点有一个或多个</span><span>TaskTracker</span><span style="font-family:'宋体';">进程。</span><span>JobTracker</span><span style="font-family:'宋体';">是一个关键模块，它出现问题会引起系统的瘫痪，如果一个</span><span>TaskTracker</span><span style="font-family:'宋体';">出现问题，</span><span>JobTracker</span><span style="font-family:'宋体';">会调度其他</span><span>TaskTracker</span><span style="font-family:'宋体';">进程重试。</span><span></span></p>
<p><span style="font-family:'宋体';">下面是一个用</span><span>Google</span><span style="font-family:'宋体';">的</span><span>MapReduce</span><span style="font-family:'宋体';">的介绍的</span><span>RapReduce</span><span style="font-family:'宋体';">原理：</span><span></span></p>
<p><span style="color:#000000;font-size:10.5pt;">了解</span><span>MapReduce</span><span style="color:#000000;font-size:10.5pt;">模型的人应该知道，</span><span>Map</span><span style="color:#000000;font-size:10.5pt;">函数的输出是一系列的</span><span>Key/Value</span><span style="color:#000000;font-size:10.5pt;">对（</span><span>pair</span><span style="color:#000000;font-size:10.5pt;">），这些</span><span>Key/Value</span><span style="color:#000000;font-size:10.5pt;">对是给</span><span>Reduce</span><span style="color:#000000;font-size:10.5pt;">函数使用的。但是在这里可以发现，</span><span>Map</span><span style="color:#000000;font-size:10.5pt;">函数的输入参数也是</span><span>Key</span><span style="color:#000000;font-size:10.5pt;">和</span><span>Value</span><span style="color:#000000;font-size:10.5pt;">。但其实，输入的</span><span>Key/Value</span><span style="color:#000000;font-size:10.5pt;">和输出的</span><span>Key/Value</span><span style="color:#000000;font-size:10.5pt;">不是同一组东西。对于一个</span><span>Map</span><span style="color:#000000;font-size:10.5pt;">函数调用，输入的是一个</span><span>Key/Value</span><span style="color:#000000;font-size:10.5pt;">对，而输出呢，是一组</span><span>Key/Value</span><span style="color:#000000;font-size:10.5pt;">对。举例来说，如果要统计一篇文章中所有单词的数目，那么输入的</span><span>Key</span><span style="color:#000000;font-size:10.5pt;">可能就是行数，输入的</span><span>Value</span><span style="color:#000000;font-size:10.5pt;">就是该行的内容。对于一次</span><span>Map</span><span style="color:#000000;font-size:10.5pt;">调用，就是要统计出一行中各个单词出现的次数，所以输出的</span><span>Key</span><span style="color:#000000;font-size:10.5pt;">是单词，</span><span>Value</span><span style="color:#000000;font-size:10.5pt;">是这个单词的出现次数。</span><span><br>
Map</span><span style="color:#000000;font-size:10.5pt;">函数的输入之所以也用</span><span>Key/Value</span><span style="color:#000000;font-size:10.5pt;">的形式，可能是因为一般来说一个任务并不是用一次</span><span>MapReduce</span><span style="color:#000000;font-size:10.5pt;">就能够完成，而是需要用到多次</span><span>MapReduce</span><span style="color:#000000;font-size:10.5pt;">调用，下一个</span><span>Map</span><span style="color:#000000;font-size:10.5pt;">调用的输入很有可能就是上一个</span><span>Reduce</span><span style="color:#000000;font-size:10.5pt;">的输出结果（</span><span>Key/Value</span><span style="color:#000000;font-size:10.5pt;">对）。</span><span></span></p>
<p><span><br></span><span style="color:#000000;font-size:10.5pt;">系统流程</span><span></span></p>
<p><span style="font-size:10.5pt;"></span><span></span></p>
<p><span><span><img class="blogimg" src="http://hiphotos.baidu.com/yanxionglu/pic/item/501f21373c55774991ef3905.jpg" border="0" alt=""></span><br><br></span><span style="color:#000000;font-size:10.5pt;">结合上面的图，这里描述了当一个用户程序执行</span><span>MapReduce</span><span style="color:#000000;font-size:10.5pt;">调用后，系统的流程：</span><span><br>
1.</span><span style="color:#000000;font-size:10.5pt;">首先，用户程序中的</span><span>MapReduceLibrary</span><span style="color:#000000;font-size:10.5pt;">会将输入的文件（就是要处理的文件）切分成大小为</span><span>16M——64M</span><span style="color:#000000;font-size:10.5pt;">之间的</span><span>M</span><span style="color:#000000;font-size:10.5pt;">份（就是图中的</span><span>split
 0</span><span style="color:#000000;font-size:10.5pt;">，</span><span>split 1</span><span style="color:#000000;font-size:10.5pt;">，</span><span>...</span><span style="color:#000000;font-size:10.5pt;">），一般来说，这</span><span>M</span><span style="color:#000000;font-size:10.5pt;">份数据是放在了</span><span>cluster</span><span style="color:#000000;font-size:10.5pt;">的多台机器上。然后在整个</span><span>cluster</span><span style="color:#000000;font-size:10.5pt;">的机器上启动程序的多份拷贝，如图所示（</span><span>1</span><span style="color:#000000;font-size:10.5pt;">）。</span><span></span></p>
<p><span>2. </span><span style="color:#000000;font-size:10.5pt;">其中的一份程序拷贝是</span><span>master</span><span style="color:#000000;font-size:10.5pt;">，其余的拷贝是</span><span>workers</span><span style="color:#000000;font-size:10.5pt;">。</span><span>master</span><span style="color:#000000;font-size:10.5pt;">会将任务分配给</span><span>workers</span><span style="color:#000000;font-size:10.5pt;">。任务包括了</span><span>M</span><span style="color:#000000;font-size:10.5pt;">个</span><span>map</span><span style="color:#000000;font-size:10.5pt;">的任务和</span><span>R</span><span style="color:#000000;font-size:10.5pt;">个</span><span>
 reduce</span><span style="color:#000000;font-size:10.5pt;">的任务，</span><span>master</span><span style="color:#000000;font-size:10.5pt;">会找到空闲的</span><span>worker</span><span style="color:#000000;font-size:10.5pt;">然后将</span><span>map</span><span style="color:#000000;font-size:10.5pt;">或者</span><span>reduce</span><span style="color:#000000;font-size:10.5pt;">的任务分配给它。（</span><span>M</span><span style="color:#000000;font-size:10.5pt;">的值取决于</span><span>input
 files</span><span style="color:#000000;font-size:10.5pt;">被切分的块数；</span><span>R</span><span style="color:#000000;font-size:10.5pt;">值则是根据</span><span>map</span><span style="color:#000000;font-size:10.5pt;">中所能</span><span>hash</span><span style="color:#000000;font-size:10.5pt;">出的</span><span>key</span><span style="color:#000000;font-size:10.5pt;">的数量。）如图所示（</span><span>2</span><span style="color:#000000;font-size:10.5pt;">）。</span><span></span></p>
<p><span>3. </span><span style="color:#000000;font-size:10.5pt;">当一个</span><span>worker</span><span style="color:#000000;font-size:10.5pt;">被分配到</span><span>map</span><span style="color:#000000;font-size:10.5pt;">任务，那么它就会处理</span><span>M</span><span style="color:#000000;font-size:10.5pt;">份中的一份</span><span>split</span><span style="color:#000000;font-size:10.5pt;">。</span><span>InputData</span><span style="color:#000000;font-size:10.5pt;">中的数据也是</span><span>Key/Value</span><span style="color:#000000;font-size:10.5pt;">形式的很多</span><span>
 pairs</span><span style="color:#000000;font-size:10.5pt;">（这个在前面中提到了），</span><span>Map</span><span style="color:#000000;font-size:10.5pt;">任务的</span><span>worker</span><span style="color:#000000;font-size:10.5pt;">会将这些</span><span>pairs</span><span style="color:#000000;font-size:10.5pt;">一个一个传递给</span><span>Map</span><span style="color:#000000;font-size:10.5pt;">函数，</span><span>Map</span><span style="color:#000000;font-size:10.5pt;">函数产生的很多新的</span><span>Key/Value </span><span style="color:#000000;font-size:10.5pt;">对会被缓存在内存中。</span><span></span></p>
<p><span>4. </span><span style="color:#000000;font-size:10.5pt;">周期性的，</span><span>buffer</span><span style="color:#000000;font-size:10.5pt;">中缓存的那些</span><span>pairs</span><span style="color:#000000;font-size:10.5pt;">会写入到本地</span><span>disk</span><span style="color:#000000;font-size:10.5pt;">中。如图所示（</span><span>3</span><span style="color:#000000;font-size:10.5pt;">）（</span><span>4</span><span style="color:#000000;font-size:10.5pt;">）。由于有</span><span>R</span><span style="color:#000000;font-size:10.5pt;">个</span><span>reduce</span><span style="color:#000000;font-size:10.5pt;">任务，所以</span><span>disk</span><span style="color:#000000;font-size:10.5pt;">中的</span><span>pair </span><span style="color:#000000;font-size:10.5pt;">会按照一定规则分为</span><span>R</span><span style="color:#000000;font-size:10.5pt;">个区，每个区的数据都特定的给某一个</span><span>reduceWorker</span><span style="color:#000000;font-size:10.5pt;">。在图中的每个</span><span>Map
 Worker</span><span style="color:#000000;font-size:10.5pt;">所对应的</span><span>Intermediatefiles</span><span style="color:#000000;font-size:10.5pt;">其实被分成了</span><span>R</span><span style="color:#000000;font-size:10.5pt;">个区（很有可能就是</span><span>R</span><span style="color:#000000;font-size:10.5pt;">个文件）。这些区的位置会被传递到</span><span>master</span><span style="color:#000000;font-size:10.5pt;">上，它会负责将这些位置交给</span><span>reduce
 workers</span><span style="color:#000000;font-size:10.5pt;">。可以看到，</span><span>master</span><span style="color:#000000;font-size:10.5pt;">在这里起到了一个</span><span>“</span><span style="color:#000000;font-size:10.5pt;">承上启下</span><span>”</span><span style="color:#000000;font-size:10.5pt;">的作用，</span><span>Map</span><span style="color:#000000;font-size:10.5pt;">函数和</span><span>Reduce</span><span style="color:#000000;font-size:10.5pt;">函数之间的连接是由</span><span>master</span><span style="color:#000000;font-size:10.5pt;">完成的。</span><span></span></p>
<p><span>5. Reduce Worker</span><span style="color:#000000;font-size:10.5pt;">从</span><span>master</span><span style="color:#000000;font-size:10.5pt;">获取了这些区的位置，然后将这些</span><span>Key/Value</span><span style="color:#000000;font-size:10.5pt;">对从</span><span>mapWorker</span><span style="color:#000000;font-size:10.5pt;">处通过</span><span>RPC</span><span style="color:#000000;font-size:10.5pt;">读取。注意，</span><span>Reduce
 Worker</span><span style="color:#000000;font-size:10.5pt;">只读那些对应于自己的区的数据。如图所示（</span><span>5</span><span style="color:#000000;font-size:10.5pt;">）。读取完数据后需要对于这些</span><span>Key/Value</span><span style="color:#000000;font-size:10.5pt;">对按照</span><span>Key</span><span style="color:#000000;font-size:10.5pt;">进行排序，如果需要，可能还采取外排的方式（</span><span>externalsort</span><span style="color:#000000;font-size:10.5pt;">）。之所以需要排序是因为对于一个</span><span>Key</span><span style="color:#000000;font-size:10.5pt;">，会有很多组不同的</span><span>pair</span><span style="color:#000000;font-size:10.5pt;">，通过排序可以将它们聚合在一起。</span><span></span></p>
<p><span>6. reduceWorker</span><span style="color:#000000;font-size:10.5pt;">迭代整个被排序后的</span><span>Key/Value</span><span style="color:#000000;font-size:10.5pt;">数据，将每个独一无二的</span><span>key</span><span style="color:#000000;font-size:10.5pt;">和它所对应的</span><span>value</span><span style="color:#000000;font-size:10.5pt;">序列（之所以是序列，是因为对于一个</span><span>
 key</span><span style="color:#000000;font-size:10.5pt;">可能有很多个</span><span>Key/Value</span><span style="color:#000000;font-size:10.5pt;">，每个项中的</span><span>value</span><span style="color:#000000;font-size:10.5pt;">都不同，它们已经通过排序聚合在了一起）送入</span><span>Reduce</span><span style="color:#000000;font-size:10.5pt;">函数中。</span><span>Reduce</span><span style="color:#000000;font-size:10.5pt;">函数对于这样的输入产生的结果往往是</span><span>0</span><span style="color:#000000;font-size:10.5pt;">或者</span><span>1</span><span style="color:#000000;font-size:10.5pt;">个值（比如将所有</span><span>Value</span><span style="color:#000000;font-size:10.5pt;">相加，和就是最后的结果）。</span><span>Reduce</span><span style="color:#000000;font-size:10.5pt;">函数对于</span><span>Reduce</span><span style="color:#000000;font-size:10.5pt;">函数的结果会被添加到最终的</span><span>
 output file</span><span style="color:#000000;font-size:10.5pt;">里（每次</span><span>reduce Worker</span><span style="color:#000000;font-size:10.5pt;">都会产生一个输出文件，最终一共有</span><span>R</span><span style="color:#000000;font-size:10.5pt;">个文件，因为一共有</span><span>R</span><span style="color:#000000;font-size:10.5pt;">个</span><span>reduce</span><span style="color:#000000;font-size:10.5pt;">的任务）。如图所示（</span><span>6</span><span style="color:#000000;font-size:10.5pt;">）。</span><span></span></p>
<p><span>7. </span><span style="color:#000000;font-size:10.5pt;">当所有的</span><span>map</span><span style="color:#000000;font-size:10.5pt;">和</span><span>reduce</span><span style="color:#000000;font-size:10.5pt;">任务结束后，</span><span>master</span><span style="color:#000000;font-size:10.5pt;">会唤醒用户的程序。这时候，用户的</span><span>MapReduce</span><span style="color:#000000;font-size:10.5pt;">调用返回。</span><span></span></p>
<p><span style="font-family:'宋体';color:#000000;">还需要提及的是，当整个流程顺利完成以后，最终得到的其实是</span><span>R</span><span style="font-family:'宋体';color:#000000;">个文件。如果想要最终的结果，应该将这</span><span>R</span><span style="font-family:'宋体';color:#000000;">个文件合并。但一般来说，都是将这</span><span>R</span><span style="font-family:'宋体';color:#000000;">个文件作为另一个</span><span>MapReduce</span><span style="font-family:'宋体';color:#000000;">任务的输入。</span><span></span></p>
<p><span> </span></p>
</div>
</td>
</tr></tbody></table>            </div>
                </div>