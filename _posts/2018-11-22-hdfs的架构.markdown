---
layout:     post
title:      hdfs的架构
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                <p align="left" style="background:#FFFFFF;"><span style="color:#000000;">目录</span></p><p style="background:#FFFFFF;"><span style="color:#000000;">·    </span><a href="https://www.cnblogs.com/codeOfLife/p/5375120.html#HDFS%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84" rel="nofollow"><span style="color:#000000;">HDFS </span><span style="color:#000000;">是做什么的</span></a></p><p style="background:#FFFFFF;"><span style="color:#000000;">·    </span><a href="https://www.cnblogs.com/codeOfLife/p/5375120.html#HDFS%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5" rel="nofollow"><span style="color:#000000;">HDFS </span><span style="color:#000000;">从何而来</span></a></p><p style="background:#FFFFFF;"><span style="color:#000000;">·    </span><a href="https://www.cnblogs.com/codeOfLife/p/5375120.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9HDFS%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE" rel="nofollow"><span style="color:#000000;">为什么选择</span><span style="color:#000000;"> HDFS </span><span style="color:#000000;">存储数据</span></a></p><p style="background:#FFFFFF;"><span style="color:#000000;">·    </span><a href="https://www.cnblogs.com/codeOfLife/p/5375120.html#HDFS%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE" rel="nofollow"><span style="color:#000000;">HDFS </span><span style="color:#000000;">如何存储数据</span></a></p><p style="background:#FFFFFF;"><span style="color:#000000;">·    </span><a href="https://www.cnblogs.com/codeOfLife/p/5375120.html#HDFS%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6" rel="nofollow"><span style="color:#000000;">HDFS </span><span style="color:#000000;">如何读取文件</span></a></p><p style="background:#FFFFFF;"><span style="color:#000000;">·    </span><a href="https://www.cnblogs.com/codeOfLife/p/5375120.html#HDFS%E5%A6%82%E4%BD%95%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6" rel="nofollow"><span style="color:#000000;">HDFS </span><span style="color:#000000;">如何写入文件</span></a></p><p style="background:#FFFFFF;"><span style="color:#000000;">·    </span><a href="https://www.cnblogs.com/codeOfLife/p/5375120.html#HDFS%E5%89%AF%E6%9C%AC%E5%AD%98%E6%94%BE%E7%AD%96%E7%95%A5" rel="nofollow"><span style="color:#000000;">HDFS </span><span style="color:#000000;">副本存放策略</span></a></p><p style="background:#FFFFFF;"><span style="color:#000000;">·    </span><a href="https://www.cnblogs.com/codeOfLife/p/5375120.html#hadoop2x%E6%96%B0%E7%89%B9%E6%80%A7" rel="nofollow"><span style="color:#000000;">Hadoop2.x</span><span style="color:#000000;">新特性</span></a></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">1</span><span style="color:#000000;">、</span><a></a><span style="color:#000000;">HDFS </span><span style="color:#000000;">是做什么的</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">HDFS</span><span style="color:#000000;">（</span><span style="color:#000000;">HadoopDistributed File System</span><span style="color:#000000;">）是</span><span style="color:#000000;">Hadoop</span><span style="color:#000000;">项目的核心子项目，是分布式计算中数据存储管理的基础，是基于流数据模式访问和处理超大文件的需求而开发的，可以运行于廉价的商用服务器上。它所具有的高容错、高可靠性、高可扩展性、高获得性、高吞吐率等特征为海量数据提供了不怕故障的存储，为超大数据集（</span><span style="color:#000000;">Large Data Set</span><span style="color:#000000;">）的应用处理带来了很多便利</span><span style="color:#000000;">。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">2</span><span style="color:#000000;">、</span><a></a><span style="color:#000000;">HDFS </span><span style="color:#000000;">从何而来</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">HDFS </span><span style="color:#000000;">源于</span><span style="color:#000000;"> Google </span><span style="color:#000000;">在</span><span style="color:#000000;">2003</span><span style="color:#000000;">年</span><span style="color:#000000;">10</span><span style="color:#000000;">月份发表的</span><span style="color:#000000;">GFS</span><span style="color:#000000;">（</span><span style="color:#000000;">Google File System</span><span style="color:#000000;">）</span><span style="color:#000000;">论文。</span><span style="color:#000000;">它其实就是</span><span style="color:#000000;"> GFS </span><span style="color:#000000;">的一个克隆版本</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">3</span><span style="color:#000000;">、<a></a>为什么选择</span><span style="color:#000000;"> HDFS </span><span style="color:#000000;">存储数据</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">  </span><span style="color:#000000;">之所以选择</span><span style="color:#000000;"> HDFS </span><span style="color:#000000;">存储数据，因为</span><span style="color:#000000;"> HDFS </span><span style="color:#000000;">具有以下优点：</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">1</span><span style="color:#000000;">、</span><span style="color:#000000;">高容错性</span></p><p style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">数据自动保存多个副本。它通过增加副本的形式，提高容错性。</span></p><p style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">某一个副本丢失以后，它可以自动恢复，这是由</span><span style="color:#000000;"> HDFS </span><span style="color:#000000;">内部机制实现的，我们不必关心。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">2</span><span style="color:#000000;">、适合批处理</span></p><p style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">它是通过移动计算而不是移动数据。</span></p><p style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">它会把数据位置暴露给计算框架。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">3</span><span style="color:#000000;">、适合大数据处理</span></p><p style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">处理数据达到</span><span style="color:#000000;"> GB</span><span style="color:#000000;">、</span><span style="color:#000000;">TB</span><span style="color:#000000;">、甚至</span><span style="color:#000000;">PB</span><span style="color:#000000;">级别的数据。</span></p><p style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">能够处理百万规模以上的文件数量，数量相当之大。</span></p><p style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">能够处理</span><span style="color:#000000;">10K</span><span style="color:#000000;">节点的规模。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">4</span><span style="color:#000000;">、流式文件访问</span></p><p style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">一次写入，多次读取。文件一旦写入不能修改，只能追加。</span></p><p style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">它能保证数据的一致性。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">5</span><span style="color:#000000;">、可构建在廉价机器上</span></p><p style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">它通过多副本机制，提高可靠性。</span></p><p style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">它提供了容错和恢复机制。比如某一个副本丢失，可以通过其它副本来恢复。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">　　当然</span><span style="color:#000000;"> HDFS </span><span style="color:#000000;">也有它的劣势，并不适合所有的场合：</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">1</span><span style="color:#000000;">、低延时数据访问</span></p><p style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">比如毫秒级的来存储数据，这是不行的，它做不到。</span></p><p style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">它适合高吞吐率的场景，就是在某一时间内写入大量的数据。但是它在低延时的情况下是不行的，比如毫秒级以内读取数据，这样它是很难做到的。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">2</span><span style="color:#000000;">、小文件存储</span></p><p style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">存储大量小文件</span><span style="color:#000000;">(</span><span style="color:#000000;">这里的小文件是指小于</span><span style="color:#000000;">HDFS</span><span style="color:#000000;">系统的</span><span style="color:#000000;">Block</span><span style="color:#000000;">大小的文件（默认</span><span style="color:#000000;">64M</span><span style="color:#000000;">）</span><span style="color:#000000;">)</span><span style="color:#000000;">的话，它会占用</span><span style="color:#000000;"> NameNode</span><span style="color:#000000;">大量的内存来存储文件、目录和块信息。这样是不可取的，因为</span><span style="color:#000000;">NameNode</span><span style="color:#000000;">的内存总是有限的。</span></p><p style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">小文件存储的寻道时间会超过读取时间，它违反了</span><span style="color:#000000;">HDFS</span><span style="color:#000000;">的设计目标。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">3</span><span style="color:#000000;">、并发写入、文件随机修改</span></p><p style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">一个文件只能有一个写，不允许多个线程同时写。</span></p><p style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">仅支持数据</span><span style="color:#000000;"> append</span><span style="color:#000000;">（追加），不支持文件的随机修改。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">4</span><span style="color:#000000;">、</span><a></a><span style="color:#000000;">HDFS </span><span style="color:#000000;">如何存储数据</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;"><img src="https://img-blog.csdn.net/20180306205420288?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2RyMjAwMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">HDFS</span><span style="color:#000000;">的架构图</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">HDFS </span><span style="color:#000000;">采用</span><span style="color:#000000;">Master/Slave</span><span style="color:#000000;">的架构来存储数据，这种架构主要由四个部分组成，分别为</span><span style="color:#000000;">HDFS Client</span><span style="color:#000000;">、</span><span style="color:#000000;">NameNode</span><span style="color:#000000;">、</span><span style="color:#000000;">DataNode</span><span style="color:#000000;">和</span><span style="color:#000000;">Secondary NameNode</span><span style="color:#000000;">。下面我们分别介绍这四个组成部分</span><span style="color:#000000;">   </span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">1</span><span style="color:#000000;">、</span><span style="color:#000000;">Client</span><span style="color:#000000;">：就是客户端。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">文件切分。文件上传</span><span style="color:#000000;"> HDFS </span><span style="color:#000000;">的时候，</span><span style="color:#000000;">Client </span><span style="color:#000000;">将文件切分成</span><span style="color:#000000;">一个一个的</span><span style="color:#000000;">Block</span><span style="color:#000000;">，然后进行存储。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">与</span><span style="color:#000000;"> NameNode </span><span style="color:#000000;">交互，获取文件的位置信息。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">与</span><span style="color:#000000;"> DataNode </span><span style="color:#000000;">交互，读取或者写入数据。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">Client </span><span style="color:#000000;">提供一些命令来管理</span><span style="color:#000000;"> HDFS</span><span style="color:#000000;">，比如启动或者关闭</span><span style="color:#000000;">HDFS</span><span style="color:#000000;">。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">Client </span><span style="color:#000000;">可以通过一些命令来访问</span><span style="color:#000000;"> HDFS</span><span style="color:#000000;">。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">2</span><span style="color:#000000;">、</span><span style="color:#000000;">NameNode</span><span style="color:#000000;">：就是</span><span style="color:#000000;"> master</span><span style="color:#000000;">，它是一个主管、管理者。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">管理</span><span style="color:#000000;"> HDFS </span><span style="color:#000000;">的名称空间</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">管理数据块（</span><span style="color:#000000;">Block</span><span style="color:#000000;">）映射信息</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">配置副本策略</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">处理客户端读写请求。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">3</span><span style="color:#000000;">、</span><span style="color:#000000;">DataNode</span><span style="color:#000000;">：就是</span><span style="color:#000000;">Slave</span><span style="color:#000000;">。</span><span style="color:#000000;">NameNode </span><span style="color:#000000;">下达命令，</span><span style="color:#000000;">DataNode </span><span style="color:#000000;">执行实际的操作。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">存储实际的数据块。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">执行数据块的读</span><span style="color:#000000;">/</span><span style="color:#000000;">写操作。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">4</span><span style="color:#000000;">、</span><span style="color:#000000;">Secondary NameNode</span><span style="color:#000000;">：并非</span><span style="color:#000000;"> NameNode </span><span style="color:#000000;">的热备。当</span><span style="color:#000000;">NameNode </span><span style="color:#000000;">挂掉的时候，它并不能马上替换</span><span style="color:#000000;"> NameNode </span><span style="color:#000000;">并提供服务。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">辅助</span><span style="color:#000000;"> NameNode</span><span style="color:#000000;">，分担其工作量。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">定期合并</span><span style="color:#000000;"> fsimage</span><span style="color:#000000;">和</span><span style="color:#000000;">fsedits</span><span style="color:#000000;">，并推送给</span><span style="color:#000000;">NameNode</span><span style="color:#000000;">。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">在紧急情况下，可辅助恢复</span><span style="color:#000000;"> NameNode</span><span style="color:#000000;">。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">5</span><span style="color:#000000;">、</span><a></a><span style="color:#000000;">HDFS </span><span style="color:#000000;">如何读取文件</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;"><img src="https://img-blog.csdn.net/20180306205355288?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2RyMjAwMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">HDFS</span><span style="color:#000000;">的文件读取原理，主要包括以下几个步骤：</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">首先调用</span><span style="color:#000000;">FileSystem</span><span style="color:#000000;">对象的</span><span style="color:#000000;">open</span><span style="color:#000000;">方法，其实获取的是一个</span><span style="color:#000000;">DistributedFileSystem</span><span style="color:#000000;">的实例。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">DistributedFileSystem</span><span style="color:#000000;">通过</span><span style="color:#000000;">RPC(</span><span style="color:#000000;">远程过程调用</span><span style="color:#000000;">)</span><span style="color:#000000;">获得文件的第一批</span><span style="color:#000000;">block</span><span style="color:#000000;">的</span><span style="color:#000000;">locations</span><span style="color:#000000;">，同一</span><span style="color:#000000;">block</span><span style="color:#000000;">按照重复数会返回多个</span><span style="color:#000000;">locations</span><span style="color:#000000;">，这些</span><span style="color:#000000;">locations</span><span style="color:#000000;">按照</span><span style="color:#000000;">hadoop</span><span style="color:#000000;">拓扑结构排序，距离客户端近的排在前面。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">前两步会返回一个</span><span style="color:#000000;">FSDataInputStream</span><span style="color:#000000;">对象，该对象会被封装成</span><span style="color:#000000;"> DFSInputStream</span><span style="color:#000000;">对象，</span><span style="color:#000000;">DFSInputStream</span><span style="color:#000000;">可以方便的管理</span><span style="color:#000000;">datanode</span><span style="color:#000000;">和</span><span style="color:#000000;">namenode</span><span style="color:#000000;">数据流。客户端调用</span><span style="color:#000000;">read</span><span style="color:#000000;">方法，</span><span style="color:#000000;">DFSInputStream</span><span style="color:#000000;">就会找出离客户端最近的</span><span style="color:#000000;">datanode</span><span style="color:#000000;">并连接</span><span style="color:#000000;">datanode</span><span style="color:#000000;">。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">数据从</span><span style="color:#000000;">datanode</span><span style="color:#000000;">源源不断的流向客户端。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">如果第一个</span><span style="color:#000000;">block</span><span style="color:#000000;">块的数据读完了，就会关闭指向第一个</span><span style="color:#000000;">block</span><span style="color:#000000;">块的</span><span style="color:#000000;">datanode</span><span style="color:#000000;">连接，接着读取下一个</span><span style="color:#000000;">block</span><span style="color:#000000;">块。这些操作对客户端来说是透明的，从客户端的角度来看只是读一个持续不断的流。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">如果第一批</span><span style="color:#000000;">block</span><span style="color:#000000;">都读完了，</span><span style="color:#000000;">DFSInputStream</span><span style="color:#000000;">就会去</span><span style="color:#000000;">namenode</span><span style="color:#000000;">拿下一批</span><span style="color:#000000;">blocks</span><span style="color:#000000;">的</span><span style="color:#000000;">location</span><span style="color:#000000;">，然后继续读，如果所有的</span><span style="color:#000000;">block</span><span style="color:#000000;">块都读完，这时就会关闭掉所有的流。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">6</span><span style="color:#000000;">、</span><a></a><span style="color:#000000;">HDFS </span><span style="color:#000000;">如何写入文件</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;"><img src="https://img-blog.csdn.net/20180306205337738?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2RyMjAwMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">HDFS</span><span style="color:#000000;">的文件写入原理，主要包括以下几个步骤：</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">客户端通过调用</span><span style="color:#000000;">DistributedFileSystem </span><span style="color:#000000;">的</span><span style="color:#000000;">create</span><span style="color:#000000;">方法，创建一个新的文件。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">DistributedFileSystem </span><span style="color:#000000;">通过</span><span style="color:#000000;"> RPC</span><span style="color:#000000;">（远程过程调用）调用</span><span style="color:#000000;"> NameNode</span><span style="color:#000000;">，去创建一个没有</span><span style="color:#000000;">blocks</span><span style="color:#000000;">关联的新文件。创建前，</span><span style="color:#000000;">NameNode </span><span style="color:#000000;">会做各种校验，比如文件是否存在，客户端有无权限去创建等。如果校验通过，</span><span style="color:#000000;">NameNode </span><span style="color:#000000;">就会记录下新文件，否则就会抛出</span><span style="color:#000000;">IO</span><span style="color:#000000;">异常。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">前两步结束后会返回</span><span style="color:#000000;">FSDataOutputStream </span><span style="color:#000000;">的对象，和读文件的时候相似，</span><span style="color:#000000;">FSDataOutputStream </span><span style="color:#000000;">被封装成</span><span style="color:#000000;"> DFSOutputStream</span><span style="color:#000000;">，</span><span style="color:#000000;">DFSOutputStream </span><span style="color:#000000;">可以协调</span><span style="color:#000000;"> NameNode</span><span style="color:#000000;">和</span><span style="color:#000000;"> DataNode</span><span style="color:#000000;">。客户端开始写数据到</span><span style="color:#000000;">DFSOutputStream,DFSOutputStream</span><span style="color:#000000;">会把数据切成一个个小</span><span style="color:#000000;">packet</span><span style="color:#000000;">，然后排成队列</span><span style="color:#000000;"> data queue</span><span style="color:#000000;">。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">DataStreamer </span><span style="color:#000000;">会去处理接受</span><span style="color:#000000;"> data queue</span><span style="color:#000000;">，它先问询</span><span style="color:#000000;"> NameNode </span><span style="color:#000000;">这个新的</span><span style="color:#000000;"> block </span><span style="color:#000000;">最适合存储的在哪几个</span><span style="color:#000000;">DataNode</span><span style="color:#000000;">里，比如重复数是</span><span style="color:#000000;">3</span><span style="color:#000000;">，那么就找到</span><span style="color:#000000;">3</span><span style="color:#000000;">个最适合的</span><span style="color:#000000;"> DataNode</span><span style="color:#000000;">，把它们排成一个</span><span style="color:#000000;"> pipeline</span><span style="color:#000000;">。</span><span style="color:#000000;">DataStreamer </span><span style="color:#000000;">把</span><span style="color:#000000;"> packet </span><span style="color:#000000;">按队列输出到管道的第一个</span><span style="color:#000000;"> DataNode </span><span style="color:#000000;">中，第一个</span><span style="color:#000000;"> DataNode</span><span style="color:#000000;">又把</span><span style="color:#000000;"> packet </span><span style="color:#000000;">输出到第二个</span><span style="color:#000000;"> DataNode </span><span style="color:#000000;">中，以此类推。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">DFSOutputStream </span><span style="color:#000000;">还有一个队列叫</span><span style="color:#000000;"> ack queue</span><span style="color:#000000;">，也是由</span><span style="color:#000000;"> packet </span><span style="color:#000000;">组成，等待</span><span style="color:#000000;">DataNode</span><span style="color:#000000;">的收到响应，当</span><span style="color:#000000;">pipeline</span><span style="color:#000000;">中的所有</span><span style="color:#000000;">DataNode</span><span style="color:#000000;">都表示已经收到的时候，这时</span><span style="color:#000000;">akc queue</span><span style="color:#000000;">才会把对应的</span><span style="color:#000000;">packet</span><span style="color:#000000;">包移除掉。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">客户端完成写数据后，调用</span><span style="color:#000000;">close</span><span style="color:#000000;">方法关闭写入流。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">DataStreamer </span><span style="color:#000000;">把剩余的包都刷到</span><span style="color:#000000;"> pipeline </span><span style="color:#000000;">里，然后等待</span><span style="color:#000000;"> ack </span><span style="color:#000000;">信息，收到最后一个</span><span style="color:#000000;"> ack </span><span style="color:#000000;">后，通知</span><span style="color:#000000;"> DataNode </span><span style="color:#000000;">把文件标示为已完成。</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">7</span><span style="color:#000000;">、</span><a></a><span style="color:#000000;">HDFS </span><span style="color:#000000;">副本存放策略</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">namenode</span><span style="color:#000000;">如何选择在哪个</span><span style="color:#000000;">datanode </span><span style="color:#000000;">存储副本（</span><span style="color:#000000;">replication</span><span style="color:#000000;">）？这里需要对可靠性、写入带宽和读取带宽进行权衡。</span><span style="color:#000000;">Hadoop</span><span style="color:#000000;">对</span><span style="color:#000000;">datanode</span><span style="color:#000000;">存储副本有自己的副本策略，在其发展过程中一共有两个版本的副本策略，分别如下所示</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;"><img src="https://img-blog.csdn.net/20180306205315569?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2RyMjAwMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">8</span><span style="color:#000000;">、</span><a></a><span style="color:#000000;">hadoop2.x</span><span style="color:#000000;">新特性</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">引入了</span><span style="color:#000000;">NameNodeFederation</span><span style="color:#000000;">，解决了横向内存扩展</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">引入了</span><span style="color:#000000;">Namenode HA</span><span style="color:#000000;">，解决了</span><span style="color:#000000;">namenode</span><span style="color:#000000;">单点故障</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">引入了</span><span style="color:#000000;">YARN</span><span style="color:#000000;">，负责资源管理和调度</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">增加了</span><span style="color:#000000;">ResourceManager HA</span><span style="color:#000000;">解决了</span><span style="color:#000000;">ResourceManager</span><span style="color:#000000;">单点故障</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">1</span><span style="color:#000000;">、</span><span style="color:#000000;">NameNode Federation</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">    </span><span style="color:#000000;">架构如下图</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">    <img src="https://img-blog.csdn.net/20180306205300443?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2RyMjAwMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">存在多个</span><span style="color:#000000;">NameNode</span><span style="color:#000000;">，每个</span><span style="color:#000000;">NameNode</span><span style="color:#000000;">分管一部分目录</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">NameNode</span><span style="color:#000000;">共用</span><span style="color:#000000;">DataNode</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">　　这样做的好处就是当</span><span style="color:#000000;">NN</span><span style="color:#000000;">内存受限时，能扩展内存，解决内存扩展问题，而且每个</span><span style="color:#000000;">NN</span><span style="color:#000000;">独立工作相互不受影响，比如其中一个</span><span style="color:#000000;">NN</span><span style="color:#000000;">挂掉啦，它不会影响其他</span><span style="color:#000000;">NN</span><span style="color:#000000;">提供服务，但我们需要注意的是，虽然有多个</span><span style="color:#000000;">NN</span><span style="color:#000000;">，分管不同的目录，但是对于特定的</span><span style="color:#000000;">NN</span><span style="color:#000000;">，依然存在单点故障，因为没有它没有热备，解决单点故障使用</span><span style="color:#000000;">NameNode HA</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">2</span><span style="color:#000000;">、</span><span style="color:#000000;">NameNode HA</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">　　　　解决方案：</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">基于</span><span style="color:#000000;">NFS</span><span style="color:#000000;">共享存储解决方案</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">·        </span><span style="color:#000000;">基于</span><span style="color:#000000;">Qurom Journal Manager(QJM)</span><span style="color:#000000;">解决方案</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">1</span><span style="color:#000000;">、基于</span><span style="color:#000000;">NFS</span><span style="color:#000000;">方案</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">Active NN</span><span style="color:#000000;">与</span><span style="color:#000000;">Standby NN</span><span style="color:#000000;">通过</span><span style="color:#000000;">NFS</span><span style="color:#000000;">实现共享数据，但如果</span><span style="color:#000000;">Active NN</span><span style="color:#000000;">与</span><span style="color:#000000;">NFS</span><span style="color:#000000;">之间或</span><span style="color:#000000;">Standby NN</span><span style="color:#000000;">与</span><span style="color:#000000;">NFS</span><span style="color:#000000;">之间，其中一处有网络故障的话，那就会造成数据同步问题</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">2</span><span style="color:#000000;">、基于</span><span style="color:#000000;">QJM</span><span style="color:#000000;">方案</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">    </span><span style="color:#000000;">　　架构如下图</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">    <img src="https://img-blog.csdn.net/20180306205248407?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2RyMjAwMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">    </span><span style="color:#000000;">Active NN</span><span style="color:#000000;">、</span><span style="color:#000000;">Standby NN</span><span style="color:#000000;">有主备之分，</span><span style="color:#000000;">NN Active</span><span style="color:#000000;">是主的，</span><span style="color:#000000;">NN Standby</span><span style="color:#000000;">备用的</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">    </span><span style="color:#000000;">　　集群启动之后，一个</span><span style="color:#000000;">namenode</span><span style="color:#000000;">是</span><span style="color:#000000;">active</span><span style="color:#000000;">状态，来处理</span><span style="color:#000000;">client</span><span style="color:#000000;">与</span><span style="color:#000000;">datanode</span><span style="color:#000000;">之间的请求，并把相应的日志文件写到本地中或</span><span style="color:#000000;">JN</span><span style="color:#000000;">中；</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">    </span><span style="color:#000000;">Active NN</span><span style="color:#000000;">与</span><span style="color:#000000;">Standby NN</span><span style="color:#000000;">之间是通过一组</span><span style="color:#000000;">JN</span><span style="color:#000000;">共享数据（</span><span style="color:#000000;">JN</span><span style="color:#000000;">一般为奇数个，</span><span style="color:#000000;">ZK</span><span style="color:#000000;">一般也为奇数个），</span><span style="color:#000000;">Active NN</span><span style="color:#000000;">会把日志文件、镜像文件写到</span><span style="color:#000000;">JN</span><span style="color:#000000;">中去，只要</span><span style="color:#000000;">JN</span><span style="color:#000000;">中有一半写成功，那就表明</span><span style="color:#000000;">Active NN</span><span style="color:#000000;">向</span><span style="color:#000000;">JN</span><span style="color:#000000;">中写成功啦，</span><span style="color:#000000;">Standby NN</span><span style="color:#000000;">就开始从</span><span style="color:#000000;">JN</span><span style="color:#000000;">中读取数据，来实现与</span><span style="color:#000000;">Active NN</span><span style="color:#000000;">数据同步，这种方式支持容错，因为</span><span style="color:#000000;">Standby NN</span><span style="color:#000000;">在启动的时候，会加载镜像文件（</span><span style="color:#000000;">fsimage</span><span style="color:#000000;">）并周期性的从</span><span style="color:#000000;">JN</span><span style="color:#000000;">中获取日志文件来保持与</span><span style="color:#000000;">Active NN</span><span style="color:#000000;">同步</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">    </span><span style="color:#000000;">　　为了实现</span><span style="color:#000000;">Standby NN</span><span style="color:#000000;">在</span><span style="color:#000000;">Active NN</span><span style="color:#000000;">挂掉之后，能迅速的再提供服务，需要</span><span style="color:#000000;">DN</span><span style="color:#000000;">不仅需要向</span><span style="color:#000000;">Active NN</span><span style="color:#000000;">汇报，同时还要向</span><span style="color:#000000;">Standby NN</span><span style="color:#000000;">汇报，这样就使得</span><span style="color:#000000;">Standby NN</span><span style="color:#000000;">能保存数据块在</span><span style="color:#000000;">DN</span><span style="color:#000000;">上的位置信息，因为在</span><span style="color:#000000;">NameNode</span><span style="color:#000000;">在启动过程中最费时工作，就是处理所有</span><span style="color:#000000;">DN</span><span style="color:#000000;">上的数据块的信息</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">    </span><span style="color:#000000;">　　为了实现</span><span style="color:#000000;">Active NN</span><span style="color:#000000;">高热备，增加了</span><span style="color:#000000;">FailoverController</span><span style="color:#000000;">和</span><span style="color:#000000;">ZK</span><span style="color:#000000;">，</span><span style="color:#000000;">FailoverController</span><span style="color:#000000;">通过</span><span style="color:#000000;">Heartbeat</span><span style="color:#000000;">的方式与</span><span style="color:#000000;">ZK</span><span style="color:#000000;">通信，通过</span><span style="color:#000000;">ZK</span><span style="color:#000000;">来选举，一旦</span><span style="color:#000000;">Active NN</span><span style="color:#000000;">挂掉，就选取另一个</span><span style="color:#000000;">FailoverController</span><span style="color:#000000;">作为</span><span style="color:#000000;">active</span><span style="color:#000000;">状态，然后</span><span style="color:#000000;">FailoverController</span><span style="color:#000000;">通过</span><span style="color:#000000;">rpc</span><span style="color:#000000;">，让</span><span style="color:#000000;">standby NN</span><span style="color:#000000;">转变为</span><span style="color:#000000;">Active NN</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">    </span><span style="color:#000000;">FailoverController</span><span style="color:#000000;">一方面监控</span><span style="color:#000000;">NN</span><span style="color:#000000;">的状态信息，一方面还向</span><span style="color:#000000;">ZK</span><span style="color:#000000;">定时发送心跳，使自己被选举。当自己被选为主（</span><span style="color:#000000;">Active</span><span style="color:#000000;">）的时候，就会通过</span><span style="color:#000000;">rpc</span><span style="color:#000000;">使相应</span><span style="color:#000000;">NN</span><span style="color:#000000;">转变</span><span style="color:#000000;">Active</span><span style="color:#000000;">状态</span></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">　　　　3</span>、结合HDFS2的新特性，在实际生成环境中部署图</p><p align="left" style="background:#FFFFFF;"><img src="https://img-blog.csdn.net/20180306205235943?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2RyMjAwMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p><p align="left" style="background:#FFFFFF;"><span style="color:#000000;">　　　　这里有12</span>个DN,有4个NN，NN-1与NN-2是主备关系，它们管理/share目录；NN-3与NN-4是主备关系，它们管理/user目录</p>            </div>
                </div>