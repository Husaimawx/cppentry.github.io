---
layout:     post
title:      HDFS原理：HDFS数据存储
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								<div class="article-copyright">
					版权声明：本文为博主原创文章，未经博主允许不得转载。					https://blog.csdn.net/WYpersist/article/details/79797569				</div>
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                <h2 style="background-color:rgb(255,255,255);">HDFS的架构和数据存储原理</h2><p align="justify" style="background-color:rgb(255,255,255);">HDFS是一个主/从（Mater/Slave）<span style="font-family:'微软雅黑';">体系结构，从最终用户的角度来看，它就像传统的</span>   <span style="font-family:'微软雅黑';">文件系统一样，可以通过目录路径对文件执行</span>CRUD（Create、Read、Update和Delete）   <span style="font-family:'微软雅黑';">操作。但由于分布式存储的性质，</span>HDFS集群拥有一个NameNode和一些DataNode。</p><p style="background-color:rgb(255,255,255);">NameNode管理文件系统的元数据，DataNode存储实际的数据。客户端通过同</p><p style="background-color:rgb(255,255,255);">NameNode和DataNodes的交互访问文件系统。客户端联系NameNode<span style="font-family:'微软雅黑';">以获取文件的元数</span>   <span style="font-family:'微软雅黑';">据，而真正的文件</span>I/O操作是直接和DataNode进行交互的。</p><h2 style="background-color:rgb(255,255,255);">HDFS的架构图</h2><p style="background-color:rgb(255,255,255);"><img src="https://img-blog.csdn.net/20180330143028851" alt="" style="border:none;"><br></p><p style="background-color:rgb(255,255,255);"><span style="font-family:'微软雅黑';">这种架构主要由四个部分组成，分别为</span>HDFS Client、NameNode、DataNode和Secondary NameNode。下面我们分别介绍这四个组成部分。</p><p style="background-color:rgb(255,255,255);">Client：就是客户端。</p><p style="background-color:rgb(255,255,255);">1<span style="font-family:'微软雅黑';">、文件切分。文件上传</span> HDFS <span style="font-family:'微软雅黑';">的时候</span><span style="font-family:'微软雅黑';">，</span>Client <span style="font-family:'微软雅黑';">将文件切分成</span> <span style="font-family:'微软雅黑';">一个一个的</span>Block，然后进行存储。</p><p style="background-color:rgb(255,255,255);">2、与 NameNode 交互，获取文件的位置信息。</p><p style="background-color:rgb(255,255,255);">3、与 DataNode 交互，读取或者写入数据。</p><p style="background-color:rgb(255,255,255);">4、Client 提供一些命令来管理 HDFS，比如启动或者关闭HDFS。</p><p style="background-color:rgb(255,255,255);">5、Client 可以通过一些命令来访问 HDFS。</p><p style="background-color:rgb(255,255,255);">NameNode：就是 master，它是一个主管、管理者。</p><p style="background-color:rgb(255,255,255);"> </p><p style="background-color:rgb(255,255,255);">1、管理 HDFS 的名称空间。</p><p style="background-color:rgb(255,255,255);">2、管理数据块（Block）映射信息</p><p style="background-color:rgb(255,255,255);">3、配置副本策略</p><p style="background-color:rgb(255,255,255);">4、处理客户端读写请求。</p><p style="background-color:rgb(255,255,255);">DataNode：就是Slave。NameNode 下达命令，DataNode 执行实际的操作。</p><p style="background-color:rgb(255,255,255);">1、存储实际的数据块。</p><p style="background-color:rgb(255,255,255);">2、执行数据块的读/写操作。</p><p style="background-color:rgb(255,255,255);">Secondary NameNode：并非 NameNode 的热备。当NameNode 挂掉的时候，它并不能马上替换 NameNode 并提供服务。</p><p style="background-color:rgb(255,255,255);">1、辅助 NameNode，分担其工作量。</p><p style="background-color:rgb(255,255,255);">2、定期合并 fsimage和fsedits，并推送给NameNode。</p><p style="background-color:rgb(255,255,255);">3、在紧急情况下，可辅助恢复 NameNode。</p><p style="background-color:rgb(255,255,255);"><br></p><p style="background-color:rgb(255,255,255);"><span style="font-size:28px;"><strong>为什么选择 HDFS 存储数据</strong></span></p><p style="background-color:rgb(255,255,255);">1、之所以选择 HDFS 存储数据，是因为 HDFS 具有以下优点：</p><p style="background-color:rgb(255,255,255);">(1) 高容错性</p><p style="background-color:rgb(255,255,255);">1) 数据自动保存多个副本。它通过增加副本的形式，提高容错性。</p><p style="background-color:rgb(255,255,255);">2) <span style="font-family:'微软雅黑';">某一个副本丢失以后，它可以自动恢复，这是由</span> HDFS <span style="font-family:'微软雅黑';">内部机制实现的，我们不必关</span></p><p style="background-color:rgb(255,255,255);">心。</p><p style="background-color:rgb(255,255,255);">(2) 适合批处理</p><p style="background-color:rgb(255,255,255);">1) 它是通过移动计算而不是移动数据。</p><p style="background-color:rgb(255,255,255);">2) 它会把数据位置暴露给计算框架。</p><p style="background-color:rgb(255,255,255);">(3) 适合大数据处理</p><p style="background-color:rgb(255,255,255);">1) <span style="font-family:'微软雅黑';">数据规模：能够处理数据规模达到</span> GB、TB、甚至PB级别的数据。</p><p style="background-color:rgb(255,255,255);">2) 文件规模：能够处理百万规模以上的文件数量，数量相当之大。</p><p style="background-color:rgb(255,255,255);">3) <span style="font-family:'微软雅黑';">节点规模：能够处理</span>10K节点的规模。</p><p style="background-color:rgb(255,255,255);">(4) 流式数据访问</p><p style="background-color:rgb(255,255,255);">1) 一次写入，多次读取，不能修改，只能追加。</p><p style="background-color:rgb(255,255,255);">2) 它能保证数据的一致性。</p><p style="background-color:rgb(255,255,255);">(5) 可构建在廉价机器上</p><p style="background-color:rgb(255,255,255);">1) 它通过多副本机制，提高可靠性。</p><p style="background-color:rgb(255,255,255);">2) 它提供了容错和恢复机制。比如某一个副本丢失，可以通过其它副本来恢复。</p><p style="background-color:rgb(255,255,255);">2、当然 HDFS 也有它的劣势，并不适合所有的场合：</p><p style="background-color:rgb(255,255,255);">(1) 不适合低延时数据访问</p><p style="background-color:rgb(255,255,255);">1) 比如毫秒级的来存储数据，这是不行的，它做不到。</p><p style="background-color:rgb(255,255,255);">2) <span style="font-family:'微软雅黑';">它适合高吞吐率的场景，就是在某一时间内写入大量的数据。但是它在低延时的情况</span>  下是不行的，比如毫秒级以内读取数据，这样它是很难做到的。</p><p style="background-color:rgb(255,255,255);">改进策略</p><p style="background-color:rgb(255,255,255);">(2) 无法高效的对大量小文件进行存储</p><p style="background-color:rgb(255,255,255);">1) <span style="font-family:'微软雅黑';">存储大量小文件的话，它会占用</span>  NameNode大量的内存来存储文件、目录和块信<span style="font-family:'微软雅黑';">息。这样是不可取的，因为</span>NameNode的内存总是有限的。</p><p style="background-color:rgb(255,255,255);">2) <span style="font-family:'微软雅黑';">小文件存储的寻道时间会超过读取时间，它违反了</span>HDFS<span style="font-family:'微软雅黑';">的设计目标。</span> 改进策略</p><p style="background-color:rgb(255,255,255);">(3) 并发写入、文件随机修改</p><p style="background-color:rgb(255,255,255);">1) 一个文件只能有一个写，不允许多个线程同时写。</p><p style="background-color:rgb(255,255,255);">2) <span style="font-family:'微软雅黑';">仅支持数据</span> append（追加），不支持文件的随机修改。</p>            </div>
                </div>