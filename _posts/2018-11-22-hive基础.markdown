---
layout:     post
title:      hive基础
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                hive基础 <br>2011年07月11日<br>　　（一）： <br>　　Hive 是什么 <br>　　在接触一个新的事物首先要回到的问题是：这是什么？ <br>　　这里引用 Hive wiki 上的介绍： <br>　　Hive is a data warehouse infrastructure built on top of Hadoop. It provides tools to enable easy data ETL, a mechanism to put structures on the data, and the capability to querying and analysis of large data sets stored in Hadoop files. Hive defines a simple SQL-like query language, called QL, that enables users familiar with SQL to query the data. At the same time, this language also allows programmers who are familiar with the MapReduce fromwork to be able to plug in their custom mappers and reducers to perform more sophisticated analysis that may not be supported by the built-in capabilities of the language. <br>　　Hive 是建立在 Hadoop 上的数据仓库基础构架。它提供了一系列的工具，可以用来进行数据提取转化加载（ETL），这是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制。Hive 定义了简单的类 SQL 查询语言，称为 QL，它允许熟悉 SQL 的用户查询数据。同时，这个语言也允许熟悉 MapReduce 开发者的开发自定义的 mapper 和 reducer 来处理内建的 mapper 和 reducer 无法完成的复杂的分析工作。 <br>　　Hive does not mandate read or written data be in the “Hive format”―there is no such thing. Hive works equally well on Thrift, control delimited, or your specialized data formats. Please see File Format and SerDe in Developer Guide for details. <br>　　Hive 没有专门的数据格式。 Hive 可以很好的工作在 Thrift 之上，控制分隔符，也允许用户指定数据格式。 <br>　　Hive 资源 <br>　　Hive 本身提供了较丰富的文档，以下链接提供了 Hive 的一些基础文档： <br>　　FaceBook 镜像（被墙）：[[http://mirror.facebook.com/facebook/hive]] <br>　　Wiki 页面：[[http://wiki.apache.org/hadoop/Hive]] <br>　　入门指南：[[http://wiki.apache.org/hadoop/Hive/GettingStarted]] <br>　　查询语言指南：[[http://wiki.apache.org/hadoop/Hive/HiveQL]] <br>　　演示文稿：[[http://wiki.apache.org/hadoop/Hive/Presentations]] <br>　　蓝图：[[http://wiki.apache.org/hadoop/Hive/Roadmap]] <br>　　大多数有关 Hive 的使用和特性的问题可以从以上的链接中寻找到答案。当然，由于 Hive 本身在不断的发展中，文档的更新速度很多时候都赶不上 Hive 本身的更新速度，若希望了解 Hive 的最新动态或者遇到 Bug，可以加入 Hive 的邮件列表： <br>　　* User: hive-user@hadoop.apache.org <br>　　* Developer: hive-dev@hadoop.apache.org <br>　　Hive 的下载配置安装 <br>　　请参考入门指南, 这里给出最基本的提纲: <br>　　安装配置 Hadoop。 <br>　　安装配置数据库（mysql 等）。 <br>　　获得 Hive 源码或者可执行代码。wget http://www.apache.org/dist/hadoop/hive/hive-0.5.0/hive-0.5.0-bin.tar.gz <br>　　tar xzf hive-0.5.0-bin.tar.gz <br>　　cd hive-0.5.0-bin <br>　　配置 Hive 如何访问数据库，如何访问 Hadoop。 <br>　　运行 Hive。 <br>　　当看到 Hive 提示符‘Hive&gt;’的时候，恭喜，你可以开始你的 Hive 之旅了 <br>　　（二）： <br>　　图一 <br>　　主要分为以下几个部分： <br>　　用户接口，包括 CLI，Client，WUI。 <br>　　元数据存储，通常是存储在关系数据库如 mysql, derby 中。 <br>　　解释器、编译器、优化器、执行器。 <br>　　Hadoop：用 HDFS 进行存储，利用 MapReduce 进行计算。 <br>　　用户接口主要有三个：CLI，Client 和 WUI。其中最常用的是 CLI，Cli 启动的时候，会同时启动一个 Hive 副本。Client 是 Hive 的客户端，用户连接至 Hive Server。在启动 Client 模式的时候，需要指出 Hive Server 所在节点，并且在该节点启动 Hive Server。 WUI 是通过浏览器访问 Hive。 <br>　　Hive 将元数据存储在数据库中，如 mysql、derby。Hive 中的元数据包括表的名字，表的列和分区及其属性，表的属性（是否为外部表等），表的数据所在目录等。 <br>　　解释器、编译器、优化器完成 HQL 查询语句从词法分析、语法分析、编译、优化以及查询计划的生成。生成的查询计划存储在 HDFS 中，并在随后有 MapReduce 调用执行。 <br>　　Hive 的数据存储在 HDFS 中，大部分的查询由 MapReduce 完成（包含 * 的查询，比如 select * from tbl 不会生成 MapRedcue 任务）。 <br>　　Hive 元数据存储 <br>　　Hive 将元数据存储在 RDBMS 中，有三种模式可以连接到数据库： <br>　　Single User Mode： 此模式连接到一个 In-memory 的数据库 Derby，一般用于 Unit Test <br>　　图二 <br>　　Multi User Mode：通过网络连接到一个数据库中，是最经常使用到的模式。 <br>　　图三 <br>　　Hive 的数据存储 <br>　　首先，Hive 没有专门的数据存储格式，也没有为数据建立索引，用户可以非常自由的组织 Hive 中的表，只需要在创建表的时候告诉 Hive 数据中的列分隔符和行分隔符，Hive 就可以解析数据。 <br>　　其次，Hive 中所有的数据都存储在 HDFS 中，Hive 中包含以下数据模型：Table，External Table，Partition，Bucket。 <br>　　Hive 中的 Table 和数据库中的 Table 在概念上是类似的，每一个 Table 在 Hive 中都有一个相应的目录存储数据。例如，一个表 pvs，它在 HDFS 中的路径为：/wh/pvs，其中，wh 是在 hive-site.xml 中由 ${hive.metastore.warehouse.dir} 指定的数据仓库的目录，所有的 Table 数据（不包括 External Table）都保存在这个目录中。 <br>　　Partition 对应于数据库中的 Partition 列的密集索引，但是 Hive 中 Partition 的组织方式和数据库中的很不相同。在 Hive 中，表中的一个 Partition 对应于表下的一个目录，所有的 Partition 的数据都存储在对应的目录中。例如：pvs 表中包含 ds 和 city 两个 Partition，则对应于 ds = 20090801, ctry = US 的 HDFS 子目录为：/wh/pvs/ds=20090801/ctry=US；对应于 ds = 20090801, ctry = CA 的 HDFS 子目录为；/wh/pvs/ds=20090801/ctry=CA <br>　　Buckets 对指定列计算 hash，根据 hash 值切分数据，目的是为了并行，每一个 Bucket 对应一个文件。将 user 列分散至 32 个 bucket，首先对 user 列的值计算 hash，对应 hash 值为 0 的 HDFS 目录为：/wh/pvs/ds=20090801/ctry=US/part-00000；hash 值为 20 的 HDFS 目录为：/wh/pvs/ds=20090801/ctry=US/part-00020 <br>　　External Table 指向已经在 HDFS 中存在的数据，可以创建 Partition。它和 Table 在元数据的组织上是相同的，而实际数据的存储则有较大的差异。 <br>　　Table 的创建过程和数据加载过程（这两个过程可以在同一个语句中完成），在加载数据的过程中，实际数据会被移动到数据仓库目录中；之后对数据对访问将会直接在数据仓库目录中完成。删除表时，表中的数据和元数据将会被同时删除。 <br>　　External Table 只有一个过程，加载数据和创建表同时完成（CREATE EXTERNAL TABLE ……LOCATION），实际数据是存储在 LOCATION 后面指定的 HDFS 路径中，并不会移动到数据仓库目录中。 <br>　　（三）： <br>　　摘要：由于 Hive 采用了 SQL 的查询语言 HQL，因此很容易将 Hive 理解为数据库。其实 <br>　　从结构上来看，Hive 和数据库除了拥有类似的查询语言，再无类似之处。本文将 <br>　　从多个方面来阐述 Hive 和数据库的差异。数据库可以用在 Online 的应用中，但是 <br>　　Hive 是为数据仓库而设计的，清楚这一点，有助于从应用角度理解 Hive 的特性。 <br>　　查询语言 HQL SQL <br>　　数据存储位置 HDFS Raw Device 或者 Local FS <br>　　数据格式 用户定义 系统决定 <br>　　数据更新 不支持 支持 <br>　　索引 无 有  <br>　　执行 MapRedcue Executor <br>　　执行延迟 高 低 <br>　　可扩展性 高 低 <br>　　数据规模 大 小 <br>　　1.查询语言。由于 SQL 被广泛的应用在数据仓库中，因此，专门针对 Hive 的特性设计了类 SQL 的查询语言 HQL。熟悉 SQL 开发的开发者可以很方便的使用 Hive 进行开发。 <br>　　2.数据存储位置。Hive 是建立在 Hadoop 之上的，所有 Hive 的数据都是存储在 HDFS 中的。而数据库则可以将数据保存在块设备或者本地文件系统中。 <br>　　3.数据格式。Hive 中没有定义专门的数据格式，数据格式可以由用户指定，用户定义数据格式需要指定三个属性：列分隔符（通常为空格、”\t”、”\x001″）、行分隔符（”\n”）以及读取文件数据的方法（Hive 中默认有三个文件格式 TextFile，SequenceFile 以及 RCFile）。由于在加载数据的过程中，不需要从用户数据格式到 Hive 定义的数据格式的转换，因此，Hive 在加载的过程中不会对数据本身进行任何修改，而只是将数据内容复制或者移动到相应的 HDFS 目录中。而在数据库中，不同的数据库有不同的存储引擎，定义了自己的数据格式。所有数据都会按照一定的组织存储，因此，数据库加载数据的过程会比较耗时。 <br>　　4.数据更新。由于 Hive 是针对数据仓库应用设计的，而数据仓库的内容是读多写少的。因此，Hive 中不支持对数据的改写和添加，所有的数据都是在加载的时候中确定好的。而数据库中的数据通常是需要经常进行修改的，因此可以使用 INSERT INTO ...  VALUES 添加数据，使用 UPDATE ... SET 修改数据。 <br>　　5.索引。之前已经说过，Hive 在加载数据的过程中不会对数据进行任何处理，甚至不会对数据进行扫描，因此也没有对数据中的某些 Key 建立索引。Hive 要访问数据中满足条件的特定值时，需要暴力扫描整个数据，因此访问延迟较高。由于 MapReduce 的引入， Hive 可以并行访问数据，因此即使没有索引，对于大数据量的访问，Hive 仍然可以体现出优势。数据库中，通常会针对一个或者几个列建立索引，因此对于少量的特定条件的数据的访问，数据库可以有很高的效率，较低的延迟。由于数据的访问延迟较高，决定了 Hive 不适合在线数据查询。 <br>　　6.执行。Hive 中大多数查询的执行是通过 Hadoop 提供的 MapReduce 来实现的（类似 select * from tbl 的查询不需要 MapReduce）。而数据库通常有自己的执行引擎。 <br>　　7.执行延迟。之前提到，Hive 在查询数据的时候，由于没有索引，需要扫描整个表，因此延迟较高。另外一个导致 Hive 执行延迟高的因素是 MapReduce 框架。由于 MapReduce 本身具有较高的延迟，因此在利用 MapReduce 执行 Hive 查询时，也会有较高的延迟。相对的，数据库的执行延迟较低。当然，这个低是有条件的，即数据规模较小，当数据规模大到超过数据库的处理能力的时候，Hive 的并行计算显然能体现出优势。 <br>　　8.可扩展性。由于 Hive 是建立在 Hadoop 之上的，因此 Hive 的可扩展性是和 Hadoop 的可扩展性是一致的（世界上最大的 Hadoop 集群在 Yahoo!，2009年的规模在 4000 台节点左右）。而数据库由于 ACID 语义的严格限制，扩展行非常有限。目前最先进的并行数据库 Oracle 在理论上的扩展能力也只有 100 台左右。 <br>　　9.数据规模。由于 Hive 建立在集群上并可以利用 MapReduce 进行并行计算，因此可以支持很大规模的数据；对应的，数据库可以支持的数据规模较小。 <br>　　（四）：Hive QL <br>　　Hive 的官方文档中对查询语言有了很详细的描述，请参考：http://wiki.apache.org/hadoop/Hive/LanguageManual ，本文的内容大部分翻译自该页面，期间加入了一些在使用过程中需要注意到的事项。 <br>　　Create Table <br>　　CREATE [EXTERNAL] TABLE [IF NOT EXISTS] table_name <br>　　[(col_name data_type [COMMENT col_comment], ...)] <br>　　[COMMENT table_comment] <br>　　[PARTITIONED BY (col_name data_type <br>　　[COMMENT col_comment], ...)] <br>　　[CLUSTERED BY (col_name, col_name, ...) <br>　　[SORTED BY (col_name [ASC|DESC], ...)] <br>　　INTO num_buckets BUCKETS] <br>　　[ROW FORMAT row_format] <br>　　[STORED AS file_format] <br>　　[LOCATION hdfs_path] <br>　　CREATE TABLE 创建一个指定名字的表。如果相同名字的表已经存在，则抛出异常；用户可以用 IF NOT EXIST 选项来忽略这个异常。 <br>　　EXTERNAL 关键字可以让用户创建一个外部表，在建表的同时指定一个指向实际数据的路径（LOCATION），Hive 创建内部表时，会将数据移动到数据仓库指向的路径；若创建外部表，仅记录数据所在的路径，不对数据的位置做任何改变。在删除表的时候，内部表的元数据和数据会被一起删除，而外部表只删除元数据，不删除数据。 <br>　　LIKE 允许用户复制现有的表结构，但是不复制数据。 <br>　　用户在建表的时候可以自定义 SerDe 或者使用自带的 SerDe。如果没有指定 ROW FORMAT 或者 ROW FORMAT DELIMITED，将会使用自带的 SerDe。在建表的时候，用户还需要为表指定列，用户在指定表的列的同时也会指定自定义的 SerDe，Hive 通过 SerDe 确定表的具体的列的数据。 <br>　　如果文件数据是纯文本，可以使用 STORED AS TEXTFILE。如果数据需要压缩，使用 STORED AS SEQUENCE 。 <br>　　有分区的表可以在创建的时候使用 PARTITIONED BY 语句。一个表可以拥有一个或者多个分区，每一个分区单独存在一个目录下。而且，表和分区都可以对某个列进行 CLUSTERED BY 操作，将若干个列放入一个桶（bucket）中。也可以利用SORT BY 对数据进行排序。这样可以为特定应用提高性能。 <br>　　表名和列名不区分大小写，SerDe 和属性名区分大小写。表和列的注释是字符串。 <br>　　Drop Table <br>　　删除一个内部表的同时会同时删除表的元数据和数据。删除一个外部表，只删除元数据而保留数据。 <br>　　Alter Table <br>　　Alter table 语句允许用户改变现有表的结构。用户可以增加列/分区，改变serde，增加表和 serde 熟悉，表本身重命名。 <br>　　Add Partitions <br>　　ALTER TABLE table_name ADD <br>　　partition_spec [ LOCATION 'location1' ] <br>　　partition_spec [ LOCATION 'location2' ] ... <br>　　partition_spec: <br>　　: PARTITION (partition_col = partition_col_value, <br>　　partition_col = partiton_col_value, ...) <br>　　用户可以用 ALTER TABLE ADD PARTITION 来向一个表中增加分区。当分区名是字符串时加引号。 <br>　　ALTER TABLE page_view ADD <br>　　PARTITION (dt='2008-08-08', country='us') <br>　　location '/path/to/us/part080808' <br>　　PARTITION (dt='2008-08-09', country='us') <br>　　location '/path/to/us/part080809'; <br>　　DROP PARTITION <br>　　ALTER TABLE table_name DROP <br>　　partition_spec, partition_spec,... <br>　　用户可以用 ALTER TABLE DROP PARTITION 来删除分区。分区的元数据和数据将被一并删除。 <br>　　ALTER TABLE page_view <br>　　DROP PARTITION (dt='2008-08-08', country='us'); <br>　　RENAME TABLE <br>　　ALTER TABLE table_name RENAME TO new_table_name <br>　　这个命令可以让用户为表更名。数据所在的位置和分区名并不改变。换而言之，老的表名并未“释放”，对老表的更改会改变新表的数据。 <br>　　Change Column Name/Type/Position/Comment <br>　　ALTER TABLE table_name CHANGE [COLUMN] <br>　　col_old_name col_new_name column_type <br>　　[COMMENT col_comment] <br>　　[FIRST|AFTER column_name] <br>　　这个命令可以允许用户修改一个列的名称、数据类型、注释或者位置。 <br>　　比如： <br>　　CREATE TABLE test_change (a int, b int, c int); <br>　　ALTER TABLE test_change CHANGE a a1 INT; 将 a 列的名字改为 a1. <br>　　ALTER TABLE test_change CHANGE a a1 STRING AFTER b; 将 a 列的名字改为 a1，a 列的数据类型改为 string，并将它放置在列 b 之后。新的表结构为： b int, a1 string, c int. <br>　　ALTER TABLE test_change CHANGE b b1 INT FIRST; 会将 b 列的名字修改为 b1, 并将它放在第一列。新表的结构为： b1 int, a string, c int. <br>　　注意：对列的改变只会修改 Hive 的元数据，而不会改变实际数据。用户应该确定保证元数据定义和实际数据结构的一致性。 <br>　　Add/Replace Columns <br>　　ALTER TABLE table_name ADD|REPLACE <br>　　COLUMNS (col_name data_type [COMMENT col_comment], ...) <br>　　ADD COLUMNS 允许用户在当前列的末尾增加新的列，但是在分区列之前。 <br>　　REPLACE COLUMNS 删除以后的列，加入新的列。只有在使用 native 的 SerDE（DynamicSerDe or MetadataTypeColumnsetSerDe）的时候才可以这么做。 <br>　　Alter Table Properties <br>　　ALTER TABLE table_name SET TBLPROPERTIES table_properties <br>　　table_properties: <br>　　: (property_name = property_value, property_name = property_value, ... ) <br>　　用户可以用这个命令向表中增加 metadata，目前 last_modified_user，last_modified_time 属性都是由 Hive 自动管理的。用户可以向列表中增加自己的属性。可以使用 DESCRIBE EXTENDED TABLE 来获得这些信息。 <br>　　Add Serde Properties <br>　　ALTER TABLE table_name <br>　　SET SERDE serde_class_name <br>　　[WITH SERDEPROPERTIES serde_properties] <br>　　ALTER TABLE table_name <br>　　SET SERDEPROPERTIES serde_properties <br>　　serde_properties: <br>　　: (property_name = property_value, <br>　　property_name = property_value, ... ) <br>　　这个命令允许用户向 SerDe 对象增加用户定义的元数据。Hive 为了序列化和反序列化数据，将会初始化 SerDe 属性，并将属性传给表的 SerDe。如此，用户可以为自定义的 SerDe 存储属性。 <br>　　Alter Table File Format and Organization <br>　　ALTER TABLE table_name SET FILEFORMAT file_format <br>　　ALTER TABLE table_name CLUSTERED BY (col_name, col_name, ...) <br>　　[SORTED BY (col_name, ...)] INTO num_buckets BUCKETS <br>　　这个命令修改了表的物理存储属性。 <br>　　Loading files into table <br>　　当数据被加载至表中时，不会对数据进行任何转换。Load 操作只是将数据复制/移动至 Hive 表对应的位置。 <br>　　Syntax: <br>　　LOAD DATA [LOCAL] INPATH 'filepath' [OVERWRITE] <br>　　INTO TABLE tablename <br>　　[PARTITION (partcol1=val1, partcol2=val2 ...)] <br>　　Synopsis: <br>　　Load 操作只是单纯的复制/移动操作，将数据文件移动到 Hive 表对应的位置。 <br>　　* filepath 可以是： <br>　　o 相对路径，例如：project/data1 <br>　　o 绝对路径，例如： /user/hive/project/data1 <br>　　o 包含模式的完整 URI，例如：hdfs://namenode:9000/user/hive/project/data1 <br>　　* 加载的目标可以是一个表或者分区。如果表包含分区，必须指定每一个分区的分区名。 <br>　　* filepath 可以引用一个文件（这种情况下，Hive 会将文件移动到表所对应的目录中）或者是一个目录（在这种情况下，Hive 会将目录中的所有文件移动至表所对应的目录中）。 <br>　　* 如果指定了 LOCAL，那么： <br>　　o load 命令会去查找本地文件系统中的 filepath。如果发现是相对路径，则路径会被解释为相对于当前用户的当前路径。用户也可以为本地文件指定一个完整的 URI，比如：file:///user/hive/project/data1. <br>　　o load 命令会将 filepath 中的文件复制到目标文件系统中。目标文件系统由表的位置属性决定。被复制的数据文件移动到表的数据对应的位置。 <br>　　* 如果没有指定 LOCAL 关键字，如果 filepath 指向的是一个完整的 URI，hive 会直接使用这个 URI。 否则： <br>　　o 如果没有指定 schema 或者 authority，Hive 会使用在 hadoop 配置文件中定义的 schema 和 authority，fs.default.name 指定了 Namenode 的 URI。 <br>　　o 如果路径不是绝对的，Hive 相对于 /user/ 进行解释。 <br>　　o Hive 会将 filepath 中指定的文件内容移动到 table （或者 partition）所指定的路径中。 <br>　　* 如果使用了 OVERWRITE 关键字，则目标表（或者分区）中的内容（如果有）会被删除，然后再将 filepath 指向的文件/目录中的内容添加到表/分区中。 <br>　　* 如果目标表（分区）已经有一个文件，并且文件名和 filepath 中的文件名冲突，那么现有的文件会被新文件所替代。 <br>　　SELECT <br>　　Syntax <br>　　SELECT [ALL | DISTINCT] select_expr, select_expr, ... <br>　　FROM table_reference <br>　　[WHERE where_condition] <br>　　[GROUP BY col_list] <br>　　[ <br>　　CLUSTER BY col_list <br>　　| [DISTRIBUTE BY col_list] <br>　　[SORT BY col_list] <br>　　] <br>　　[LIMIT number] <br>　　* 一个SELECT语句可以是一个union查询或一个子查询的一部分。 <br>　　* table_reference是查询的输入，可以是一个普通表、一个视图、一个join或一个子查询 <br>　　* 简单查询。例如，下面这一语句从t1表中查询所有列的信息。 <br>　　SELECT * FROM t1 <br>　　WHERE Clause <br>　　where condition 是一个布尔表达式。例如，下面的查询语句只返回销售记录大于 10，且归属地属于美国的销售代表。Hive 不支持在WHERE 子句中的 IN，EXIST 或子查询。 <br>　　SELECT * FROM sales WHERE amount &gt; 10 AND region = "US" <br>　　ALL and DISTINCT Clauses <br>　　使用ALL和DISTINCT选项区分对重复记录的处理。默认是ALL，表示查询所有记录。DISTINCT表示去掉重复的记录。 <br>　　hive&gt; SELECT col1, col2 FROM t1 <br>　　1 3 <br>　　1 3 <br>　　1 4 <br>　　2 5 <br>　　hive&gt; SELECT DISTINCT col1, col2 FROM t1 <br>　　1 3 <br>　　1 4 <br>　　2 5 <br>　　hive&gt; SELECT DISTINCT col1 FROM t1 <br>　　1 <br>　　2 <br>　　基于Partition的查询 <br>　　一般 SELECT 查询会扫描整个表（除非是为了抽样查询）。但是如果一个表使用 PARTITIONED BY 子句建表，查询就可以利用分区剪枝（input pruning）的特性，只扫描一个表中它关心的那一部分。Hive 当前的实现是，只有分区断言出现在离 FROM 子句最近的那个WHERE 子句中，才会启用分区剪枝。例如，如果 page_views 表使用 date 列分区，以下语句只会读取分区为‘2008-03-01’的数据。 <br>　　SELECT page_views.* <br>　　FROM page_views <br>　　WHERE page_views.date &gt;= '2008-03-01' <br>　　AND page_views.date  10 <br>　　可以用以下查询来表达： <br>　　SELECT col1 FROM (SELECT col1, SUM(col2) AS col2sum <br>　　FROM t1 GROUP BY col1) t2 <br>　　WHERE t2.col2sum &gt; 10 <br>　　LIMIT Clause <br>　　Limit 可以限制查询的记录数。查询的结果是随机选择的。下面的查询语句从 t1 表中随机查询5条记录： <br>　　SELECT * FROM t1 LIMIT 5 <br>　　Top k 查询。下面的查询语句查询销售记录最大的 5 个销售代表。 <br>　　SET mapred.reduce.tasks = 1 <br>　　SELECT * FROM sales SORT BY amount DESC LIMIT 5 <br>　　REGEX Column Specification <br>　　SELECT 语句可以使用正则表达式做列选择，下面的语句查询除了 ds 和 hr 之外的所有列： <br>　　SELECT `(ds|hr)?+.+` FROM sales <br>　　Join <br>　　Syntax <br>　　join_table: <br>　　table_reference JOIN table_factor [join_condition] <br>　　| table_reference {LEFT|RIGHT|FULL} [OUTER] <br>　　JOIN table_reference join_condition <br>　　| table_reference LEFT SEMI JOIN <br>　　table_reference join_condition <br>　　table_reference: <br>　　table_factor <br>　　| join_table <br>　　table_factor: <br>　　tbl_name [alias] <br>　　| table_subquery alias <br>　　| ( table_references ) <br>　　join_condition: <br>　　ON equality_expression ( AND equality_expression )* <br>　　equality_expression: <br>　　expression = expression <br>　　Hive 只支持等值连接（equality joins）、外连接（outer joins）和（left semi joins???）。Hive 不支持所有非等值的连接，因为非等值连接非常难转化到 map/reduce 任务。另外，Hive 支持多于 2 个表的连接。 <br>　　写 join 查询时，需要注意几个关键点： <br>　　1. 只支持等值join，例如： <br>　　SELECT a.* FROM a JOIN b ON (a.id = b.id) <br>　　SELECT a.* FROM a JOIN b <br>　　ON (a.id = b.id AND a.department = b.department) <br>　　是正确的，然而: <br>　　SELECT a.* FROM a JOIN b ON (a.id  b.id) <br>　　是错误的。 <br>　　2. 可以 join 多于 2 个表，例如 <br>　　SELECT a.val, b.val, c.val FROM a JOIN b <br>　　ON (a.key = b.key1) JOIN c ON (c.key = b.key2) <br>　　如果join中多个表的 join key 是同一个，则 join 会被转化为单个 map/reduce 任务，例如： <br>　　SELECT a.val, b.val, c.val FROM a JOIN b <br>　　ON (a.key = b.key1) JOIN c <br>　　ON (c.key = b.key1) <br>　　被转化为单个 map/reduce 任务，因为 join 中只使用了 b.key1 作为 join key。 <br>　　SELECT a.val, b.val, c.val FROM a JOIN b ON (a.key = b.key1) <br>　　JOIN c ON (c.key = b.key2) <br>　　而这一 join 被转化为 2 个 map/reduce 任务。因为 b.key1 用于第一次 join 条件，而 b.key2 用于第二次 join。 <br>　　join 时，每次 map/reduce 任务的逻辑是这样的：reducer 会缓存 join 序列中除了最后一个表的所有表的记录，再通过最后一个表将结果序列化到文件系统。这一实现有助于在 reduce 端减少内存的使用量。实践中，应该把最大的那个表写在最后（否则会因为缓存浪费大量内存）。例如： <br>　　SELECT a.val, b.val, c.val FROM a <br>　　JOIN b ON (a.key = b.key1) JOIN c ON (c.key = b.key1) <br>　　所有表都使用同一个 join key（使用 1 次 map/reduce 任务计算）。Reduce 端会缓存 a 表和 b 表的记录，然后每次取得一个 c 表的记录就计算一次 join 结果，类似的还有： <br>　　SELECT a.val, b.val, c.val FROM a <br>　　JOIN b ON (a.key = b.key1) JOIN c ON (c.key = b.key2) <br>　　这里用了 2 次 map/reduce 任务。第一次缓存 a 表，用 b 表序列化；第二次缓存第一次 map/reduce 任务的结果，然后用 c 表序列化。 <br>　　LEFT，RIGHT 和 FULL OUTER 关键字用于处理 join 中空记录的情况，例如： <br>　　SELECT a.val, b.val FROM a LEFT OUTER <br>　　JOIN b ON (a.key=b.key) <br>　　对应所有 a 表中的记录都有一条记录输出。输出的结果应该是 a.val, b.val，当 a.key=b.key 时，而当 b.key 中找不到等值的 a.key 记录时也会输出 a.val, NULL。“FROM a LEFT OUTER JOIN b”这句一定要写在同一行――意思是 a 表在 b 表的左边，所以 a 表中的所有记录都被保留了；“a RIGHT OUTER JOIN b”会保留所有 b 表的记录。OUTER JOIN 语义应该是遵循标准 SQL spec的。 <br>　　Join 发生在 WHERE 子句之前。如果你想限制 join 的输出，应该在 WHERE 子句中写过滤条件――或是在 join 子句中写。这里面一个容易混淆的问题是表分区的情况： <br>　　SELECT a.val, b.val FROM a <br>　　LEFT OUTER JOIN b ON (a.key=b.key) <br>　　WHERE a.ds='2009-07-07' AND b.ds='2009-07-07' <br>　　会 join a 表到 b 表（OUTER JOIN），列出 a.val 和 b.val 的记录。WHERE 从句中可以使用其他列作为过滤条件。但是，如前所述，如果 b 表中找不到对应 a 表的记录，b 表的所有列都会列出 NULL，包括 ds 列。也就是说，join 会过滤 b 表中不能找到匹配 a 表 join key 的所有记录。这样的话，LEFT OUTER 就使得查询结果与 WHERE 子句无关了。解决的办法是在 OUTER JOIN 时使用以下语法： <br>　　SELECT a.val, b.val FROM a LEFT OUTER JOIN b <br>　　ON (a.key=b.key AND <br>　　b.ds='2009-07-07' AND <br>　　a.ds='2009-07-07') <br>　　这一查询的结果是预先在 join 阶段过滤过的，所以不会存在上述问题。这一逻辑也可以应用于 RIGHT 和 FULL 类型的 join 中。 <br>　　Join 是不能交换位置的。无论是 LEFT 还是 RIGHT join，都是左连接的。 <br>　　SELECT a.val1, a.val2, b.val, c.val <br>　　FROM a <br>　　JOIN b ON (a.key = b.key) <br>　　LEFT OUTER JOIN c ON (a.key = c.key) <br>　　先 join a 表到 b 表，丢弃掉所有 join key 中不匹配的记录，然后用这一中间结果和 c 表做 join。这一表述有一个不太明显的问题，就是当一个 key 在 a 表和 c 表都存在，但是 b 表中不存在的时候：整个记录在第一次 join，即 a JOIN b 的时候都被丢掉了（包括a.val1，a.val2和a.key），然后我们再和 c 表 join 的时候，如果 c.key 与 a.key 或 b.key 相等，就会得到这样的结果：NULL, NULL, NULL, c.val。 <br>　　LEFT SEMI JOIN 是 IN/EXISTS 子查询的一种更高效的实现。Hive 当前没有实现 IN/EXISTS 子查询，所以你可以用 LEFT SEMI JOIN 重写你的子查询语句。LEFT SEMI JOIN 的限制是， JOIN 子句中右边的表只能在 ON 子句中设置过滤条件，在 WHERE 子句、SELECT 子句或其他地方过滤都不行。 <br>　　SELECT a.key, a.value <br>　　FROM a <br>　　WHERE a.key in <br>　　(SELECT b.key <br>　　FROM B); <br>　　可以被重写为： <br>　　SELECT a.key, a.val <br>　　FROM a LEFT SEMI JOIN b on (a.key = b.key) <br>　　（五）：Hive优化 <br>　　Hive 针对不同的查询进行了优化，优化可以通过配置进行控制，本文将介绍部分优化的策略以及优化控制选项。 <br>　　列裁剪（Column Pruning） <br>　　在读数据的时候，只读取查询中需要用到的列，而忽略其他列。例如，对于查询： <br>　　SELECT a,b FROM T WHERE e 内存，将条目少的表放在左边，可以有效减少发生 OOM 错误的几率。 <br>　　对于一条语句中有多个 Join 的情况，如果 Join 的条件相同，比如查询： <br>　　INSERT OVERWRITE TABLE pv_users <br>　　SELECT pv.pageid, u.age FROM page_view p <br>　　JOIN user u ON (pv.userid = u.userid) <br>　　JOIN newuser x ON (u.userid = x.userid); <br>　　* 如果 Join 的 key 相同，不管有多少个表，都会则会合并为一个 Map-Reduce <br>　　* 一个 Map-Reduce 任务，而不是 ‘n’ 个 <br>　　* 在做 OUTER JOIN 的时候也是一样 <br>　　如果 Join 的条件不相同，比如： <br>　　INSERT OVERWRITE TABLE pv_users <br>　　SELECT pv.pageid, u.age FROM page_view p <br>　　JOIN user u ON (pv.userid = u.userid) <br>　　JOIN newuser x on (u.age = x.age); <br>　　Map-Reduce 的任务数目和 Join 操作的数目是对应的，上述查询和以下查询是等价的： <br>　　INSERT OVERWRITE TABLE tmptable <br>　　SELECT * FROM page_view p JOIN user u <br>　　ON (pv.userid = u.userid); <br>　　INSERT OVERWRITE TABLE pv_users <br>　　SELECT x.pageid, x.age FROM tmptable x <br>　　JOIN newuser y ON (x.age = y.age); <br>　　Map Join <br>　　Join 操作在 Map 阶段完成，不再需要Reduce，前提条件是需要的数据在 Map 的过程中可以访问到。比如查询： <br>　　INSERT OVERWRITE TABLE pv_users <br>　　SELECT /*+ MAPJOIN(pv) */ pv.pageid, u.age <br>　　FROM page_view pv <br>　　JOIN user u ON (pv.userid = u.userid); <br>　　可以在 Map 阶段完成 Join，如图所示： <br>　　相关的参数为： <br>　　* hive.join.emit.interval = 1000 How many rows in the right-most join operand Hive should buffer before emitting the join result. <br>　　* hive.mapjoin.size.key = 10000 <br>　　* hive.mapjoin.cache.numrows = 10000 <br>　　Group By <br>　　* Map 端部分聚合： <br>　　o 并不是所有的聚合操作都需要在 Reduce 端完成，很多聚合操作都可以先在 Map 端进行部分聚合，最后在 Reduce 端得出最终结果。 <br>　　o 基于 Hash <br>　　o 参数包括： <br>　　+ hive.map.aggr = true 是否在 Map 端进行聚合，默认为 True <br>　　+ hive.groupby.mapaggr.checkinterval = 100000 在 Map 端进行聚合操作的条目数目 <br>　　* 有数据倾斜的时候进行负载均衡 <br>　　o hive.groupby.skewindata = false <br>　　o 当选项设定为 true，生成的查询计划会有两个 MR Job。第一个 MR Job 中，Map 的输出结果集合会随机分布到 Reduce 中，每个 Reduce 做部分聚合操作，并输出结果，这样处理的结果是相同的 Group By Key 有可能被分发到不同的 Reduce 中，从而达到负载均衡的目的；第二个 MR Job 再根据预处理的数据结果按照 Group By Key 分布到 Reduce 中（这个过程可以保证相同的 Group By Key 被分布到同一个 Reduce 中），最后完成最终的聚合操作。 <br>　　合并小文件 <br>　　文件数目过多，会给 HDFS 带来压力，并且会影响处理效率，可以通过合并 Map 和 Reduce 的结果文件来消除这样的影响： <br>　　* hive.merge.mapfiles = true 是否和并 Map 输出文件，默认为 True <br>　　* hive.merge.mapredfiles = false 是否合并 Reduce 输出文件，默认为 False <br>　　* hive.merge.size.per.task = 256*1000*1000 合并文件的大小 <br>　　（六）：Hive 的扩展特性 <br>　　Hive 是一个很开放的系统，很多内容都支持用户定制，包括： <br>　　* 文件格式：Text File，Sequence File <br>　　* 内存中的数据格式： Java Integer/String, Hadoop IntWritable/Text <br>　　* 用户提供的 map/reduce 脚本：不管什么语言，利用 stdin/stdout 传输数据 <br>　　* 用户自定义函数: Substr, Trim, 1            </div>
                </div>