---
layout:     post
title:      Kafka负载均衡、Kafka自定义Partition、Kafk文件存储机制
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                <h2><span style="font-family:Cambria;color:#000000;">1</span>、<span style="font-family:Cambria;">Kafka</span>整体结构图</h2><p><span style="font-family:Calibri;color:#000000;">Kafka</span>名词解释和工作方式</p><p><span style="font-family:Calibri;color:#000000;"> </span></p><p><span style="color:#000000;">l  <span style="font-family:Calibri;">Producer </span>：消息生产者，就是向<span style="font-family:Calibri;">kafka broker</span>发消息的客户端。</span></p><p><span style="color:#000000;">l  <span style="font-family:Calibri;">Consumer </span>：消息消费者，向<span style="font-family:Calibri;">kafka broker</span>取消息的客户端</span></p><p><span style="color:#000000;">l  <span style="font-family:Calibri;">Topic </span>：咋们可以理解为一个队列。</span></p><p><span style="color:#000000;">l  <span style="font-family:Calibri;">Consumer Group </span>（<span style="font-family:Calibri;">CG</span>）：这是<span style="font-family:Calibri;">kafka</span>用来实现一个<span style="font-family:Calibri;">topic</span>消息的广播（发给所有的<span style="font-family:Calibri;">consumer</span>）和单播（发给任意一个<span style="font-family:Calibri;">consumer</span>）的手段。一个<span style="font-family:Calibri;">topic</span>可以有多个<span style="font-family:Calibri;">CG</span>。<span style="font-family:Calibri;">topic</span>的消息会<a name="OLE_LINK6"></a><a name="OLE_LINK5">复制（不是真的复制，是概念上的）到所有的</a><span style="font-family:Calibri;">CG</span>，但每个<span style="font-family:Calibri;">partion</span>只会把消息发给该<span style="font-family:Calibri;">CG</span>中的一个<span style="font-family:Calibri;">consumer</span>。如果需要实现广播，只要每个<span style="font-family:Calibri;">consumer</span>有一个独立的<span style="font-family:Calibri;">CG</span>就可以了。要实现单播只要所有的<span style="font-family:Calibri;">consumer</span>在同一个<span style="font-family:Calibri;">CG</span>。用<span style="font-family:Calibri;">CG</span>还可以将<span style="font-family:Calibri;">consumer</span>进行自由的分组而不需要多次发送消息到不同的<span style="font-family:Calibri;">topic</span>。</span></p><p><span style="color:#000000;">l  <span style="font-family:Calibri;">Broker </span>：一台<span style="font-family:Calibri;">kafka</span>服务器就是一个<span style="font-family:Calibri;">broker</span>。一个集群由多个<span style="font-family:Calibri;">broker</span>组成。一个<span style="font-family:Calibri;">broker</span>可以容纳多个<span style="font-family:Calibri;">topic</span>。</span></p><p><span style="color:#000000;">l  <span style="font-family:Calibri;">Partition</span>：为了实现扩展性，一个非常大的<span style="font-family:Calibri;">topic</span>可以分布到多个<span style="font-family:Calibri;">broker</span>（即服务器）上，一个<span style="font-family:Calibri;">topic</span>可以分为多个<span style="font-family:Calibri;">partition</span>，每个<span style="font-family:Calibri;">partition</span>是一个有序的队列。<span style="font-family:Calibri;">partition</span>中的每条消息都会被分配一个有序的<span style="font-family:Calibri;">id</span>（<span style="font-family:Calibri;">offset</span>）。<span style="font-family:Calibri;">kafka</span>只保证按一个<span style="font-family:Calibri;">partition</span>中的顺序将消息发给<span style="font-family:Calibri;">consumer</span>，不保证一个<span style="font-family:Calibri;">topic</span>的整体（多个<span style="font-family:Calibri;">partition</span>间）的顺序。</span></p><p><span style="color:#000000;">l  <span style="font-family:Calibri;">Offset</span>：<span style="font-family:Calibri;">kafka</span>的存储文件都是按照<span style="font-family:Calibri;">offset.kafka</span>来命名，用<span style="font-family:Calibri;">offset</span>做名字的好处是方便查找。例如你想找位于<span style="font-family:Calibri;">2049</span>的位置，只要找到<span style="font-family:Calibri;">2048.kafka</span>的文件即可。当然<span style="font-family:Calibri;">the first offset</span>就是<span style="font-family:Calibri;">00000000000.kafka</span></span></p><h2><span style="font-family:Cambria;color:#000000;">2</span>、<a name="OLE_LINK2"></a><a name="OLE_LINK1"><span style="font-family:Cambria;">Consumer</span></a>与<span style="font-family:Cambria;">topic</span>关系</h2><p><span style="color:#000000;">本质上<span style="font-family:Calibri;">kafka</span>只支持<span style="font-family:Calibri;">Topic</span>；</span></p><p><span style="color:#000000;">l  每个<span style="font-family:Calibri;">group</span>中可以有多个<span style="font-family:Calibri;">consumer</span>，每个<span style="font-family:Calibri;">consumer</span>属于一个<span style="font-family:Calibri;">consumergroup</span>；</span></p><p><span style="color:#000000;">通常情况下，一个<span style="font-family:Calibri;">group</span>中会包含多个<span style="font-family:Calibri;">consumer</span>，这样不仅可以提高<span style="font-family:Calibri;">topic</span>中消息的并发消费能力，而且还能提高<span style="font-family:Calibri;">"</span>故障容错<span style="font-family:Calibri;">"</span>性，如果<span style="font-family:Calibri;">group</span>中的某个<span style="font-family:Calibri;">consumer</span>失效那么其消费的<span style="font-family:Calibri;">partitions</span>将会有其他<span style="font-family:Calibri;">consumer</span>自动接管。</span></p><p><span style="color:#000000;">l  对于<span style="font-family:Calibri;">Topic</span>中的一条特定的消息，只会被订阅此<span style="font-family:Calibri;">Topic</span>的每个<span style="font-family:Calibri;">group</span>中的其中一个<span style="font-family:Calibri;">consumer</span>消费，此消息不会发送给一个<span style="font-family:Calibri;">group</span>的多个<span style="font-family:Calibri;">consumer</span>；</span></p><p><span style="color:#000000;">那么一个<span style="font-family:Calibri;">group</span>中所有的<span style="font-family:Calibri;">consumer</span>将会交错的消费整个<span style="font-family:Calibri;">Topic</span>，每个<span style="font-family:Calibri;">group</span>中<span style="font-family:Calibri;">consumer</span>消息消费互相独立，我们可以认为一个<span style="font-family:Calibri;">group</span>是一个<span style="font-family:Calibri;">"</span>订阅<span style="font-family:Calibri;">"</span>者。</span></p><p><span style="color:#000000;">l  在<span style="font-family:Calibri;">kafka</span>中<span style="font-family:Calibri;">,</span>一个<span style="font-family:Calibri;">partition</span>中的消息只会被<span style="font-family:Calibri;">group</span>中的一个<span style="font-family:Calibri;">consumer</span>消费</span><span><span style="color:#FF0000;"><span style="font-family:Calibri;">(</span></span><span style="color:#FF0000;">同一时刻</span><span style="color:#FF0000;"><span style="font-family:Calibri;">)</span></span></span><span style="color:#000000;">；</span></p><p><span style="color:#000000;">一个<span style="font-family:Calibri;">Topic</span>中的每个<span style="font-family:Calibri;">partions</span>，只会被一个<span style="font-family:Calibri;">"</span>订阅者<span style="font-family:Calibri;">"</span>中的一个<span style="font-family:Calibri;">consumer</span>消费，不过一个<span style="font-family:Calibri;">consumer</span>可以同时消费多个<span style="font-family:Calibri;">partitions</span>中的消息。</span></p><p><span style="color:#000000;">l  <span style="font-family:Calibri;">kafka</span>的设计原理决定<span style="font-family:Calibri;">,</span>对于一个<span style="font-family:Calibri;">topic</span>，同一个<span style="font-family:Calibri;">group</span>中不能有多于<span style="font-family:Calibri;">partitions</span>个数的<span style="font-family:Calibri;">consumer</span>同时消费，否则将意味着某些<span style="font-family:Calibri;">consumer</span>将无法得到消息。</span></p><p><span><span style="color:#FF0000;"><span style="font-family:Calibri;">kafka</span></span><span style="color:#FF0000;">只能保证一个</span><span style="color:#FF0000;"><span style="font-family:Calibri;">partition</span></span><span style="color:#FF0000;">中的消息被某个</span><span style="color:#FF0000;"><span style="font-family:Calibri;">consumer</span></span><span style="color:#FF0000;">消费时是顺序的；事实上，从</span><span style="color:#FF0000;"><span style="font-family:Calibri;">Topic</span></span><span style="color:#FF0000;">角度来说</span><span style="color:#FF0000;"><span style="font-family:Calibri;">,</span></span><span style="color:#FF0000;">当有多个</span><span style="color:#FF0000;"><span style="font-family:Calibri;">partitions</span></span><span style="color:#FF0000;">时</span><span style="color:#FF0000;"><span style="font-family:Calibri;">,</span></span><span style="color:#FF0000;">消息仍不是全局有序的。</span></span></p><h2><span style="font-family:Cambria;color:#000000;">3</span>、<span style="font-family:Cambria;">Kafka</span>消息的分发</h2><p><span style="font-family:Calibri;color:#000000;">         </span><strong><span style="color:#FF0000;">Producer</span><span style="color:#FF0000;">客户端负责消息的分发</span></strong></p><p><span style="color:#000000;">l  <span style="font-family:Calibri;">kafka</span>集群中的任何一个<span style="font-family:Calibri;">broker</span>都可以向<span style="font-family:Calibri;">producer</span>提供<span style="font-family:Calibri;">metadata</span>信息<span style="font-family:Calibri;">,</span>这些<span style="font-family:Calibri;">metadata</span>中包含<span style="font-family:Calibri;">"</span>集群中存活的<span style="font-family:Calibri;">servers</span>列表<span style="font-family:Calibri;">"/"partitions leader</span>列表<span style="font-family:Calibri;">"</span>等信息；</span></p><p><span style="color:#000000;">l  当<span style="font-family:Calibri;">producer</span>获取到<span style="font-family:Calibri;">metadata</span>信息之后<span style="font-family:Calibri;">,producer</span>将会和<span style="font-family:Calibri;">Topic</span>下所有<span style="font-family:Calibri;">partition leader</span>保持<span style="font-family:Calibri;">socket</span>连接；</span></p><p><span style="color:#000000;">l  消息由<span style="font-family:Calibri;">producer</span>直接通过<span style="font-family:Calibri;">socket</span>发送到<span style="font-family:Calibri;">broker</span>，中间不会经过任何<span style="font-family:Calibri;">"</span>路由层<span style="font-family:Calibri;">"</span>，事实上，消息被路由到哪个<span style="font-family:Calibri;">partition</span>上由<span style="font-family:Calibri;">producer</span>客户端决定；</span></p><p><span style="color:#000000;">比如可以采用<span style="font-family:Calibri;">"random""key-hash""</span>轮询<span style="font-family:Calibri;">"</span>等<span style="font-family:Calibri;">,</span></span><strong><span style="color:#FF0000;">如果一个</span><span style="color:#FF0000;"><span style="font-family:Calibri;">topic</span></span><span style="color:#FF0000;">中有多个</span><span style="color:#FF0000;"><span style="font-family:Calibri;">partitions,</span></span><span style="color:#FF0000;">那么在</span><span style="color:#FF0000;"><span style="font-family:Calibri;">producer</span></span><span style="color:#FF0000;">端实现</span><span style="color:#FF0000;"><span style="font-family:Calibri;">"</span></span><span style="color:#FF0000;">消息均衡分发</span><span style="color:#FF0000;"><span style="font-family:Calibri;">"</span></span><span style="color:#FF0000;">是必要的。</span></strong></p><p><span style="color:#000000;">l  在<span style="font-family:Calibri;">producer</span>端的配置文件中<span style="font-family:Calibri;">,</span>开发者可以指定<span style="font-family:Calibri;">partition</span>路由的方式。</span></p><p><span style="font-family:Calibri;color:#000000;"> </span></p><p><span style="font-family:Calibri;color:#000000;">Producer</span>消息发送的应答机制</p><p><span style="color:#000000;">设置发送数据是否需要服务端的反馈<span style="font-family:Calibri;">,</span>有三个值<span style="font-family:Calibri;">0,1,-1</span></span></p><p><span style="font-family:Calibri;color:#000000;">0: producer</span>不会等待<span style="font-family:Calibri;">broker</span>发送<span style="font-family:Calibri;">ack </span></p><p><span style="font-family:Calibri;color:#000000;">1: </span>当<span style="font-family:Calibri;">leader</span>接收到消息之后发送<span style="font-family:Calibri;">ack </span></p><p><span style="font-family:Calibri;color:#000000;">-1: </span>当所有的<span style="font-family:Calibri;">follower</span>都同步消息成功后发送<span style="font-family:Calibri;">ack</span></p><p><span style="font-family:Calibri;color:#000000;">         request.required.acks=0</span></p><h2><strong><span style="color:#333333;">4</span><span style="color:#333333;">、</span></strong><a name="OLE_LINK4"></a><a name="OLE_LINK3"><strong><span style="color:#333333;">Consumer</span></strong></a><strong><span style="color:#333333;">的负载均衡</span></strong></h2><p><span style="color:#000000;">当一个<span style="font-family:Calibri;">group</span>中<span style="font-family:Calibri;">,</span>有<span style="font-family:Calibri;">consumer</span>加入或者离开时<span style="font-family:Calibri;">,</span>会触发<span style="font-family:Calibri;">partitions</span>均衡<span style="font-family:Calibri;">.</span>均衡的最终目的<span style="font-family:Calibri;">,</span>是提升<span style="font-family:Calibri;">topic</span>的并发消费能力，步骤如下：</span></p><p><a name="OLE_LINK8"></a><span style="color:#000000;"><a name="OLE_LINK7"><span style="font-family:Calibri;">1、</span>  假如<span style="font-family:Calibri;">topic1,</span></a>具有如下<span style="font-family:Calibri;">partitions: P0,P1,P2,P3</span></span></p><p><span style="font-family:Calibri;color:#000000;">2、</span>  加入<span style="font-family:Calibri;">group</span>中<span style="font-family:Calibri;">,</span>有如下<span style="font-family:Calibri;">consumer: C1,C2</span></p><p><span style="font-family:Calibri;color:#000000;">3、</span>  首先根据<span style="font-family:Calibri;">partition</span>索引号对<span style="font-family:Calibri;">partitions</span>排序<span style="font-family:Calibri;">: P0,P1,P2,P3</span></p><p><span style="font-family:Calibri;color:#000000;">4、</span>  根据<span style="font-family:Calibri;">consumer.id</span>排序<span style="font-family:Calibri;">: C0,C1</span></p><p><span style="font-family:Calibri;color:#000000;">5、</span>  计算倍数<span style="font-family:Calibri;">: M = [P0,P1,P2,P3].size / [C0,C1].size,</span>本例值<span style="font-family:Calibri;">M=2(</span>向上取整<span style="font-family:Calibri;">)</span></p><p></p><p></p><div><span style="font-family:Calibri;color:#000000;">6、</span>  然后依次分配<span style="font-family:Calibri;">partitions: C0 = [P0,P1],C1=[P2,P3],</span>即<span style="font-family:Calibri;">Ci = [P(i *M),P((i + 1) * M -1)]</span></div><div><span style="font-family:Calibri;"><img src="https://img-blog.csdn.net/20180702013029663?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9sb25nXzRfMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></span></div><span style="font-family:Calibri;"></span><h2 style="background:#FFFFFF;"><span style="color:#000000;">kafka</span><span style="color:#000000;">文件存<span style="background:#FFFFFF;">储机制</span></span></h2><h3><span style="font-family:Calibri;font-size:18px;color:#000000;">5.1</span>、<span style="font-family:Calibri;">Kafka</span>文件存储基本结构</h3><div><p><span style="color:#000000;">l  在<span style="font-family:Calibri;">Kafka</span>文件存储中，同一个<span style="font-family:Calibri;">topic</span>下有多个不同<span style="font-family:Calibri;">partition</span>，每个<span style="font-family:Calibri;">partition</span>为一个目录，<span style="font-family:Calibri;">partiton</span>命名规则为<span style="font-family:Calibri;">topic</span>名称<span style="font-family:Calibri;">+</span>有序序号，第一个<span style="font-family:Calibri;">partiton</span>序号从<span style="font-family:Calibri;">0</span>开始，序号最大值为<span style="font-family:Calibri;">partitions</span>数量减<span style="font-family:Calibri;">1</span>。</span></p></div><div><p><span style="color:#000000;">l  每个<span style="font-family:Calibri;">partion(</span>目录<span style="font-family:Calibri;">)</span>相当于一个巨型文件被平均分配到多个大小相等<span style="font-family:Calibri;">segment(</span>段<span style="font-family:Calibri;">)</span></span><span style="color:#000000;">数据文件中。</span><strong><span style="color:#FF0000;">但每个段</span><span style="color:#FF0000;"><span style="font-family:Calibri;">segmentfile</span></span><span style="color:#FF0000;">消息数量不一定相等</span></strong><span style="color:#000000;">，这种特性方便<span style="font-family:Calibri;">oldsegment file</span>快速被删除。默认保留<span style="font-family:Calibri;">7</span>天的数据。</span></p></div><div><img src="https://img-blog.csdn.net/20180702013044621?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9sb25nXzRfMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></div><div><p style="text-indent:-21pt;"><span style="color:#000000;"><span xml:lang="en-us" lang="en-us" style="font-family:Wingdings;"><span>l<span style="font:7pt 'Times New Roman';">  </span></span></span><span style="font-family:'宋体';">每个</span><span xml:lang="en-us" lang="en-us"><span style="font-family:Calibri;">partiton</span></span><span style="font-family:'宋体';">只需要支持顺序读写就行了，</span><span xml:lang="en-us" lang="en-us"><span style="font-family:Calibri;">segment</span></span><span style="font-family:'宋体';">文件生命周期由服务端配置参数决定。（什么时候创建，什么时候删除）</span></span><span xml:lang="en-us" lang="en-us"></span></p></div><div><img src="https://img-blog.csdn.net/20180702013058829?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9sb25nXzRfMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></div><div><p><span style="color:#000000;">数据有序的讨论？</span></p><p><span style="font-family:Calibri;color:#000000;">         </span>一个<span style="font-family:Calibri;">partition</span>的数据是否是有序的？<span style="font-family:Calibri;">       </span>间隔性有序，不连续</p><p><span style="font-family:Calibri;color:#000000;">         </span>针对一个<span style="font-family:Calibri;">topic</span>里面的数据，只能做到<span style="font-family:Calibri;">partition</span>内部有序，不能做到全局有序。</p><p><span style="font-family:Calibri;color:#000000;">         </span>特别加入消费者的场景后，如何保证消费者消费的数据全局有序的？伪命题。</p><p><span style="font-family:Calibri;color:#000000;"> </span></p><p><span style="color:#000000;">只有一种情况下才能保证全局有序？就是只有一个<span style="font-family:Calibri;">partition</span>。</span></p><h3><span style="font-family:Calibri;font-size:18px;color:#000000;">5.2</span>、<span style="font-family:Calibri;">Kafka Partition </span><span style="color:#000000;background:#FFFFFF;">Segment</span></h3><p><span style="color:#000000;">l </span><span style="color:#000000;background:#FFFFFF;">Segment</span><span style="color:#000000;">file</span><span style="color:#000000;">组成：由2</span>大部分组成，分别为index file和data file，此2个文件一一对应，成对出现，后缀".index"和“.log”分别表示为segment索引文件、数据文件。</p></div><div><img src="https://img-blog.csdn.net/2018070201311481?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9sb25nXzRfMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></div><div><p><span style="color:#000000;">l </span><span style="color:#000000;background:#FFFFFF;">Segment</span><span style="color:#000000;">文件命名规则：partion</span>全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset值。数值最大为64位long大小，19位数字字符长度，没有数字用0填充。</p><p><span style="color:#000000;">l </span><span style="color:#3e3e3e;">索引文件存储大量元数据，数据文件存储大量消息，索引文件中元数据指向对应数据文件中message</span>的物理偏移地址。</p></div><div><img src="https://img-blog.csdn.net/20180702013126360?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9sb25nXzRfMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></div><div><p style="background:#FFFFFF;" align="center"><span style="color:#3e3e3e;">3</span><span style="color:#3e3e3e;">，497</span>：当前log文件中的第几条信息，存放在磁盘上的那个地方</p><p style="background:#FFFFFF;" align="center"><span style="color:#3e3e3e;"> </span></p><p><span style="color:#3e3e3e;">上述图中索引文件存储大量元数据，数据文件存储大量消息，索引文件中元数据指向对应数据文件中message</span>的物理偏移地址。</p><p><span style="color:#3e3e3e;">其中以索引文件中元数据3,497</span>为例，依次在数据文件中表示第3个message(在全局partiton表示第368772个message)、以及该消息的物理偏移地址为497。</p><p style="background:#FFFFFF;" align="center"><span style="color:#3e3e3e;"> </span></p><p><span style="color:#3e3e3e;">l </span><span style="color:#3e3e3e;">segment data file</span><span style="color:#3e3e3e;">由许多message</span>组成， qq物理结构如下：</p><div align="right"><table style="background:#FFFFFF;" width="712" cellspacing="0" cellpadding="0" border="1"><thead><tr><td style="background:rgb(247,247,247);"><p align="center"><strong><span style="color:#3e3e3e;">关键字</span></strong></p></td>   <td style="background:rgb(247,247,247);"><p align="center"><strong><span style="color:#3e3e3e;">解释说明</span></strong></p></td>  </tr></thead><tbody><tr><td><p align="center"><span style="color:#3e3e3e;">8 byte offset</span></p></td>  <td><p><span style="color:#3e3e3e;">在parition(</span>分区)内的每条消息都有一个有序的id号，这个id号被称为偏移(offset),它可以唯一确定每条消息在parition(分区)内的位置。即offset表示partiion的第多少message</p></td> </tr><tr><td style="background:rgb(248,248,248);"><p align="center"><span style="color:#3e3e3e;">4 byte  message size</span></p></td>  <td style="background:rgb(248,248,248);"><p><span style="color:#3e3e3e;">message</span><span style="color:#3e3e3e;">大小</span></p></td> </tr><tr><td><p align="center"><span style="color:#3e3e3e;">4 byte CRC32</span></p></td>  <td><p><span style="color:#3e3e3e;">用crc32</span>校验message</p></td> </tr><tr><td style="background:rgb(248,248,248);"><p align="center"><span style="color:#3e3e3e;">1 byte </span><span style="color:#3e3e3e;">“magic"</span></p></td>  <td style="background:rgb(248,248,248);"><p><span style="color:#3e3e3e;">表示本次发布Kafka</span>服务程序协议版本号</p></td> </tr><tr><td><p align="center"><span style="color:#3e3e3e;">1 byte </span><span style="color:#3e3e3e;">“attributes"</span></p></td>  <td><p><span style="color:#3e3e3e;">表示为独立版本、或标识压缩类型、或编码类型。</span></p></td> </tr><tr><td style="background:rgb(248,248,248);"><p align="center"><span style="color:#3e3e3e;">4 byte key  length</span></p></td>  <td style="background:rgb(248,248,248);"><p><span style="color:#3e3e3e;">表示key</span>的长度,当key为-1时，K byte key字段不填</p></td> </tr><tr><td><p align="center"><span style="color:#3e3e3e;">K byte key</span></p></td>  <td><p><span style="color:#3e3e3e;">可选</span></p></td> </tr><tr><td style="background:rgb(248,248,248);"><p align="center"><span style="color:#3e3e3e;">value bytes  payload</span></p></td>  <td style="background:rgb(248,248,248);"><p><span style="color:#3e3e3e;">表示实际消息数据。</span></p></td> </tr></tbody></table></div><p style="background:#FFFFFF;"><span style="color:#000000;"> </span></p><p style="background:#FFFFFF;"><span style="color:#000000;"> </span></p><h3><span style="font-family:Calibri;font-size:18px;color:#000000;">5.3</span>、<span style="font-family:Calibri;">Kafka </span><span style="color:#000000;background:#FFFFFF;">查找</span><span style="color:#000000;background:#FFFFFF;">message</span></h3><p><span style="color:#000000;">读取<span style="font-family:Calibri;">offset=368776</span>的<span style="font-family:Calibri;">message</span>，需要通过下面<span style="font-family:Calibri;">2</span>个步骤查找。</span></p></div><div><img src="https://img-blog.csdn.net/20180702013206739?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9sb25nXzRfMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></div><div><h4><span style="font-size:18px;"><span style="color:#000000;"><span xml:lang="en-us" lang="en-us"><span style="font-family:Cambria;">5.3.1</span></span><span style="font-family:'宋体';">、查找</span><span xml:lang="en-us" lang="en-us"><span style="font-family:Cambria;">segment file</span></span></span></span></h4><p style="text-indent:21pt;"><span style="color:#000000;"><span xml:lang="en-us" lang="en-us"><span style="font-family:Calibri;">00000000000000000000.index</span></span><span style="font-family:'宋体';">表示最开始的文件，起始偏移量</span><span xml:lang="en-us" lang="en-us"><span style="font-family:Calibri;">(offset)</span></span><span style="font-family:'宋体';">为</span><span xml:lang="en-us" lang="en-us"><span style="font-family:Calibri;">0</span></span></span></p><p style="text-indent:21pt;"><span style="color:#000000;"><span xml:lang="en-us" lang="en-us"><span style="font-family:Calibri;">00000000000000368769.index</span></span><span style="font-family:'宋体';">的消息量起始偏移量为</span><span xml:lang="en-us" lang="en-us"><span style="font-family:Calibri;">368770= 368769 + 1</span></span></span></p><p style="text-indent:21pt;"><span style="color:#000000;"><span xml:lang="en-us" lang="en-us"><span style="font-family:Calibri;">00000000000000737337.index</span></span><span style="font-family:'宋体';">的起始偏移量为</span><span xml:lang="en-us" lang="en-us"><span style="font-family:Calibri;">737338=737337+ 1</span></span></span></p><p style="text-indent:21pt;"><span style="font-family:'宋体';"><span style="color:#000000;">其他后续文件依次类推。</span></span><span xml:lang="en-us" lang="en-us"></span></p><p><span style="color:#000000;"><span style="font-family:'宋体';">以起始偏移量命名并排序这些文件，只要根据</span><span xml:lang="en-us" lang="en-us"><span style="font-family:Calibri;">offset**</span></span><span style="font-family:'宋体';">二分查找</span><span xml:lang="en-us" lang="en-us"><span style="font-family:Calibri;">**</span></span><span style="font-family:'宋体';">文件列表，就可以快速定位到具体文件。当</span><span xml:lang="en-us" lang="en-us"><span style="font-family:Calibri;">offset=368776</span></span><span style="font-family:'宋体';">时定位到</span><span xml:lang="en-us" lang="en-us"><span style="font-family:Calibri;">00000000000000368769.index</span></span><span style="font-family:'宋体';">和对应</span><span xml:lang="en-us" lang="en-us"><span style="font-family:Calibri;">log</span></span><span style="font-family:'宋体';">文件。</span></span><span xml:lang="en-us" lang="en-us"></span></p><h4><span style="font-size:18px;"><span style="color:#000000;"><span xml:lang="en-us" lang="en-us"><span style="font-family:Cambria;">5.3.2</span></span><span style="font-family:'宋体';">、通过</span><span xml:lang="en-us" lang="en-us"><span style="font-family:Cambria;">segment file</span></span><span style="font-family:'宋体';">查找</span><span xml:lang="en-us" lang="en-us"><span style="font-family:Cambria;">message<span>  </span></span></span></span></span></h4><p><span style="color:#000000;"><span style="font-family:'宋体';">当</span><span xml:lang="en-us" lang="en-us"><span style="font-family:Calibri;">offset=368776</span></span><span style="font-family:'宋体';">时，依次定位到</span><span xml:lang="en-us" lang="en-us"><span style="font-family:Calibri;">00000000000000368769.index</span></span><span style="font-family:'宋体';">的元数据物理位置和</span><span xml:lang="en-us" lang="en-us"><span style="font-family:Calibri;">00000000000000368769.log</span></span><span style="font-family:'宋体';">的物理偏移地址</span></span><span xml:lang="en-us" lang="en-us"></span></p><p style="text-indent:21pt;"><span style="color:#000000;"><span style="font-family:'宋体';">然后再通过</span><span xml:lang="en-us" lang="en-us"><span style="font-family:Calibri;">00000000000000368769.log</span></span><span style="font-family:'宋体';">顺序查找直到</span><span xml:lang="en-us" lang="en-us"><span style="font-family:Calibri;">offset=368776</span></span><span style="font-family:'宋体';">为止。</span></span><span xml:lang="en-us" lang="en-us"></span></p><h2 style="background:#FFFFFF;"><br></h2></div><div><br></div>            </div>
                </div>