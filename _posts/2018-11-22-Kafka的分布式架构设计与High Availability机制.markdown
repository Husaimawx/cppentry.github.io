---
layout:     post
title:      Kafka的分布式架构设计与High Availability机制
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                <div class="iteye-blog-content-contain" style="font-size:14px;">
<p class="MsoNormal" align="left"><strong><span style="font-size:12pt;font-family:'宋体';">一、<span lang="en-us" xml:lang="en-us">Kafka</span>的基本概述</span></strong></p>
<p class="MsoListParagraph" style="margin-left:46.8pt;text-indent:0cm;" align="left"><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us"> </span></strong></p>
<p class="MsoNormal" align="left"><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">1</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">、<span lang="en-us" xml:lang="en-us">Kafka</span>是什么？</span></strong></p>
<p style="text-indent:21pt;line-height:20pt;"><span lang="en-us" xml:lang="en-us">kafka</span>官网上对<span lang="en-us" xml:lang="en-us">kafka</span>的定义叫：<span lang="en-us" xml:lang="en-us">A distributed publish-subscribe messaging system</span>。<span lang="en-us" xml:lang="en-us">publish-subscribe</span>是发布和订阅的意思，所以准确的说<span lang="en-us" xml:lang="en-us">kafka</span>是一个消息订阅和发布的系统。最初，<span lang="en-us" xml:lang="en-us">Kafka</span>实际上是<span lang="en-us" xml:lang="en-us">linkedin</span>用于日志处理的分布式消息队列，<span lang="en-us" xml:lang="en-us">linkedin</span>的日志数据容量大，但对可靠性要求不高，其日志数据主要包括用户行为（登录、浏览、点击、分享、喜欢）以及系统运行日志（<span lang="en-us" xml:lang="en-us">CPU</span>、内存、磁盘、网络、系统及进程状态）。</p>
<p style="text-indent:21pt;line-height:18.9pt;"><span style="font-size:10.5pt;" lang="en-us" xml:lang="en-us"> </span></p>
<p class="MsoNormal" align="left"><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">2</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">、<span lang="en-us" xml:lang="en-us">Kafka</span>能做什么？</span></strong></p>
<p style="text-indent:21pt;line-height:20pt;">现今，<span lang="en-us" xml:lang="en-us">Kafa</span>主要用于处理活跃的流式数据，如分析用户的行为，包括用户的<span lang="en-us" xml:lang="en-us">pageview</span>（页面浏览），以便能够设计出更好的广告位，对用户搜索关键词进行统计以便分析出当前的流行趋势，比如经济学上著名的长裙理论：如果长裙的销量高了，说明经济不景气了，因为姑娘们没钱买各种丝袜了。当然还有些业务数据，如果存数据库浪费，而直接用传统的存硬盘方式效率又低下，这个时候，也可以使用<span lang="en-us" xml:lang="en-us">Kafka</span>的分布式进行存储。</p>
<p style="line-height:14.65pt;"><strong><span lang="en-us" xml:lang="en-us">3</span></strong><strong><span>、<span lang="en-us" xml:lang="en-us">Kafka</span>中的相关概念</span></strong></p>
<p class="MsoNormal" align="left">&lt;!--[if !supportLists]--&gt;<span style="font-size:10pt;font-family:Symbol;" lang="en-us" xml:lang="en-us">·<span style="font-size:7pt;line-height:normal;font-family:'Times New Roman';">        </span></span>&lt;!--[endif]--&gt;<strong><span style="font-size:12pt;font-family:Arial, sans-serif;" lang="en-us" xml:lang="en-us">Broker</span></strong></p>
<p class="MsoNormal" style="line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Kafka</span><span style="font-size:12pt;font-family:'宋体';">集群包含一个或多个服务器，这种服务器被称为<span lang="en-us" xml:lang="en-us">broker</span>。一台<span lang="en-us" xml:lang="en-us">kafka</span>服务器就是一个<span lang="en-us" xml:lang="en-us">broker</span>，一个集群由多个<span lang="en-us" xml:lang="en-us">broker</span>组成，一个<span lang="en-us" xml:lang="en-us">broker</span>可以容纳多个<span lang="en-us" xml:lang="en-us">topic</span>。</span></p>
<p class="MsoNormal" align="left">&lt;!--[if !supportLists]--&gt;<span style="font-size:10pt;font-family:Symbol;" lang="en-us" xml:lang="en-us">·<span style="font-size:7pt;line-height:normal;font-family:'Times New Roman';">        </span></span>&lt;!--[endif]--&gt;<strong><span style="font-size:12pt;font-family:Arial, sans-serif;" lang="en-us" xml:lang="en-us">Topic</span></strong></p>
<p class="MsoNormal" style="line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';">每条发布到<span lang="en-us" xml:lang="en-us">Kafka</span>集群的消息都有一个类别，这个类别被称为<span lang="en-us" xml:lang="en-us">Topic</span>，<span lang="en-us" xml:lang="en-us">Kafka</span>中<span lang="en-us" xml:lang="en-us">Topic</span>可以理解为一个存储消息的队列。物理上不同<span lang="en-us" xml:lang="en-us">Topic</span>的消息分开存储，逻辑上一个<span lang="en-us" xml:lang="en-us">Topic</span>的消息虽然保存在一个或多个<span lang="en-us" xml:lang="en-us">broker</span>上但用户只需指定消息的<span lang="en-us" xml:lang="en-us">Topic</span>即可生产或消费数据而不必关心数据存于何处。</span></p>
<p class="MsoNormal" align="left">&lt;!--[if !supportLists]--&gt;<span style="font-size:10pt;font-family:Symbol;" lang="en-us" xml:lang="en-us">·<span style="font-size:7pt;line-height:normal;font-family:'Times New Roman';">        </span></span>&lt;!--[endif]--&gt;<strong><span style="font-size:12pt;font-family:Arial, sans-serif;" lang="en-us" xml:lang="en-us">Partition</span></strong></p>
<p class="MsoNormal" style="line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Partition</span><span style="font-size:12pt;font-family:'宋体';">是物理上的概念，<span lang="en-us" xml:lang="en-us">Kafka</span>物理上把<span lang="en-us" xml:lang="en-us">Topic</span>分成一个或多个<span lang="en-us" xml:lang="en-us">Partition</span>，每个<span lang="en-us" xml:lang="en-us">Partition</span>在物理上对应一个文件夹，该文件夹下存储这个<span lang="en-us" xml:lang="en-us">Partition</span>的所有消息和索引文件。如创建<span lang="en-us" xml:lang="en-us">topic1</span>和<span lang="en-us" xml:lang="en-us">topic2</span>两个<span lang="en-us" xml:lang="en-us">topic</span>，且分别有<span lang="en-us" xml:lang="en-us">13</span>个和<span lang="en-us" xml:lang="en-us">19</span>个<span lang="en-us" xml:lang="en-us">Partition</span>分区，则整个集群上相应会生成<span lang="en-us" xml:lang="en-us">32</span>个文件夹。为了实现扩展性，一个非常大的<span lang="en-us" xml:lang="en-us">topic</span>可以分布到多个<span lang="en-us" xml:lang="en-us">broker</span>上，但<span lang="en-us" xml:lang="en-us">kafka</span>只保证按一个<span lang="en-us" xml:lang="en-us">partition</span>中的顺序将消息发给<span lang="en-us" xml:lang="en-us">consumer</span>，不保证一个<span lang="en-us" xml:lang="en-us">topic</span>的整体（多个<span lang="en-us" xml:lang="en-us">partition</span>间）的顺序。</span></p>
<p class="MsoNormal" align="left">&lt;!--[if !supportLists]--&gt;<span style="font-size:10pt;font-family:Symbol;" lang="en-us" xml:lang="en-us">·<span style="font-size:7pt;line-height:normal;font-family:'Times New Roman';">        </span></span>&lt;!--[endif]--&gt;<strong><span style="font-size:12pt;font-family:Arial, sans-serif;" lang="en-us" xml:lang="en-us">Producer</span></strong></p>
<p class="MsoNormal" align="left"><span style="font-size:12pt;font-family:'宋体';">负责发布消息到<span lang="en-us" xml:lang="en-us">Kafka broker</span>。</span></p>
<p class="MsoNormal" align="left">&lt;!--[if !supportLists]--&gt;<span style="font-size:10pt;font-family:Symbol;" lang="en-us" xml:lang="en-us">·<span style="font-size:7pt;line-height:normal;font-family:'Times New Roman';">        </span></span>&lt;!--[endif]--&gt;<strong><span style="font-size:12pt;font-family:Arial, sans-serif;" lang="en-us" xml:lang="en-us">Consumer</span></strong></p>
<p class="MsoNormal" align="left"><span style="font-size:12pt;font-family:'宋体';">消息消费者，向<span lang="en-us" xml:lang="en-us">Kafka broker</span>读取消息的客户端。</span></p>
<p class="MsoNormal" align="left">&lt;!--[if !supportLists]--&gt;<span style="font-size:10pt;font-family:Symbol;" lang="en-us" xml:lang="en-us">·<span style="font-size:7pt;line-height:normal;font-family:'Times New Roman';">        </span></span>&lt;!--[endif]--&gt;<strong><span style="font-size:12pt;font-family:Arial, sans-serif;" lang="en-us" xml:lang="en-us">Consumer Group</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">（</span></strong><strong><span style="font-size:12pt;font-family:Arial, sans-serif;" lang="en-us" xml:lang="en-us">CG</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">）</span></strong><strong><span style="font-size:12pt;font-family:Arial, sans-serif;" lang="en-us" xml:lang="en-us"><br></span></strong><span style="font-size:12pt;font-family:'宋体';">这是<span lang="en-us" xml:lang="en-us">kafka</span>用来实现一个<span lang="en-us" xml:lang="en-us">topic</span>消息的广播（发给所有的<span lang="en-us" xml:lang="en-us">consumer</span>）和单播（发给任意一个<span lang="en-us" xml:lang="en-us">consumer</span>）的手段。一个<span lang="en-us" xml:lang="en-us"> topic</span>可以属于多个<span lang="en-us" xml:lang="en-us">CG</span>。<span lang="en-us" xml:lang="en-us">topic</span>的消息会复制（不是真的复制，是概念上的）到所有的<span lang="en-us" xml:lang="en-us">CG</span>，但每个<span lang="en-us" xml:lang="en-us">CG</span>只会把消息发给该<span lang="en-us" xml:lang="en-us">CG</span>中的一个<span lang="en-us" xml:lang="en-us">consumer</span>。如果需要实现广播，只要每个<span lang="en-us" xml:lang="en-us">consumer</span>有一个独立的<span lang="en-us" xml:lang="en-us">CG</span>就可以了。要实现单播只要所有的<span lang="en-us" xml:lang="en-us">consumer</span>在同一个<span lang="en-us" xml:lang="en-us">CG</span>。用<span lang="en-us" xml:lang="en-us">CG</span>还可以将<span lang="en-us" xml:lang="en-us">consumer</span>进行自由的分组而不需要多次发送消息到不同的<span lang="en-us" xml:lang="en-us">topic</span>。每个<span lang="en-us" xml:lang="en-us">consumer</span>属于一个特定的<span lang="en-us" xml:lang="en-us">Consumer Group, Kafka</span>允许为每个<span lang="en-us" xml:lang="en-us">consumer</span>指定<span lang="en-us" xml:lang="en-us">group name</span>，若不指定<span lang="en-us" xml:lang="en-us">group name</span>则属于默认的<span lang="en-us" xml:lang="en-us">group</span>。</span></p>
<p style="line-height:14.65pt;"><strong><span style="font-family:Helvetica, sans-serif;" lang="en-us" xml:lang="en-us">4</span></strong><strong>、</strong><strong><span style="font-family:Helvetica, sans-serif;" lang="en-us" xml:lang="en-us">Kafka</span></strong><strong>的特性：</strong></p>
<p class="MsoNormal" style="text-indent:21pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">1</span><span style="font-size:12pt;font-family:'宋体';">）数据在磁盘上存取代价为<span lang="en-us" xml:lang="en-us">O(1)</span>，而一般数据在磁盘上是使用<span lang="en-us" xml:lang="en-us">BTree</span>存储的，存取代价为<span lang="en-us" xml:lang="en-us">O</span>（<span lang="en-us" xml:lang="en-us">lgn</span>）。</span></p>
<p class="MsoNormal" style="line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">   2</span><span style="font-size:12pt;font-family:'宋体';">）高吞吐率：即使在普通的节点（非常普通的硬件）上每秒钟也能处理成百上千的<span lang="en-us" xml:lang="en-us">message</span>。</span></p>
<p class="MsoNormal" style="line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">   3</span><span style="font-size:12pt;font-family:'宋体';">）显式分布式：即所有的<span lang="en-us" xml:lang="en-us">producer</span>、<span lang="en-us" xml:lang="en-us">broker</span>和<span lang="en-us" xml:lang="en-us">consumer</span>都会有多个，均匀分布并支持通过<span lang="en-us" xml:lang="en-us">kafka</span>服务器和消费机集群来分区消息。</span></p>
<p class="MsoNormal" style="line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">   4</span><span style="font-size:12pt;font-family:'宋体';">）支持数据并行加载到<span lang="en-us" xml:lang="en-us">Hadoop</span>中。</span></p>
<p class="MsoNormal" style="line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">   5) </span><span style="font-size:12pt;font-family:'宋体';">支持<span lang="en-us" xml:lang="en-us">Broker</span>间的消息分区及分布式消费，同时保证每个<span lang="en-us" xml:lang="en-us">partition</span>内的消息顺序传输。</span></p>
<p class="MsoNormal" style="line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">   6</span><span style="font-size:12pt;font-family:'宋体';">）同时支持离线数据处理和实时数据处理：当前很多的消息队列服务提供可靠交付保证，并默认是即时消费（不适合离线），而<span lang="en-us" xml:lang="en-us">Kafka</span>通过构建分布式的集群，允许消息在系统中累积，使得<span lang="en-us" xml:lang="en-us">kafka</span>同时支持离线和在线日志处理。</span></p>
<p class="MsoListParagraph" align="left">&lt;!--[if !supportLists]--&gt;<span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">7）</span>&lt;!--[endif]--&gt;<span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Scale out</span><span style="font-size:12pt;font-family:'宋体';">：支持在线水平扩展。</span></p>
<p class="MsoNormal" align="left"><span style="font-family:'宋体';">二、</span><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Kafka</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">的架构设计</span></strong></p>
<p class="MsoNormal" style="line-height:18.9pt;" align="left"><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">1</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">、 最简单的<span lang="en-us" xml:lang="en-us">Kafka</span>部署图</span></strong></p>
<p class="MsoNormal" style="text-indent:21pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';">如果将消息的发布（<span lang="en-us" xml:lang="en-us">publish</span>）称作<span lang="en-us" xml:lang="en-us">producer</span>，将消息的订阅（<span lang="en-us" xml:lang="en-us">subscribe</span>）表述为<span lang="en-us" xml:lang="en-us">consumer</span>，将中间的存储阵列称作<span lang="en-us" xml:lang="en-us">broker</span>，这样可以得到一个最简单的消息发布与订阅模型：</span></p>
<p class="MsoNormal" align="left"><br><img src="http://dl2.iteye.com/upload/attachment/0110/8891/45e7289b-807b-37dc-b8c6-22dad850130a.png" alt=""><br> </p>
<p class="MsoNormal" align="left"><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us"> </span></strong><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">2</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">、<span lang="en-us" xml:lang="en-us">kafka</span>的拓扑图</span></strong><span style="font-size:12pt;font-family:'宋体';">：</span></p>
<p class="MsoNormal" style="text-indent:21pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Kafka</span><span style="font-size:12pt;font-family:'宋体';">是显示的分布式消息发布和订阅系统，除了有多个<span lang="en-us" xml:lang="en-us">producer, broker</span>，<span lang="en-us" xml:lang="en-us">consumer</span>外，还有一个<span lang="en-us" xml:lang="en-us">zookeeper</span>集群用于管理<span lang="en-us" xml:lang="en-us">producer</span>，<span lang="en-us" xml:lang="en-us">broker</span>和<span lang="en-us" xml:lang="en-us">consumer</span>之间的协同调用。</span></p>
<p class="MsoNormal" align="left"><br><img src="http://dl2.iteye.com/upload/attachment/0110/8893/9f659d0e-e287-38bc-a443-618f279a5f16.png" alt=""><br> </p>
<p class="MsoNormal" style="text-indent:21pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';">从图中可以看出，一个典型的<span lang="en-us" xml:lang="en-us">Kafka</span>集群中包含若干<span lang="en-us" xml:lang="en-us">Producer</span>（可以是<span lang="en-us" xml:lang="en-us">web</span>前端产生的<span lang="en-us" xml:lang="en-us">Page View</span>，或者是服务器日志，系统<span lang="en-us" xml:lang="en-us">CPU</span>、<span lang="en-us" xml:lang="en-us">Memory</span>等），若干<span lang="en-us" xml:lang="en-us">broker</span>（<span lang="en-us" xml:lang="en-us">Kafka</span>支持水平扩展，一般<span lang="en-us" xml:lang="en-us">broker</span>数量越多，集群吞吐率越高），若干<span lang="en-us" xml:lang="en-us">Consumer Group</span>，以及一个</span><span lang="en-us" xml:lang="en-us"><a href="http://zookeeper.apache.org/" rel="nofollow"><span style="font-size:12pt;font-family:'宋体';color:#000000;">Zookeeper</span></a></span><span style="font-size:12pt;font-family:'宋体';">集群。<span lang="en-us" xml:lang="en-us">Kafka</span>通过<span lang="en-us" xml:lang="en-us">Zookeeper</span>管理集群配置，选举<span lang="en-us" xml:lang="en-us">leader</span>，以及在<span lang="en-us" xml:lang="en-us">Consumer Group</span>发生变化时进行<span lang="en-us" xml:lang="en-us">rebalance</span>。<span lang="en-us" xml:lang="en-us">Producer</span>使用<span lang="en-us" xml:lang="en-us">push</span>模式将消息发布到<span lang="en-us" xml:lang="en-us">broker</span>，<span lang="en-us" xml:lang="en-us">Consumer</span>使用<span lang="en-us" xml:lang="en-us">pull</span>模式从<span lang="en-us" xml:lang="en-us">broker</span>订阅并消费消息。</span></p>
<p class="MsoNormal" style="text-indent:21pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';">图上有个细节需要注意，<span lang="en-us" xml:lang="en-us">Producer</span>到<span lang="en-us" xml:lang="en-us">Broker</span>的过程是<span lang="en-us" xml:lang="en-us">push</span>，也就是有数据就推送到<span lang="en-us" xml:lang="en-us">Broker</span>，而<span lang="en-us" xml:lang="en-us">Consumer</span>到<span lang="en-us" xml:lang="en-us">Broker</span>的过程是<span lang="en-us" xml:lang="en-us">pull</span>，是通过<span lang="en-us" xml:lang="en-us">Consumer</span>主动去拉数据的，而不是<span lang="en-us" xml:lang="en-us">Broker</span>把数据主动发送到<span lang="en-us" xml:lang="en-us">Consumer</span>端的。</span></p>
<p class="MsoNormal" style="text-indent:21pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us"> </span></p>
<p class="MsoNormal" style="text-indent:21pt;" align="left"><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">3</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">、</span></strong><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Zookeeper</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">和<span lang="en-us" xml:lang="en-us">Procuder</span>、<span lang="en-us" xml:lang="en-us">Broker</span>、<span lang="en-us" xml:lang="en-us">Consumer</span>的协同工作</span></strong></p>
<p class="MsoNormal" style="text-indent:21pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';">为了便于理解，假定此时<span lang="en-us" xml:lang="en-us">Kafka</span>集群中有两台<span lang="en-us" xml:lang="en-us">Producer</span>，但只有一台<span lang="en-us" xml:lang="en-us">Kafka</span>的<span lang="en-us" xml:lang="en-us">Broker</span>、<span lang="en-us" xml:lang="en-us">Zookeeper</span>和<span lang="en-us" xml:lang="en-us">Consumer</span>。如下图所示的部署集群。</span></p>
<p class="MsoNormal" style="text-indent:21pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us"><br><img src="http://dl2.iteye.com/upload/attachment/0110/8895/bc0787e0-d8cb-3720-9f1c-ef3cfbbaa0ac.jpg" alt=""><br>  </span></p>
<p class="MsoNormal" style="line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us"> <span>1</span></span><span style="font-size:12pt;font-family:'宋体';">、 <span lang="en-us" xml:lang="en-us">Kafka Broker</span>其实就是<span lang="en-us" xml:lang="en-us">Kafka</span>的<span lang="en-us" xml:lang="en-us">server</span>，<span lang="en-us" xml:lang="en-us">Broker</span>主要做存储用，每个<span lang="en-us" xml:lang="en-us">Broker</span>启动后会在<span lang="en-us" xml:lang="en-us">Zookeeper</span>上注册一个临时的<span lang="en-us" xml:lang="en-us">broker registry</span>，包含<span lang="en-us" xml:lang="en-us">Broker</span>的<span lang="en-us" xml:lang="en-us">IP</span>地址和端口号，所存储的<span lang="en-us" xml:lang="en-us">topics</span>和<span lang="en-us" xml:lang="en-us">partitions</span>信息。</span></p>
<p class="MsoNormal" style="line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us"> 2</span><span style="font-size:12pt;font-family:'宋体';">、<span lang="en-us" xml:lang="en-us">Zookeeper</span>，可以把<span lang="en-us" xml:lang="en-us">Zookeeper</span>想象成它维持了一张表，记录了各个节点的<span lang="en-us" xml:lang="en-us">IP</span>、端口等配置信息。</span></p>
<p class="MsoNormal" style="line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us"> 3</span><span style="font-size:12pt;font-family:'宋体';">、<span lang="en-us" xml:lang="en-us">Producer1,Producer2,Consumer</span>的共同之处就是都配置了<span lang="en-us" xml:lang="en-us">zkClient</span>，更明确的说，就是运行前必须配置<span lang="en-us" xml:lang="en-us">Zookeeper</span>的地址，道理也很简单，因为他们之间的连接都是需要<span lang="en-us" xml:lang="en-us">Zookeeper</span>来进行分发的。</span></p>
<p class="MsoNormal" style="line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us"> 4</span><span style="font-size:12pt;font-family:'宋体';">、<span lang="en-us" xml:lang="en-us">Kafka Broker</span>和<span lang="en-us" xml:lang="en-us">Zookeeper</span>可以放在一台机器上，也可以分开放，此外<span lang="en-us" xml:lang="en-us">Zookeeper</span>也可以配集群<span lang="en-us" xml:lang="en-us">,</span>这样就不会出现单点故障。</span></p>
<p class="MsoNormal" style="text-indent:12pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">5</span><span style="font-size:12pt;font-family:'宋体';">、 每个<span lang="en-us" xml:lang="en-us">Consumer</span>启动后会在<span lang="en-us" xml:lang="en-us">Zookeeper</span>上注册一个临时的<span lang="en-us" xml:lang="en-us">consumer registry</span>：包含<span lang="en-us" xml:lang="en-us">Consumer</span>所属的<span lang="en-us" xml:lang="en-us">Consumer Group</span>以及订阅的<span lang="en-us" xml:lang="en-us">topics</span>。每个<span lang="en-us" xml:lang="en-us">Consumer Group</span>关联一个临时的<span lang="en-us" xml:lang="en-us">owner registry</span>和一个持久的<span lang="en-us" xml:lang="en-us">offset registry</span>。对于被订阅的每个<span lang="en-us" xml:lang="en-us">partition</span>包含一个<span lang="en-us" xml:lang="en-us">owner registry</span>，内容为订阅这个<span lang="en-us" xml:lang="en-us">partition</span>的<span lang="en-us" xml:lang="en-us">consumer id</span>，同时包含一个<span lang="en-us" xml:lang="en-us">offset registry</span>，内容为上一次订阅的<span lang="en-us" xml:lang="en-us">offset</span>。</span></p>
<p class="MsoNormal" style="line-height:18.9pt;" align="left"><strong><span style="font-size:12pt;font-family:'宋体';">整个系统运行的顺序可简单归纳为：</span></strong></p>
<p class="MsoNormal" style="text-indent:12pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">1</span><span style="font-size:12pt;font-family:'宋体';">、启动<span lang="en-us" xml:lang="en-us">Zookeeper</span>的<span lang="en-us" xml:lang="en-us">server</span>。</span></p>
<p class="MsoNormal" style="text-indent:12pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">2</span><span style="font-size:12pt;font-family:'宋体';">、启动<span lang="en-us" xml:lang="en-us">Kafka</span>的<span lang="en-us" xml:lang="en-us">server</span>。</span></p>
<p class="MsoNormal" style="text-indent:12pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">3</span><span style="font-size:12pt;font-family:'宋体';">、<span lang="en-us" xml:lang="en-us">Producer</span>如果生产了数据， 会先通过<span lang="en-us" xml:lang="en-us">Zookeeper</span>找到<span lang="en-us" xml:lang="en-us">Broker</span>，然后将数据存放进<span lang="en-us" xml:lang="en-us">Broker</span>。</span></p>
<p class="MsoNormal" style="text-indent:12pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">4</span><span style="font-size:12pt;font-family:'宋体';">、<span lang="en-us" xml:lang="en-us">Consumer</span>如果要消费数据，会先通过<span lang="en-us" xml:lang="en-us">Zookeeper</span>找对应的<span lang="en-us" xml:lang="en-us">Broker</span>，然后消费。</span></p>
<p class="MsoNormal" style="text-indent:12.05pt;line-height:18.9pt;" align="left"><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Producer</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">代码实例：</span></strong></p>
<table class="MsoTableGrid" style="border-collapse:collapse;border:none;" border="1" cellspacing="0" cellpadding="0"><tbody><tr><td style="width:426.1pt;" valign="top" width="710">
<p class="MsoNormal" align="left"><span style="text-decoration:underline;"><span style="font-size:10pt;font-family:Consolas;" lang="en-us" xml:lang="en-us">producer</span></span><span style="font-size:10pt;font-family:Consolas;" lang="en-us" xml:lang="en-us"> = </span><strong><span style="font-size:10pt;font-family:Consolas;color:#7f0055;" lang="en-us" xml:lang="en-us">new</span></strong><span style="font-size:10pt;font-family:Consolas;" lang="en-us" xml:lang="en-us"> Producer(<span style="text-decoration:underline;">...</span>)<span style="text-decoration:underline;">;</span></span></p>
<p class="MsoNormal" align="left"><span style="font-size:10pt;font-family:Consolas;" lang="en-us" xml:lang="en-us">message  = </span><strong><span style="font-size:10pt;font-family:Consolas;color:#7f0055;" lang="en-us" xml:lang="en-us">new</span></strong><span style="font-size:10pt;font-family:Consolas;" lang="en-us" xml:lang="en-us"> Message(</span><span style="font-size:10pt;font-family:Consolas;color:#2a00ff;" lang="en-us" xml:lang="en-us">"Hello Ebay"</span><span style="font-size:10pt;font-family:Consolas;" lang="en-us" xml:lang="en-us">.getBytes());</span></p>
<p class="MsoNormal" align="left"><span style="font-size:10pt;font-family:Consolas;" lang="en-us" xml:lang="en-us">set      = </span><strong><span style="font-size:10pt;font-family:Consolas;color:#7f0055;" lang="en-us" xml:lang="en-us">new</span></strong><span style="font-size:10pt;font-family:Consolas;" lang="en-us" xml:lang="en-us"> MessageSet(message);</span></p>
<p class="MsoNormal" align="left"><span style="font-size:10pt;font-family:Consolas;" lang="en-us" xml:lang="en-us">producer.send(</span><span style="font-size:10pt;font-family:Consolas;color:#2a00ff;" lang="en-us" xml:lang="en-us">"topic1"</span><span style="font-size:10pt;font-family:Consolas;" lang="en-us" xml:lang="en-us">, set);</span></p>
</td>
</tr></tbody></table><p class="MsoNormal" style="text-indent:12pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';">发布消息时，<span lang="en-us" xml:lang="en-us">Producer</span>先构造一条消息，将消息加入到消息集<span lang="en-us" xml:lang="en-us">set</span>中（<span lang="en-us" xml:lang="en-us">Kafka</span>支持批量发布，可以往消息集合中添加多条消息，然后一次性发布<span lang="en-us" xml:lang="en-us">), send</span>消息时，<span lang="en-us" xml:lang="en-us">client</span>需指定消息所属的<span lang="en-us" xml:lang="en-us">topic</span>。</span></p>
<p class="MsoNormal" style="line-height:18.9pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us"> <strong>Consumer</strong></span><strong><span style="font-size:12pt;font-family:'宋体';">代码实例：</span></strong></p>
<table class="MsoTableGrid" style="border-collapse:collapse;border:none;" border="1" cellspacing="0" cellpadding="0"><tbody><tr><td style="width:426.1pt;" valign="top" width="710">
<p class="MsoNormal" align="left"><span style="font-size:10pt;font-family:Consolas;" lang="en-us" xml:lang="en-us">streams[<span style="text-decoration:underline;">]</span> = Consumer.createMessageStreams(</span><span style="font-size:10pt;font-family:Consolas;color:#2a00ff;" lang="en-us" xml:lang="en-us">"topic1"</span><span style="font-size:10pt;font-family:Consolas;" lang="en-us" xml:lang="en-us">, 1);</span></p>
<p class="MsoNormal" align="left"><strong><span style="font-size:10pt;font-family:Consolas;color:#7f0055;" lang="en-us" xml:lang="en-us">for</span></strong><span style="font-size:10pt;font-family:Consolas;" lang="en-us" xml:lang="en-us"> (<span style="text-decoration:underline;">message</span> : streams) {</span></p>
<p class="MsoNormal" align="left"><span style="font-size:10pt;font-family:Consolas;" lang="en-us" xml:lang="en-us">    <span style="text-decoration:underline;">bytes</span> = <span style="text-decoration:underline;">message</span>.payload();</span></p>
<p class="MsoNormal" align="left"><span style="font-size:10pt;font-family:Consolas;" lang="en-us" xml:lang="en-us">    </span><span style="font-size:10pt;font-family:Consolas;color:#3f7f5f;" lang="en-us" xml:lang="en-us">// do something with the bytes</span></p>
<p class="MsoNormal" style="line-height:18.9pt;" align="left"><span style="font-size:10pt;font-family:Consolas;" lang="en-us" xml:lang="en-us">}</span></p>
</td>
</tr></tbody></table><p class="MsoNormal" style="text-indent:21pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';">订阅消息时<span lang="en-us" xml:lang="en-us">,Consumer</span>需指定<span lang="en-us" xml:lang="en-us">topic</span>以及<span lang="en-us" xml:lang="en-us">partition num</span>（每个<span lang="en-us" xml:lang="en-us">partition</span>对应一个逻辑日志流，如<span lang="en-us" xml:lang="en-us">topic</span>代表某个产品线，<span lang="en-us" xml:lang="en-us">partition</span>代表产品线的日志按天切分的结果），<span lang="en-us" xml:lang="en-us">client</span>订阅后，就可迭代读取消息，如果没有消息，<span lang="en-us" xml:lang="en-us">client</span>会阻塞直到有新的消息发布。<span lang="en-us" xml:lang="en-us">Consumer</span>可以累积确认接收到的消息，当其确认了某个<span lang="en-us" xml:lang="en-us">offset</span>的消息，意味着之前的消息也都已成功接收到，此时<span lang="en-us" xml:lang="en-us">Broker</span>会更新<span lang="en-us" xml:lang="en-us">Zookeeper</span>上的<span lang="en-us" xml:lang="en-us">offset registry</span>。</span></p>
<p class="MsoNormal" style="text-indent:21pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';">那么怎样记录每个<span lang="en-us" xml:lang="en-us">Consumer</span>处理的信息的状态呢？其实在<span lang="en-us" xml:lang="en-us">Kafka</span>中仅保存了每个<span lang="en-us" xml:lang="en-us">Consumer</span>已经处理数据的<span lang="en-us" xml:lang="en-us">offset</span>。这样有两个好处：一是保存的数据量少，二是当<span lang="en-us" xml:lang="en-us">Consumer</span>出错时，重新启动<span lang="en-us" xml:lang="en-us">Consumer</span>处理数据时，只需从最近的<span lang="en-us" xml:lang="en-us">offset</span>开始处理数据即可。</span></p>
<p class="MsoNormal" style="line-height:18.9pt;" align="left"><span style="font-family:Helvetica, sans-serif;" lang="en-us" xml:lang="en-us"> </span></p>
<p class="MsoNormal" align="left"><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">4</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">、<span lang="en-us" xml:lang="en-us">Kafka</span>的存储策略</span></strong></p>
<p class="MsoNormal" style="text-indent:21pt;line-height:18.9pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Kafka broker</span><span style="font-size:12pt;font-family:'宋体';">主要是用于做存储使用，每个<span lang="en-us" xml:lang="en-us">broker</span>上可存储很多的<span lang="en-us" xml:lang="en-us">topic</span>信息。</span></p>
<p class="MsoNormal" style="line-height:18.9pt;" align="left"><br><img src="http://dl2.iteye.com/upload/attachment/0110/8897/369abe2c-2f12-3947-8368-8a664ab337b9.png" alt=""><br> </p>
<p class="MsoNormal" style="text-indent:21pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">1</span><span style="font-size:12pt;font-family:'宋体';">、<span lang="en-us" xml:lang="en-us">Kafka</span>以<span lang="en-us" xml:lang="en-us">topic</span>来进行消息管理，每个<span lang="en-us" xml:lang="en-us">topic</span>包含多个<span lang="en-us" xml:lang="en-us">partition</span>，一个<span lang="en-us" xml:lang="en-us">partition</span>对应一个逻辑<span lang="en-us" xml:lang="en-us">log</span>，由多个<span lang="en-us" xml:lang="en-us">segment</span>组成。</span></p>
<p class="MsoNormal" style="line-height:18.9pt;" align="left"><br><img src="http://dl2.iteye.com/upload/attachment/0110/8899/0fa20106-e3c7-3276-9d36-a27be06506af.png" alt=""><br> </p>
<p class="MsoNormal" style="line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us"> 2</span><span style="font-size:12pt;font-family:'宋体';">、每个<span lang="en-us" xml:lang="en-us">segment</span>中存储多条消息，消息<span lang="en-us" xml:lang="en-us">id</span>由其逻辑位置决定，即从消息<span lang="en-us" xml:lang="en-us">id</span>可直接定位到消息的存储位置，避免<span lang="en-us" xml:lang="en-us">id</span>到位置的额外映射。</span></p>
<p class="MsoNormal" style="line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us"> 3</span><span style="font-size:12pt;font-family:'宋体';">、每个<span lang="en-us" xml:lang="en-us">partition</span>在内存中对应一个<span lang="en-us" xml:lang="en-us">index</span>，记录每个<span lang="en-us" xml:lang="en-us">segment</span>中的第一条消息偏移。</span></p>
<p class="MsoNormal" style="line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us"> 4</span><span style="font-size:12pt;font-family:'宋体';">、发布者发到某个<span lang="en-us" xml:lang="en-us">topic</span>的消息会被均匀的分布到多个<span lang="en-us" xml:lang="en-us">part</span>上（随机或根据用户指定的回调函数进行分布），<span lang="en-us" xml:lang="en-us">broker</span>收到发布消息往对应<span lang="en-us" xml:lang="en-us">part</span>的最后一个<span lang="en-us" xml:lang="en-us">segment</span>上添加该消息，当某个<span lang="en-us" xml:lang="en-us">segment</span>上的消息条数达到配置值或消息发布时间超过阈值时，<span lang="en-us" xml:lang="en-us">segment</span>上的消息会被<span lang="en-us" xml:lang="en-us">flush</span>到磁盘，只有<span lang="en-us" xml:lang="en-us">flush</span>到磁盘上的消息订阅者才能订阅到，<span lang="en-us" xml:lang="en-us">segment</span>达到一定的大小后将不会再往该<span lang="en-us" xml:lang="en-us">segment</span>写数据，<span lang="en-us" xml:lang="en-us">broker</span>会创建新的<span lang="en-us" xml:lang="en-us">segment</span>。</span></p>
<p class="MsoNormal" style="line-height:18.9pt;" align="left"><span style="font-family:Helvetica, sans-serif;" lang="en-us" xml:lang="en-us"> </span></p>
<p class="MsoNormal" align="left"><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">5</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">、<span lang="en-us" xml:lang="en-us">Kafka</span>的<span lang="en-us" xml:lang="en-us">delivery guarantee</span></span></strong></p>
<p class="MsoNormal" style="text-indent:21pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';">在<span lang="en-us" xml:lang="en-us">Kafka</span>上，有两个原因可能导致低效：太多的网络请求和过多的字节拷贝。为了提高网络利用率，<span lang="en-us" xml:lang="en-us">Kafka</span>把<span lang="en-us" xml:lang="en-us">message</span>分成一组一组的，每次请求会把一组<span lang="en-us" xml:lang="en-us">message</span>发给相应的<span lang="en-us" xml:lang="en-us">consumer</span>。 此外，为了减少字节拷贝，采用<span lang="en-us" xml:lang="en-us">sendfile</span>系统调用， <span lang="en-us" xml:lang="en-us">sendfile</span>比传统的利用<span lang="en-us" xml:lang="en-us">socket</span>发送文件进行拷贝高效得多。</span></p>
<p class="MsoNormal" style="line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Kafka</span><span style="font-size:12pt;font-family:'宋体';">支持有这几种<span lang="en-us" xml:lang="en-us">delivery guarantee</span>：</span></p>
<p class="MsoNormal" align="left">&lt;!--[if !supportLists]--&gt;<span style="font-size:10pt;font-family:Symbol;" lang="en-us" xml:lang="en-us">·<span style="font-size:7pt;line-height:normal;font-family:'Times New Roman';">        </span></span>&lt;!--[endif]--&gt;<span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">At most once </span><span style="font-size:12pt;font-family:'宋体';">消息可能会丢，但绝不会重复传输</span></p>
<p class="MsoNormal" align="left">&lt;!--[if !supportLists]--&gt;<span style="font-size:10pt;font-family:Symbol;" lang="en-us" xml:lang="en-us">·<span style="font-size:7pt;line-height:normal;font-family:'Times New Roman';">        </span></span>&lt;!--[endif]--&gt;<span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">At least one </span><span style="font-size:12pt;font-family:'宋体';">消息绝不会丢，但可能会重复传输</span></p>
<p class="MsoNormal" align="left">&lt;!--[if !supportLists]--&gt;<span style="font-size:10pt;font-family:Symbol;" lang="en-us" xml:lang="en-us">·<span style="font-size:7pt;line-height:normal;font-family:'Times New Roman';">        </span></span>&lt;!--[endif]--&gt;<span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Exactly once </span><span style="font-size:12pt;font-family:'宋体';">每条消息肯定会被传输一次且仅传输一次，很多时候这是用户所想要的。</span></p>
<p class="MsoNormal" align="left"><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">6</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">、<span lang="en-us" xml:lang="en-us">Kafka</span>多数据中心的数据流拓扑结构</span></strong></p>
<p class="MsoNormal" style="text-indent:21pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';">实际设计中，有时由于安全性问题并不想让一个单个的<span lang="en-us" xml:lang="en-us">Kafka</span>集群系统跨越多个数据中心（数据中心之间可以进行通信），而是想让<span lang="en-us" xml:lang="en-us">Kafka</span>支持多数据中心的数据流拓扑结构。这可通过在集群之间进行镜像或“同步”实现。这个功能非常简单，镜像集群只是作为源集群的数据使用者（<span lang="en-us" xml:lang="en-us">Consumer</span>）的角色运行。这意味着，一个单个的集群就能够将来自多个数据中心的数据集中到一个位置。下面所示是可用于支持批量装载（<span lang="en-us" xml:lang="en-us">batch loads</span>）的多数据中心拓扑结构的一个例子：</span></p>
<p class="MsoNormal" align="left"><br><br><img src="http://dl2.iteye.com/upload/attachment/0110/8903/5c66f8a2-af7a-3670-aaea-1980984e92e4.png" alt=""><br> <br> </p>
<p class="MsoNormal" style="text-indent:21pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';">请注意，在图中上方的两个集群之间不存在通信连接，两者可能大小不同，具有不同数量的节点，而下面部分中的这个单个的集群可以镜像任意数量的源集群。</span></p>
<p class="MsoNormal" style="text-indent:21pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">从以上可以的分析可以看出：<span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Kafka</span>的主要设计理念就是同时提供离线处理和实时处理。根据这一特性，可以使用<span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Storm</span>这种实时流处理系统对消息进行实时在线处理，同时使用<span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Hadoop</span>这种批处理系统进行离线处理，还可以同时将数据实时备份到另一个数据中心，只需要保证这三个操作所使用的<span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Consumer</span>属于不同的<span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Consumer Group</span>即可，因为分属不同<span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Consumer Group</span>的<span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Consumer</span>都将收到<span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Producer</span>发布到<span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Kafka broker</span>的信息。</span><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us"> </span></p>
<p class="MsoNormal" align="left"><span style="font-family:Helvetica, sans-serif;" lang="en-us" xml:lang="en-us"> </span></p>
<p class="MsoNormal" align="left"><span style="font-family:'宋体';">三、</span><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Kafka</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">的<span lang="en-us" xml:lang="en-us">High Availability</span>机制</span></strong></p>
<p class="MsoNormal" align="left"><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">   1</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">、概述：</span></strong></p>
<p class="MsoNormal" style="text-indent:21pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Kafka</span><span style="font-size:12pt;font-family:'宋体';">在<span lang="en-us" xml:lang="en-us">0.8</span>版本以后，开始提供<span lang="en-us" xml:lang="en-us">High Availability</span>机制。在此之前一旦一个或多个<span lang="en-us" xml:lang="en-us">Broker</span>宕机，则宕机期间其上所有<span lang="en-us" xml:lang="en-us">Partition</span>的数据将不可被消费，<span lang="en-us" xml:lang="en-us">Producer</span>也不能再讲数据存储于这些<span lang="en-us" xml:lang="en-us">Partition</span>中。若该<span lang="en-us" xml:lang="en-us">Broker</span>永远不能再恢复，或者产生磁盘故障，则其上数据将丢失。无论<span lang="en-us" xml:lang="en-us">Producer</span>使用同步模式还是异步模式发送数据，都会造成整个系统的可用性降低，因为如果<span lang="en-us" xml:lang="en-us">Producer</span>使用同步模式，则<span lang="en-us" xml:lang="en-us">Producer</span>会在尝试重新发送</span><span lang="en-us" xml:lang="en-us">message.send.max.retries</span><span style="font-size:12pt;font-family:'宋体';">（默认值为<span lang="en-us" xml:lang="en-us">3</span>）次后抛出<span lang="en-us" xml:lang="en-us">Exception</span>，用户可以选择停止发送后续数据或者选择继续选择发送。者、选择继续发送会造成数据的阻塞，选择停止发送会造成本应发往该<span lang="en-us" xml:lang="en-us">Broker</span>的数据的丢失；而如果<span lang="en-us" xml:lang="en-us">Producer</span>使用异步模式，<span lang="en-us" xml:lang="en-us">Producer</span>会尝试重新发送</span><span lang="en-us" xml:lang="en-us">message.send.max.retries</span><span style="font-size:12pt;font-family:'宋体';">（默认值为<span lang="en-us" xml:lang="en-us">3</span>）次后记录该异常并继续发送后续数据，这会造成数据丢失并且用户只能通过日志发现该问题，更为悲惨的是当前<span lang="en-us" xml:lang="en-us">Kafka</span>的<span lang="en-us" xml:lang="en-us">Producer</span>并未对异步模式提供<span lang="en-us" xml:lang="en-us">callback</span>接口。</span></p>
<p class="MsoNormal" style="text-indent:21pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Kafka</span><span style="font-size:12pt;font-family:'宋体';">的<span lang="en-us" xml:lang="en-us">HA</span>机制主要是通过<span lang="en-us" xml:lang="en-us">Data Replication</span>和<span lang="en-us" xml:lang="en-us">Leader Election</span>来保证的<span lang="en-us" xml:lang="en-us">,Data Replication</span>指的是每一个<span lang="en-us" xml:lang="en-us">Partition</span>都可能会有<span lang="en-us" xml:lang="en-us">1</span>个或者多个<span lang="en-us" xml:lang="en-us">Replica</span>，其中有一个<span lang="en-us" xml:lang="en-us">Replica</span>会被推选为<span lang="en-us" xml:lang="en-us">Leader</span>节点，其余落选的为<span lang="en-us" xml:lang="en-us">Follower</span>节点，其中<span lang="en-us" xml:lang="en-us">Leader</span>将会跟踪与其保持同步的<span lang="en-us" xml:lang="en-us">Replica</span>列表，该列表称为<span lang="en-us" xml:lang="en-us">ISR</span>（即<span lang="en-us" xml:lang="en-us">in-sync Replica</span>）。</span></p>
<p class="MsoNormal" style="text-indent:21pt;" align="left"><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us"> </span></strong></p>
<p class="MsoNormal" style="text-indent:21pt;" align="left"><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">2</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">、<span lang="en-us" xml:lang="en-us">Data Replication </span></span></strong></p>
<p class="MsoNormal" style="text-indent:21pt;" align="left"><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">2.1</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">、<span lang="en-us" xml:lang="en-us">Kafka</span>分配<span lang="en-us" xml:lang="en-us">Replica</span>的算法：</span></strong></p>
<p class="MsoNormal" style="text-indent:21pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';">为了更好的做负载均衡，<span lang="en-us" xml:lang="en-us">Kafka</span>尽量将所有的<span lang="en-us" xml:lang="en-us">Partition</span>均匀分配到整个集群上。一个典型的部署方式是一个<span lang="en-us" xml:lang="en-us">Topic</span>的<span lang="en-us" xml:lang="en-us">Partition</span>数量大于<span lang="en-us" xml:lang="en-us">Broker</span>的数量。同时为了提高<span lang="en-us" xml:lang="en-us">Kafka</span>的容错能力，也需要将同一个<span lang="en-us" xml:lang="en-us">Partition</span>的<span lang="en-us" xml:lang="en-us">Replica</span>尽量分散到不同的机器。实际上，如果所有的 <span lang="en-us" xml:lang="en-us">Replica</span>都在同一个<span lang="en-us" xml:lang="en-us">Broker</span>上，那一旦该<span lang="en-us" xml:lang="en-us">Broker</span>宕机，该<span lang="en-us" xml:lang="en-us">Partition</span>的所有<span lang="en-us" xml:lang="en-us">Replica</span>都无法工作，也就达不到<span lang="en-us" xml:lang="en-us">HA</span>的效果。同时，如果某个<span lang="en-us" xml:lang="en-us">Broker</span>宕机了，需要保证它上面的负载可以被均匀的分配到其它幸存的所有<span lang="en-us" xml:lang="en-us">Broker</span>上。</span></p>
<p class="MsoNormal" style="text-indent:21pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Kafka</span><span style="font-size:12pt;font-family:'宋体';">分配<span lang="en-us" xml:lang="en-us">Replica</span>的算法如下（假设总共有<span lang="en-us" xml:lang="en-us">n</span>个<span lang="en-us" xml:lang="en-us">broker</span>）：</span></p>
<ol type="1" start="1"><li class="MsoNormal" style="text-align:left;line-height:20pt;"><span style="font-size:12pt;font-family:'宋体';">将所有<span lang="en-us" xml:lang="en-us">Broker</span>和待分配的<span lang="en-us" xml:lang="en-us">Partition</span>排序 </span></li>
<li class="MsoNormal" style="text-align:left;line-height:20pt;"><span style="font-size:12pt;font-family:'宋体';">将第<span lang="en-us" xml:lang="en-us">i</span>个<span lang="en-us" xml:lang="en-us">Partition</span>分配到第（<span lang="en-us" xml:lang="en-us">i mod n</span>）个<span lang="en-us" xml:lang="en-us">Broker</span>上 </span></li>
<li class="MsoNormal" style="text-align:left;line-height:20pt;"><span style="font-size:12pt;font-family:'宋体';">将第<span lang="en-us" xml:lang="en-us">i</span>个<span lang="en-us" xml:lang="en-us">Partition</span>的第<span lang="en-us" xml:lang="en-us">j</span>个<span lang="en-us" xml:lang="en-us">Replica</span>分配到第（<span lang="en-us" xml:lang="en-us">(i + j) mode n</span>）个<span lang="en-us" xml:lang="en-us">Broker</span>上</span></li>
</ol><p class="MsoNormal" style="text-indent:18pt;" align="left"><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">2.2</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">、<span lang="en-us" xml:lang="en-us">Kafka</span>传播（<span lang="en-us" xml:lang="en-us">Propagate</span>）消息与<span lang="en-us" xml:lang="en-us">ACK</span>的过程</span></strong></p>
<p style="text-indent:21pt;line-height:20pt;"><span lang="en-us" xml:lang="en-us">Producer</span>在发布消息到某个<span lang="en-us" xml:lang="en-us">Partition</span>时，先通过<span lang="en-us" xml:lang="en-us">ZooKeeper</span>找到该<span lang="en-us" xml:lang="en-us">Partition</span>的<span lang="en-us" xml:lang="en-us">Leader</span>，然后无论该<span lang="en-us" xml:lang="en-us">Topic</span>的<span lang="en-us" xml:lang="en-us">Replication Factor</span>为多少（也即该<span lang="en-us" xml:lang="en-us">Partition</span>有多少个<span lang="en-us" xml:lang="en-us">Replica</span>），<span lang="en-us" xml:lang="en-us">Producer</span>只将该消息发送到该<span lang="en-us" xml:lang="en-us">Partition</span>的<span lang="en-us" xml:lang="en-us">Leader</span>，<span lang="en-us" xml:lang="en-us">Leader</span>会将该消息写入其本地<span lang="en-us" xml:lang="en-us">Log</span>。每个<span lang="en-us" xml:lang="en-us">Follower</span>都从<span lang="en-us" xml:lang="en-us">Leader pull</span>数据。这种方式上，<span lang="en-us" xml:lang="en-us">Follower</span>存储的数据顺序与<span lang="en-us" xml:lang="en-us">Leader</span>保持一致。<span lang="en-us" xml:lang="en-us">Follower</span>在收到该消息并写入其<span lang="en-us" xml:lang="en-us">Log</span>后，向<span lang="en-us" xml:lang="en-us">Leader</span>发送<span lang="en-us" xml:lang="en-us"> ACK</span>。一旦<span lang="en-us" xml:lang="en-us">Leader</span>收到了<span lang="en-us" xml:lang="en-us">ISR</span>中的所有<span lang="en-us" xml:lang="en-us">Replica</span>的<span lang="en-us" xml:lang="en-us">ACK</span>，该消息就被认为已经<span lang="en-us" xml:lang="en-us">commit</span>了，<span lang="en-us" xml:lang="en-us">Leader</span>将增加<span lang="en-us" xml:lang="en-us">HW</span>（高水位：表示最近一次提交消息的偏移位置）并且向<span lang="en-us" xml:lang="en-us"> Producer</span>发送<span lang="en-us" xml:lang="en-us">ACK</span>。</p>
<p style="text-indent:21pt;line-height:20pt;">为了提高性能，每个Follower在接收到数据后就立马向Leader发送ACK，而非等到数据写入Log中。因此，对于已经commit的消息，Kafka只能保证它被存于多个Replica的内存中，而不能保证它们被持久化到磁盘中，也就不能完全保证异常发生后该条消息一定能被 Consumer消费。但考虑到这种场景非常少见，可以认为这种方式是在性能和数据持久化上做了一个比较好的平衡。Consumer读消息也是从Leader读取，只有被commit过的消息（offset低于HW的消息）才会暴露给Consumer。</p>
<p class="MsoNormal" style="text-indent:21pt;" align="left"><a name="OLE_LINK2"></a><a name="OLE_LINK1"></a><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">2.3</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">、<span lang="en-us" xml:lang="en-us">Partition Follower</span>和<span lang="en-us" xml:lang="en-us">Leader</span>间的<span lang="en-us" xml:lang="en-us">ISR</span>复制机制</span></strong></p>
<p style="text-indent:21pt;line-height:20pt;">和大部分分布式系统一样，<span lang="en-us" xml:lang="en-us">Kafka</span>处理失败需要明确定义一个<span lang="en-us" xml:lang="en-us">Broker</span>是否<span lang="en-us" xml:lang="en-us">“</span>活着<span lang="en-us" xml:lang="en-us">”</span>。对于<span lang="en-us" xml:lang="en-us">Kafka</span>而言，<span lang="en-us" xml:lang="en-us">Kafka</span>存活包含两个条件，一是它必须维护与<span lang="en-us" xml:lang="en-us">ZooKeeper</span>的<span lang="en-us" xml:lang="en-us">session</span>（这个通过<span lang="en-us" xml:lang="en-us">ZooKeeper</span>的<span lang="en-us" xml:lang="en-us">Heartbeat</span>机制来实现）；二是<span lang="en-us" xml:lang="en-us">Follower</span>必须能够及时将<span lang="en-us" xml:lang="en-us"> Leader</span>的消息复制过来，不能<span lang="en-us" xml:lang="en-us">“</span>落后太多<span lang="en-us" xml:lang="en-us">”</span>。<span lang="en-us" xml:lang="en-us">Leader</span>会跟踪与其保持同步的<span lang="en-us" xml:lang="en-us">Replica</span>列表，即上面说到的<span lang="en-us" xml:lang="en-us">ISR</span>，如果一个<span lang="en-us" xml:lang="en-us">Follower</span>宕机，或者落后太多，<span lang="en-us" xml:lang="en-us">Leader</span>将把它从<span lang="en-us" xml:lang="en-us">ISR</span>中移除。这里所描述的<span lang="en-us" xml:lang="en-us">“</span>落后太多<span lang="en-us" xml:lang="en-us">”</span>指<span lang="en-us" xml:lang="en-us">Follower</span>复制的消息落后于<span lang="en-us" xml:lang="en-us">Leader</span>后的条数超过预定值（该值可在<span lang="en-us" xml:lang="en-us">$KAFKA_HOME/config/server.properties</span>中通过<code><span lang="en-us" xml:lang="en-us">replica.lag.max.messages</span></code>配置，其默认值是<span lang="en-us" xml:lang="en-us">4000</span>）或者<span lang="en-us" xml:lang="en-us">Follower</span>超过一定时间（该值可在<span lang="en-us" xml:lang="en-us">$KAFKA_HOME/config/server.properties</span>中通过<code><span lang="en-us" xml:lang="en-us">replica.lag.time.max.ms</span></code>来配置，其默认值是<span lang="en-us" xml:lang="en-us">10000</span>）未向<span lang="en-us" xml:lang="en-us">Leader</span>发送<span lang="en-us" xml:lang="en-us">fetch</span>请求。</p>
<p style="text-indent:21pt;line-height:20pt;"><span lang="en-us" xml:lang="en-us">Kafka</span>的复制机制既不是完全的同步复制，也不是单纯的异步复制。事实上，完全同步复制要求所有能工作的<span lang="en-us" xml:lang="en-us">Follower</span>都复制完，这条消息才会被认为<span lang="en-us" xml:lang="en-us">commit</span>，这种复制方式极大的影响了吞吐率<span lang="en-us" xml:lang="en-us">,</span>而异步复制方式下，<span lang="en-us" xml:lang="en-us">Follower</span>异步的从<span lang="en-us" xml:lang="en-us"> Leader</span>复制数据，数据只要被<span lang="en-us" xml:lang="en-us">Leader</span>写入<span lang="en-us" xml:lang="en-us">log</span>就被认为已经<span lang="en-us" xml:lang="en-us">commit</span>，这种情况下如果<span lang="en-us" xml:lang="en-us">Follower</span>都复制完都落后于<span lang="en-us" xml:lang="en-us">Leader</span>，而如果<span lang="en-us" xml:lang="en-us">Leader</span>突然宕机，则会丢失数据。而<span lang="en-us" xml:lang="en-us">Kafka</span>的这种使用<span lang="en-us" xml:lang="en-us">ISR</span>的方式则很好的均衡了确保数据不丢失以及吞吐率。<span lang="en-us" xml:lang="en-us">Follower</span>可以批量的从<span lang="en-us" xml:lang="en-us"> Leader</span>复制数据，这样极大的提高复制性能（批量写磁盘），极大减少了<span lang="en-us" xml:lang="en-us">Follower</span>与<span lang="en-us" xml:lang="en-us">Leader</span>的差距。</p>
<p style="text-indent:21pt;line-height:20pt;">需要说明的是，<span lang="en-us" xml:lang="en-us">Kafka</span>只解决<span lang="en-us" xml:lang="en-us">fail/recover</span>，不处理<span lang="en-us" xml:lang="en-us">“Byzantine”</span>（<span lang="en-us" xml:lang="en-us">“</span>拜占庭<span lang="en-us" xml:lang="en-us">”</span>）问题。一条消息只有被<span lang="en-us" xml:lang="en-us">ISR</span>里的所有<span lang="en-us" xml:lang="en-us"> Follower</span>都从<span lang="en-us" xml:lang="en-us">Leader</span>复制过去才会被认为已提交。这样就避免了部分数据被写进了<span lang="en-us" xml:lang="en-us">Leader</span>，还没来得及被任何<span lang="en-us" xml:lang="en-us">Follower</span>复制就宕机了，而造成数据丢失（<span lang="en-us" xml:lang="en-us">Consumer</span>无法消费这些数据）。而对于<span lang="en-us" xml:lang="en-us">Producer</span>而言，它可以选择是否等待消息<span lang="en-us" xml:lang="en-us">commit</span>，这可以通过<code><span lang="en-us" xml:lang="en-us">request.required.acks</span></code>来设置<span lang="en-us" xml:lang="en-us">,</span>这种机制确保了只要<span lang="en-us" xml:lang="en-us">ISR</span>有一个或以上的<span lang="en-us" xml:lang="en-us">Follower</span>，一条被<span lang="en-us" xml:lang="en-us">commit</span>的消息就不会丢失。</p>
<p class="MsoNormal" style="text-indent:21pt;" align="left"><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">2.4</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">、<span lang="en-us" xml:lang="en-us">Follower</span>从<span lang="en-us" xml:lang="en-us">Leader Fetch</span>数据</span></strong></p>
<p><span lang="en-us" xml:lang="en-us">Follower</span>通过向<span lang="en-us" xml:lang="en-us">Leader</span>发送<span lang="en-us" xml:lang="en-us">FetchRequest</span>获取消息，<span lang="en-us" xml:lang="en-us">FetchRequest</span>结构如下</p>
<p><br><img src="http://dl2.iteye.com/upload/attachment/0110/8905/fce1d496-5511-3c3e-94fc-5106a3b48a02.png" alt=""><br> </p>
<p style="text-indent:21pt;">从<span lang="en-us" xml:lang="en-us">FetchRequest</span>的结构可以看出，每个<span lang="en-us" xml:lang="en-us">Fetch</span>请求都要指定最大等待时间和最小获取字节数，以及由<span lang="en-us" xml:lang="en-us">TopicAndPartition </span>和<span lang="en-us" xml:lang="en-us">PartitionFetchInfo</span>构成的<span lang="en-us" xml:lang="en-us">Map</span>。实际上，<span lang="en-us" xml:lang="en-us">Follower</span>从<span lang="en-us" xml:lang="en-us">Leader Fetch</span>数据和<span lang="en-us" xml:lang="en-us">Consumer</span>从<span lang="en-us" xml:lang="en-us">Broker Fetch</span>数据，都是通过<span lang="en-us" xml:lang="en-us">FetchRequest</span>请求完成，所以在<span lang="en-us" xml:lang="en-us">FetchRequest</span>结构中，其中一个字段是<span lang="en-us" xml:lang="en-us">clientID</span>，并且其默认值是<span lang="en-us" xml:lang="en-us"> ConsumerConfig.DefaultClientId</span>。<span lang="en-us" xml:lang="en-us">Leader</span>收到<span lang="en-us" xml:lang="en-us">Fetch</span>请求后，<span lang="en-us" xml:lang="en-us">Kafka</span>通过<span lang="en-us" xml:lang="en-us">KafkaApis.handleFetchRequest</span>响应该请求，响应过程如下：</p>
<ol type="1" start="1"><li class="MsoNormal" style="text-align:left;">
<span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">replicaManager</span><span style="font-size:12pt;font-family:'宋体';">根据请求读出数据存入<span lang="en-us" xml:lang="en-us">dataRead</span>中。</span>
</li>
<li class="MsoNormal" style="text-align:left;"><span style="font-size:12pt;font-family:'宋体';">如果该请求来自<span lang="en-us" xml:lang="en-us">Follower</span>则更新其相应的<span lang="en-us" xml:lang="en-us">LEO</span>（<span lang="en-us" xml:lang="en-us">log end offset</span>）以及相应<span lang="en-us" xml:lang="en-us">Partition</span>的<span lang="en-us" xml:lang="en-us">High Watermark</span></span></li>
<li class="MsoNormal" style="text-align:left;"><span style="font-size:12pt;font-family:'宋体';">根据<span lang="en-us" xml:lang="en-us">dataRead</span>算出可读消息长度（单位为字节）并存入<span lang="en-us" xml:lang="en-us">bytesReadable</span>中。</span></li>
<li class="MsoNormal" style="text-align:left;"><span style="font-size:12pt;font-family:'宋体';">满足下面<span lang="en-us" xml:lang="en-us">4</span>个条件中的<span lang="en-us" xml:lang="en-us">1</span>个，则立即将相应的数据返回 </span></li>
</ol><ul type="circle"><li class="MsoNormal" style="text-align:left;">
<span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Fetch</span><span style="font-size:12pt;font-family:'宋体';">请求不希望等待，即<span lang="en-us" xml:lang="en-us">fetchRequest.macWait &lt;= 0</span></span>
</li>
<li class="MsoNormal" style="text-align:left;">
<span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">Fetch</span><span style="font-size:12pt;font-family:'宋体';">请求不要求一定能取到消息，即<span lang="en-us" xml:lang="en-us">fetchRequest.numPartitions &lt;= 0</span>，也即<span lang="en-us" xml:lang="en-us">requestInfo</span>为空</span>
</li>
<li class="MsoNormal" style="text-align:left;"><span style="font-size:12pt;font-family:'宋体';">有足够的数据可供返回，即<span lang="en-us" xml:lang="en-us">bytesReadable &gt;= fetchRequest.minBytes</span></span></li>
<li class="MsoNormal" style="text-align:left;"><span style="font-size:12pt;font-family:'宋体';">读取数据时发生异常</span></li>
<li class="MsoNormal" style="text-align:left;"><span style="font-size:12pt;font-family:'宋体';">若不满足以上<span lang="en-us" xml:lang="en-us">4</span>个条件，<span lang="en-us" xml:lang="en-us">FetchRequest</span>将不会立即返回，并将该请求封装成<span lang="en-us" xml:lang="en-us">DelayedFetch</span>。检查该<span lang="en-us" xml:lang="en-us">DeplayedFetch</span>是否满足，若满足则返回请求，否则将该请求加入<span lang="en-us" xml:lang="en-us">Watch</span>列表</span></li>
</ul><p><span lang="en-us" xml:lang="en-us">Leader</span>通过以<span lang="en-us" xml:lang="en-us">FetchResponse</span>的形式将消息返回给<span lang="en-us" xml:lang="en-us">Follower</span>，<span lang="en-us" xml:lang="en-us">FetchResponse</span>结构如下</p>
<p><br><img src="http://dl2.iteye.com/upload/attachment/0110/8907/09b2a446-85fc-3e83-9a27-91b269774a4a.png" alt=""><br> </p>
<p class="MsoNormal" style="text-indent:21pt;" align="left"><a name="OLE_LINK3"></a><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">2.5</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">、<span lang="en-us" xml:lang="en-us">Partition</span>的重新分配</span></strong></p>
<p style="text-indent:18pt;">管理工具发出重新分配<span lang="en-us" xml:lang="en-us">Partition</span>请求后，会将相应信息写到<code><span lang="en-us" xml:lang="en-us">/admin/reassign_partitions</span></code>上，而该操作会触发<span lang="en-us" xml:lang="en-us">ReassignedPartitionsIsrChangeListener</span>，从而通过执行回调函数<span lang="en-us" xml:lang="en-us">KafkaController.onPartitionReassignment</span>来完成<span lang="en-us" xml:lang="en-us">Partition</span>的重新分配，主要过程是将<span lang="en-us" xml:lang="en-us">ZooKeeper</span>中的<span lang="en-us" xml:lang="en-us">AR</span>（<span lang="en-us" xml:lang="en-us">Current Assigned Replicas</span>）更新为<span lang="en-us" xml:lang="en-us">OAR</span>（<span lang="en-us" xml:lang="en-us">Original list of replicas for partition</span>）<span lang="en-us" xml:lang="en-us"> + RAR</span>（<span lang="en-us" xml:lang="en-us">Reassigned replicas</span>）。</p>
<p class="MsoNormal" style="text-indent:21pt;" align="left"><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">2.6</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">、<span lang="en-us" xml:lang="en-us">Replication</span>工具</span></strong></p>
<p><code><span lang="en-us" xml:lang="en-us">1</span>、<span lang="en-us" xml:lang="en-us">Topic Tool</span></code></p>
<p><code>在<span lang="en-us" xml:lang="en-us">$KAFKA_HOME/bin/kafka-topics.sh</span></code>，该工具可用于创建、删除、修改、查看某个<span lang="en-us" xml:lang="en-us">Topic</span>的相关配置信息，也可用于列出所有<span lang="en-us" xml:lang="en-us">Topic</span>。</p>
<p><span lang="en-us" xml:lang="en-us">2</span>、<span lang="en-us" xml:lang="en-us">Replica Verification Tool</span></p>
<p><code>在<span lang="en-us" xml:lang="en-us">$KAFKA_HOME/bin/kafka-replica-verification.sh</span></code>，该工具用来验证所指定的一个或多个<span lang="en-us" xml:lang="en-us">Topic</span>下每个<span lang="en-us" xml:lang="en-us">Partition</span>对应的所有<span lang="en-us" xml:lang="en-us">Replica</span>是否都同步。可通过<code><span lang="en-us" xml:lang="en-us">topic-white-list</span></code>这一参数指定所需要验证的所有<span lang="en-us" xml:lang="en-us">Topic</span>，支持正则表达式。</p>
<p><span lang="en-us" xml:lang="en-us">3</span>、<span lang="en-us" xml:lang="en-us">Kafka Reassign Partitions Tool</span></p>
<p style="text-indent:21pt;">该工具的设计目标与后面即将提到的<span lang="en-us" xml:lang="en-us">Preferred Replica Leader Election Tool</span>有些类似，都旨在促进<span lang="en-us" xml:lang="en-us">Kafka</span>集群的负载均衡。不同的是，<span lang="en-us" xml:lang="en-us">Preferred Replica Leader Election</span>只能在<span lang="en-us" xml:lang="en-us">Partition</span>的<span lang="en-us" xml:lang="en-us">AR</span>范围内调整其<span lang="en-us" xml:lang="en-us">Leader</span>，使<span lang="en-us" xml:lang="en-us">Leader</span>分布均匀，而该工具还可以调整<span lang="en-us" xml:lang="en-us">Partition</span>的<span lang="en-us" xml:lang="en-us">AR</span>，<span lang="en-us" xml:lang="en-us">Follower</span>需要从<span lang="en-us" xml:lang="en-us">Leader Fetch</span>数据以保持与<span lang="en-us" xml:lang="en-us">Leader</span>同步，所以仅仅保持<span lang="en-us" xml:lang="en-us">Leader</span>分布的平衡对整个集群的负载均衡来说是不够的。另外，生产环境下，随着负载的增大，可能需要给<span lang="en-us" xml:lang="en-us">Kafka</span>集群扩容，向<span lang="en-us" xml:lang="en-us">Kafka</span>集群中增加<span lang="en-us" xml:lang="en-us">Broker</span>非常简单方便，但是对于已有的<span lang="en-us" xml:lang="en-us">Topic</span>，并不会自动将其<span lang="en-us" xml:lang="en-us">Partition</span>迁移到新加入的<span lang="en-us" xml:lang="en-us">Broker</span>上，此时可用该工具达到此目的。</p>
<p style="text-indent:21pt;">某些场景下，实际负载可能远小于最初预期负载，此时可用该工具将分布在整个集群上的<span lang="en-us" xml:lang="en-us">Partition</span>重装分配到某些机器上，然后可以停止不需要的<span lang="en-us" xml:lang="en-us">Broker</span>从而实现节约资源的目的。需要说明的是，该工具不仅可以调整<span lang="en-us" xml:lang="en-us">Partition</span>的<span lang="en-us" xml:lang="en-us">AR</span>位置，还可调整其<span lang="en-us" xml:lang="en-us">AR</span>数量，即改变该<span lang="en-us" xml:lang="en-us">Topic</span>的<span lang="en-us" xml:lang="en-us">replication factor</span>。该工具有三种使用模式：<span lang="en-us" xml:lang="en-us">generate</span>模式，给定需要重新分配的<span lang="en-us" xml:lang="en-us">Topic</span>，自动生成<span lang="en-us" xml:lang="en-us">reassign plan</span>（并不执行）；<span lang="en-us" xml:lang="en-us">execute</span>模式，根据指定的<span lang="en-us" xml:lang="en-us">reassign plan</span>重新分配<span lang="en-us" xml:lang="en-us">Partition</span>；<span lang="en-us" xml:lang="en-us">verify</span>模式，验证重新分配。</p>
<p><span lang="en-us" xml:lang="en-us">Kafka Replication</span>的数据流如下图所示：</p>
<p class="MsoNormal" style="text-indent:21pt;" align="left"><br><img src="http://dl2.iteye.com/upload/attachment/0110/8909/62755b29-4919-3357-ae23-c6892833c5ad.jpg" alt=""><br> </p>
<p class="MsoNormal" align="left"><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us"> </span></strong></p>
<p class="MsoNormal" align="left"><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">3</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">、<span lang="en-us" xml:lang="en-us">Leader Election </span></span></strong></p>
<p class="MsoNormal" style="text-indent:21pt;line-height:20pt;" align="left"><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">3.1</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">、概述</span></strong></p>
<p class="MsoNormal" style="text-indent:21pt;line-height:20pt;" align="left"><span style="font-size:12pt;font-family:'宋体';">引入<span lang="en-us" xml:lang="en-us">Replication</span>之后，同一个<span lang="en-us" xml:lang="en-us">Partition</span>可能会有多个<span lang="en-us" xml:lang="en-us">Replica</span>，这时实际上需要从这些<span lang="en-us" xml:lang="en-us">Replica</span>中推选出一个<span lang="en-us" xml:lang="en-us">Leader</span>，如果没有一个<span lang="en-us" xml:lang="en-us">Leader</span>，所有<span lang="en-us" xml:lang="en-us">Replica</span>都可同时读<span lang="en-us" xml:lang="en-us">/</span>写数据，那就需要保证多个<span lang="en-us" xml:lang="en-us">Replica</span>之间互相（<span lang="en-us" xml:lang="en-us">N×N</span>条通路）同步数据，数据的一致性和有序性非常难保证，大大增加了<span lang="en-us" xml:lang="en-us">Replication</span>实现的复杂性，同时也增加了出现异常的几率，而引入<span lang="en-us" xml:lang="en-us">Leader</span>后，只有<span lang="en-us" xml:lang="en-us">Leader</span>负责数据读写（即<span lang="en-us" xml:lang="en-us">Leader</span>负责与<span lang="en-us" xml:lang="en-us">Producer</span>和<span lang="en-us" xml:lang="en-us">Consumer</span>交互），而<span lang="en-us" xml:lang="en-us">Follower</span>负责向<span lang="en-us" xml:lang="en-us">Leader</span>顺序<span lang="en-us" xml:lang="en-us">Fetch</span>数据（<span lang="en-us" xml:lang="en-us">N</span>条通路），这样的设计使得系统更加简单且高效。</span></p>
<p class="MsoNormal" style="text-indent:21pt;line-height:20pt;" align="left"><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">3.2</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">、<span lang="en-us" xml:lang="en-us">Kafka</span>借助<span lang="en-us" xml:lang="en-us">Zookeeper</span>和<span lang="en-us" xml:lang="en-us">ISR</span>选择<span lang="en-us" xml:lang="en-us">Leader</span></span></strong></p>
<p style="text-indent:21pt;line-height:20pt;"><span lang="en-us" xml:lang="en-us">Kafka</span>中，一个简单直观的选择<span lang="en-us" xml:lang="en-us">Leader</span>的方案是所有<span lang="en-us" xml:lang="en-us">Follower</span>都在<span lang="en-us" xml:lang="en-us">ZooKeeper</span>上设置一个<span lang="en-us" xml:lang="en-us">Watch</span>，一旦<span lang="en-us" xml:lang="en-us">Leader</span>宕机，其对应的<span lang="en-us" xml:lang="en-us">ephemeral znode</span>会自动删除，此时所有<span lang="en-us" xml:lang="en-us">Follower</span>都尝试创建该节点，而创建成功者（<span lang="en-us" xml:lang="en-us">ZooKeeper</span>保证只有一个能创建成功）即是新的<span lang="en-us" xml:lang="en-us">Leader</span>，其它<span lang="en-us" xml:lang="en-us">Replica</span>即为<span lang="en-us" xml:lang="en-us">Follower</span>，但由于<span lang="en-us" xml:lang="en-us">Follower</span>可能落后<span lang="en-us" xml:lang="en-us">Leader</span>许多或者<span lang="en-us" xml:lang="en-us">crash</span>了，所以必须确保选择<span lang="en-us" xml:lang="en-us">“</span>最新<span lang="en-us" xml:lang="en-us">”</span>的<span lang="en-us" xml:lang="en-us">Follower</span>作为新的<span lang="en-us" xml:lang="en-us">Leader</span>。一个基本的原则就是，如果<span lang="en-us" xml:lang="en-us">Leader</span>不在了，新的<span lang="en-us" xml:lang="en-us">Leader</span>必须拥有原来的<span lang="en-us" xml:lang="en-us">Leader commit</span>过的所有消息。这就需要作一个折衷，如果<span lang="en-us" xml:lang="en-us">Leader</span>在标明一条消息被<span lang="en-us" xml:lang="en-us">commit</span>前等待更多的<span lang="en-us" xml:lang="en-us">Follower</span>确认，那在它宕机之后就有更多的<span lang="en-us" xml:lang="en-us">Follower</span>可以作为新的<span lang="en-us" xml:lang="en-us">Leader</span>，但这也会造成吞吐率的下降。<span lang="en-us" xml:lang="en-us">  </span></p>
<p style="text-indent:21pt;line-height:20pt;">一种非常常用的选举<span lang="en-us" xml:lang="en-us">leader</span>的方式是<span lang="en-us" xml:lang="en-us">“Majority Vote”</span>（<span lang="en-us" xml:lang="en-us">“</span>少数服从多数<span lang="en-us" xml:lang="en-us">”</span>），但<span lang="en-us" xml:lang="en-us">Kafka</span>并未采用这种方式。这种模式下，如果我们有<span lang="en-us" xml:lang="en-us">2f+1</span>个<span lang="en-us" xml:lang="en-us">Replica</span>（包含<span lang="en-us" xml:lang="en-us">Leader</span>和<span lang="en-us" xml:lang="en-us">Follower</span>），那在<span lang="en-us" xml:lang="en-us">commit</span>之前必须保证有<span lang="en-us" xml:lang="en-us">f+1</span>个<span lang="en-us" xml:lang="en-us">Replica</span>复制完消息，为了保证正确选出新的<span lang="en-us" xml:lang="en-us">Leader</span>，<span lang="en-us" xml:lang="en-us">fail</span>的<span lang="en-us" xml:lang="en-us">Replica</span>不能超过<span lang="en-us" xml:lang="en-us">f</span>个。因为在剩下的任意<span lang="en-us" xml:lang="en-us">f+1</span>个<span lang="en-us" xml:lang="en-us">Replica</span>里，至少有一个<span lang="en-us" xml:lang="en-us">Replica</span>包含有最新的所有消息。这种方式有个很大的优势，系统的<span lang="en-us" xml:lang="en-us">latency</span>只取决于最快的几个<span lang="en-us" xml:lang="en-us">Broker</span>，而非最慢那个<span lang="en-us" xml:lang="en-us">(</span>即只要最快的<span lang="en-us" xml:lang="en-us">n+1</span>个有数据了，就能选出一个<span lang="en-us" xml:lang="en-us">Leader</span>来<span lang="en-us" xml:lang="en-us">)</span>。但<span lang="en-us" xml:lang="en-us">Majority Vote</span>也有一些劣势，为了保证<span lang="en-us" xml:lang="en-us">Leader Election</span>的正常进行，它所能容忍的<span lang="en-us" xml:lang="en-us">fail</span>的<span lang="en-us" xml:lang="en-us">follower</span>个数比较少。如果要容忍<span lang="en-us" xml:lang="en-us">2</span>个<span lang="en-us" xml:lang="en-us">follower</span>挂掉，必须要有<span lang="en-us" xml:lang="en-us">5</span>个以上的<span lang="en-us" xml:lang="en-us">Replica</span>，如果要容忍<span lang="en-us" xml:lang="en-us">3</span>个<span lang="en-us" xml:lang="en-us">Follower</span>挂掉，必须要有<span lang="en-us" xml:lang="en-us">7</span>个以上的<span lang="en-us" xml:lang="en-us">Replica</span>。换句话说，在生产环境下为了保证较高的容错程度，必须要有大量的<span lang="en-us" xml:lang="en-us">Replica</span>，而大量的<span lang="en-us" xml:lang="en-us">Replica</span>又会在大数据量下导致性能的急剧下降。这就是这种算法更多用在<span lang="en-us" xml:lang="en-us"><a href="http://zookeeper.apache.org/" rel="nofollow"><span style="color:#000000;">ZooKeeper</span></a></span>这种共享集群配置的系统中而很少在需要存储大量数据的系统中使用的原因。例如<span lang="en-us" xml:lang="en-us">HDFS</span>的<span lang="en-us" xml:lang="en-us">HA Feature</span>是基于<span lang="en-us" xml:lang="en-us"><a href="http://blog.cloudera.com/blog/2012/10/quorum-based-journaling-in-cdh4-1" rel="nofollow"><span style="color:#000000;">majority-vote-based journal</span></a></span>，但是它的数据存储并没有使用这种方式。</p>
<p style="text-indent:21pt;line-height:20pt;"><span lang="en-us" xml:lang="en-us">Kafka0.8</span>以后增加了一个<span lang="en-us" xml:lang="en-us">Controller</span>概念，它在所有<span lang="en-us" xml:lang="en-us">broker</span>中选出一个<span lang="en-us" xml:lang="en-us">controller</span>，所有<span lang="en-us" xml:lang="en-us">Partition</span>的<span lang="en-us" xml:lang="en-us">Leader</span>选举都由<span lang="en-us" xml:lang="en-us">controller</span>决定，<span lang="en-us" xml:lang="en-us">controller</span>会将<span lang="en-us" xml:lang="en-us">Leader</span>的改变直接通过<span lang="en-us" xml:lang="en-us">RPC</span>的方式（比<span lang="en-us" xml:lang="en-us">ZooKeeper Queue</span>的方式更高效）通知需为为此作为响应的<span lang="en-us" xml:lang="en-us">Broker</span>。同时<span lang="en-us" xml:lang="en-us">controller</span>也负责增删<span lang="en-us" xml:lang="en-us">Topic</span>以及<span lang="en-us" xml:lang="en-us">Replica</span>的重新分配。前面提到<span lang="en-us" xml:lang="en-us">Kafka</span>在<span lang="en-us" xml:lang="en-us">ZooKeeper</span>中动态维护了一个<span lang="en-us" xml:lang="en-us">ISR</span>（<span lang="en-us" xml:lang="en-us">in-sync replicas</span>），这个<span lang="en-us" xml:lang="en-us">ISR</span>里的所有<span lang="en-us" xml:lang="en-us">Replica</span>都跟上了<span lang="en-us" xml:lang="en-us">leader</span>，只有<span lang="en-us" xml:lang="en-us">ISR</span>里的成员才有被选为<span lang="en-us" xml:lang="en-us">Leader</span>的可能。在这种模式下，对于<span lang="en-us" xml:lang="en-us">f+1</span>个<span lang="en-us" xml:lang="en-us">Replica</span>，一个<span lang="en-us" xml:lang="en-us">Partition</span>能在保证不丢失已经<span lang="en-us" xml:lang="en-us">commit</span>的消息的前提下容忍<span lang="en-us" xml:lang="en-us">f</span>个<span lang="en-us" xml:lang="en-us">Replica</span>的失败。在大多数使用场景中，这种模式是非常有利的。事实上，为了容忍<span lang="en-us" xml:lang="en-us">f</span>个<span lang="en-us" xml:lang="en-us">Replica</span>的失败，<span lang="en-us" xml:lang="en-us">Majority Vote</span>和<span lang="en-us" xml:lang="en-us">ISR</span>在<span lang="en-us" xml:lang="en-us">commit</span>前需要等待的<span lang="en-us" xml:lang="en-us">Replica</span>数量是一样的，但是<span lang="en-us" xml:lang="en-us">ISR</span>需要的总的<span lang="en-us" xml:lang="en-us">Replica</span>的个数几乎是<span lang="en-us" xml:lang="en-us">Majority Vote</span>的一半。虽然<span lang="en-us" xml:lang="en-us">Majority Vote</span>与<span lang="en-us" xml:lang="en-us">ISR</span>相比有不需等待最慢的<span lang="en-us" xml:lang="en-us">Broker</span>这一优势，但是<span lang="en-us" xml:lang="en-us">Kafka</span>官方认为<span lang="en-us" xml:lang="en-us">Kafka</span>可以通过<span lang="en-us" xml:lang="en-us">Producer</span>选择是否被<span lang="en-us" xml:lang="en-us">commit</span>阻塞来改善这一问题，并且节省下来的<span lang="en-us" xml:lang="en-us">Replica</span>和磁盘使得<span lang="en-us" xml:lang="en-us">ISR</span>模式仍然值得。</p>
<p class="MsoNormal" style="text-indent:21pt;line-height:20pt;" align="left"><strong><span style="font-size:12pt;font-family:'宋体';" lang="en-us" xml:lang="en-us">3.3</span></strong><strong><span style="font-size:12pt;font-family:'宋体';">、<span lang="en-us" xml:lang="en-us">Preferred Replica Leader Election Tool</span></span></strong></p>
<p style="text-indent:21pt;line-height:20pt;">有了<span lang="en-us" xml:lang="en-us">Replication</span>机制后，每个<span lang="en-us" xml:lang="en-us">Partition</span>可能有多个备份。某个<span lang="en-us" xml:lang="en-us">Partition</span>的<span lang="en-us" xml:lang="en-us">Replica</span>列表叫作<span lang="en-us" xml:lang="en-us"> AR</span>（<span lang="en-us" xml:lang="en-us">Assigned Replicas</span>），<span lang="en-us" xml:lang="en-us">AR</span>中的第一个<span lang="en-us" xml:lang="en-us">Replica</span>即为<span lang="en-us" xml:lang="en-us">“Preferred Replica</span>“。创建一个新的<span lang="en-us" xml:lang="en-us">Topic</span>或者给已有<span lang="en-us" xml:lang="en-us">Topic</span>增加<span lang="en-us" xml:lang="en-us">Partition</span>时，<span lang="en-us" xml:lang="en-us">Kafka</span>保证<span lang="en-us" xml:lang="en-us">Preferred Replica</span>被均匀分布到集群中的所有<span lang="en-us" xml:lang="en-us">Broker</span>上。理想情况下，<span lang="en-us" xml:lang="en-us">Preferred Replica</span>会被选为<span lang="en-us" xml:lang="en-us">Leader</span>。以上两点保证了所有<span lang="en-us" xml:lang="en-us">Partition</span>的<span lang="en-us" xml:lang="en-us">Leader</span>被均匀分布到了集群当中，这一点非常重要，因为所有的读写操作都由<span lang="en-us" xml:lang="en-us">Leader</span>完成，若<span lang="en-us" xml:lang="en-us">Leader</span>分布过于集中，会造成集群负载不均衡。但是，随着集群的运行，该平衡可能会因为<span lang="en-us" xml:lang="en-us">Broker</span>的宕机而被打破，该工具就是用来帮助恢复<span lang="en-us" xml:lang="en-us">Leader</span>分配的平衡。</p>
<p style="text-indent:21pt;line-height:20pt;">事实上，每个<span lang="en-us" xml:lang="en-us">Topic</span>从失败中恢复过来后，它默认会被设置为<span lang="en-us" xml:lang="en-us">Follower</span>角色，除非某个<span lang="en-us" xml:lang="en-us">Partition</span>的<span lang="en-us" xml:lang="en-us">Replica</span>全部宕机，而当前<span lang="en-us" xml:lang="en-us"> Broker</span>是该<span lang="en-us" xml:lang="en-us">Partition</span>的<span lang="en-us" xml:lang="en-us">AR</span>中第一个恢复回来的<span lang="en-us" xml:lang="en-us">Replica</span>。因此，某个<span lang="en-us" xml:lang="en-us">Partition</span>的<span lang="en-us" xml:lang="en-us">Leader</span>（<span lang="en-us" xml:lang="en-us">Preferred Replica</span>）宕机并恢复后，它很可能不再是该<span lang="en-us" xml:lang="en-us">Partition</span>的<span lang="en-us" xml:lang="en-us">Leader</span>，但仍然是<span lang="en-us" xml:lang="en-us">Preferred Replica</span>。</p>
<p><em><span style="font-family:'宋体';">其用法为：</span></em></p>
<p><span lang="en-us" xml:lang="en-us">$KAFKA_HOME/bin/kafka-preferred-replica-election.sh --zookeeper localhost:2181</span></p>
<p>在包含<span lang="en-us" xml:lang="en-us">8</span>个<span lang="en-us" xml:lang="en-us">Broker</span>的<span lang="en-us" xml:lang="en-us">Kafka</span>集群上，创建<span lang="en-us" xml:lang="en-us">1</span>个名为<span lang="en-us" xml:lang="en-us">topic1</span>，<span lang="en-us" xml:lang="en-us">replication-factor</span>为<span lang="en-us" xml:lang="en-us">3</span>，<span lang="en-us" xml:lang="en-us">Partition</span>数为<span lang="en-us" xml:lang="en-us">8</span>的<span lang="en-us" xml:lang="en-us">Topic</span>，使用如下命令查看其<span lang="en-us" xml:lang="en-us">Partition/Replica</span>分布。</p>
<pre><span lang="en-us" xml:lang="en-us">$KAFKA_HOME/bin/kafka-topics.sh --describe --topic topic1 --zookeeper localhost:2181</span></pre>
<p>查询结果如下图所示，从图中可以看到，<span lang="en-us" xml:lang="en-us">Kafka</span>将所有<span lang="en-us" xml:lang="en-us">Replica</span>均匀分布到了整个集群，并且<span lang="en-us" xml:lang="en-us">Leader</span>也均匀分布。</p>
<p><br><img src="http://dl2.iteye.com/upload/attachment/0110/8911/d95c1a1a-f2c0-33fa-bc06-6cba7f9b6894.png" alt=""><br> </p>
<p>手动停止部分<span lang="en-us" xml:lang="en-us">Broker</span>，<span lang="en-us" xml:lang="en-us">topic1</span>的<span lang="en-us" xml:lang="en-us">Partition/Replica</span>分布如下图所示。从图中可以看到，由于<span lang="en-us" xml:lang="en-us">Broker 1/2/4</span>都被停止，<span lang="en-us" xml:lang="en-us">Partition 0</span>的<span lang="en-us" xml:lang="en-us">Leader</span>由原来的<span lang="en-us" xml:lang="en-us">1</span>变为<span lang="en-us" xml:lang="en-us">3</span>，<span lang="en-us" xml:lang="en-us">Partition 1</span>的<span lang="en-us" xml:lang="en-us">Leader</span>由原来的<span lang="en-us" xml:lang="en-us">2</span>变为<span lang="en-us" xml:lang="en-us">5</span>，<span lang="en-us" xml:lang="en-us">Partition 2</span>的<span lang="en-us" xml:lang="en-us">Leader</span>由原来的<span lang="en-us" xml:lang="en-us">3</span>变为<span lang="en-us" xml:lang="en-us">6</span>，<span lang="en-us" xml:lang="en-us">Partition 3</span>的<span lang="en-us" xml:lang="en-us">Leader</span>由原来的<span lang="en-us" xml:lang="en-us">4</span>变为<span lang="en-us" xml:lang="en-us">7</span>。</p>
<p><br><img src="http://dl2.iteye.com/upload/attachment/0110/8913/3136eca3-045c-3a67-a49d-62180eb76585.png" alt=""><br> </p>
<p>再重新启动<span lang="en-us" xml:lang="en-us">ID</span>为<span lang="en-us" xml:lang="en-us">1</span>的<span lang="en-us" xml:lang="en-us">Broker</span>，<span lang="en-us" xml:lang="en-us">topic1</span>的<span lang="en-us" xml:lang="en-us">Partition/Replica</span>分布如下。可以看到，虽然<span lang="en-us" xml:lang="en-us">Broker 1</span>已经启动（<span lang="en-us" xml:lang="en-us">Partition 0</span>和<span lang="en-us" xml:lang="en-us">Partition5</span>的<span lang="en-us" xml:lang="en-us">ISR</span>中有<span lang="en-us" xml:lang="en-us">1</span>），但是<span lang="en-us" xml:lang="en-us">1</span>并不是任何一个<span lang="en-us" xml:lang="en-us">Parititon</span>的<span lang="en-us" xml:lang="en-us">Leader</span>，而<span lang="en-us" xml:lang="en-us">Broker 5/6/7</span>都是<span lang="en-us" xml:lang="en-us">2</span>个<span lang="en-us" xml:lang="en-us">Partition</span>的<span lang="en-us" xml:lang="en-us">Leader</span>，即<span lang="en-us" xml:lang="en-us">Leader</span>的分布不均衡<span lang="en-us" xml:lang="en-us">——</span>一个<span lang="en-us" xml:lang="en-us">Broker</span>最多是<span lang="en-us" xml:lang="en-us">2</span>个<span lang="en-us" xml:lang="en-us">Partition</span>的<span lang="en-us" xml:lang="en-us">Leader</span>，而 最少是<span lang="en-us" xml:lang="en-us">0</span>个<span lang="en-us" xml:lang="en-us">Partition</span>的<span lang="en-us" xml:lang="en-us">Leader</span>。</p>
<p><br><img src="http://dl2.iteye.com/upload/attachment/0110/8915/cddcd224-8ad3-3807-9165-75cc5376f5be.png" alt=""><br> </p>
<p>运行该工具后，<span lang="en-us" xml:lang="en-us">topic1</span>的<span lang="en-us" xml:lang="en-us">Partition/Replica</span>分布如下图所示。由图可见，除了<span lang="en-us" xml:lang="en-us">Partition 1</span>和<span lang="en-us" xml:lang="en-us">Partition 3</span>由于<span lang="en-us" xml:lang="en-us">Broker 2</span>和<span lang="en-us" xml:lang="en-us">Broker 4</span>还未启动，所以其<span lang="en-us" xml:lang="en-us">Leader</span>不是其<span lang="en-us" xml:lang="en-us">Preferred Repliac</span>外，其它所有<span lang="en-us" xml:lang="en-us">Partition</span>的<span lang="en-us" xml:lang="en-us">Leader</span>都是其<span lang="en-us" xml:lang="en-us">Preferred Replica</span>。同时，与运行该工具前相比，<span lang="en-us" xml:lang="en-us">Leader</span>的分配更均匀<span lang="en-us" xml:lang="en-us">——</span>一个<span lang="en-us" xml:lang="en-us">Broker</span>最多是<span lang="en-us" xml:lang="en-us">2</span>个<span lang="en-us" xml:lang="en-us">Parittion</span>的<span lang="en-us" xml:lang="en-us">Leader</span>，最少是<span lang="en-us" xml:lang="en-us">1</span>个<span lang="en-us" xml:lang="en-us"> Partition</span>的<span lang="en-us" xml:lang="en-us">Leader</span>。</p>
<p><span lang="en-us" xml:lang="en-us">WS:</span>所以<span lang="en-us" xml:lang="en-us">Partition</span>的<span lang="en-us" xml:lang="en-us">Replica</span>其实就是指某个<span lang="en-us" xml:lang="en-us">Broker</span>的<span lang="en-us" xml:lang="en-us">id</span>。</p>
<p><br><img src="http://dl2.iteye.com/upload/attachment/0110/8917/dfe8e04c-2442-3256-bbb6-c4260ea28b4c.png" alt=""><br> </p>
<p>启动<span lang="en-us" xml:lang="en-us">Broker 2</span>和<span lang="en-us" xml:lang="en-us">Broker 4</span>，<span lang="en-us" xml:lang="en-us">Leader</span>分布与上一步相比并未变化，如下图所示。</p>
<p><br><img src="http://dl2.iteye.com/upload/attachment/0110/8921/a678566b-b8d0-3f19-81cb-6c39a055871c.png" alt=""><br> </p>
<p>再次运行该工具，所有<span lang="en-us" xml:lang="en-us">Partition</span>的<span lang="en-us" xml:lang="en-us">Leader</span>都由其<span lang="en-us" xml:lang="en-us">Preferred Replica</span>承担，<span lang="en-us" xml:lang="en-us">Leader</span>分布更均匀<span lang="en-us" xml:lang="en-us">——</span>每个<span lang="en-us" xml:lang="en-us">Broker</span>承担<span lang="en-us" xml:lang="en-us">1</span>个<span lang="en-us" xml:lang="en-us">Partition</span>的<span lang="en-us" xml:lang="en-us">Leader</span>角色。</p>
<p> </p>
<p>除了手动运行该工具使<span lang="en-us" xml:lang="en-us">Leader</span>分配均匀外，<span lang="en-us" xml:lang="en-us">Kafka</span>还提供了自动平衡<span lang="en-us" xml:lang="en-us">Leader</span>分配的功能，该功能可通过将<code><span lang="en-us" xml:lang="en-us">auto.leader.rebalance.enable</span></code>设置为<span lang="en-us" xml:lang="en-us">true</span>开启，它将周期性检查<span lang="en-us" xml:lang="en-us">Leader</span>分配是否平衡，若不平衡度超过一定阈值则自动由<span lang="en-us" xml:lang="en-us">Controller</span>尝试将各<span lang="en-us" xml:lang="en-us">Partition</span>的<span lang="en-us" xml:lang="en-us">Leader</span>设置为其<span lang="en-us" xml:lang="en-us">Preferred Replica</span>。检查周期由<code><span lang="en-us" xml:lang="en-us">leader.imbalance.check.interval.seconds</span></code>指定，不平衡度阈值由<code><span lang="en-us" xml:lang="en-us">leader.imbalance.per.broker.percentage</span></code>指定。</p>
</div>            </div>
                </div>