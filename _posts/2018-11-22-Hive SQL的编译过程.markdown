---
layout:     post
title:      Hive SQL的编译过程
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                
<h1 class="title" style="color:rgb(42,41,53);">
Hive SQL的编译过程</h1>
<p class="info" style="color:rgb(153,153,153);">
<span class="nick">木叶丸</span><span class="Separate"> ·</span><span class="date">2014-02-12 17:30</span></p>
<div class="article__content" style="color:rgb(68,68,68);line-height:2em;border-bottom:1px dashed rgb(221,221,221);font-family:'Hiragino Sans GB', 'Microsoft Yahei', '微软雅黑', sans-serif;">
<p style="color:rgb(102,102,102);font-size:1.16em;">
Hive是基于Hadoop的一个数据仓库系统，在各大公司都有广泛的应用。美团数据仓库也是基于Hive搭建，每天执行近万次的Hive ETL计算流程，负责每天数百GB的数据存储和分析。Hive的稳定性和性能对我们的数据分析非常关键。</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
在几次升级Hive的过程中，我们遇到了一些大大小小的问题。通过向社区的咨询和自己的努力，在解决这些问题的同时我们对Hive将SQL编译为MapReduce的过程有了比较深入的理解。对这一过程的理解不仅帮助我们解决了一些Hive的bug，也有利于我们优化Hive SQL，提升我们对Hive的掌控力，同时有能力去定制一些需要的功能。</p>
<h2 id="mapreduce-sql-" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.73em;">
MapReduce实现基本SQL操作的原理</h2>
<p style="color:rgb(102,102,102);font-size:1.16em;">
详细讲解SQL编译为MapReduce之前，我们先来看看MapReduce框架实现SQL基本操作的原理</p>
<h3 id="join-" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.4em;">
Join的实现原理</h3>
<pre style="color:rgb(0,0,0);font-family:'Helvetica Regular';font-size:1em;overflow:auto;background-color:rgb(245,252,251);border-left:1px solid rgb(50,211,195);line-height:1.5em;"><code style="font-family:monospace, monospace;font-size:1em;background:none;border:none;">select u.name, o.orderid from order o join user u on o.uid = u.uid;
</code></pre>
<p style="color:rgb(102,102,102);font-size:1.16em;">
在map的输出value中为不同表的数据打上tag标记，在reduce阶段根据tag判断数据来源。MapReduce的过程如下（这里只是说明最基本的Join的实现，还有其他的实现方式）</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/join.png" alt="MapReduce CommonJoin的实现" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<h3 id="group-by-" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.4em;">
Group By的实现原理</h3>
<pre style="color:rgb(0,0,0);font-family:'Helvetica Regular';font-size:1em;overflow:auto;background-color:rgb(245,252,251);border-left:1px solid rgb(50,211,195);line-height:1.5em;"><code style="font-family:monospace, monospace;font-size:1em;background:none;border:none;">select rank, isonline, count(*) from city group by rank, isonline;
</code></pre>
<p style="color:rgb(102,102,102);font-size:1.16em;">
将GroupBy的字段组合为map的输出key值，利用MapReduce的排序，在reduce阶段保存LastKey区分不同的key。MapReduce的过程如下（当然这里只是说明Reduce端的非Hash聚合过程）</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/groupby.png" alt="MapReduce Group By的实现" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<h3 id="distinct-" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.4em;">
Distinct的实现原理</h3>
<pre style="color:rgb(0,0,0);font-family:'Helvetica Regular';font-size:1em;overflow:auto;background-color:rgb(245,252,251);border-left:1px solid rgb(50,211,195);line-height:1.5em;"><code style="font-family:monospace, monospace;font-size:1em;background:none;border:none;">select dealid, count(distinct uid) num from order group by dealid;
</code></pre>
<p style="color:rgb(102,102,102);font-size:1.16em;">
当只有一个distinct字段时，如果不考虑Map阶段的Hash GroupBy，只需要将GroupBy字段和Distinct字段组合为map输出key，利用mapreduce的排序，同时将GroupBy字段作为reduce的key，在reduce阶段保存LastKey即可完成去重</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/1distinct.png" alt="MapReduce Distinct的实现" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
如果有多个distinct字段呢，如下面的SQL</p>
<pre style="color:rgb(0,0,0);font-family:'Helvetica Regular';font-size:1em;overflow:auto;background-color:rgb(245,252,251);border-left:1px solid rgb(50,211,195);line-height:1.5em;"><code style="font-family:monospace, monospace;font-size:1em;background:none;border:none;">select dealid, count(distinct uid), count(distinct date) from order group by dealid;
</code></pre>
<p style="color:rgb(102,102,102);font-size:1.16em;">
实现方式有两种：</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
（1）如果仍然按照上面一个distinct字段的方法，即下图这种实现方式，无法跟据uid和date分别排序，也就无法通过LastKey去重，仍然需要在reduce阶段在内存中通过Hash去重</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/2distinct-a.png" alt="MapReduce Multi Distinct的实现" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
（2）第二种实现方式，可以对所有的distinct字段编号，每行数据生成n行数据，那么相同字段就会分别排序，这时只需要在reduce阶段记录LastKey即可去重。</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
这种实现方式很好的利用了MapReduce的排序，节省了reduce阶段去重的内存消耗，但是缺点是增加了shuffle的数据量。</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
需要注意的是，在生成reduce value时，除第一个distinct字段所在行需要保留value值，其余distinct数据行value字段均可为空。</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/2distinct-b.png" alt="MapReduce Multi Distinct的实现" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<h2 id="sql-mapreduce-" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.73em;">
SQL转化为MapReduce的过程</h2>
<p style="color:rgb(102,102,102);font-size:1.16em;">
了解了MapReduce实现SQL基本操作之后，我们来看看Hive是如何将SQL转化为MapReduce任务的，整个编译过程分为六个阶段：</p>
<ol style="font-size:1em;"><li style="color:rgb(102,102,102);">Antlr定义SQL的语法规则，完成SQL词法，语法解析，将SQL转化为抽象语法树AST Tree</li><li style="color:rgb(102,102,102);">遍历AST Tree，抽象出查询的基本组成单元QueryBlock</li><li style="color:rgb(102,102,102);">遍历QueryBlock，翻译为执行操作树OperatorTree</li><li style="color:rgb(102,102,102);">逻辑层优化器进行OperatorTree变换，合并不必要的ReduceSinkOperator，减少shuffle数据量</li><li style="color:rgb(102,102,102);">遍历OperatorTree，翻译为MapReduce任务</li><li style="color:rgb(102,102,102);">物理层优化器进行MapReduce任务的变换，生成最终的执行计划</li></ol><p style="color:rgb(102,102,102);font-size:1.16em;">
下面分别对这六个阶段进行介绍</p>
<h3 id="phase1-sql-" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.4em;">
Phase1 SQL词法，语法解析</h3>
<h4 id="antlr" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.16em;">
Antlr</h4>
<p style="color:rgb(102,102,102);font-size:1.16em;">
Hive使用Antlr实现SQL的词法和语法解析。Antlr是一种语言识别的工具，可以用来构造领域语言。<br>
这里不详细介绍Antlr，只需要了解使用Antlr构造特定的语言只需要编写一个语法文件，定义词法和语法替换规则即可，Antlr完成了词法分析、语法分析、语义分析、中间代码生成的过程。</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
Hive中语法规则的定义文件在0.10版本以前是Hive.g一个文件，随着语法规则越来越复杂，由语法规则生成的Java解析类可能超过Java类文件的最大上限，0.11版本将Hive.g拆成了5个文件，词法规则HiveLexer.g和语法规则的4个文件SelectClauseParser.g，FromClauseParser.g，IdentifiersParser.g，HiveParser.g。</p>
<h4 id="-ast-tree" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.16em;">
抽象语法树AST Tree</h4>
<p style="color:rgb(102,102,102);font-size:1.16em;">
经过词法和语法解析后，如果需要对表达式做进一步的处理，使用 Antlr 的抽象语法树语法Abstract Syntax Tree，在语法分析的同时将输入语句转换成抽象语法树，后续在遍历语法树时完成进一步的处理。</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
下面的一段语法是Hive SQL中SelectStatement的语法规则，从中可以看出，SelectStatement包含select, from, where, groupby, having, orderby等子句。<br>
（在下面的语法规则中，箭头表示对于原语句的改写，改写后会加入一些特殊词标示特定语法，比如TOK_QUERY标示一个查询块）</p>
<pre style="color:rgb(0,0,0);font-family:'Helvetica Regular';font-size:1em;overflow:auto;background-color:rgb(245,252,251);border-left:1px solid rgb(50,211,195);line-height:1.5em;"><code style="font-family:monospace, monospace;font-size:1em;background:none;border:none;">selectStatement
   :
   selectClause
   fromClause
   whereClause?
   groupByClause?
   havingClause?
   orderByClause?
   clusterByClause?
   distributeByClause?
   sortByClause?
   limitClause? -&gt; ^(TOK_QUERY fromClause ^(TOK_INSERT ^(TOK_DESTINATION ^(TOK_DIR TOK_TMP_FILE))
                     selectClause whereClause? groupByClause? havingClause? orderByClause? clusterByClause?
                     distributeByClause? sortByClause? limitClause?))
   ;
</code></pre>
<h4 id="-sql" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.16em;">
样例SQL</h4>
<p style="color:rgb(102,102,102);font-size:1.16em;">
为了详细说明SQL翻译为MapReduce的过程，这里以一条简单的SQL为例，SQL中包含一个子查询，最终将数据写入到一张表中</p>
<pre style="color:rgb(0,0,0);font-family:'Helvetica Regular';font-size:1em;overflow:auto;background-color:rgb(245,252,251);border-left:1px solid rgb(50,211,195);line-height:1.5em;"><code style="font-family:monospace, monospace;font-size:1em;background:none;border:none;">FROM
( 
  SELECT
    p.datekey datekey,
    p.userid userid,
    c.clienttype
  FROM
    detail.usersequence_client c
    JOIN fact.orderpayment p ON p.orderid = c.orderid
    JOIN default.user du ON du.userid = p.userid
  WHERE p.datekey = 20131118 
) base
INSERT OVERWRITE TABLE `test`.`customer_kpi`
SELECT
  base.datekey,
  base.clienttype,
  count(distinct base.userid) buyer_count
GROUP BY base.datekey, base.clienttype
</code></pre>
<h4 id="sql-ast-tree" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.16em;">
SQL生成AST Tree</h4>
<p style="color:rgb(102,102,102);font-size:1.16em;">
Antlr对Hive SQL解析的代码如下，HiveLexerX，HiveParser分别是Antlr对语法文件Hive.g编译后自动生成的词法解析和语法解析类，在这两个类中进行复杂的解析。</p>
<pre style="color:rgb(0,0,0);font-family:'Helvetica Regular';font-size:1em;overflow:auto;background-color:rgb(245,252,251);border-left:1px solid rgb(50,211,195);line-height:1.5em;"><code style="font-family:monospace, monospace;font-size:1em;background:none;border:none;">HiveLexerX lexer = new HiveLexerX(new ANTLRNoCaseStringStream(command));    //词法解析，忽略关键词的大小写
TokenRewriteStream tokens = new TokenRewriteStream(lexer);
if (ctx != null) {
  ctx.setTokenRewriteStream(tokens);
}
HiveParser parser = new HiveParser(tokens);                                 //语法解析
parser.setTreeAdaptor(adaptor);
HiveParser.statement_return r = null;
try {
  r = parser.statement();                                                   //转化为AST Tree
} catch (RecognitionException e) {
  e.printStackTrace();
  throw new ParseException(parser.errors);
}
</code></pre>
<p style="color:rgb(102,102,102);font-size:1.16em;">
最终生成的AST Tree如下图右侧（使用Antlr Works生成，Antlr Works是Antlr提供的编写语法文件的编辑器），图中只是展开了骨架的几个节点，没有完全展开。<br>
子查询1/2，分别对应右侧第1/2两个部分。</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/sql-ast.png" alt="SQL生成AST Tree" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
这里注意一下内层子查询也会生成一个TOK_DESTINATION节点。请看上面SelectStatement的语法规则，这个节点是在语法改写中特意增加了的一个节点。原因是Hive中所有查询的数据均会保存在HDFS临时的文件中，无论是中间的子查询还是查询最终的结果，Insert语句最终会将数据写入表所在的HDFS目录下。</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
详细来看，将内存子查询的from子句展开后，得到如下AST Tree，每个表生成一个TOK_TABREF节点，Join条件生成一个“=”节点。其他SQL部分类似，不一一详述。</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/ast-tree.png" alt="AST Tree" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<h3 id="phase2-sql-queryblock" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.4em;">
Phase2 SQL基本组成单元QueryBlock</h3>
<p style="color:rgb(102,102,102);font-size:1.16em;">
AST Tree仍然非常复杂，不够结构化，不方便直接翻译为MapReduce程序，AST Tree转化为QueryBlock就是将SQL进一部抽象和结构化。</p>
<h4 id="queryblock" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.16em;">
QueryBlock</h4>
<p style="color:rgb(102,102,102);font-size:1.16em;">
QueryBlock是一条SQL最基本的组成单元，包括三个部分：输入源，计算过程，输出。简单来讲一个QueryBlock就是一个子查询。</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
下图为Hive中QueryBlock相关对象的类图，解释图中几个重要的属性</p>
<ul style="font-size:1em;"><li style="color:rgb(102,102,102);">QB#aliasToSubq（表示QB类的aliasToSubq属性）保存子查询的QB对象，aliasToSubq key值是子查询的别名</li><li style="color:rgb(102,102,102);">QB#qbp即QBParseInfo保存一个基本SQL单元中的给个操作部分的AST Tree结构，QBParseInfo#nameToDest这个HashMap保存查询单元的输出，key的形式是inclause-i（由于Hive支持Multi Insert语句，所以可能有多个输出），value是对应的ASTNode节点，即TOK_DESTINATION节点。类QBParseInfo其余HashMap属性分别保存输出和各个操作的ASTNode节点的对应关系。</li><li style="color:rgb(102,102,102);">QBParseInfo#JoinExpr保存TOK_JOIN节点。QB#QBJoinTree是对Join语法树的结构化。</li><li style="color:rgb(102,102,102);">QB#qbm保存每个输入表的元信息，比如表在HDFS上的路径，保存表数据的文件格式等。</li><li style="color:rgb(102,102,102);">QBExpr这个对象是为了表示Union操作。</li></ul><p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/queryblock.png" alt="QueryBlock" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<h4 id="ast-tree-queryblock" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.16em;">
AST Tree生成QueryBlock</h4>
<p style="color:rgb(102,102,102);font-size:1.16em;">
AST Tree生成QueryBlock的过程是一个递归的过程，先序遍历AST Tree，遇到不同的Token节点，保存到相应的属性中，主要包含以下几个过程</p>
<ul style="font-size:1em;"><li style="color:rgb(102,102,102);">TOK_QUERY =&gt; 创建QB对象，循环递归子节点</li><li style="color:rgb(102,102,102);">TOK_FROM =&gt; 将表名语法部分保存到QB对象的<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">aliasToTabs</code>等属性中</li><li style="color:rgb(102,102,102);">TOK_INSERT =&gt; 循环递归子节点</li><li style="color:rgb(102,102,102);">TOK_DESTINATION =&gt; 将输出目标的语法部分保存在QBParseInfo对象的nameToDest属性中</li><li style="color:rgb(102,102,102);">TOK_SELECT =&gt; 分别将查询表达式的语法部分保存在<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">destToSelExpr</code>、<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">destToAggregationExprs</code>、<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">destToDistinctFuncExprs</code>三个属性中</li><li style="color:rgb(102,102,102);">TOK_WHERE =&gt; 将Where部分的语法保存在QBParseInfo对象的destToWhereExpr属性中</li></ul><p style="color:rgb(102,102,102);font-size:1.16em;">
最终样例SQL生成两个QB对象，QB对象的关系如下，QB1是外层查询，QB2是子查询</p>
<pre style="color:rgb(0,0,0);font-family:'Helvetica Regular';font-size:1em;overflow:auto;background-color:rgb(245,252,251);border-left:1px solid rgb(50,211,195);line-height:1.5em;"><code style="font-family:monospace, monospace;font-size:1em;background:none;border:none;">QB1

  \

   QB2
</code></pre>
<h3 id="phase3-operator" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.4em;">
Phase3 逻辑操作符Operator</h3>
<h4 id="operator" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.16em;">
Operator</h4>
<p style="color:rgb(102,102,102);font-size:1.16em;">
Hive最终生成的MapReduce任务，Map阶段和Reduce阶段均由OperatorTree组成。逻辑操作符，就是在Map阶段或者Reduce阶段完成单一特定的操作。</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
基本的操作符包括TableScanOperator，SelectOperator，FilterOperator，JoinOperator，GroupByOperator，ReduceSinkOperator</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
从名字就能猜出各个操作符完成的功能，TableScanOperator从MapReduce框架的Map接口原始输入表的数据，控制扫描表的数据行数，标记是从原表中取数据。JoinOperator完成Join操作。FilterOperator完成过滤操作</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
ReduceSinkOperator将Map端的字段组合序列化为Reduce Key/value, Partition Key，只可能出现在Map阶段，同时也标志着Hive生成的MapReduce程序中Map阶段的结束。</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
Operator在Map Reduce阶段之间的数据传递都是一个流式的过程。每一个Operator对一行数据完成操作后之后将数据传递给childOperator计算。</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
Operator类的主要属性和方法如下</p>
<ul style="font-size:1em;"><li style="color:rgb(102,102,102);">RowSchema表示Operator的输出字段</li><li style="color:rgb(102,102,102);">InputObjInspector outputObjInspector解析输入和输出字段</li><li style="color:rgb(102,102,102);">processOp接收父Operator传递的数据，forward将处理好的数据传递给子Operator处理</li><li style="color:rgb(102,102,102);">Hive每一行数据经过一个Operator处理之后，会对字段重新编号，colExprMap记录每个表达式经过当前Operator处理前后的名称对应关系，在下一个阶段逻辑优化阶段用来回溯字段名</li><li style="color:rgb(102,102,102);">由于Hive的MapReduce程序是一个动态的程序，即不确定一个MapReduce Job会进行什么运算，可能是Join，也可能是GroupBy，所以Operator将所有运行时需要的参数保存在OperatorDesc中，OperatorDesc在提交任务前序列化到HDFS上，在MapReduce任务执行前从HDFS读取并反序列化。Map阶段OperatorTree在HDFS上的位置在Job.getConf(“hive.exec.plan”)
 + “/map.xml”</li></ul><p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/operator.png" alt="QueryBlock" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<h4 id="queryblock-operator-tree" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.16em;">
QueryBlock生成Operator Tree</h4>
<p style="color:rgb(102,102,102);font-size:1.16em;">
QueryBlock生成Operator Tree就是遍历上一个过程中生成的QB和QBParseInfo对象的保存语法的属性，包含如下几个步骤：</p>
<ul style="font-size:1em;"><li style="color:rgb(102,102,102);">QB#aliasToSubq =&gt; 有子查询，递归调用</li><li style="color:rgb(102,102,102);">QB#aliasToTabs =&gt; TableScanOperator</li><li style="color:rgb(102,102,102);">QBParseInfo#joinExpr =&gt; QBJoinTree =&gt; ReduceSinkOperator + JoinOperator</li><li style="color:rgb(102,102,102);">QBParseInfo#destToWhereExpr =&gt; FilterOperator</li><li style="color:rgb(102,102,102);">QBParseInfo#destToGroupby =&gt; ReduceSinkOperator + GroupByOperator</li><li style="color:rgb(102,102,102);">QBParseInfo#destToOrderby =&gt; ReduceSinkOperator + ExtractOperator</li></ul><p style="color:rgb(102,102,102);font-size:1.16em;">
<span><span>由于Join/GroupBy/OrderBy均需要在Reduce阶段完成，所以在生成相应操作的Operator之前都会先生成一个ReduceSinkOperator，将字段组合并序列化为Reduce Key/value, Partition Key</span></span></p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
接下来详细分析样例SQL生成OperatorTree的过程</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
先序遍历上一个阶段生成的QB对象</p>
<ol style="font-size:1em;"><li style="color:rgb(102,102,102);">
<p style="font-size:1em;">
首先根据子QueryBlock <code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">QB2#aliasToTabs {du=dim.user, c=detail.usersequence_client, p=fact.orderpayment}</code>生成TableScanOperator</p>
<pre style="color:rgb(0,0,0);font-family:'Helvetica Regular';font-size:1em;overflow:auto;background-color:rgb(245,252,251);border-left:1px solid rgb(50,211,195);line-height:1.5em;"><code style="font-family:monospace, monospace;font-size:1em;background:none;border:none;"> TableScanOperator(“dim.user”) TS[0]
 TableScanOperator(“detail.usersequence_client”) TS[1]        TableScanOperator(“fact.orderpayment”) TS[2]
</code></pre>
</li><li style="color:rgb(102,102,102);">
<p style="font-size:1em;">
先序遍历<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">QBParseInfo#joinExpr</code>生成<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">QBJoinTree</code>，类<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">QBJoinTree</code>也是一个树状结构，<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">QBJoinTree</code>保存左右表的ASTNode和这个查询的别名，最终生成的查询树如下</p>
<pre style="color:rgb(0,0,0);font-family:'Helvetica Regular';font-size:1em;overflow:auto;background-color:rgb(245,252,251);border-left:1px solid rgb(50,211,195);line-height:1.5em;"><code style="font-family:monospace, monospace;font-size:1em;background:none;border:none;">    base
    /  \
   p    du
  /      \
 c        p
</code></pre>
</li></ol><ol style="font-size:1em;"><li style="color:rgb(102,102,102);">前序遍历<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">QBJoinTree</code>，先生成<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">detail.usersequence_client</code>和<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">fact.orderpayment</code>的Join操作树</li></ol><p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/qb-to-operator-1.png" alt="Join to Operator" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<span><span>图中 TS=TableScanOperator RS=ReduceSinkOperator JOIN=JoinOperator</span></span></p>
<ol style="font-size:1em;"><li style="color:rgb(102,102,102);">生成中间表与dim.user的Join操作树</li></ol><p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/qb-to-operator-2.png" alt="Join to Operator" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<ol style="font-size:1em;"><li style="color:rgb(102,102,102);">根据QB2 <code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">QBParseInfo#destToWhereExpr</code> 生成<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">FilterOperator</code>。此时QB2遍历完成。</li></ol><p style="color:rgb(102,102,102);font-size:1.16em;">
下图中SelectOperator在某些场景下会根据一些条件判断是否需要解析字段。</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/qb-to-operator-3.png" alt="Where to Operator" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<span><span>图中 FIL= FilterOperator SEL= SelectOperator</span></span></p>
<ol style="font-size:1em;"><li style="color:rgb(102,102,102);">根据QB1的QBParseInfo#destToGroupby生成ReduceSinkOperator + GroupByOperator</li></ol><p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/qb-to-operator-4.png" alt="GroupBy to Operator" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<span><span>图中 GBY= GroupByOperator</span></span><br><span><span>GBY[12]是HASH聚合，即在内存中通过Hash进行聚合运算</span></span></p>
<ol style="font-size:1em;"><li style="color:rgb(102,102,102);">最终都解析完后，会生成一个FileSinkOperator，将数据写入HDFS</li></ol><p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/qb-to-operator-5.png" alt="FileSinkOperator" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<span><span>图中FS=FileSinkOperator</span></span></p>
<h3 id="phase4-" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.4em;">
Phase4 逻辑层优化器</h3>
<p style="color:rgb(102,102,102);font-size:1.16em;">
大部分逻辑层优化器通过变换OperatorTree，合并操作符，达到减少MapReduce Job，减少shuffle数据量的目的。</p>
<table class="confluenceTable tablesorter" style="border-collapse:collapse;border-spacing:0px;"><thead><tr class="sortableHeader" style="border-style:solid;border-width:1px 0px;border-color:rgb(204,204,204);"><th class="confluenceTh sortableHeader tablesorter-headerSortUp" style="text-align:left;">
<div class="tablesorter-header-inner">
<p class="p2" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">名称</span></p>
</div>
</th>
<th class="confluenceTh sortableHeader" style="text-align:left;">
<div class="tablesorter-header-inner">
<p class="p2" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">作用</span></p>
</div>
</th>
</tr></thead><tbody><tr style="border-style:solid;border-width:1px 0px;border-color:rgb(204,204,204);"><td class="confluenceTd" style="vertical-align:top;">
<p class="p3" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">② SimpleFetchOptimizer</span></p>
</td>
<td class="confluenceTd" style="vertical-align:top;">
<p class="p4" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">优化没有</span><span class="s3">GroupBy</span><span class="s1">表达式的聚合查询</span></p>
</td>
</tr><tr style="border-style:solid;border-width:1px 0px;border-color:rgb(204,204,204);"><td class="confluenceTd" style="vertical-align:top;">
<p class="p3" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">② MapJoinProcessor</span></p>
</td>
<td class="confluenceTd" style="vertical-align:top;">
<p class="p3" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">MapJoin</span><span class="s2">，需要SQL中提供</span><span class="s1">hint，0.11版本已不用</span></p>
</td>
</tr><tr style="border-style:solid;border-width:1px 0px;border-color:rgb(204,204,204);"><td class="confluenceTd" style="vertical-align:top;">
<p class="p3" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">② BucketMapJoinOptimizer</span></p>
</td>
<td class="confluenceTd" style="vertical-align:top;">
<p class="p3" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">BucketMapJoin</span></p>
</td>
</tr><tr style="border-style:solid;border-width:1px 0px;border-color:rgb(204,204,204);"><td class="confluenceTd" style="vertical-align:top;">
<p class="p3" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">② GroupByOptimizer</span></p>
</td>
<td class="confluenceTd" style="vertical-align:top;">
<p class="p3" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">Map</span><span class="s2">端聚合</span></p>
</td>
</tr><tr style="border-style:solid;border-width:1px 0px;border-color:rgb(204,204,204);"><td class="confluenceTd" style="vertical-align:top;">
<p class="p3" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1"><span>① </span>ReduceSinkDeDuplication</span></p>
</td>
<td class="confluenceTd" style="vertical-align:top;">
<p class="p3" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s2">合并线性的</span><span class="s1">OperatorTree</span><span class="s2">中</span><span class="s1">partition/sort key</span><span class="s2">相同的</span><span class="s1">reduce</span></p>
</td>
</tr><tr style="border-style:solid;border-width:1px 0px;border-color:rgb(204,204,204);"><td class="confluenceTd" style="vertical-align:top;">
<p class="p3" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">① PredicatePushDown</span></p>
</td>
<td class="confluenceTd" style="vertical-align:top;">
<p class="p4" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">谓词前置</span></p>
</td>
</tr><tr style="border-style:solid;border-width:1px 0px;border-color:rgb(204,204,204);"><td class="confluenceTd" style="vertical-align:top;">
<p class="p3" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1"><span>① </span>CorrelationOptimizer</span></p>
</td>
<td class="confluenceTd" style="vertical-align:top;">
<p class="p4" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">利用查询中的相关性，合并有相关性的</span><span class="s3">Job</span><span class="s1">，</span><span class="s3">HIVE-2206</span></p>
</td>
</tr><tr style="border-style:solid;border-width:1px 0px;border-color:rgb(204,204,204);"><td class="confluenceTd" style="vertical-align:top;">
<p class="p3" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">ColumnPruner</span></p>
</td>
<td class="confluenceTd" style="vertical-align:top;">
<p class="p4" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">字段剪枝</span></p>
</td>
</tr></tbody></table><p style="color:rgb(102,102,102);font-size:1.16em;">
表格中①的优化器均是一个Job干尽可能多的事情/合并。②的都是减少shuffle数据量，甚至不做Reduce。</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
CorrelationOptimizer优化器非常复杂，都能利用查询中的相关性，合并有相关性的Job，参考 <a href="https://cwiki.apache.org/confluence/display/Hive/Correlation+Optimizer" rel="nofollow" style="text-decoration:none;color:rgb(50,211,195);">Hive Correlation Optimizer</a></p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
对于样例SQL，有两个优化器对其进行优化。下面分别介绍这两个优化器的作用，并补充一个优化器ReduceSinkDeDuplication的作用</p>
<h4 id="predicatepushdown-" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.16em;">
PredicatePushDown优化器</h4>
<p style="color:rgb(102,102,102);font-size:1.16em;">
断言判断提前优化器将OperatorTree中的FilterOperator提前到TableScanOperator之后</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/PredicatePushDown.png" alt="PredicatePushDown" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<h4 id="nonblockingopdedupproc-" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.16em;">
NonBlockingOpDeDupProc优化器</h4>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">NonBlockingOpDeDupProc</code>优化器合并SEL-SEL 或者 FIL-FIL 为一个Operator</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/NonBlockingOpDeDupProc.png" alt="NonBlockingOpDeDupProc" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<h4 id="reducesinkdeduplication-" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.16em;">
ReduceSinkDeDuplication优化器</h4>
<p style="color:rgb(102,102,102);font-size:1.16em;">
ReduceSinkDeDuplication可以合并线性相连的两个RS。实际上CorrelationOptimizer是ReduceSinkDeDuplication的超集，能合并线性和非线性的操作RS，但是Hive先实现的ReduceSinkDeDuplication</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
譬如下面这条SQL语句</p>
<pre style="color:rgb(0,0,0);font-family:'Helvetica Regular';font-size:1em;overflow:auto;background-color:rgb(245,252,251);border-left:1px solid rgb(50,211,195);line-height:1.5em;"><code style="font-family:monospace, monospace;font-size:1em;background:none;border:none;">from (select key, value from src group by key, value) s select s.key group by s.key;
</code></pre>
<p style="color:rgb(102,102,102);font-size:1.16em;">
经过前面几个阶段之后，会生成如下的OperatorTree，两个Tree是相连的，这里没有画到一起</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/ReduceSinkDeDuplication1.png" alt="ReduceSinkDeDuplication" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
这时候遍历OperatorTree后能发现前前后两个RS输出的Key值和PartitionKey如下</p>
<table class="confluenceTable tablesorter" style="border-collapse:collapse;border-spacing:0px;"><thead><tr class="sortableHeader" style="border-style:solid;border-width:1px 0px;border-color:rgb(204,204,204);"><th class="confluenceTh sortableHeader tablesorter-headerSortDown" style="text-align:left;">
<div class="tablesorter-header-inner">
<p class="p1" style="color:rgb(102,102,102);font-size:1.16em;">
 </p>
</div>
</th>
<th class="confluenceTh sortableHeader" style="text-align:left;">
<div class="tablesorter-header-inner">
<p class="p2" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">Key</span></p>
</div>
</th>
<th class="confluenceTh sortableHeader" style="text-align:left;">
<div class="tablesorter-header-inner">
<p class="p2" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">Partition</span>Key</p>
</div>
</th>
</tr></thead><tbody><tr style="border-style:solid;border-width:1px 0px;border-color:rgb(204,204,204);"><th class="confluenceTh" style="text-align:left;">
<p class="p2" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">childRS</span></p>
</th>
<td class="confluenceTd" style="vertical-align:top;">
<p class="p2" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">key</span></p>
</td>
<td class="confluenceTd" style="vertical-align:top;">
<p class="p2" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">key</span></p>
</td>
</tr><tr style="border-style:solid;border-width:1px 0px;border-color:rgb(204,204,204);"><th class="confluenceTh" style="text-align:left;">
<p class="p2" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">parentRS</span></p>
</th>
<td class="confluenceTd" style="vertical-align:top;">
<p class="p2" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">key,value</span></p>
</td>
<td class="confluenceTd" style="vertical-align:top;">
<p class="p2" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">key,value</span></p>
</td>
</tr></tbody></table><p style="color:rgb(102,102,102);font-size:1.16em;">
ReduceSinkDeDuplication优化器检测到：1. pRS Key完全包含cRS Key，且排序顺序一致；2. pRS PartitionKey完全包含cRS PartitionKey。符合优化条件，会对执行计划进行优化。</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
ReduceSinkDeDuplication将childRS和parentheRS与childRS之间的Operator删掉，保留的RS的Key为key,value字段，PartitionKey为key字段。合并后的OperatorTree如下：</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/ReduceSinkDeDuplication2.png" alt="ReduceSinkDeDuplication" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<h3 id="phase5-operatortree-mapreduce-job-" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.4em;">
Phase5 OperatorTree生成MapReduce Job的过程</h3>
<p style="color:rgb(102,102,102);font-size:1.16em;">
OperatorTree转化为MapReduce Job的过程分为下面几个阶段</p>
<ol style="font-size:1em;"><li style="color:rgb(102,102,102);">对输出表生成MoveTask</li><li style="color:rgb(102,102,102);">从OperatorTree的其中一个根节点向下深度优先遍历</li><li style="color:rgb(102,102,102);">ReduceSinkOperator标示Map/Reduce的界限，多个Job间的界限</li><li style="color:rgb(102,102,102);">遍历其他根节点，遇过碰到JoinOperator合并MapReduceTask</li><li style="color:rgb(102,102,102);">生成StatTask更新元数据</li><li style="color:rgb(102,102,102);">剪断Map与Reduce间的Operator的关系</li></ol><h4 id="-movetask" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.16em;">
对输出表生成MoveTask</h4>
<p style="color:rgb(102,102,102);font-size:1.16em;">
由上一步OperatorTree只生成了一个FileSinkOperator，直接生成一个MoveTask，完成将最终生成的HDFS临时文件移动到目标表目录下</p>
<pre style="color:rgb(0,0,0);font-family:'Helvetica Regular';font-size:1em;overflow:auto;background-color:rgb(245,252,251);border-left:1px solid rgb(50,211,195);line-height:1.5em;"><code style="font-family:monospace, monospace;font-size:1em;background:none;border:none;">MoveTask[Stage-0]
Move Operator
</code></pre>
<h4 id="-" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.16em;">
开始遍历</h4>
<p style="color:rgb(102,102,102);font-size:1.16em;">
将OperatorTree中的所有根节点保存在一个toWalk的数组中，循环取出数组中的元素（省略QB1，未画出）</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/begin-walk.png" alt="开始遍历" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
取出最后一个元素TS[p]放入栈 opStack{TS[p]}中</p>
<h4 id="rule-1-ts-mapreducetask-mapwork" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.16em;">
Rule #1 TS% 生成MapReduceTask对象，确定MapWork</h4>
<p style="color:rgb(102,102,102);font-size:1.16em;">
发现栈中的元素符合下面规则R1（这里用python代码简单表示）</p>
<pre style="color:rgb(0,0,0);font-family:'Helvetica Regular';font-size:1em;overflow:auto;background-color:rgb(245,252,251);border-left:1px solid rgb(50,211,195);line-height:1.5em;"><code style="font-family:monospace, monospace;font-size:1em;background:none;border:none;">"".join([t + "%" for t in opStack]) == "TS%"
</code></pre>
<p style="color:rgb(102,102,102);font-size:1.16em;">
生成一个<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">MapReduceTask[Stage-1]</code>对象，<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">MapReduceTask[Stage-1]</code>对象的<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">MapWork</code>属性保存Operator根节点的引用。由于OperatorTree之间之间的Parent
 Child关系，这个时候<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">MapReduceTask[Stage-1]</code>包含了以<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">TS[p]</code>为根的所有Operator</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/operator-to-mapreduce-1.png" alt="Stage-1 生成Map阶段" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<h4 id="rule-2-ts-rs-reducework" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.16em;">
Rule #2 TS%.*RS% 确定ReduceWork</h4>
<p style="color:rgb(102,102,102);font-size:1.16em;">
继续遍历TS[p]的子Operator，将子Operator存入栈opStack中<br>
当第一个RS进栈后，即栈opStack = {TS[p], FIL[18], RS[4]}时，就会满足下面的规则R2</p>
<pre style="color:rgb(0,0,0);font-family:'Helvetica Regular';font-size:1em;overflow:auto;background-color:rgb(245,252,251);border-left:1px solid rgb(50,211,195);line-height:1.5em;"><code style="font-family:monospace, monospace;font-size:1em;background:none;border:none;">"".join([t + "%" for t in opStack]) == "TS%.*RS%"
</code></pre>
<p style="color:rgb(102,102,102);font-size:1.16em;">
这时候在<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">MapReduceTask[Stage-1]</code>对象的<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">ReduceWork</code>属性保存<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">JOIN[5]</code>的引用</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/operator-to-mapreduce-2.png" alt="Stage-1 生成Reduce阶段" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<h4 id="rule-3-rs-rs-mapreducetask-mapreducetask" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.16em;">
Rule #3 RS%.*RS% 生成新MapReduceTask对象，切分MapReduceTask</h4>
<p style="color:rgb(102,102,102);font-size:1.16em;">
继续遍历JOIN[5]的子Operator，将子Operator存入栈opStack中</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
当第二个RS放入栈时，即当栈<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">opStack = {TS[p], FIL[18], RS[4], JOIN[5], RS[6]}</code>时，就会满足下面的规则R3</p>
<pre style="color:rgb(0,0,0);font-family:'Helvetica Regular';font-size:1em;overflow:auto;background-color:rgb(245,252,251);border-left:1px solid rgb(50,211,195);line-height:1.5em;"><code style="font-family:monospace, monospace;font-size:1em;background:none;border:none;">"".join([t + "%" for t in opStack]) == “RS%.*RS%” //循环遍历opStack的每一个后缀数组
</code></pre>
<p style="color:rgb(102,102,102);font-size:1.16em;">
这时候创建一个新的<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">MapReduceTask[Stage-2]</code>对象，将OperatorTree从<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">JOIN[5]</code>和<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">RS[6]</code>之间剪开，并为<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">JOIN[5]</code>生成一个子Operator <code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">FS[19]</code>，<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">RS[6]</code>生成一个<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">TS[20]</code>，<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">MapReduceTask[Stage-2]</code>对象的<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">MapWork</code>属性保存<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">TS[20]</code>的引用。</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
新生成的<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">FS[19]</code>将中间数据落地，存储在HDFS临时文件中。</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/operator-to-mapreduce-3.png" alt="Stage-2" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
继续遍历RS[6]的子Operator，将子Operator存入栈opStack中</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
当<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">opStack = {TS[p], FIL[18], RS[4], JOIN[5], RS[6], JOIN[8], SEL[10], GBY[12], RS[13]}</code>时，又会满足R3规则</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
同理生成<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">MapReduceTask[Stage-3]</code>对象，并切开 Stage-2 和 Stage-3 的OperatorTree</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/operator-to-mapreduce-4.png" alt="Stage-3" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<h4 id="r4-fs-mapreducetask-movetask" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.16em;">
R4 FS% 连接MapReduceTask与MoveTask</h4>
<p style="color:rgb(102,102,102);font-size:1.16em;">
最终将所有子Operator存入栈中之后，<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">opStack = {TS[p], FIL[18], RS[4], JOIN[5], RS[6], JOIN[8], SEL[10],
 GBY[12], RS[13], GBY[14], SEL[15], FS[17]}</code> 满足规则R4</p>
<pre style="color:rgb(0,0,0);font-family:'Helvetica Regular';font-size:1em;overflow:auto;background-color:rgb(245,252,251);border-left:1px solid rgb(50,211,195);line-height:1.5em;"><code style="font-family:monospace, monospace;font-size:1em;background:none;border:none;">"".join([t + "%" for t in opStack]) == “FS%”
</code></pre>
<p style="color:rgb(102,102,102);font-size:1.16em;">
这时候将<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">MoveTask</code>与<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">MapReduceTask[Stage-3]</code>连接起来，并生成一个<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">StatsTask</code>，修改表的元信息</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/operator-to-mapreduce-5.png" alt="MoveTask" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<h4 id="-stage" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.16em;">
合并Stage</h4>
<p style="color:rgb(102,102,102);font-size:1.16em;">
此时并没有结束，还有两个根节点没有遍历。</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
将opStack栈清空，将toWalk的第二个元素加入栈。会发现<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">opStack = {TS[du]}</code>继续满足R1 TS%，生成<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">MapReduceTask[Stage-5]</code></p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/operator-to-mapreduce-6.png" alt="Stage-5" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
继续从<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">TS[du]</code>向下遍历，当<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">opStack={TS[du],
 RS[7]}</code>时，满足规则R2 TS%.*RS%</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
此时将<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">JOIN[8]</code>保存为<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">MapReduceTask[Stage-5]</code>的<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">ReduceWork</code>时，发现在一个Map对象保存的Operator与MapReduceWork对象关系的<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">Map&lt;Operator,
 MapReduceWork&gt;</code>对象中发现，<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">JOIN[8]</code>已经存在。此时将<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">MapReduceTask[Stage-2]</code>和<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">MapReduceTask[Stage-5]</code>合并为一个MapReduceTask</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/operator-to-mapreduce-7.png" alt="合并 Stage-2 和 Stage-5" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
同理从最后一个根节点<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">TS[c]</code>开始遍历，也会对MapReduceTask进行合并</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/operator-to-mapreduce-8.png" alt="合并 Stage-1 和 Stage-6" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<h4 id="-map-reduce-" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.16em;">
切分Map Reduce阶段</h4>
<p style="color:rgb(102,102,102);font-size:1.16em;">
最后一个阶段，将MapWork和ReduceWork中的OperatorTree以RS为界限剪开</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/operator-to-mapreduce-9.png" alt="切分Map Reduce阶段" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<h4 id="operatortree-mapreducetask-" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.16em;">
OperatorTree生成MapReduceTask全貌</h4>
<p style="color:rgb(102,102,102);font-size:1.16em;">
最终共生成3个MapReduceTask，如下图</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/operator-to-mapreduce-10.png" alt="OperatorTree生成MapReduceTask全貌" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<h3 id="phase6-" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.4em;">
Phase6 物理层优化器</h3>
<p style="color:rgb(102,102,102);font-size:1.16em;">
这里不详细介绍每个优化器的原理，单独介绍一下MapJoin的优化器</p>
<table class="confluenceTable tablesorter" style="border-collapse:collapse;border-spacing:0px;"><thead><tr class="sortableHeader" style="border-style:solid;border-width:1px 0px;border-color:rgb(204,204,204);"><th class="confluenceTh sortableHeader tablesorter-headerSortUp" style="text-align:left;">
<div class="tablesorter-header-inner">
<p class="p2" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">名称</span></p>
</div>
</th>
<th class="confluenceTh sortableHeader" style="text-align:left;">
<div class="tablesorter-header-inner">
<p class="p2" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">作用</span></p>
</div>
</th>
</tr></thead><tbody><tr style="border-style:solid;border-width:1px 0px;border-color:rgb(204,204,204);"><td class="confluenceTd" style="vertical-align:top;">
<p class="p3" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">Vectorizer</span></p>
</td>
<td class="confluenceTd" style="vertical-align:top;">
<p class="p3" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">HIVE-4160，将在0.13中发布</span></p>
</td>
</tr><tr style="border-style:solid;border-width:1px 0px;border-color:rgb(204,204,204);"><td class="confluenceTd" style="vertical-align:top;">
<p class="p3" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">SortMergeJoinResolver</span></p>
</td>
<td class="confluenceTd" style="vertical-align:top;">
<p class="p4" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">与</span><span class="s2">bucket</span><span class="s1">配合，类似于归并排序</span></p>
</td>
</tr><tr style="border-style:solid;border-width:1px 0px;border-color:rgb(204,204,204);"><td class="confluenceTd" style="vertical-align:top;">
<p class="p3" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">SamplingOptimizer</span></p>
</td>
<td class="confluenceTd" style="vertical-align:top;">
<p class="p3" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s3">并行</span><span class="s1">order by优化器，在0.12中发布</span></p>
</td>
</tr><tr style="border-style:solid;border-width:1px 0px;border-color:rgb(204,204,204);"><td class="confluenceTd" style="vertical-align:top;">
<p class="p3" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">CommonJoinResolver + MapJoinResolver</span></p>
</td>
<td class="confluenceTd" style="vertical-align:top;">
<p class="p3" style="color:rgb(102,102,102);font-size:1.16em;">
<span class="s1">MapJoin优化器</span></p>
</td>
</tr></tbody></table><h4 id="mapjoin-" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.16em;">
MapJoin原理</h4>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/mapjoin.png" alt="mapjoin原理" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
MapJoin简单说就是在Map阶段将小表读入内存，顺序扫描大表完成Join。</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
上图是Hive MapJoin的原理图，出自Facebook工程师Liyin Tang的一篇介绍Join优化的slice，从图中可以看出MapJoin分为两个阶段：</p>
<ol style="font-size:1em;"><li style="color:rgb(102,102,102);">
<p style="font-size:1em;">
通过MapReduce Local Task，将小表读入内存，生成HashTableFiles上传至Distributed Cache中，这里会对HashTableFiles进行压缩。</p>
</li><li style="color:rgb(102,102,102);">
<p style="font-size:1em;">
MapReduce Job在Map阶段，每个Mapper从Distributed Cache读取HashTableFiles到内存中，顺序扫描大表，在Map阶段直接进行Join，将数据传递给下一个MapReduce任务。</p>
</li></ol><p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/conditionaltask.png" alt="conditionaltask" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
如果Join的两张表一张表是临时表，就会生成一个ConditionalTask，在运行期间判断是否使用MapJoin</p>
<h4 id="commonjoinresolver-" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.16em;">
CommonJoinResolver优化器</h4>
<p style="color:rgb(102,102,102);font-size:1.16em;">
CommonJoinResolver优化器就是将CommonJoin转化为MapJoin，转化过程如下</p>
<ol style="font-size:1em;"><li style="color:rgb(102,102,102);">深度优先遍历Task Tree</li><li style="color:rgb(102,102,102);">找到JoinOperator，判断左右表数据量大小</li><li style="color:rgb(102,102,102);">对与小表 + 大表 =&gt; MapJoinTask，对于小/大表 + 中间表 =&gt; ConditionalTask</li></ol><p style="color:rgb(102,102,102);font-size:1.16em;">
遍历上一个阶段生成的MapReduce任务，发现<code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">MapReduceTask[Stage-2]</code> <code style="color:rgb(0,0,0);font-family:monospace, monospace;font-size:1em;background:rgb(238,238,238);border:1px solid rgb(204,204,204);">JOIN[8]</code>中有一张表为临时表，先对Stage-2进行深度拷贝（由于需要保留原始执行计划为Backup
 Plan，所以这里将执行计划拷贝了一份），生成一个MapJoinOperator替代JoinOperator，然后生成一个MapReduceLocalWork读取小表生成HashTableFiles上传至DistributedCache中。</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/mapjoin-1.png" alt="mapjoin变换" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
MapReduceTask经过变换后的执行计划如下图所示</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/mapjoin-2.png" alt="mapjoin变换" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<h4 id="mapjoinresolver-" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.16em;">
MapJoinResolver优化器</h4>
<p style="color:rgb(102,102,102);font-size:1.16em;">
MapJoinResolver优化器遍历Task Tree，将所有有local work的MapReduceTask拆成两个Task</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/MapJoinResolver-1.png" alt="MapJoinResolver" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
最终MapJoinResolver处理完之后，执行计划如下图所示</p>
<p style="color:rgb(102,102,102);font-size:1.16em;">
<img src="http://tech.meituan.com/img/hive/MapJoinResolver-2.png" alt="MapJoinResolver" style="border:0px;color:#FFFFFF;vertical-align:middle;"></p>
<h3 id="hive-sql-" style="color:rgb(42,41,53);line-height:1.5em;font-size:1.4em;">
Hive SQL编译过程的设计</h3>
<p style="color:rgb(102,102,102);font-size:1.16em;">
从上述整个SQL编译的过程，可以看出编译过程的设计有几个优点值得学习和借鉴</p>
<ul style="font-size:1em;"><li style="color:rgb(102,102,102);">使用Antlr开源软件定义语法规则，大大简化了词法和语法的编译解析过程，仅仅需要维护一份语法文件即可。</li><li style="color:rgb(102,102,102);">整体思路很清晰，分阶段的设计使整个编译过程代码容易维护，使得后续各种优化器方便的以可插拔的方式开关，譬如Hive 0.13最新的特性Vectorization和对Tez引擎的支持都是可插拔的。</li><li style="color:rgb(102,102,102);">每个Operator只完成单一的功能，简化了整个MapReduce程序。</li></ul><h3 style="color:rgb(42,41,53);line-height:1.5em;font-size:1.4em;">
社区发展方向</h3>
<p style="color:rgb(102,102,102);font-size:1.16em;">
Hive依然在迅速的发展中，为了提升Hive的性能，hortonworks公司主导的Stinger计划提出了一系列对Hive的改进，比较重要的改进有：</p>
<ul style="font-size:1em;"><li style="color:rgb(102,102,102);">Vectorization - 使Hive从单行单行处理数据改为批量处理方式，大大提升了指令流水线和缓存的利用率</li><li style="color:rgb(102,102,102);">Hive on Tez - 将Hive底层的MapReduce计算框架替换为Tez计算框架。Tez不仅可以支持多Reduce阶段的任务MRR，还可以一次性提交执行计划，因而能更好的分配资源。</li><li style="color:rgb(102,102,102);">Cost Based Optimizer - 使Hive能够自动选择最优的Join顺序，提高查询速度</li><li style="color:rgb(102,102,102);">Implement insert, update, and delete in Hive with full ACID support - 支持表按主键的增量更新</li></ul><p style="color:rgb(102,102,102);font-size:1.16em;">
我们也将跟进社区的发展，结合自身的业务需要，提升Hive型ETL流程的性能</p>
<h3 style="color:rgb(42,41,53);line-height:1.5em;font-size:1.4em;">
参考</h3>
<p style="color:rgb(102,102,102);font-size:1.16em;">
Antlr: <a href="http://www.antlr.org/" rel="nofollow" style="text-decoration:none;color:rgb(50,211,195);">http://www.antlr.org/</a><br>
Wiki Antlr介绍: <a href="http://en.wikipedia.org/wiki/ANTLR" rel="nofollow" style="text-decoration:none;color:rgb(50,211,195);">http://en.wikipedia.org/wiki/ANTLR</a><br>
Hive Wiki: <a href="https://cwiki.apache.org/confluence/display/Hive/Home" rel="nofollow" style="text-decoration:none;color:rgb(50,211,195);">https://cwiki.apache.org/confluence/display/Hive/Home</a><br>
HiveSQL编译过程: <a href="http://www.slideshare.net/recruitcojp/internal-hive" rel="nofollow" style="text-decoration:none;color:rgb(50,211,195);">http://www.slideshare.net/recruitcojp/internal-hive</a><br>
Join Optimization in Hive: <a href="https://cwiki.apache.org/confluence/download/attachments/27362054/Hive+Summit+2011-join.pdf?version=1&amp;modificationDate=1309986642000" rel="nofollow" style="text-decoration:none;color:rgb(50,211,195);">Join
 Strategies in Hive from the 2011 Hadoop Summit (Liyin Tang, Namit Jain)</a><br>
Hive Design Docs: <a href="https://cwiki.apache.org/confluence/display/Hive/DesignDocs" rel="nofollow" style="text-decoration:none;color:rgb(50,211,195);">https://cwiki.apache.org/confluence/display/Hive/DesignDocs</a></p>
<div class="hidden-mobile"><br></div>
<div class="hidden-mobile">转账自美团技术博客。<br><p style="color:rgb(102,102,102);font-size:1.16em;">
原文地址：http://tech.meituan.com/hive-sql-to-mapreduce.html</p>
</div>
</div>
            </div>
                </div>