---
layout:     post
title:      Hbase 热点(数据倾斜)问题解决方案---rowkey散列和预分区设计
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                
<div class="news_tag">转载自http://student-lp.iteye.com/blog/2309075<br><br>
                                                                          <strong><span style="font-size:18px;"> Hbase 热点(数据倾斜)问题解决方案---rowkey散列和预分区设计</span> </strong> 
<br><br><a href="http://www.iteye.com/blogs/tag/hbase%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C" rel="nofollow">hbase数据倾斜   
</a><a href="http://www.iteye.com/blogs/tag/hbase%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98" rel="nofollow">hbase热点问题   
</a><a href="http://www.iteye.com/blogs/tag/rowkey%E8%AE%BE%E8%AE%A1" rel="nofollow">rowkey设计   
</a><a href="http://www.iteye.com/blogs/tag/region%E5%88%86%E8%A3%82" rel="nofollow">region分裂</a></div>
<div id="blog_content" class="blog_content">
<div class="iteye-blog-content-contain">
<p style="font-size:14px;">     Hbase的表会被划分为1....n个Region,被托管在RegionServer中。Region二个重要的属性：Startkey与EndKey表示这个Region维护的rowkey的范围，当我们要读写数据时，如果rowkey落在某个start-end key范围内，那么就会定位到目标region并且读写到相关的数据。</p>
<p style="font-size:14px;">    默认情况下，当我们通过hbaseAdmin指定TableDescriptor来创建一张表时，只有一个region正处于混沌时期，start-end key无边界，可谓海纳百川。所有的rowkey都写入到这个region里，然后数据越来越多，region的size越来越大时，大到一定的阀值，hbase就会将region一分为二，成为2个region，这个过程称为分裂（region-split）。</p>
<p style="font-size:14px;">    如果我们就这样默认建表，表里不断的put数据，更严重的是我们的rowkey还是顺序增大的，是比较可怕的。存在的缺点比较明显：首先是热点写，我们总是向最大的start key所在的region写数据，因为我们的rowkey总是会比之前的大，并且hbase的是按升序方式排序的。所以写操作总是被定位到无上界的那个region中；其次，由于热点，我们总是往最大的start key的region写记录，之前分裂出来的region不会被写数据，有点打入冷宫的感觉，他们都处于半满状态，这样的分布也是不利的。</p>
<p style="font-size:14px;">    如果在写比较频繁的场景下，数据增长太快，split的次数也会增多，由于split是比较耗费资源的，所以我们并不希望这种事情经常发生。</p>
<p style="font-size:14px;">    在集群中为了得到更好的并行性，我们希望有好的load blance，让每个节点提供的请求都是均衡的，我们也不希望，region不要经常split，因为split会使server有一段时间的停顿，如何能做到呢？</p>
<p style="font-size:14px;">   <strong> 随机散列与预分区二者结合起来，是比较完美的</strong>。预分区一开始就预建好了一部分region，这些region都维护着自己的start-end keys，在配合上随机散列，写数据能均衡的命中这些预建的region，就能解决上面的那些缺点，大大提供性能。</p>
<p style="font-size:14px;"><strong>一、解决思路</strong></p>
<p style="font-size:14px;">    提供两种思路：hash与partition。</p>
<p style="font-size:14px;"><strong>1、hash方案</strong></p>
<p style="font-size:14px;">    hash就是rowkey前面由一串随机字符串组成，随机字符串生成方式可以由SHA或者MD5方式生成，只要region所管理的start-end keys范围比较随机，那么就可以解决写热点问题。例如：</p>
<div class="dp-highlighter">
<div class="bar">
<div class="tools">Java代码  <a title="收藏这段代码"><img class="star" src="http://student-lp.iteye.com/images/icon_star.png" alt="收藏代码"></a></div>
</div>
<ol start="1" class="dp-j"><li><span><span class="keyword">long</span><span> currentId = 1L;  </span></span></li><li><span><span class="keyword">byte</span><span> [] rowkey = Bytes.add(MD5Hash.getMD5AsHex(Bytes.toBytes(currentId))  </span></span></li><li><span>                    .substring(<span class="number">0</span><span>, </span><span class="number">8</span><span>).getBytes(),Bytes.toBytes(currentId));  </span></span></li></ol></div>
<p style="font-size:14px;">     假如rowkey原本是自增长的long型，可以将rowkey转为hash再转为bytes，加上本身id转为bytes，这样就生成随便的rowkey。那么对于这种方式的rowkey设计，如何去进行预分区呢？</p>
<ol><li>取样，先随机生成一定数量的rowkey，将取样数据按升序排序放到一个集合里。</li><li>根据预分区的region个数，对整个集合平均分割，即是相关的splitkeys。</li><li>HBaseAdmin.createTable(HTableDescriptor tableDescriptor,byte[][] splitkeys)可以指定预分区的splitkey，即指定region间的rowkey临界值。</li></ol><p style="font-size:14px;">    创建split计算器，用于从抽样数据生成一个比较合适的splitkeys</p>
<div class="dp-highlighter">
<div class="bar">
<div class="tools">Java代码  <a title="收藏这段代码"><img class="star" src="http://student-lp.iteye.com/images/icon_star.png" alt="收藏代码"></a></div>
</div>
<ol start="1" class="dp-j"><li><span><span class="keyword">public</span><span> </span><span class="keyword">class</span><span> HashChoreWoker </span><span class="keyword">implements</span><span> SplitKeysCalculator{  </span></span></li><li><span>    <span class="comment">//随机取机数目</span><span>  </span></span></li><li><span>    <span class="keyword">private</span><span> </span><span class="keyword">int</span><span> baseRecord;  </span></span></li><li><span>    <span class="comment">//rowkey生成器</span><span>  </span></span></li><li><span>    <span class="keyword">private</span><span> RowKeyGenerator rkGen;  </span></span></li><li><span>    <span class="comment">//取样时，由取样数目及region数相除所得的数量.</span><span>  </span></span></li><li><span>    <span class="keyword">private</span><span> </span><span class="keyword">int</span><span> splitKeysBase;  </span></span></li><li><span>    <span class="comment">//splitkeys个数</span><span>  </span></span></li><li><span>    <span class="keyword">private</span><span> </span><span class="keyword">int</span><span> splitKeysNumber;  </span></span></li><li><span>    <span class="comment">//由抽样计算出来的splitkeys结果</span><span>  </span></span></li><li><span>    <span class="keyword">private</span><span> </span><span class="keyword">byte</span><span>[][] splitKeys;  </span></span></li><li><span>  </span></li><li><span>    <span class="keyword">public</span><span> HashChoreWoker(</span><span class="keyword">int</span><span> baseRecord, </span><span class="keyword">int</span><span> prepareRegions) {  </span></span></li><li><span>        <span class="keyword">this</span><span>.baseRecord = baseRecord;  </span></span></li><li><span>        <span class="comment">//实例化rowkey生成器</span><span>  </span></span></li><li><span>        rkGen = <span class="keyword">new</span><span> HashRowKeyGenerator();  </span></span></li><li><span>        splitKeysNumber = prepareRegions - <span class="number">1</span><span>;  </span></span></li><li><span>        splitKeysBase = baseRecord / prepareRegions;  </span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span class="keyword">public</span><span> </span><span class="keyword">byte</span><span>[][] calcSplitKeys() {  </span></span></li><li><span>        splitKeys = <span class="keyword">new</span><span> </span><span class="keyword">byte</span><span>[splitKeysNumber][];  </span></span></li><li><span>        <span class="comment">//使用treeset保存抽样数据，已排序过</span><span>  </span></span></li><li><span>        TreeSet&lt;<span class="keyword">byte</span><span>[]&gt; rows = </span><span class="keyword">new</span><span> TreeSet&lt;</span><span class="keyword">byte</span><span>[]&gt;(Bytes.BYTES_COMPARATOR);  </span></span></li><li><span>        <span class="keyword">for</span><span> (</span><span class="keyword">int</span><span> i = </span><span class="number">0</span><span>; i &lt; baseRecord; i++) {  </span></span></li><li><span>            rows.add(rkGen.nextId());  </span></li><li><span>        }  </span></li><li><span>        <span class="keyword">int</span><span> pointer = </span><span class="number">0</span><span>;  </span></span></li><li><span>        Iterator&lt;<span class="keyword">byte</span><span>[]&gt; rowKeyIter = rows.iterator();  </span></span></li><li><span>        <span class="keyword">int</span><span> index = </span><span class="number">0</span><span>;  </span></span></li><li><span>        <span class="keyword">while</span><span> (rowKeyIter.hasNext()) {  </span></span></li><li><span>            <span class="keyword">byte</span><span>[] tempRow = rowKeyIter.next();  </span></span></li><li><span>            rowKeyIter.remove();  </span></li><li><span>            <span class="keyword">if</span><span> ((pointer != </span><span class="number">0</span><span>) &amp;&amp; (pointer % splitKeysBase == </span><span class="number">0</span><span>)) {  </span></span></li><li><span>                <span class="keyword">if</span><span> (index &lt; splitKeysNumber) {  </span></span></li><li><span>                    splitKeys[index] = tempRow;  </span></li><li><span>                    index ++;  </span></li><li><span>                }  </span></li><li><span>            }  </span></li><li><span>            pointer ++;  </span></li><li><span>        }  </span></li><li><span>        rows.clear();  </span></li><li><span>        rows = <span class="keyword">null</span><span>;  </span></span></li><li><span>        <span class="keyword">return</span><span> splitKeys;  </span></span></li><li><span>    }  </span></li><li><span>}  </span></li></ol></div>
<p style="font-size:14px;">     KeyGenerator及实现</p>
<div class="dp-highlighter">
<div class="bar">
<div class="tools">Java代码  <a title="收藏这段代码"><img class="star" src="http://student-lp.iteye.com/images/icon_star.png" alt="收藏代码"></a></div>
</div>
<ol start="1" class="dp-j"><li><span><span class="comment">//interface</span><span>  </span></span></li><li><span><span class="keyword">public</span><span> </span><span class="keyword">interface</span><span> RowKeyGenerator {  </span></span></li><li><span>    <span class="keyword">byte</span><span> [] nextId();  </span></span></li><li><span>}  </span></li><li><span><span class="comment">//implements</span><span>  </span></span></li><li><span><span class="keyword">public</span><span> </span><span class="keyword">class</span><span> HashRowKeyGenerator </span><span class="keyword">implements</span><span> RowKeyGenerator {  </span></span></li><li><span>    <span class="keyword">private</span><span> </span><span class="keyword">long</span><span> currentId = </span><span class="number">1</span><span>;  </span></span></li><li><span>    <span class="keyword">private</span><span> </span><span class="keyword">long</span><span> currentTime = System.currentTimeMillis();  </span></span></li><li><span>    <span class="keyword">private</span><span> Random random = </span><span class="keyword">new</span><span> Random();  </span></span></li><li><span>    <span class="keyword">public</span><span> </span><span class="keyword">byte</span><span>[] nextId() {  </span></span></li><li><span>        <span class="keyword">try</span><span> {  </span></span></li><li><span>            currentTime += random.nextInt(<span class="number">1000</span><span>);  </span></span></li><li><span>            <span class="keyword">byte</span><span>[] lowT = Bytes.copy(Bytes.toBytes(currentTime), </span><span class="number">4</span><span>, </span><span class="number">4</span><span>);  </span></span></li><li><span>            <span class="keyword">byte</span><span>[] lowU = Bytes.copy(Bytes.toBytes(currentId), </span><span class="number">4</span><span>, </span><span class="number">4</span><span>);  </span></span></li><li><span>            <span class="keyword">return</span><span> Bytes.add(MD5Hash.getMD5AsHex(Bytes.add(lowU, lowT)).substring(</span><span class="number">0</span><span>, </span><span class="number">8</span><span>).getBytes(),  </span></span></li><li><span>                    Bytes.toBytes(currentId));  </span></li><li><span>        } <span class="keyword">finally</span><span> {  </span></span></li><li><span>            currentId++;  </span></li><li><span>        }  </span></li><li><span>    }  </span></li><li><span>}  </span></li></ol></div>
<p style="font-size:14px;">     unit test case测试</p>
<div class="dp-highlighter">
<div class="bar">
<div class="tools">Java代码  <a title="收藏这段代码"><img class="star" src="http://student-lp.iteye.com/images/icon_star.png" alt="收藏代码"></a></div>
</div>
<ol start="1" class="dp-j"><li><span><span class="annotation">@Test</span><span>  </span></span></li><li><span><span class="keyword">public</span><span> </span><span class="keyword">void</span><span> testHashAndCreateTable() </span><span class="keyword">throws</span><span> Exception{  </span></span></li><li><span>        HashChoreWoker worker = <span class="keyword">new</span><span> HashChoreWoker(</span><span class="number">1000000</span><span>,</span><span class="number">10</span><span>);  </span></span></li><li><span>        <span class="keyword">byte</span><span> [][] splitKeys = worker.calcSplitKeys();  </span></span></li><li><span>          </span></li><li><span>        HBaseAdmin admin = <span class="keyword">new</span><span> HBaseAdmin(HBaseConfiguration.create());  </span></span></li><li><span>        TableName tableName = TableName.valueOf(<span class="string">"hash_split_table"</span><span>);  </span></span></li><li><span>          </span></li><li><span>        <span class="keyword">if</span><span> (admin.tableExists(tableName)) {  </span></span></li><li><span>            <span class="keyword">try</span><span> {  </span></span></li><li><span>                admin.disableTable(tableName);  </span></li><li><span>            } <span class="keyword">catch</span><span> (Exception e) {  </span></span></li><li><span>            }  </span></li><li><span>            admin.deleteTable(tableName);  </span></li><li><span>        }  </span></li><li><span>  </span></li><li><span>        HTableDescriptor tableDesc = <span class="keyword">new</span><span> HTableDescriptor(tableName);  </span></span></li><li><span>        HColumnDescriptor columnDesc = <span class="keyword">new</span><span> HColumnDescriptor(Bytes.toBytes(</span><span class="string">"info"</span><span>));  </span></span></li><li><span>        columnDesc.setMaxVersions(<span class="number">1</span><span>);  </span></span></li><li><span>        tableDesc.addFamily(columnDesc);  </span></li><li><span>  </span></li><li><span>        admin.createTable(tableDesc ,splitKeys);  </span></li><li><span>  </span></li><li><span>        admin.close();  </span></li><li><span>    }  </span></li></ol></div>
<p style="font-size:14px;">     查看建表结果，执行：scan 'hbase:meta'</p>
<p style="font-size:14px;"><img alt="" src="http://dl2.iteye.com/upload/attachment/0118/4295/6a4e4a5d-d928-3850-908f-c18b20efb9d4.jpg" height="355" width="618"><br>
    以上我们只是显示了部分region的信息，可以看到region的start-end key还是比较随机散列的。同样可以查看hdfs的目录结构，的确和预期的38个预分区一致： </p>
<p style="font-size:14px;"><img alt="" src="http://dl2.iteye.com/upload/attachment/0118/4297/9a1f2400-635c-394b-a3ce-72295043fd02.jpg" height="730" width="445"><br>
    以上就是按照hash方式，预建好分区，以后再插入数据的时候，也是按照此rowkeyGenerator的方式生成rowkey。</p>
<p style="font-size:14px;"><strong>2、partition的方式</strong></p>
<p style="font-size:14px;">    partition顾名思义就是分区式，这种分区有点类似于mapreduce中的partitioner，将区域用长整数作为分区号，每个region管理着相应的区域数据，在rowkey生成时，将ID取模后，然后拼上ID整体作为rowkey，这个比较简单，不需要取样，splitkeys也非常简单，直接是分区号即可。直接上代码：</p>
<div class="dp-highlighter">
<div class="bar">
<div class="tools">Java代码  <a title="收藏这段代码"><img class="star" src="http://student-lp.iteye.com/images/icon_star.png" alt="收藏代码"></a></div>
</div>
<ol start="1" class="dp-j"><li><span><span class="keyword">public</span><span> </span><span class="keyword">class</span><span> PartitionRowKeyManager </span><span class="keyword">implements</span><span> RowKeyGenerator,  </span></span></li><li><span>        SplitKeysCalculator {  </span></li><li><span>  </span></li><li><span>    <span class="keyword">public</span><span> </span><span class="keyword">static</span><span> </span><span class="keyword">final</span><span> </span><span class="keyword">int</span><span> DEFAULT_PARTITION_AMOUNT = </span><span class="number">20</span><span>;  </span></span></li><li><span>    <span class="keyword">private</span><span> </span><span class="keyword">long</span><span> currentId = </span><span class="number">1</span><span>;  </span></span></li><li><span>    <span class="keyword">private</span><span> </span><span class="keyword">int</span><span> partition = DEFAULT_PARTITION_AMOUNT;  </span></span></li><li><span>    <span class="keyword">public</span><span> </span><span class="keyword">void</span><span> setPartition(</span><span class="keyword">int</span><span> partition) {  </span></span></li><li><span>        <span class="keyword">this</span><span>.partition = partition;  </span></span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span class="keyword">public</span><span> </span><span class="keyword">byte</span><span>[] nextId() {  </span></span></li><li><span>        <span class="keyword">try</span><span> {  </span></span></li><li><span>            <span class="keyword">long</span><span> partitionId = currentId % partition;  </span></span></li><li><span>            <span class="keyword">return</span><span> Bytes.add(Bytes.toBytes(partitionId),  </span></span></li><li><span>                    Bytes.toBytes(currentId));  </span></li><li><span>        } <span class="keyword">finally</span><span> {  </span></span></li><li><span>            currentId++;  </span></li><li><span>        }  </span></li><li><span>    }  </span></li><li><span>  </span></li><li><span>    <span class="keyword">public</span><span> </span><span class="keyword">byte</span><span>[][] calcSplitKeys() {  </span></span></li><li><span>        <span class="keyword">byte</span><span>[][] splitKeys = </span><span class="keyword">new</span><span> </span><span class="keyword">byte</span><span>[partition - </span><span class="number">1</span><span>][];  </span></span></li><li><span>        <span class="keyword">for</span><span>(</span><span class="keyword">int</span><span> i = </span><span class="number">1</span><span>; i &lt; partition ; i ++) {  </span></span></li><li><span>            splitKeys[i-<span class="number">1</span><span>] = Bytes.toBytes((</span><span class="keyword">long</span><span>)i);  </span></span></li><li><span>        }  </span></li><li><span>        <span class="keyword">return</span><span> splitKeys;  </span></span></li><li><span>    }  </span></li><li><span>}  </span></li></ol></div>
<p style="font-size:14px;">    calcSplitKeys方法比较单纯，splitkey就是partition的编号，测试类如下：</p>
<div class="dp-highlighter">
<div class="bar">
<div class="tools">Java代码  <a title="收藏这段代码"><img class="star" src="http://student-lp.iteye.com/images/icon_star.png" alt="收藏代码"></a></div>
</div>
<ol start="1" class="dp-j"><li><span><span class="annotation">@Test</span><span>  </span></span></li><li><span>    <span class="keyword">public</span><span> </span><span class="keyword">void</span><span> testPartitionAndCreateTable() </span><span class="keyword">throws</span><span> Exception{  </span></span></li><li><span>          </span></li><li><span>        PartitionRowKeyManager rkManager = <span class="keyword">new</span><span> PartitionRowKeyManager();  </span></span></li><li><span>        <span class="comment">//只预建10个分区</span><span>  </span></span></li><li><span>        rkManager.setPartition(<span class="number">10</span><span>);  </span></span></li><li><span>          </span></li><li><span>        <span class="keyword">byte</span><span> [][] splitKeys = rkManager.calcSplitKeys();  </span></span></li><li><span>          </span></li><li><span>        HBaseAdmin admin = <span class="keyword">new</span><span> HBaseAdmin(HBaseConfiguration.create());  </span></span></li><li><span>        TableName tableName = TableName.valueOf(<span class="string">"partition_split_table"</span><span>);  </span></span></li><li><span>          </span></li><li><span>        <span class="keyword">if</span><span> (admin.tableExists(tableName)) {  </span></span></li><li><span>            <span class="keyword">try</span><span> {  </span></span></li><li><span>                admin.disableTable(tableName);  </span></li><li><span>  </span></li><li><span>            } <span class="keyword">catch</span><span> (Exception e) {  </span></span></li><li><span>            }  </span></li><li><span>            admin.deleteTable(tableName);  </span></li><li><span>        }  </span></li><li><span>  </span></li><li><span>        HTableDescriptor tableDesc = <span class="keyword">new</span><span> HTableDescriptor(tableName);  </span></span></li><li><span>        HColumnDescriptor columnDesc = <span class="keyword">new</span><span> HColumnDescriptor(Bytes.toBytes(</span><span class="string">"info"</span><span>));  </span></span></li><li><span>        columnDesc.setMaxVersions(<span class="number">1</span><span>);  </span></span></li><li><span>        tableDesc.addFamily(columnDesc);  </span></li><li><span>  </span></li><li><span>        admin.createTable(tableDesc ,splitKeys);  </span></li><li><span>  </span></li><li><span>        admin.close();  </span></li><li><span>    }  </span></li></ol></div>
<p style="font-size:14px;">     <span style="font-size:14px;">同样我们可以看看meta表和hdfs的目录结果，其实和hash类似，region都会分好区。</span></p>
<p><span style="font-size:14px;">     通过partition实现的loadblance写的话，当然生成rowkey方式也要结合当前的region数目取模而求得，大家同样也可以做些实验，看看数据插入后的分布。</span></p>
<p><span style="font-size:14px;">     在这里也顺提一下，如果是顺序的增长型原id,可以将id保存到一个数据库，传统的也好,redis的也好，每次取的时候，将数值设大1000左右，以后id可以在内存内增长，当内存数量已经超过1000的话，再去load下一个，有点类似于oracle中的sqeuence.</span></p>
<p><span style="font-size:14px;">     随机分布加预分区也不是一劳永逸的。因为数据是不断地增长的，随着时间不断地推移，已经分好的区域，或许已经装不住更多的数据，当然就要进一步进行split了，同样也会出现性能损耗问题，所以我们还是要规划好数据增长速率，观察好数据定期维护，按需分析是否要进一步分行手工将分区再分好，也或者是更严重的是新建表，做好更大的预分区然后进行数据迁移。如果数据装不住了，对于partition方式预分区的话，如果让它自然分裂的话，情况分严重一点。因为分裂出来的分区号会是一样的，所以计算到partitionId的话，其实还是回到了顺序写年代，会有部分热点写问题出现，如果使用partition方式生成主键的话，数据增长后就要不断地调整分区了，比如增多预分区，或者加入子分区号的处理.(我们的分区号为long型，可以将它作为多级partition)</span></p>
<p><span style="font-size:14px;">    以上基本已经讲完了防止热点写使用的方法和防止频繁split而采取的预分区。但rowkey设计，远远也不止这些，比如rowkey长度，然后它的长度最大可以为char的MAXVALUE,但是看过之前我写KeyValue的分析知道，我们的数据都是以KeyValue方式存储在MemStore或者HFile中的，每个KeyValue都会存储rowKey的信息，如果rowkey太大的话，比如是128个字节，一行10个字段的表，100万行记录，光rowkey就占了1.2G+所以长度还是不要过长，另外设计，还是按需求来吧。</span></p>
</div>
</div>
            </div>
                </div>