---
layout:     post
title:      hadoop入门6
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                <p>HBASE基础知识</p><p>HBASE的伪分布的搭建</p><p>HBASE Shell</p><p>HBASE的批量导入</p><p>HBASE的JAVA客户端</p><p>HBASE的集群的搭建</p><p>HABASE的表设计</p><p>HBASE的底层存储模型</p><p>HBase(column DB)：面向列的数据库</p><p>HBase是一个高可靠性，高性能，面向列，可伸缩的分布式存储系统。面向列的数据库。HDBase利用HDFS作为其文件存储系统，利用Map/Reduce来分析数据。</p><p><span style="color:#ff0000;">概念：</span></p><p><span style="color:#ff0000;">主键</span><span style="color:#000000;">：Row Key（行键）。</span></p><p><span style="color:#000000;">        访问数据有三种方式：</span></p><p><span style="color:#000000;">        1.通过单个row key访问。<br></span></p><p><span style="color:#000000;">        2.通过row key的range（范围）<br></span></p><p><span style="color:#000000;">        3.全表扫描<br></span></p><p><span style="color:#ff0000;">列族</span>:Column Family</p><p>        列族在创建表的时候声明，<span style="color:#ff0000;">一个列族可以包含多个列</span>，列中的数据以二进制形式存在，没有数据类型。<br></p><p><span style="color:#ff0000;">时间戳</span>：timestamp。</p><p>        HBase中通过row和colums确定的为一个存储单元称为cell。每个cell都保存着同一份数据的多个版本。版本通过时间戳来索引。一个cell里面可以存多个数据。<br></p><p>新浪微博-&gt;Redis-&gt;HBase</p><p>单节点部署：修改配置文件</p><p>vim hbase-env.sh            29行，把JAVA_HOME导入进来</p><p></p><p>vim hbase-site.xml     </p><p>    &lt;property&gt;</p>                &lt;name&gt;hbase.rootdir&lt;/name&gt;<br>                &lt;value&gt;file:///root/hbase&lt;/value&gt;<br><p>        &lt;/property&gt;</p><p>在Bin目录下调用脚本就ok了start-hbase.sh，这个时候启动jps会显示进程：HMaster。</p><p>使用hbase命令行来操作hbase:bin目录下：./hbase命令 ./hbae shell </p><p>对表的操作:ddl.对数据的操作：dml </p><p>create 't1', 't2', 't3' ,'t4'</p><p></p><p>创建一张表：hbase(main):012:0&gt; <span style="color:#ff0000;">create 'people'</span>,{NAME=&gt;'info',VERSIONS=&gt;3},{NAME=&gt;'data',VERSIONS=&gt;1}</p>0 row(s) in 0.5810 seconds<br>=&gt; Hbase::Table - people<br><p>list指令    desc指令    用来查看表和查看数据信息 describe</p><p>插入数据：put指令。help 'put'</p><p> hbase&gt; t.put 'r1', 'c1', 'value', ts1  表明，列明，值 time stamp</p><p>put 'people' ,'rk0001','info:name','cls'</p><p>put 'people','rk0001','info:gender','female'           scan 'people'</p><p><span style="color:#ff0000;">ROW                  COLUMN+CELL                                               <br> rk0001              column=info:gender, timestamp=1530840939607, value=female <br> rk0001              column=info:name, timestamp=1530840571602, value=lsc      <br></span></p><p><span style="color:#ff0000;">1 row(s) in 0.0780 seconds        返回的是1行，</span></p><p><span style="color:#ff0000;">一个列族下面可以有N多个列，随便定义</span></p><p><span style="color:#ff0000;">hbase(main):009:0&gt; put 'people','rk0002','info:gender','female'<br></span></p><p><span style="color:#ff0000;"><br></span></p><p><span style="color:#000000;">hbase(main):010:0&gt; scan 'people'<br>ROW                  COLUMN+CELL                                               <br> rk0001              column=data:torrent, timestamp=1530841653382, value=\xEF\x<br>                     BF\xBD\xEF\xBF\xBD                                        <br> rk0001              column=info:gender, timestamp=1530840939607, value=female <br> rk0001              column=info:name, timestamp=1530840571602, value=lsc      <br> rk0001              column=info:size, timestamp=1530841529101, value=36       <br> rk0002              column=info:gender, timestamp=1530841933403, value=female <br> rk0002              column=info:name, timestamp=1530841793927, value=bdyjy    <br>2 row(s) in 0.0210 seconds<br></span></p><p>每一行含有几列，每列的内容是列族中的内容，可以自己定义多个内容。</p><p><br><br><span style="color:#ff0000;">hbase(main):011:0&gt; put 'people','rk0001','info:size','37'<br>0 row(s) in 0.0090 seconds</span><br><br>hbase(main):012:0&gt; scan 'people'<br>ROW                  COLUMN+CELL                                               <br> rk0001              column=data:torrent, timestamp=1530841653382, value=\xEF\x<br>                     BF\xBD\xEF\xBF\xBD                                        <br> rk0001              column=info:gender, timestamp=1530840939607, value=female <br> rk0001              column=info:name, timestamp=1530840571602, value=lsc      <br> rk0001              column=info:size, timestamp=1530842043472, value=37       <br> rk0002              column=info:gender, timestamp=1530841933403, value=female <br> rk0002              column=info:name, timestamp=1530841793927, value=bdyjy    <br>2 row(s) in 0.0310 seconds<br></p><p><span style="color:rgb(255,0,0);">hbase(main):011:0&gt; put 'people','rk0001','info:size','38'</span><br style="color:rgb(255,0,0);"><span style="color:rgb(255,0,0);">0 row(s) in 0.0090 seconds</span><br></p><p>hbase(main):014:0&gt; scan 'people'<br>ROW                  COLUMN+CELL                                               <br> rk0001              column=data:torrent, timestamp=1530841653382, value=\xEF\x<br>                     BF\xBD\xEF\xBF\xBD                                        <br> rk0001              column=info:gender, timestamp=1530840939607, value=female <br> rk0001              column=info:name, timestamp=1530840571602, value=lsc      <br> rk0001              column=info:size, timestamp=1530842095702, value=38       <br> rk0002              column=info:gender, timestamp=1530841933403, value=female <br> rk0002              column=info:name, timestamp=1530841793927, value=bdyjy    <br></p><p>2 row(s) in 0.0120 second            </p><p>info这个列族的VERSION是3， scan 'people',{COLUMNS =&gt;'info',VERSIONS=&gt;3}</p><p>最大版本只有3个  如果再插一条数据就会把第一个给覆盖了。 </p><p>将覆盖的内容查出来,由于还没有进行flush。退出再进来就查不出来了。</p><p><span style="background-color:rgb(255,255,255);"><span style="color:#ff0000;">scan 'people', {RAW=&gt;true,VERSIONS=&gt;10}     进程一停止重新进来时就会被消除。</span></span></p><p><span style="color:#ff0000;"><span style="background-color:rgb(255,255,255);">列族+列的名称占一列的。可以动态添加各种列。并且每一个数据都是立体的，没保存数据的内存不需要占据空间的。</span></span></p><p>十分的灵活，</p><p><img src="https://img-blog.csdn.net/20180706101144222?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ludmluY2libGVGRg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p><p>rowkey是行键，info是列族， 下面的name.gender是列名（列的标识符），存储数据的格子叫cell。一个cell里面可以保存多个值，每个值都有一个time stamp</p><p><span style="color:#ff0000;">首先通过行row key来定义，再通过列族加上列的标识符来定义一个cell。</span></p><p><span style="color:#ff0000;"><br></span></p><p><span style="font-size:18px;color:#ff0000;">HBASE集群搭建</span></p><p><span style="font-size:18px;color:#ff0000;">      </span><span style="color:#000000;"><span style="font-size:18px;"> </span><span style="font-size:16px;"> 1.启动HDFS：首先启动zookeeper，再启动HDFS。</span></span></p><p><span style="color:#000000;"><span style="font-size:16px;">          2.在一台机器上修改配置文件，直接拷贝到其他节点上。<br></span></span></p><p><span style="font-size:16px;color:#000000;">第一修改文件：修改</span><span style="font-size:16px;color:#ff0000;">hbase-site.xml</span><span style="font-size:16px;color:#000000;">即可</span></p><p>                        &lt;property&gt;<br></p><p>                                    &lt;name&gt;hbase.rootdir&lt;/name&gt;<br></p><p>                                    &lt;value&gt;hdfs://ns1/hbase&lt;/value&gt;        //存放路径，就在hbase的根目录下<br></p><p>                        &lt;/property<br></p><p>把相关文件夹的内容拷贝过来就OK了，有很多属性</p><p><span style="color:#ff0000;">第二修改文件</span>：hbase-env.sh也需要配置：里面修改JAVA_HOME（单节点）。</p><p>集群模式：<span style="color:#ff0000;">vim hbase-env.sh</span>        122行:告诉HBASE是否管理Zookeeper的实例 这里改成false  以后HBASE链接的是外部的zk，不用自己的zk。</p><p>指定hbase的小弟 </p><p></p><p>第三修改文件 ：<span style="background-color:rgb(255,255,255);"><span style="color:#ff0000;">vim regionservers</span></span>：</p><p>        itcast03<span>	</span>itcast04<span>	</span>itcast05<span>	</span>itcast06  这里指定哪些机器启动HBase。默认是localhost。</p><p>利用1号车将修改好的配置文件拷贝给其他的节点上。    Region Servers管理界面：60010</p><p>将映射文件拷贝到HBase上的conf目录，</p><p>./hbase-daemon.sh start master</p><p><br></p><p>HBASE理论知识</p><p>        物理存储Table在行的方向上分割为多个HRegion，一个region由[startkey,endkey]表示。分布式存储和负载均衡最小的单位就是Region。存储数据时候存放到不同的机器上去。分布存储在不同的机器上，压力就没那么大了。Region在RegionServer里。 Hbase的老大：HMaster,小弟是HRegionServer。这个Server是用来维护Region的，Region是最小的单元。有索引，按照字典顺序排序。    </p><p>        也就是数据要存储在不同的计算机上，将数据分布式存储在不同的机器上。将一个数据表来划分为多个HRegion，Region是用来存储数据的。Region在Region Servers。<span style="color:#ff0000;">HBase的老大是HMaster,小弟是HRegionServer。1号机器和2号机器上面同时会有HMaster，通过Zookeeper来进行协调的，保证了高可靠性。5号机器上有HRegionServer,这个Server是用来存储数据的。</span><span style="color:#000000;">Region是放在内存当中的，每隔一段时间会把数据写入到HDFS中。老大和小弟都有多个，会进行集群切换。已经按照字典进行排序了。比如第一个Region:保存1，11,111等ID，第二个Region保存和2有关的，因此也就有索引。ResionServer维护着Resion，一个表中有多个Region，这些Region存放在多个机器上。</span></p><p><span style="color:#000000;"><img src="https://img-blog.csdn.net/20180709160601441?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ludmluY2libGVGRg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></span></p><p>按照rowkey来进行排序的，这里面有5个Region,第一个Region是0-2，包含前面不包含后面。 1开头的：第一个Region。如果要查5000的内容，首先确定在rs2中，再进行插入。如果是6W的数据，插入到rs2中：分布式存储。</p><p><img src="https://img-blog.csdn.net/20180709161605450?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ludmluY2libGVGRg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p><p>Zookeeper用来协调HMASTER,HMASTER是管理HRegionServer,HRegion里面是存储的数据，一个HRegion只能对应一个HRegionServer。过多的VERSION会放入到MapStrore。数据存放在StoreFile中，然后再写入到HDFS中去。</p><p><br></p><p>利用JAVA接口的方式进行开发：</p><p>                            Configuration conf=HBaseConfiguration.create();                            conf.set("hbase.zookeeper.quorum","itcast04:2181,itcast05:2181,itcast06:2181");</p><p>                                HBaseAdmin admin=new HBaseAdmin(conf);<br></p><p>            HTableEdscriptor htd=new HTableDescriptor(TableName.valueOf("peoples"));<br></p><p>           HColumnDescriptor hcd_info=new HColumnDescriptor("info")    //列族                     HColumnDescriptor hcd_data=new HColumnDescriptor("data")    //列族     </p><p>                            hcd_info.setMaxVersions(3);        //设定VERSIONS的版本为3<br></p><p>                            htd.addFamiy(hcd_info);        //往表里面添加列族</p><p>                            htd.addFamiy(hcd_data);        //往表里面添加列族<br></p><p>                            admin.createTable();     //传递表的描述,创建表，有两个列族<br></p><p><br></p><p><span style="color:#ff0000;">HBase理论知识：</span></p><p><span style="color:#ff0000;">        Master：<br></span></p><p>        1.为ReginServer分配region        2.负责region server的负载均衡<br></p><p>        3.发现失效的region server并重新分配其上的region<br></p><p>        4.GFS上的垃圾文件回收<br></p><p>        5.处理schema更新请求<br></p><p>        Region Server<br></p><p>        1.维护Master分配给它的region，处理对这些region的IO请求。<br></p><p>        2.Region server负责切分在运行过程中变得更大的region<br></p><p><span style="color:#ff0000;">可以看到，client访问hbase上数据的过程并不需要master参与（寻址访问zookeeper和region server，写访问region server），master仅仅维护着table和region的元数据信息，负载很低。</span></p><p><span style="color:#000000;">HBase中有两张特殊的Table，-ROOT-和.META.  </span></p><p><span style="color:#000000;">-ROOT-记录了.META.的region信息，是一张特殊的表，只有一个region，保存了元数据信息。</span></p><p><span style="color:#000000;">.META.表记录了用户自己创建的元数据信息。用户可以创建N多表。</span></p><p><span style="color:#ff0000;">Client访问用户数据之前需要首先访问zookeeper，然后访问-ROOT-表，接着访问.META.表，最后才能找到用户数据的位置去访问。</span></p><p><img src="https://img-blog.csdn.net/201807091823215?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ludmluY2libGVGRg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>            </div>
                </div>