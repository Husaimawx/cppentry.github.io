---
layout:     post
title:      简单认识下注册表的HIVE文件格式
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                作 者:  Sysnap<br>---------------------------------------------<br>目录<br>1 用windbg简单认识下HIVE文件<br>2 用ZwSaveKey生成一个HIVE文件<br>3 ring3来简单解释这个HIVE文件<br><br>1 用windbg简单认识下HIVE文件<br>物理上的HIVE文件<br>1 注册表是由许多个HIVE文件组成的<br>2 一个HIVE文件由许多个BIN组成,一般一个HIVE文件的开头会有一个文件头,用与描述这个HIVE文件的一些全局信息<br>3 一个BIN由许多个CELL组成<br>而CELL有好几种类型<br>比如 key cell(cm_key_node) value cell(CM_KEY_VALUE) subbkey-list cell,value-<br><br>list cell等<br><br>一个HIVE文件的结构<br>-------------         |<br>_HBASE_BLOCK |<br>_BIN0        |<br>_BIN1        |<br>_BIN2        |<br>:                | <br>:                |<br>_BINx        |<br>------------- |<br>一般自己映射HIVE文件,得到映射的基地址,这个基地址加上1页的大小就来到第一个BIN了<br>,BIN也是一个数据结构,里面也包含了一些描述这个BIN的信息,我们称之为BIN头,一个BIN<br>头的大小一般是0X20,所以一个BIN后的0X20开始就是我们的第一个CELL了,怎样把一个键及其下面的子键保存为HIVE文件,微软提供了API RegSaveKey,建议学习的时候用这个API来生成一个简单的HIVE文件,然后用WINHEX之类的工具查看该HIVE文件的内部,知道个大概<br><br>注册表相关的函数<br><br>用户态的regxxx<br>内核的NT和CM系列(关于CM系列的,一般都是没有导出的,如果想使用可以靠导出的获取没<br><br>导出的方法)<br><br>实验:<br>0 用winHex打开一个HIVE文件,看看其里面的内容<br><br>1了解与注册表有关的几个结构<br>用命令 dt nt!*cm*<br>这样就会列出一大堆数据结构出来,关于每个数据结构是怎样的,自己再dt看<br>比较重要的有<br>(HBASE_BLOCK)<br>NT!_CMHIVE<br>NT!_CMHIVE<br>NT!_CM_KEY_HASH<br>NT!_CM_KEY_BODY<br>NT!_CM_KEY_NODE<br>NT!_CM_KEY_VALUE<br>NT!_CM_KEY_SECURITY<br>NT!_CM_KEY_CONTROL_BLOCK<br><br>2一个简单的实验<br>lkd&gt; !reg dumppool<br>...略,这里会列出许多的HIVE<br><br>dumping hive at e1022b60 (NONAME)<br>Stable Length = 1000<br>1/1 pages present<br>Volatile Length = 1000<br>can't read HMAP_ENTRY at e1b16000<br>0/1 pages present<br>Total pages present = 4311 / 14680<br><br>用!reg baseblock查看这个HIVE的基块<br><br>lkd&gt; !reg baseblock e1022b60<br>FileName : NONAME<br>Signature: HBASE_BLOCK_SIGNATURE<br>Sequence1: 1<br>Sequence2: 1<br>TimeStamp: 0 0<br>Major    : 1<br>Minor    : 3<br>Type     : HFILE_TYPE_PRIMARY<br>Format   : HBASE_FORMAT_MEMORY<br>RootCell : 20<br>Length   : 0<br>Cluster : 1<br>CheckSum : 0<br><br><br>用!reg openkeys列出HIVE文件所有打开的键<br><br>lkd&gt; !reg openkeys e1022b60<br><br>Index 48: 1cbf04a8 kcb=e1035a70 cell=00000188 f=00200004 /REGISTRY/USER<br>Index 1b8: dc72ea09 kcb=e3fefb48 cell=80000020 f=00300008<br><br>/REGISTRY/USER/S-1-5-18<br>Index 595: d936a631 kcb=e1035008 cell=00000020 f=002c0000 /REGISTRY<br>Index 698: bd68092e kcb=e1035248 cell=00000120 f=00200004<br><br>/REGISTRY/MACHINE<br><br>用!reg cellindex查看一下打开键的CELL单元.它是一个_cm_key_node结构<br><br>kd&gt; !reg cellindex e1022b60 0x120<br><br>Map = e1022bc0 Type = 0 Table = 0 Block = 0 Offset = 120<br>MapTable     = e1033000 <br>BlockAddress = e1032000<br><br>pcell: e1032124<br><br>得到CELL的地址pcell: e1032124后,接着<br>lkd&gt; dt _cm_key_node e1032124<br>nt!_CM_KEY_NODE<br>   nt!_CM_KEY_NODE<br>   +0x000 Signature        : 0x6b6e<br>   +0x002 Flags            : 0x20<br>   +0x004 LastWriteTime    : _LARGE_INTEGER 0x1c8a59a`913acf5a<br>   +0x00c Spare            : 0<br>   +0x010 Parent           : 0x20<br>   +0x014 SubKeyCounts     : [2] 5<br>   +0x01c SubKeyLists      : [2] 0x448<br>   +0x024 ValueList        : _CHILD_LIST<br>   +0x01c ChildHiveReference : _CM_KEY_REFERENCE<br>   +0x02c Security         : 0x78<br>   +0x030 Class            : 0xffffffff<br>   +0x034 MaxNameLen       : 0x10<br>   +0x038 MaxClassLen      : 0<br>   +0x03c MaxValueNameLen : 0<br>   +0x040 MaxValueDataLen : 0<br>   +0x044 WorkVar          : 0<br>   +0x048 NameLength       : 7<br>   +0x04a ClassLength      : 0<br>   +0x04c Name             : [1] 0x414d<br><br>我们来解读这里的信息:<br>1 +0x000 Signature        : 0x6b6e 0x6b6e表示NK,_cm_key_node结构的标识符<br>2 +0x014 SubKeyCounts     : [2] 5 表示该键有5个子键<br>3 +0x01c SubKeyLists      : [2] 0x448 表示子键列表单元的单元索引为0x448<br>4 +0x024 ValueList        : _CHILD_LIST 表示本键键值单元的索引<br><br>注册表的组织<br>这里我们首先了解一个概念,单元索引<br>单元索引:是一个CELL在HIVE文件上的偏移量<br>看一下_CM_KEY_NODE这个结构,我们以HKEY_LOCAL_MACHINE/SYSTEM/ControlSet001<br><br>/Services/6to4这个键为例,你可以把它及其子键保存为HIVE文件,然后观察<br><br>lkd&gt; dt _CM_KEY_NODE<br>nt!_CM_KEY_NODE<br>   +0x000 Signature        : Uint2B<br>   +0x002 Flags            : Uint2B<br>   +0x004 LastWriteTime    : _LARGE_INTEGER<br>   +0x00c Spare            : Uint4B<br>   +0x010 Parent           : Uint4B<br>   +0x014 SubKeyCounts     : [2] Uint4B<br>   +0x01c SubKeyLists      : [2] Uint4B<br>   +0x024 ValueList        : _CHILD_LIST<br>   +0x01c ChildHiveReference : _CM_KEY_REFERENCE<br>   +0x02c Security         : Uint4B<br>   +0x030 Class            : Uint4B<br>   +0x034 MaxNameLen       : Uint4B<br>   +0x038 MaxClassLen      : Uint4B<br>   +0x03c MaxValueNameLen : Uint4B<br>   +0x040 MaxValueDataLen : Uint4B<br>   +0x044 WorkVar          : Uint4B<br>   +0x048 NameLength       : Uint2B<br>   +0x04a ClassLength      : Uint2B<br>   +0x04c Name             : [1] Uint2B<br>A键值<br>HKEY_LOCAL_MACHINE/SYSTEM/ControlSet001/Services/6to4这个键就是一个<br><br>_CM_KEY_NODE结构,ValueList的值就是一个单元索引了,由这个"单元索引"我们可以找到<br><br>6to4这个键的"键值列表单元",有了"键值列表单元",我们就可以找到"键值单元",有了键<br><br>值单元,我们就可以找到数据了<br>一般就是下面这条线<br>----------------------------------------------------------------------------<br>键单元----键值列表单元单元索引---键值列表单元--键值单元--数据单元<br>----------------------------------------------------------------------------<br>B子键<br>HKEY_LOCAL_MACHINE/SYSTEM/ControlSet001/Services/6to4下面还有三个子键,怎么找,<br><br>请看_CM_KEY_NODE里面的俩个成员<br>+0x014 SubKeyCounts     : [2] Uint4B<br>+0x01c SubKeyLists      : [2] Uint4B<br><br>SubKeyCounts表示这个键单元有多少个子键,SubKeyLists是子键列表单元的单元索引<br>所以一般SubKeyCounts是用于控制遍历子键的一个变量,这里我们应该知道怎么找到一个<br><br>键单元的子键了<br>----------------------------------------<br>SubKeyLists----子键列表单元-----子键单元<br>----------------------------------------<br>一个键可能有多个子键,由SubKeyCounts标识<br><br><br><br>2 用ZwSaveKey生成一个HIVE文件<br>这里我们用驱动程序,不过用户程序也是可以的,很简单,就是获得ZwSaveKey所需要的句柄,这里我们用了ZwOpenKey和ZwCreateFile,我们把//REGISTRY//MACHINE//SYSTEM//ControlSet001//Services这个键极其子键保存为一个HIVE文件.这个HIVE文件的路径是C:/my.dat<br><br>NTSTATUS DriverEntry(IN PDRIVER_OBJECT theDriverObject, <br>           IN PUNICODE_STRING theRegistryPath)<br>{<br>  <br>  HANDLE keyhandle,filehandle;<br>  <br>  IO_STATUS_BLOCK iostatus;<br>  OBJECT_ATTRIBUTES keyoa ,fileoa;<br>    <br>  UNICODE_STRING  keypath,filepath;<br>  RtlInitUnicodeString(&amp;keypath,L"//REGISTRY//MACHINE//SYSTEM//ControlSet001//Services");<br>    RtlInitUnicodeString(&amp;filepath,L"//Device//HarddiskVolume1//my.dat");<br>  <br>  InitializeObjectAttributes(<br>    &amp;keyoa,<br>  &amp;keypath,<br>    OBJ_CASE_INSENSITIVE,<br>    0,<br>    0<br>    );<br>  InitializeObjectAttributes(<br>    &amp;fileoa,<br>  &amp;filepath,<br>    OBJ_CASE_INSENSITIVE| OBJ_KERNEL_HANDLE,<br>    0,<br>    0<br>    );<br>  <br>  <br>  ZwOpenKey(&amp;keyhandle,<br>          KEY_ALL_ACCESS,<br>        &amp;keyoa);<br><br>  <br>  ZwCreateFile(<br>             &amp;filehandle,<br>                 FILE_ALL_ACCESS,<br>                 &amp;fileoa,<br>                 &amp;iostatus,<br>                 NULL,<br>                 FILE_ATTRIBUTE_NORMAL,<br>                 FILE_SHARE_READ|FILE_SHARE_WRITE,<br>                 FILE_Create| FILE_OPEN | FILE_OVERWRITE_IF,<br>                 FILE_SYNCHRONOUS_IO_NONALERT,<br>                 NULL,<br>                 NULL <br>         );<br><br>  ZwSaveKey(keyhandle, <br>          filehandle );<br>    <br>  theDriverObject-&gt;DriverUnload = OnUnload; <br>  return STATUS_SUCCESS;<br><br>}<br><br><br>3 ring3来简单解释这个HIVE文件<br><br>好了,到了这一步我们已经有了一个HIVE文件,接着我们就是解释它<br>首先把这个HIVE文件读入内存,基地址加上一个页的大小就来到了第一个BIN,BIN头大小是0X20我们不用理,加上0X20后我们就来到了第一个CELL...即ROOTCELL...接着就是开始解释这个HIVE文件了<br><br>void ListValue( PCHAR keypath,  PCM_KEY_NODE KeyNode ) <br>{<br>    char *SubKeyName=keypath;<br>  PCHAR val;<br>  <br>  memcpy(keypath,&amp;KeyNode-&gt;KeyName,KeyNode-&gt;KeyName); <br>  keypath+=KeyNode-&gt;KeyName_len;<br>  printf("the key name      :%s/n",   SubKeyName);<br><br>    <br>}<br><br><br>void ListSubKeys( PCHAR keypath,  PCM_KEY_NODE KeyNode ) <br>{<br>    RootBin=(PCHAR)KeyNode-0x20;<br>   <br>  PCM_KEY_FAST_INDEX dirKey = (PCM_KEY_FAST_INDEX)(RootBin+KeyNode-&gt;Subkeys_offset);<br>    for(ULONG index1=0;index1&lt;dirKey-&gt;NumberOfKeys;index1++)<br>  {<br>    <br>        PCM_KEY_FAST_INDEX subkey = (PCM_KEY_FAST_INDEX)((&amp;dirKey-&gt;ValueData_Offset)[index1]+RootBin);<br>        if(dirKey-&gt;Signature[1]=='f') <br>    {<br>            ListValue(keypath,(PCM_KEY_NODE)((&amp;dirKey-&gt;ValueData_Offset)[index1*2]+RootBin));<br>      <br>        } <br>    else <br>    for(ULONG index2=0;index2&lt;subkey-&gt;NumberOfKeys;index2++) <br>    {<br>            ListValue(keypath,(PCM_KEY_NODE)((&amp;subkey-&gt;ValueData_Offset)[index2]+RootBin));<br>    <br>        }<br>    }<br><br>}<br><br><br>后注:在dump hive时,正常是没有问题的...但如果使用了combojiang那篇隐藏注册表里面的那个驱动程序来隐藏注册表...比如它里面隐藏了Services键下的子键Beep,,,那我们在dump Services时就会失败....也不知道是什么原因,,应该是被什么干扰了吧...不过你可以自己复制原始的HIVE文件,在解释它...这个程序再改改应该可以...不过到了这里你应该对HIVE文件有个大概的理解了..            </div>
                </div>