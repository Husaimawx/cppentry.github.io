---
layout:     post
title:      kafka权威指南中文版之三
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                
<h2><span style="font-size:14px;"><span style="color:rgb(51,51,51);">第三章</span><span style="color:rgb(51,51,51);">kafka producer---</span><span style="color:rgb(51,51,51);">向</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">写入消息</span></span></h2>
<p><span style="font-size:14px;"><span style="color:rgb(51,51,51);">无论你将</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">作为一个消息队列，或者消息总线，还是一个数据存储平台，你都要通过生产者</span><span style="color:rgb(51,51,51);">producer</span><span style="color:rgb(51,51,51);">向</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">写入数据，通过消费者</span><span style="color:rgb(51,51,51);">consumer</span><span style="color:rgb(51,51,51);">读取</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">的数据。</span></span></p>
<p><span style="font-size:14px;"><span style="color:rgb(51,51,51);">例如，一个信用卡事务处理系统，会有一个客户端应用或者一个在线商店应用，负责在交易发生时，将每一个事务发送到</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">，另一个应用通过规则引擎校验这个事务，决定接收或者拒绝，接收或者拒绝响应可以写入</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">，这样在线商店应用就可以收到这个响应。第三方应用可以读取这个事务数据和响应数据，存储到数据库中，以备后续分析</span><span style="color:rgb(51,51,51);">(</span><span style="color:rgb(51,51,51);">改进规则引擎</span><span style="color:rgb(51,51,51);">)</span><span style="color:rgb(51,51,51);">。</span></span></p>
<p><span style="font-size:14px;"><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">提供了</span><span style="color:rgb(51,51,51);">Java</span><span style="color:rgb(51,51,51);">客户端</span><span style="color:rgb(51,51,51);">API</span><span style="color:rgb(51,51,51);">，开发者可以使用这些</span><span style="color:rgb(51,51,51);">API</span><span style="color:rgb(51,51,51);">开发应用程序，与</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">交互。本章关注如何使用</span><span style="color:rgb(51,51,51);">producer</span><span style="color:rgb(51,51,51);">客户端来开阿发应用程序，将数据写入</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">。下一章将关注</span><span style="color:rgb(51,51,51);">consumer</span><span style="color:rgb(51,51,51);">客户端，如何读取</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">数据。</span></span></p>
<p><span style="font-size:14px;"><span style="color:rgb(51,51,51);">有很多场景需要将消息写入</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">：记录用户动作，用于审计或分析；存储日志消息；与其他应用程序异步通信；作为写入数据库之前的缓冲区等等。</span></span></p>
<p><span style="color:rgb(51,51,51);"><span style="font-size:14px;">不同的场景以为着不同的需求：每条消息是否都很重要或者说可以接收消息的丢失吗？可以接受偶尔收到重复的消息吗？对消息时延和吞吐量有严格的要求吗？</span></span></p>
<p><span style="font-size:14px;"><span style="color:rgb(51,51,51);">前面的信用卡事务处理系统的例子中，可以看出对消息的要求是严格的，既不允许丢失消息也不允许重复收到消息，消息延迟要在</span><span style="color:rgb(51,51,51);">500</span><span style="color:rgb(51,51,51);">毫秒以内，需要每秒</span><span style="color:rgb(51,51,51);">100</span><span style="color:rgb(51,51,51);">万条消息的吞吐量。</span></span></p>
<p><span style="font-size:14px;"><span style="color:rgb(51,51,51);">另一种场景，如存储网站的点击事件信息到</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">。此种场景，一些消息的丢失或者重复是可以接受的，消息延迟也可以很高，只要对用户体验没有影响就可以，也就是说，消息经过几秒中到达</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">是可以的，只要下一个网页在用户点击后迅速加载出来。此时的消息吞吐量取决于网站的用户量。</span></span></p>
<p><span style="font-size:14px;"><span style="color:rgb(51,51,51);">不同的场景，不同的需求，会影响</span><span style="color:rgb(51,51,51);">producer API</span><span style="color:rgb(51,51,51);">的使用方式及配置方式。</span></span></p>
<p><span style="font-size:14px;"><strong><span style="color:rgb(51,51,51);">生产者</span><span style="color:rgb(51,51,51);">producer</span><span style="color:rgb(51,51,51);">概览</span></strong></span></p>
<p><span style="font-size:14px;"><span style="color:rgb(51,51,51);">虽然</span><span style="color:rgb(51,51,51);">producer API</span><span style="color:rgb(51,51,51);">非常简单，但是在发送消息时，其底层发生了很多事情。图</span><span style="color:rgb(51,51,51);">3-1</span><span style="color:rgb(51,51,51);">展示了发送消息到</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">的主要步骤。</span></span></p>
<p><span style="font-size:14px;"><span style="color:rgb(51,51,51);">上图中，从创建一个</span><span style="color:rgb(51,51,51);">ProducerRecord</span><span style="color:rgb(51,51,51);">开始，</span><span style="color:rgb(51,51,51);">ProducerRecord</span><span style="color:rgb(51,51,51);">包含消息要发送到哪个</span><span style="color:rgb(51,51,51);">Topic</span><span style="color:rgb(51,51,51);">，消息的值，也可以声明一个</span><span style="color:rgb(51,51,51);">key</span><span style="color:rgb(51,51,51);">和</span><span style="color:rgb(51,51,51);">partition</span><span style="color:rgb(51,51,51);">。一旦将</span><span style="color:rgb(51,51,51);">ProducerRecord</span><span style="color:rgb(51,51,51);">发送，</span><span style="color:rgb(51,51,51);">producer</span><span style="color:rgb(51,51,51);">要做的就是序列化</span><span style="color:rgb(51,51,51);">key</span><span style="color:rgb(51,51,51);">和</span><span style="color:rgb(51,51,51);">value</span><span style="color:rgb(51,51,51);">对象为二进制数组，这样才可以通过网络发送。</span></span></p>
<p><span style="font-size:14px;"><span style="color:rgb(51,51,51);">接着，数据发送到一个</span><span style="color:rgb(51,51,51);">partitioner</span><span style="color:rgb(51,51,51);">。此时如果我们在</span><span style="color:rgb(51,51,51);">ProducerRecord</span><span style="color:rgb(51,51,51);">中声明了一个</span><span style="color:rgb(51,51,51);">partition</span><span style="color:rgb(51,51,51);">分区，</span><span style="color:rgb(51,51,51);">partitioner</span><span style="color:rgb(51,51,51);">仅仅将我们自定义的</span><span style="color:rgb(51,51,51);">partition</span><span style="color:rgb(51,51,51);">返回；如果没有声明</span><span style="color:rgb(51,51,51);">partition</span><span style="color:rgb(51,51,51);">，</span><span style="color:rgb(51,51,51);">partitioner</span><span style="color:rgb(51,51,51);">将会选择一个</span><span style="color:rgb(51,51,51);">partition</span><span style="color:rgb(51,51,51);">，通常会根据</span><span style="color:rgb(51,51,51);">key</span><span style="color:rgb(51,51,51);">来选择</span><span style="color:rgb(51,51,51);">partition</span><span style="color:rgb(51,51,51);">。一旦选择了</span><span style="color:rgb(51,51,51);">partition</span><span style="color:rgb(51,51,51);">，</span><span style="color:rgb(51,51,51);">producer</span><span style="color:rgb(51,51,51);">就知道这个消息要发送到哪个</span><span style="color:rgb(51,51,51);">topic</span><span style="color:rgb(51,51,51);">和哪个分区了。</span></span></p>
<p><span style="font-size:14px;"><span style="color:rgb(51,51,51);">接着，</span><span style="color:rgb(51,51,51);">producer</span><span style="color:rgb(51,51,51);">将这个消息加入到一个消息批次中，这个消息批次中的消息会发送到相同的</span><span style="color:rgb(51,51,51);">topic</span><span style="color:rgb(51,51,51);">和</span><span style="color:rgb(51,51,51);">partition</span><span style="color:rgb(51,51,51);">。此时会开辟一个独立的线程负责发送这批消息到合适的</span><span style="color:rgb(51,51,51);">kafka
 broker</span><span style="color:rgb(51,51,51);">。</span></span></p>
<p><span style="font-size:14px;"><span style="color:rgb(51,51,51);">当</span><span style="color:rgb(51,51,51);">broker</span><span style="color:rgb(51,51,51);">收到消息，会发回一个响应信息。如果这个消息成功写入</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">，</span><span style="color:rgb(51,51,51);">broker</span><span style="color:rgb(51,51,51);">会响应一个</span><span style="color:rgb(51,51,51);">RecordMetadata</span><span style="color:rgb(51,51,51);">对象</span><span style="color:rgb(51,51,51);">(</span><span style="color:rgb(51,51,51);">包括</span><span style="color:rgb(51,51,51);">topic</span><span style="color:rgb(51,51,51);">、</span><span style="color:rgb(51,51,51);">partition</span><span style="color:rgb(51,51,51);">、以及消息在</span><span style="color:rgb(51,51,51);">partition</span><span style="color:rgb(51,51,51);">中的</span><span style="color:rgb(51,51,51);">offset)</span><span style="color:rgb(51,51,51);">。如果</span><span style="color:rgb(51,51,51);">broker</span><span style="color:rgb(51,51,51);">没有将消息写入</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">，将会响应一个错误。当</span><span style="color:rgb(51,51,51);">producer</span><span style="color:rgb(51,51,51);">收到这个错误，可以尝试重发指定次数的消息，直到放弃。</span></span></p>
<p><span style="font-size:14px;"><span style="color:rgb(51,51,51);">本章中学习如何使用</span><span style="color:rgb(51,51,51);">kafka producer</span><span style="color:rgb(51,51,51);">，会涉及到图</span><span style="color:rgb(51,51,51);">3-1</span><span style="color:rgb(51,51,51);">中的大部分组件。学习如何创建一个</span><span style="color:rgb(51,51,51);">kafkaProducer</span><span style="color:rgb(51,51,51);">和</span><span style="color:rgb(51,51,51);">ProducerRecord</span><span style="color:rgb(51,51,51);">对象；学习如何使用默认的</span><span style="color:rgb(51,51,51);">partitioner</span><span style="color:rgb(51,51,51);">和</span><span style="color:rgb(51,51,51);">serializers</span><span style="color:rgb(51,51,51);">发送消息；学习如何处理响应的错误；学习如何自定义</span><span style="color:rgb(51,51,51);">serializers</span><span style="color:rgb(51,51,51);">和</span><span style="color:rgb(51,51,51);">partitioner</span><span style="color:rgb(51,51,51);">。以及学习</span><span style="color:rgb(51,51,51);">producer</span><span style="color:rgb(51,51,51);">相关的大部分重要配置项。</span></span></p>
<p><strong><span style="color:rgb(51,51,51);"><span style="font-size:14px;"> </span></span></strong></p>
<p><span style="font-size:14px;"><strong><span style="color:rgb(51,51,51);">创建</span><span style="color:rgb(51,51,51);">kafkaProducer</span><span style="color:rgb(51,51,51);">对象</span></strong></span></p>
<p><span style="font-size:14px;"><span style="color:rgb(51,51,51);">发送消息到</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">，首先需要创建</span><span style="color:rgb(51,51,51);">KafkaProducer</span><span style="color:rgb(51,51,51);">对象。</span><span style="color:rgb(51,51,51);">KafkaProducer</span><span style="color:rgb(51,51,51);">对象需要</span><span style="color:rgb(51,51,51);">3</span><span style="color:rgb(51,51,51);">个必备的属性：</span></span></p>
<p><span style="font-size:14px;"><span style="color:#333333;">l </span><strong><span style="color:rgb(51,51,51);">bootstrap.servers</span></strong><span style="color:rgb(51,51,51);">—kafka brokers</span><span style="color:rgb(51,51,51);">的</span><span style="color:rgb(51,51,51);">host:port</span><span style="color:rgb(51,51,51);">列表。此列表中不要求包含集群中所有的</span><span style="color:rgb(51,51,51);">brokers</span><span style="color:rgb(51,51,51);">，</span><span style="color:rgb(51,51,51);">producer</span><span style="color:rgb(51,51,51);">会根据连接上的</span><span style="color:rgb(51,51,51);">broker</span><span style="color:rgb(51,51,51);">查询到其他</span><span style="color:rgb(51,51,51);">broker</span><span style="color:rgb(51,51,51);">。建议列表中至少包含两个</span><span style="color:rgb(51,51,51);">brokers</span><span style="color:rgb(51,51,51);">，因为这样即使一个</span><span style="color:rgb(51,51,51);">broker</span><span style="color:rgb(51,51,51);">连接不上，可以连接另一个</span><span style="color:rgb(51,51,51);">broker</span><span style="color:rgb(51,51,51);">。</span></span></p>
<p><span style="font-size:14px;"><span style="color:#333333;">l </span><strong><span style="color:rgb(51,51,51);">key.serializer</span></strong><span style="color:rgb(51,51,51);">—kafka brokers</span><span style="color:rgb(51,51,51);">期望的消息</span><span style="color:rgb(51,51,51);">(key</span><span style="color:rgb(51,51,51);">和</span><span style="color:rgb(51,51,51);">value)</span><span style="color:rgb(51,51,51);">二进制数组。</span><span style="color:rgb(51,51,51);">Producer</span><span style="color:rgb(51,51,51);">接口使用了参数化类型来定义</span><span style="color:rgb(51,51,51);">key
 serializer</span><span style="color:rgb(51,51,51);">，以此发送任何</span><span style="color:rgb(51,51,51);">Java</span><span style="color:rgb(51,51,51);">对象。这就意味着，</span><span style="color:rgb(51,51,51);">producer</span><span style="color:rgb(51,51,51);">必须知道如何将这些</span><span style="color:rgb(51,51,51);">Java</span><span style="color:rgb(51,51,51);">对象转换为二进制数组</span><span style="color:rgb(51,51,51);">byte
 arrays</span><span style="color:rgb(51,51,51);">。</span><span style="color:rgb(51,51,51);">key.serializer</span><span style="color:rgb(51,51,51);">应该设置为一个类，这个类实现了</span><span style="color:rgb(51,51,51);">org.apache.kafka.common.serialization.Serializer</span><span style="color:rgb(51,51,51);">接口，</span><span style="color:rgb(51,51,51);">producer</span><span style="color:rgb(51,51,51);">使用这个类将</span><span style="color:rgb(51,51,51);">key</span><span style="color:rgb(51,51,51);">对象序列化为</span><span style="color:rgb(51,51,51);">byte
 array</span><span style="color:rgb(51,51,51);">。</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">客户端包中有</span><span style="color:rgb(51,51,51);">ByteArraySerializer (which doesn’t domuch), StringSerializer andIntegerSerializer</span><span style="color:rgb(51,51,51);">三种类型的序列化器，如果发送常用类型的消息，不需要自定义序列化器。注意：即使发送只包含</span><span style="color:rgb(51,51,51);">value</span><span style="color:rgb(51,51,51);">的消息，也要设置</span><span style="color:rgb(51,51,51);">key.serializer</span><span style="color:rgb(51,51,51);">。</span></span></p>
<p><span style="font-size:14px;"><strong><span style="color:rgb(51,51,51);">value.serializer</span></strong><span style="color:rgb(51,51,51);">---</span><span style="color:rgb(51,51,51);">与</span><span style="color:rgb(51,51,51);">key.serializer</span><span style="color:rgb(51,51,51);">含义相同，其值可以与</span><span style="color:rgb(51,51,51);">key.serializer</span><span style="color:rgb(51,51,51);">相同，也可以不同。</span></span></p>
<p><span style="font-size:14px;"><span style="color:rgb(51,51,51);"><br></span></span></p>
<p><span style="font-size:14px;"><span style="color:rgb(51,51,51);"></span></span></p>
<p><em><span style="color:rgb(51,51,51);">下面的代码片段通过设置上述参数的方式创建了</span><span style="color:rgb(51,51,51);">KafkaProducer</span><span style="color:rgb(51,51,51);">对象：</span></em></p>
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td valign="top">
<p><em><span style="color:rgb(51,51,51);">private Properties kafkaProps = new Properties();//</span><span style="color:rgb(51,51,51);">创建一个properties</span>对象</em></p>
<p><em><span style="color:rgb(51,51,51);">kafkaProps.put("<strong>bootstrap.servers</strong>", "broker1:9092,broker2:9092");</span></em></p>
<p><em><span style="color:rgb(51,51,51);">//</span><span style="color:rgb(51,51,51);">设置字符串类型的消息key</span>和value</em></p>
<p><em><span style="color:rgb(51,51,51);">kafkaProps.put("<strong>key.serializer</strong>", "org.apache.kafka.common.serialization.StringSerializer");
<a href="https://www.safaribooksonline.com/library/view/kafka-the-definitive/9781491936153/ch03.html#callout_kafka_producers___writing_messages_to_kafka_CO1-2" rel="nofollow">
</a></span></em></p>
<p><em><span style="color:rgb(51,51,51);">kafkaProps.put("<strong>value.serializer</strong>", "org.apache.kafka.common.serialization.StringSerializer");</span></em></p>
<p><em><span style="color:rgb(51,51,51);">//</span><span style="color:rgb(51,51,51);">创建KafkaProducer</span>对象，设置string泛型，传入properties对象</em></p>
<p><em><span style="color:rgb(51,51,51);">producer = new KafkaProducer&lt;String, String&gt;(kafkaProps);
<a href="https://www.safaribooksonline.com/library/view/kafka-the-definitive/9781491936153/ch03.html#callout_kafka_producers___writing_messages_to_kafka_CO1-3" rel="nofollow">
</a></span></em></p>
<p><em><span style="color:rgb(51,51,51);"> </span></em></p>
</td>
</tr></tbody></table><p><em><span style="color:rgb(51,51,51);"> </span></em></p>
<p><em><span style="color:rgb(51,51,51);">可以看出，通过设置</span><span style="color:rgb(51,51,51);">properties</span><span style="color:rgb(51,51,51);">对象的不同参数，可以完成对</span><span style="color:rgb(51,51,51);">producer</span><span style="color:rgb(51,51,51);">对象的控制。</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">官方文档中列出了所有的配置参数，本章会学习其中一些重要的配置参数。</span></em></p>
<p><em><span style="color:rgb(51,51,51);">上述代码片段实例化了一个</span><span style="color:rgb(51,51,51);">producer</span><span style="color:rgb(51,51,51);">，接着就可以发送消息</span><span style="color:rgb(51,51,51);">了。有三个主要方法用来发送消息：</span></em></p>
<p><em><span style="color:#333333;">l </span><span style="color:rgb(51,51,51);">Fire-and-forget----</span><span style="color:rgb(51,51,51);">此方法用来发送消息到</span><span style="color:rgb(51,51,51);">broker</span><span style="color:rgb(51,51,51);">，不关注消息是否成功到达。大部分情况下，消息会成功到达</span><span style="color:rgb(51,51,51);">broker</span><span style="color:rgb(51,51,51);">，因为</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">是高可用了，</span><span style="color:rgb(51,51,51);">producer</span><span style="color:rgb(51,51,51);">会自动重试发送。但是，还是会有消息丢失的情况；</span></em></p>
<p><em><span style="color:#333333;">l </span><span style="color:rgb(51,51,51);">SynchronousSend(</span><span style="color:rgb(51,51,51);">同步发送</span><span style="color:rgb(51,51,51);">)---</span><span style="color:rgb(51,51,51);">发送一个消息，</span><span style="color:rgb(51,51,51);">send()</span><span style="color:rgb(51,51,51);">方法返回一个</span><span style="color:rgb(51,51,51);">Future</span><span style="color:rgb(51,51,51);">对象，使用此对象的</span><span style="color:rgb(51,51,51);">get()</span><span style="color:rgb(51,51,51);">阻塞方法可以指定</span><span style="color:rgb(51,51,51);">send</span><span style="color:rgb(51,51,51);">方法是否执行成功。</span></em></p>
<p><em>l  <span style="color:rgb(51,51,51);">Asynchronous Send(</span><span style="color:rgb(51,51,51);">异步发送</span><span style="color:rgb(51,51,51);">)---</span><span style="color:rgb(51,51,51);">以回调函数的形式调用</span><span style="color:rgb(51,51,51);">send()</span><span style="color:rgb(51,51,51);">方法，当收到</span><span style="color:rgb(51,51,51);">broker</span><span style="color:rgb(51,51,51);">的响应，会触发毁掉函数执行。</span></em></p>
<p><em><span style="color:rgb(51,51,51);">上述所有的情况，有一点要认识到：发送消息到</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">是可能失败的，需要有处理这些失败的计划。一个</span><span style="color:rgb(51,51,51);">producer</span><span style="color:rgb(51,51,51);">对象可以通过多线程的方式发送消息，也可以使用多个</span><span style="color:rgb(51,51,51);">producer</span><span style="color:rgb(51,51,51);">发送消息。</span></em></p>
<p><em><span style="color:rgb(51,51,51);">下面通过实例演示如何使用上述三种方式发送消息，以及如何处理可能发生的异常。</span></em></p>
<p><em><strong><span style="color:rgb(51,51,51);">发送消息到</span><span style="color:rgb(51,51,51);">kafka</span></strong></em></p>
<p><em><span style="color:rgb(51,51,51);">发送消息到</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">最简单的方式如下：</span></em></p>
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td valign="top">
<p><em><span style="color:rgb(51,51,51);">ProducerRecord&lt;String, String&gt; record =</span></em></p>
<p><em><span style="color:rgb(51,51,51);">    new ProducerRecord&lt;&gt;("CustomerCountry", "Precision Products", "France");
<a href="https://www.safaribooksonline.com/library/view/kafka-the-definitive/9781491936153/ch03.html#callout_kafka_producers___writing_messages_to_kafka_CO2-1" rel="nofollow">
</a></span></em></p>
<p><em><span style="color:rgb(51,51,51);">try {</span></em></p>
<p><em><span style="color:rgb(51,51,51);">  producer.send(record); <a href="https://www.safaribooksonline.com/library/view/kafka-the-definitive/9781491936153/ch03.html#callout_kafka_producers___writing_messages_to_kafka_CO2-2" rel="nofollow">
</a></span></em></p>
<p><em><span style="color:rgb(51,51,51);">} catch (Exception e) {</span></em></p>
<p><em><span style="color:rgb(51,51,51);">    e.printStackTrace(); <a href="https://www.safaribooksonline.com/library/view/kafka-the-definitive/9781491936153/ch03.html#callout_kafka_producers___writing_messages_to_kafka_CO2-3" rel="nofollow">
</a></span></em></p>
<p><em><span style="color:rgb(51,51,51);">}</span></em></p>
<p><em><span style="color:rgb(51,51,51);"> </span></em></p>
</td>
</tr></tbody></table><p><em><span style="color:#333333;">1、  </span><span style="color:rgb(51,51,51);">producer</span><span style="color:rgb(51,51,51);">对象的</span><span style="color:rgb(51,51,51);">send</span><span style="color:rgb(51,51,51);">方法接收一个</span><span style="color:rgb(51,51,51);">ProducerRecord</span><span style="color:rgb(51,51,51);">对象，所以先创建一个</span><span style="color:rgb(51,51,51);">ProducerRecord</span><span style="color:rgb(51,51,51);">对象。</span><span style="color:rgb(51,51,51);">ProducerRecord</span><span style="color:rgb(51,51,51);">有多个构造方法，后续会讨论。这里我们使用了三个参数的构造函数：</span><span style="color:rgb(51,51,51);">string</span><span style="color:rgb(51,51,51);">类型的</span><span style="color:rgb(51,51,51);">topic</span><span style="color:rgb(51,51,51);">、</span><span style="color:rgb(51,51,51);">string</span><span style="color:rgb(51,51,51);">类型的</span><span style="color:rgb(51,51,51);">key</span><span style="color:rgb(51,51,51);">、</span><span style="color:rgb(51,51,51);">string</span><span style="color:rgb(51,51,51);">类型的</span><span style="color:rgb(51,51,51);">value</span><span style="color:rgb(51,51,51);">。</span><span style="color:rgb(51,51,51);">key</span><span style="color:rgb(51,51,51);">和</span><span style="color:rgb(51,51,51);">value</span><span style="color:rgb(51,51,51);">的类型必须与</span><span style="color:rgb(51,51,51);">serializers</span><span style="color:rgb(51,51,51);">、</span><span style="color:rgb(51,51,51);">Producer</span><span style="color:rgb(51,51,51);">的泛型一致。</span></em></p>
<p><em><span style="color:#333333;">2、  </span><span style="color:rgb(51,51,51);">使用</span><span style="color:rgb(51,51,51);">Producer</span><span style="color:rgb(51,51,51);">的</span><span style="color:rgb(51,51,51);">send</span><span style="color:rgb(51,51,51);">方法发送</span><span style="color:rgb(51,51,51);">ProducerRecord</span><span style="color:rgb(51,51,51);">对象。在前面的</span><span style="color:rgb(51,51,51);">Producer</span><span style="color:rgb(51,51,51);">架构图中显示，消息会先放到缓冲区，然后启用一个独立线程发送到</span><span style="color:rgb(51,51,51);">broker</span><span style="color:rgb(51,51,51);">。</span><span style="color:rgb(51,51,51);">send</span><span style="color:rgb(51,51,51);">方法返回一个包含</span><span style="color:rgb(51,51,51);">RecordMetadata</span><span style="color:rgb(51,51,51);">的</span><span style="color:rgb(51,51,51);">Future</span><span style="color:rgb(51,51,51);">对象，这里我们忽略了返回值，不关注消息发送是否成功。这种发送消息的方式在允许消息丢失的场景下使用。</span></em></p>
<p><em><span style="color:#333333;">3、  </span><span style="color:rgb(51,51,51);">虽然我们忽略了消息发送到</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">的异常，但是在消息发送到</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">之前，还是有可能发生异常的。如序列化消息失败异常</span><span style="color:rgb(51,51,51);">SerializationException</span><span style="color:rgb(51,51,51);">、缓冲区用尽异常</span><span style="color:rgb(51,51,51);">BufferExhaustedException(</span><span style="color:rgb(51,51,51);">配置了</span><span style="color:rgb(51,51,51);">producer</span><span style="color:rgb(51,51,51);">信息，指定在缓冲区满时，不是阻塞，而是抛出异常的情况</span><span style="color:rgb(51,51,51);">)</span><span style="color:rgb(51,51,51);">、发送中断异常</span><span style="color:rgb(51,51,51);">InterruptException</span><span style="color:rgb(51,51,51);">。</span></em></p>
<p><em><strong><span style="color:rgb(51,51,51);">同步发送消息到</span><span style="color:rgb(51,51,51);">kafka</span></strong></em></p>
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td valign="top">
<p><em><span style="color:rgb(51,51,51);">ProducerRecord&lt;String, String&gt; record =</span></em></p>
<p><em><span style="color:rgb(51,51,51);">    new ProducerRecord&lt;&gt;("CustomerCountry", "Precision Products", "France");</span></em></p>
<p><em><span style="color:rgb(51,51,51);">producer.send(record).get(); </span></em><span style="color:#404040;"><a href="https://www.safaribooksonline.com/library/view/kafka-the-definitive/9781491936153/ch03.html#callout_kafka_producers___writing_messages_to_kafka_CO3-1" rel="nofollow"></a></span></p>
<p><em><span style="color:rgb(51,51,51);"> </span></em></p>
</td>
</tr></tbody></table><p><em><span style="color:rgb(51,51,51);">这里我们使用</span><span style="color:rgb(51,51,51);">Future.get()</span><span style="color:rgb(51,51,51);">方法来等待消息发送结果，直到收到</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">的响应。当</span><span style="color:rgb(51,51,51);">kafka
 broker</span><span style="color:rgb(51,51,51);">返回错误时，</span><span style="color:rgb(51,51,51);">Future</span><span style="color:rgb(51,51,51);">对象会抛出异常，我们的应用程序可以捕获异常。如果没有异常，我们会得到</span><span style="color:rgb(51,51,51);">RecordMetadata</span><span style="color:rgb(51,51,51);">对象，从中可以获取到消息的</span><span style="color:rgb(51,51,51);">offset</span><span style="color:rgb(51,51,51);">等信息。</span></em></p>
<p><em><span style="color:rgb(51,51,51);">KafkaProducer</span><span style="color:rgb(51,51,51);">有两类错误。一类是重试类错误，这类错误通过再次发送消息可以解决，例如连接错误</span><span style="color:rgb(51,51,51);">(</span><span style="color:rgb(51,51,51);">重试可能会连接成功</span><span style="color:rgb(51,51,51);">)</span><span style="color:rgb(51,51,51);">和</span><span style="color:rgb(51,51,51);">”no-leader”</span><span style="color:rgb(51,51,51);">错误。重试次数是可以配置的，只有在重试次数用完后，错误依然存在，此时客户端才会收到重试类错误。另一类错误是非重试类错误，就是说不能通过重试来解决的错误。例如</span><span style="color:rgb(51,51,51);">”</span>
 message size too large<span style="color:rgb(51,51,51);">”</span><span style="color:rgb(51,51,51);">错误。此时</span><span style="color:rgb(51,51,51);">KafkaProducer</span><span style="color:rgb(51,51,51);">将不会重试，直接返回异常。</span></em></p>
<p><em><strong><span style="color:rgb(51,51,51);">异步发送消息</span></strong></em></p>
<p><em><span style="color:rgb(51,51,51);">假设客户端程序与</span><span style="color:rgb(51,51,51);">kafka</span><span style="color:rgb(51,51,51);">集群之间的网络轮询时间为</span><span style="color:rgb(51,51,51);">10ms</span><span style="color:rgb(51,51,51);">。如果我们在发送消息后等待响应，发送</span><span style="color:rgb(51,51,51);">100</span><span style="color:rgb(51,51,51);">条消息将会消费</span><span style="color:rgb(51,51,51);">1s</span><span style="color:rgb(51,51,51);">的时间。另一方面讲，如果我们只是发送消息，不等待响应，此时发送</span><span style="color:rgb(51,51,51);">100</span><span style="color:rgb(51,51,51);">条消息将会耗费更少的时间。在大部分场景下，我们真的不需要等待一个响应，响应中的信息</span><span style="color:rgb(51,51,51);">(topic</span><span style="color:rgb(51,51,51);">、</span><span style="color:rgb(51,51,51);">partition</span><span style="color:rgb(51,51,51);">、</span><span style="color:rgb(51,51,51);">offset)</span><span style="color:rgb(51,51,51);">有时候不是客户端必须的。也就是说，我们需要知道什么时候发送失败，这样我们可以抛出异常或者写入错误日志文件中，以备后续分析。</span></em></p>
<p><em><span style="color:rgb(51,51,51);">为了能够异步发送消息，并且能处理错误，这种场景需要为</span><span style="color:rgb(51,51,51);">Producer</span><span style="color:rgb(51,51,51);">添加一个</span><span style="color:rgb(51,51,51);">callback</span><span style="color:rgb(51,51,51);">回调函数：</span></em></p>
<table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td valign="top">
<p><em><span style="color:rgb(51,51,51);">private class DemoProducerCallback implements Callback {
<a href="https://www.safaribooksonline.com/library/view/kafka-the-definitive/9781491936153/ch03.html#callout_kafka_producers___writing_messages_to_kafka_CO4-1" rel="nofollow">
</a></span></em></p>
<p><em><span style="color:rgb(51,51,51);">       @Override</span></em></p>
<p><em><span style="color:rgb(51,51,51);">    public void onCompletion(RecordMetadata recordMetadata, Exception e) {</span></em></p>
<p><em><span style="color:rgb(51,51,51);">           if (e != null) {</span></em></p>
<p><em><span style="color:rgb(51,51,51);">               e.printStackTrace(); <a href="https://www.safaribooksonline.com/library/view/kafka-the-definitive/9781491936153/ch03.html#callout_kafka_producers___writing_messages_to_kafka_CO4-2" rel="nofollow">
</a></span></em></p>
<p><em><span style="color:rgb(51,51,51);">        }</span></em></p>
<p><em><span style="color:rgb(51,51,51);">    }</span></em></p>
<p><em><span style="color:rgb(51,51,51);">}</span></em></p>
<p><em><span style="color:rgb(51,51,51);"> </span></em></p>
<p><em><span style="color:rgb(51,51,51);">ProducerRecord&lt;String, String&gt; record =</span></em></p>
<p><em><span style="color:rgb(51,51,51);">       new ProducerRecord&lt;&gt;("CustomerCountry", "Biomedical Materials", "USA");
<a href="https://www.safaribooksonline.com/library/view/kafka-the-definitive/9781491936153/ch03.html#callout_kafka_producers___writing_messages_to_kafka_CO4-3" rel="nofollow">
</a></span></em></p>
<p><em><span style="color:rgb(51,51,51);">producer.send(record, new DemoProducerCallback());
</span></em><span style="color:#404040;"><a href="https://www.safaribooksonline.com/library/view/kafka-the-definitive/9781491936153/ch03.html#callout_kafka_producers___writing_messages_to_kafka_CO4-4" rel="nofollow"></a></span></p>
<p><em><span style="color:rgb(51,51,51);"> </span></em></p>
</td>
</tr></tbody></table><p><strong><span style="color:#404040;">Serializers</span><span style="color:#404040;">序列化器</span></strong></p>
<br>            </div>
                </div>