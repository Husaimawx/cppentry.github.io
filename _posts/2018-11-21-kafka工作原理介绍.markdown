---
layout:     post
title:      kafka工作原理介绍
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                <h2>两张图读懂kafka应用：</h2><h2 style="text-align:center;"><img src="https://img-blog.csdn.net/2018062710312862?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MTg2MTk5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></h2><div style="text-align:center;"><img src="https://img-blog.csdn.net/20180627103304796?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MTg2MTk5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></div><div style="text-align:left;"><h3 style="background:rgb(255,255,255);"><strong>Kafka 中的术语</strong></h3><p></p><ul><li><span style="color:rgb(61,70,77);background:rgb(255,255,255);"> broker：中间的kafka cluster，存储消息，是由多个server组成的集群。</span></li><li> <span style="color:rgb(61,70,77);background:rgb(255,255,255);">topic：kafka给消息提供的分类方式。broker用来存储不同topic的消息数据。</span></li><li> <span style="color:rgb(61,70,77);background:rgb(255,255,255);">producer：往broker中某个topic里面生产数据。</span></li><li> <span style="color:rgb(61,70,77);background:rgb(255,255,255);">consumer：从broker中某个topic获取数据。</span></li></ul><h3 style="background:rgb(255,255,255);"><span style="font-weight:bold;"><span style="color:rgb(61,70,77);"></span></span></h3><h3 style="text-align:left;background:rgb(255,255,255);">Kafka 中的术语设计：</h3><h3 style="background:rgb(255,255,255);"><span style="font-weight:bold;"><span style="color:rgb(61,70,77);"></span></span></h3><p style="text-align:left;"></p><h4 id="7broker" style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">1、Broker</h4><p><span style="color:rgb(61,70,77);background:rgb(255,255,255);"><span style="font-family:Arial;">      中间的</span>kafka cluster，存储消息，是由多个server组成的集群。</span></p><p></p><p style="text-align:center;"><img src="https://img-blog.csdn.net/20180627104846676?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MTg2MTk5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><br>2、topic与消息<p style="background:rgb(255,255,255);"><span style="color:rgb(61,70,77);">kafka将所有消息组织成多个topic的形式存储，而每个topic又可以拆分成多个partition，每个partition又由一个一个消息组成。每个消息都被标识了一个递增序列号代表其进来的先后顺序，并按顺序存储在partition中。</span></p><br></div><h2><img src="https://img-blog.csdn.net/20180627104739139?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MTg2MTk5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></h2><div><p style="background:rgb(255,255,255);"><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">这样，消息就以一个个</span>id的方式，组织起来。</span></p><p></p><ul><li> <span style="color:rgb(61,70,77);background:rgb(255,255,255);">producer选择一个topic，生产消息，消息会通过分配策略append到某个partition末尾。</span></li><li> <span style="background:rgb(255,255,255);"><span style="color:#3d464d;">consumer选择一个topic，通过id</span><span style="color:#3d464d;">指定从哪个位置开始消费消息。消费完成之后保留id，下次可以从这个位置开始继续消费，也可以从其他任意位置开始消费。</span></span></li></ul><p style="background:rgb(255,255,255);"></p><p style="background:rgb(255,255,255);"><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">上面的id在kafka中称为offset，这种组织和处理策略提供了如下好处：</span></span></p><p></p><ul><li> <strong><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">消费者可以根据需求，灵活指定</span>offset消费。</span></strong></li><li> <strong><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">保证了消息不变性，为并发消费提供了线程安全的保证</span></span></strong><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">。每个</span>consumer都保留自己的offset，互相之间不干扰，不存在线程安全问题。</span></li><li><span> <span style="color:rgb(61,70,77);font-family:Arial;"><strong>消息访问的并行高效性</strong></span></span><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">。每个</span>topic中的消息被组织成多个partition，partition均匀分配到集群server中。生产、消费消息的时候，会被路由到指定partition，减少竞争，增加了程序的并行能力。</span></li><li><span> <span style="color:rgb(61,70,77);font-family:Arial;"><strong>增加消息系统的可伸缩性</strong></span></span><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">。每个</span>topic中保留的消息可能非常庞大，通过partition将消息切分成多个子消息，并通过负责均衡策略将partition分配到不同server。这样当机器负载满的时候，通过扩容可以将消息重新均匀分配。</span></li><li> <strong><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">保证消息可靠性</span></span></strong><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">。消息消费完成之后不会删除，可以通过重置</span>offset重新消费，保证了消息不会丢失。</span></li><li> <strong><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">灵活的持久化策略</span></span></strong><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">。可以通过指定时间段（如最近一天）来保存消息，节省</span>broker存储空间。</span></li><li> <span style="color:rgb(61,70,77);font-family:Arial;font-weight:700;background-color:rgb(255,255,255);">备份高可用性。</span>消息以<span style="color:rgb(61,70,77);">partition为单位分配到多个server，并以partition为单位进行备份。备份策略为：1个leader和N个followers，leader接受读写请求，followers被动复制leader。leader和followers会在集群中打散，保证partition高可用。</span></li></ul><h4 id="2partitions" style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">3、Partitions</h4><p style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">       每个Topics划分为一个或者多个Partition,并且Partition中的每条消息都被标记了一个sequential id ,也就是offset,并且存储的数据是可配置存储时间的 </p></div><p><img src="https://img-blog.csdn.net/20180627104806535?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MTg2MTk5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p></p><h3 style="background:rgb(255,255,255);"><strong><span style="color:rgb(61,70,77);"></span></strong></h3><h4 style="background-color:rgb(255,255,255);font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;">4、producer</h4><p style="background:rgb(255,255,255);"><span style="color:rgb(61,70,77);">producer生产消息需要如下参数：</span></p><p></p><ul><li> <span style="color:rgb(61,70,77);background:rgb(255,255,255);">topic：往哪个topic生产消息。</span></li><li> <span style="color:rgb(61,70,77);background:rgb(255,255,255);">partition：往哪个partition生产消息。</span></li><li> <span style="color:rgb(61,70,77);background:rgb(255,255,255);">key：根据该key将消息分区到不同partition。</span></li><li> <span style="color:rgb(61,70,77);background:rgb(255,255,255);">message：消息。</span></li></ul><p style="text-align:center;"><img src="https://img-blog.csdn.net/20180627104837868?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MTg2MTk5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p style="text-align:left;"></p><h4 style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><br></h4><p style="text-align:left;"></p><p style="background:rgb(255,255,255);"><span style="color:rgb(61,70,77);"><span style="font-family:Arial;"></span></span></p><h3 style="background:rgb(255,255,255);"><strong><span style="color:rgb(61,70,77);">5、consumer</span></strong></h3><p style="background:rgb(255,255,255);"><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">传统消息系统有两种模式：</span></span></p><p></p><ul><li> <span style="color:rgb(61,70,77);background:rgb(255,255,255);"><span style="font-family:Arial;">队列</span></span></li><li> <span style="color:rgb(61,70,77);background:rgb(255,255,255);"><span style="font-family:Arial;">发布订阅</span></span></li></ul><p style="text-align:left;background:rgb(255,255,255);"><span style="color:rgb(61,70,77);"><span style="color:rgb(61,70,77);">kafka通过consumer group将两种模式统一处理：</span><span style="color:rgb(61,70,77);font-family:Arial;">每个</span><span style="color:rgb(61,70,77);">consumer将自己标记consumer group名称，之后系统会将consumer group按名称分组，将消息复制并分发给所有分组，每个分组只有一个consumer能消费这条消息。如下图：</span><br></span></p><p style="text-align:center;background:rgb(255,255,255);"><span style="color:rgb(61,70,77);"><span style="color:rgb(61,70,77);"><img src="https://img-blog.csdn.net/20180627113223459?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MTg2MTk5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" style="color:rgb(61,70,77);text-align:left;background-color:rgb(255,255,255);" alt=""><br></span></span></p><p style="text-align:center;background:rgb(255,255,255);"><span style="color:rgb(61,70,77);"><img src="https://img-blog.csdn.net/20180627104913125?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MTg2MTk5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" style="text-align:center;" alt=""><br></span></p><p style="text-align:center;background:rgb(255,255,255);"><span style="color:rgb(61,70,77);"><br></span></p><p style="background:rgb(255,255,255);"><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">于是推理出两个极端情况：</span></span></p><p></p><ul><li> <span style="color:rgb(61,70,77);background:rgb(255,255,255);"><span style="font-family:Arial;">当所有</span>consumer的consumer group相同时，系统变成队列模式</span></li><li> <span style="color:rgb(61,70,77);background:rgb(255,255,255);"><span style="font-family:Arial;">当每个</span>consumer的consumer group都不相同时，系统变成发布订阅</span></li></ul><p style="background:rgb(255,255,255);"><span style="font-family:Arial;"><span style="color:#ff0000;">注意</span><span style="color:#3d464d;">：</span></span></p><p style="background:rgb(255,255,255);"><span><span style="font-family:Arial;"><span style="color:#3d464d;">       1、<span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><strong>Consumer Groups 提供了topics和partitions的隔离</strong>， 如上图Consumer Group A中的consumer-C2挂掉，consumer-C1会接收P1,P2，即一个consumer Group中有其他consumer<span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">挂掉后能够重新平衡。如下图：</span></span></span></span></span></p><p style="background:rgb(255,255,255);"><span><span style="font-family:Arial;"><span style="color:#3d464d;"><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);"><img src="https://img-blog.csdn.net/20180627105000809?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MTg2MTk5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" style="color:rgb(61,70,77);text-align:center;background-color:rgb(255,255,255);" alt=""><br></span></span></span></span></span></p><p style="background:rgb(255,255,255);"><span style="font-family:Arial;"><span style="color:#3d464d;">        2、<strong>多</strong></span></span><span style="color:#3d464d;"><strong>consumer并发消费消息时，容易导致消息乱序</strong>，</span><span style="font-family:Arial;color:rgb(61,70,77);">通过限制消费者为同步，可以保证消息有序，但是这大大降低了程序的并发性。</span></p><p style="background:rgb(255,255,255);"><span style="color:rgb(61,70,77);">    kafka通过partition的概念，保证了partition内消息有序性，缓解了上面的问题。partition内消息会复制分发给所有分组，每个分组只有一个consumer能消费这条消息。这个语义保证了某个分组消费某个分区的消息，是同步而非并发的。如果一个topic只有一个partition，那么这个topic并发消费有序，否则只是单个partition有序。</span></p><p style="background:rgb(255,255,255);"><span style="color:rgb(61,70,77);font-family:Arial;">一般消息系统，</span><strong><span style="color:#000000;">consumer存在</span><span style="color:#000000;">两种消费模型</span></strong><span style="color:rgb(61,70,77);">：</span></p><p></p><ul><li> <span style="color:rgb(61,70,77);background:rgb(255,255,255);"><strong>push</strong>：优势在于消息实时性高。劣势在于没有考虑consumer消费能力和饱和情况，容易导致producer压垮consumer。</span></li><li> <span style="color:rgb(61,70,77);background:rgb(255,255,255);"><strong>pull</strong>：优势在可以控制消费速度和消费数量，保证consumer不会出现饱和。劣势在于当没有数据，会出现空轮询，消耗cpu。</span></li></ul><p style="background:rgb(255,255,255);"><span style="color:#ff0000;">kafka采用pull</span><span style="color:rgb(61,70,77);">，并采用可配置化参数保证当存在数据并且数据量达到一定量的时候，consumer端才进行pull操作，否则一直处于block状态。</span><span style="color:rgb(61,70,77);">kakfa采用整数值consumer position来记录单个分区的消费状态，并且单个分区单个消息只能被consumer group内的一个consumer消费，维护简单开销小。消费完成，broker收到确认，position指向下次消费的offset。由于消息不会删除，在完成消费，position更新之后，consumer依然可以重置offset重新消费历史消息。</span></p><p style="background:rgb(255,255,255);"></p><h3 style="color:rgb(61,70,77);background:rgb(255,255,255);"><strong><span style="color:rgb(61,70,77);"><span style="font-family:'Microsoft YaHei UI';">消息发送语义</span></span></strong></h3><p style="color:rgb(61,70,77);background:rgb(255,255,255);"><span style="color:rgb(61,70,77);"><strong>producer视角</strong></span></p><p style="color:rgb(61,70,77);"></p><ul><li> <span style="color:rgb(61,70,77);"><span style="font-family:Arial;">消息最多发送一次：</span>producer异步发送消息，或者同步发消息但重试次数为0。</span></li><li> <span style="color:rgb(61,70,77);"><span style="font-family:Arial;">消息至少发送一次：</span>producer同步发送消息，失败、超时都会重试。</span></li><li> <span style="color:rgb(61,70,77);"><span style="font-family:Arial;">消息发且仅发一次：后续版本支持。</span></span></li></ul><p style="color:rgb(61,70,77);background:rgb(255,255,255);"><span style="color:rgb(61,70,77);"><strong>consumer视角</strong></span></p><p style="color:rgb(61,70,77);"></p><ul><li> <span style="color:rgb(61,70,77);"><span style="font-family:Arial;">消息最多消费一次：</span>consumer先读取消息，再确认position，最后处理消息。</span></li><li> <span style="color:rgb(61,70,77);"><span style="font-family:Arial;">消息至少消费一次：</span>consumer先读取消息，再处理消息，最后确认position。</span></li><li> <span style="color:rgb(61,70,77);"><span style="font-family:Arial;">消息消费且仅消费一次。</span></span></li></ul><p style="color:rgb(61,70,77);"><span style="color:rgb(61,70,77);background:rgb(255,255,255);"><strong>注意</strong>：</span></p><p style="color:rgb(61,70,77);"></p><ul><li>如果消息处理后的输出端（如<span style="color:rgb(61,70,77);">db）能保证消息更新幂等性，则多次消费也能保证exactly once语义。</span></li><li>如果输出端能支持两阶段提交协议，则能保证确认<span style="color:rgb(61,70,77);">position和处理输出消息同时成功或者同时失败。</span></li><li>在消息处理的输出端存储更新后的<span style="color:rgb(61,70,77);">position，保证了确认position和处理输出消息的原子性（简单、通用）。</span></li></ul><h3 style="color:rgb(61,70,77);background:rgb(255,255,255);"><strong><span style="color:rgb(61,70,77);"><span style="font-family:'Microsoft YaHei UI';">可用性</span></span></strong></h3><p style="color:rgb(61,70,77);background:rgb(255,255,255);"><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">    在</span>kafka中，正常情况下所有node处于</span><strong><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">同步中</span></span></strong><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">状态，当某个</span>node处于</span><strong><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">非同步中</span></span></strong><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">状态，也就意味着整个系统出问题，需要做容错处理。</span></span></p><p style="color:rgb(61,70,77);background:rgb(255,255,255);"><strong><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">同步中</span></span></strong><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">代表了：</span></span></p><p style="color:rgb(61,70,77);"></p><ul><li><span style="color:rgb(61,70,77);"><span style="font-family:Arial;"> 该</span>node与zookeeper能连通。</span></li><li> <span style="color:rgb(61,70,77);"><span style="font-family:Arial;">该</span>node如果是follower，那么consumer position与leader不能差距太大（差额可配置）。</span></li></ul><p style="color:rgb(61,70,77);background:rgb(255,255,255);"><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">某个分区内</span></span><strong><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">同步中</span></span></strong><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">的</span>node组成一个集合，即该分区的ISR。</span></p><p style="color:rgb(61,70,77);background:rgb(255,255,255);"><span style="color:rgb(61,70,77);">kafka通过两个手段容错：</span></p><p style="color:rgb(61,70,77);"></p><ul><li><strong> </strong><span style="color:rgb(61,70,77);"><span style="font-family:Arial;"><strong>数据备份</strong>：以</span>partition为单位备份，副本数可设置。当副本数为N时，代表1个leader，N-1个followers，followers可以视为leader的consumer，拉取leader的消息，append到自己的系统中</span></li><li> <span style="color:rgb(61,70,77);"><strong>failover</strong>：</span></li></ul><p style="color:rgb(61,70,77);"><span style="color:rgb(61,70,77);background:rgb(255,255,255);">        1. </span><span style="color:rgb(61,70,77);background:rgb(255,255,255);"><span style="font-family:Arial;">当</span>leader处于</span><strong><span style="color:rgb(61,70,77);background:rgb(255,255,255);"><span style="font-family:Arial;">非同步中</span></span></strong><span style="color:rgb(61,70,77);background:rgb(255,255,255);"><span style="font-family:Arial;">时，系统从</span>followers中选举新leader</span></p><p style="color:rgb(61,70,77);"><span style="color:rgb(61,70,77);background:rgb(255,255,255);">       2. </span><span style="color:rgb(61,70,77);background:rgb(255,255,255);"><span style="font-family:Arial;">当某个</span>follower状态变为</span><strong><span style="color:rgb(61,70,77);background:rgb(255,255,255);"><span style="font-family:Arial;">非同步中</span></span></strong><span style="color:rgb(61,70,77);background:rgb(255,255,255);"><span style="font-family:Arial;">时，</span>leader会将此follower剔除ISR，当此follower恢复并完成数据同步之后再次进入 ISR。</span></p><p style="color:rgb(61,70,77);background:rgb(255,255,255);"><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">另外，</span>kafka有个保障：当producer生产消息时，只有当消息被所有ISR确认时，才表示该消息提交成功。只有提交成功的消息，才能被consumer消费。</span></p><p style="background:rgb(255,255,255);"><span style="font-family:Arial;"><span style="color:#3d464d;">因此，</span><strong><span style="color:#ff0000;">当有</span></strong></span><strong><span style="color:#ff0000;">N个副本时，N个副本都在ISR中，N-1个副本都出现异常时，系统依然能提供服务</span><span style="color:#3d464d;">。</span></strong></p><p style="color:rgb(61,70,77);background:rgb(255,255,255);"><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">        假设</span>N副本全挂了，node恢复后会面临同步数据的过程，这期间ISR中没有node，会导致该分区服务不可用。kafka采用一种降级措施来处理：选举第一个恢复的node作为leader提供服务，以它的数据为基准，这个措施被称为</span><strong><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">脏</span>leader选举</span></strong><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">。</span></span><span style="font-family:Arial;">由于</span>leader是主要提供服务的，kafka broker将多个partition的leader均分在不同的server上以均摊风险。<span style="font-family:Arial;">每个</span>parition都有leader，如果在每个partition内运行选主进程，那么会导致产生非常多选主进程。kakfa采用一种轻量级的方式：从broker集群中选出一个作为controller，这个controller监控挂掉的broker，为上面的分区批量选主。</p><h3 style="color:rgb(61,70,77);background:rgb(255,255,255);"><strong><span style="color:rgb(61,70,77);"><span style="font-family:'Microsoft YaHei UI';">一致性</span></span></strong></h3><p style="color:rgb(61,70,77);background:rgb(255,255,255);"><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">上面的方案保证了数据高可用，有时高可用是体现在对一致性的牺牲上。如果希望达到强一致性，可以采取如下措施：</span></span></p><p style="color:rgb(61,70,77);"></p><ul><li> <strong><span><span style="font-family:Arial;">禁用</span></span><span><span style="font-family:Arial;">脏</span>leader选举</span></strong><span><span style="font-family:Arial;">，</span>ISR没有node时，宁可不提供服务也不要未完全同步的node。</span></li><li> <span><strong><span style="font-family:Arial;">设置最小</span>ISR数量min_isr</strong>，保证消息至少要被min_isr个node确认才能提交。</span></li></ul><h3 style="color:rgb(61,70,77);background:rgb(255,255,255);"><strong><span style="color:rgb(61,70,77);"><span style="font-family:'Microsoft YaHei UI';">持久化</span></span></strong></h3><p style="color:rgb(61,70,77);background:rgb(255,255,255);"><span style="color:rgb(61,70,77);"><span style="font-family:Arial;">基于以下几点事实，</span>kafka重度依赖磁盘而非内存来存储消息。</span></p><p style="color:rgb(61,70,77);"></p><ul><li> <span><span style="font-family:Arial;">硬盘便宜，内存贵</span></span></li><li> <span><span style="font-family:Arial;">顺序读</span>+预读取操作，能提高缓存命中率</span></li><li> <span><span style="font-family:Arial;">操作系统利用富余的内存作为</span>pagecache，配合预读取(read-ahead)+写回(write-back)技术，从cache读数据，写到cache就返回（操作系统后台flush)，提高用户进程响应速度</span></li><li> <span>java对象实际大小比理想大小要大，使得将消息存到内存成本很高</span></li><li> <span><span style="font-family:Arial;">当堆内存占用不断增加时，</span>gc抖动较大</span></li><li> <span><span style="font-family:Arial;">基于文件顺序读写的设计思路，代码编写简单</span></span></li><li>在持久化数据结构的选择上，kafka采用了queue而不是Btree</li><li> <span>kafka只有简单的根据offset读和append操作，所以基于queue操作的时间复杂度为O(1),而基于Btree操作的时间复杂度为O(logN)</span></li><li> <span><span style="font-family:Arial;">在大量文件读写的时候，基于</span>queue的read和append只需要一次磁盘寻址，而Btree则会涉及多次。磁盘寻址过程极大降低了读写性能</span></li></ul><p style="text-align:left;">参考文档：</p><p style="text-align:left;"><a href="http://kafka.apache.org/intro" rel="nofollow">kafka官方文档</a> </p><p style="text-align:left;"><a href="https://blog.csdn.net/vinfly_li/article/details/79397201" rel="nofollow"> Kafka全解析</a><br></p><p style="text-align:left;"><a href="https://www.sohu.com/a/144225753_236714" rel="nofollow">小白也能看懂的简单明了kafka原理解析</a></p><p style="text-align:center;"><br></p><p><br></p><div></div>            </div>
                </div>