---
layout:     post
title:      Apache Spark Jobs 性能调优（一）
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                <h1 id="apache-spark-jobs-性能调优一" style="font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;font-weight:500;line-height:40px;color:rgb(44,62,80);font-size:30px;background-color:rgb(249,249,245);">转载：<a href="https://www.zybuluo.com/xiaop1987/note/76737" rel="nofollow">https://www.zybuluo.com/xiaop1987/note/76737</a></h1><h1 style="font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;font-weight:500;line-height:40px;color:rgb(44,62,80);font-size:30px;background-color:rgb(249,249,245);">Apache Spark Jobs 性能调优（一）</h1><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"><code style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:14px;color:rgb(44,62,80);background-color:rgb(214,219,223);border:0px;">Spark</code> <code style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:14px;color:rgb(44,62,80);background-color:rgb(214,219,223);border:0px;">性能调优</code></p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">原文地址：<a href="http://blog.cloudera.com/blog/2015/03/how-to-tune-your-apache-spark-jobs-part-1/" rel="nofollow" style="color:rgb(0,136,204);">http://blog.cloudera.com/blog/2015/03/how-to-tune-your-apache-spark-jobs-part-1/</a></p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"></p><div class="toc" style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"><div class="toc"><ul style="margin-left:25px;list-style-type:none;"><li style="line-height:27px;"><a href="https://www.zybuluo.com/xiaop1987/note/76737#apache-spark-jobs-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%80" rel="nofollow" style="color:rgb(0,136,204);">Apache Spark Jobs 性能调优（一）</a><ul style="margin-left:25px;list-style-type:none;"><li style="line-height:27px;"><a href="https://www.zybuluo.com/xiaop1987/note/76737#spark-%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84" rel="nofollow" style="color:rgb(0,136,204);">Spark 是如何执行程序的</a></li><li style="line-height:27px;"><a href="https://www.zybuluo.com/xiaop1987/note/76737#%E9%80%89%E6%8B%A9%E6%AD%A3%E7%A1%AE%E7%9A%84-operator" rel="nofollow" style="color:rgb(0,136,204);">选择正确的 Operator</a></li><li style="line-height:27px;"><a href="https://www.zybuluo.com/xiaop1987/note/76737#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E5%8F%91%E7%94%9F-shuffle" rel="nofollow" style="color:rgb(0,136,204);">什么时候不发生 Shuffle</a></li><li style="line-height:27px;"><a href="https://www.zybuluo.com/xiaop1987/note/76737#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B-shuffle-%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD" rel="nofollow" style="color:rgb(0,136,204);">什么情况下 Shuffle 越多越好</a></li><li style="line-height:27px;"><a href="https://www.zybuluo.com/xiaop1987/note/76737#%E4%BA%8C%E6%AC%A1%E6%8E%92%E5%BA%8F" rel="nofollow" style="color:rgb(0,136,204);">二次排序</a></li><li style="line-height:27px;"><a href="https://www.zybuluo.com/xiaop1987/note/76737#%E7%BB%93%E8%AE%BA" rel="nofollow" style="color:rgb(0,136,204);">结论</a></li></ul></li></ul></div></div><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"></p><hr style="border-top-width:0px;border-right-width:0px;border-left-width:0px;border-bottom-style:dashed;border-bottom-color:rgb(207,207,207);color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">当你开始编写 Apache Spark 代码或者浏览公开的 API 的时候，你会遇到各种各样术语，比如 <em>transformation</em>，<em>action</em>，<em>RDD</em> 等等。 了解到这些是编写 Spark 代码的基础。 同样，当你任务开始失败或者你需要透过web界面去了解自己的应用为何如此费时的时候，你需要去了解一些新的名词： <em>job</em>, <em>stage</em>, <em>task</em>。对于这些新术语的理解有助于编写<span style="font-weight:700;">良好</span> Spark 代码。这里的<span style="font-weight:700;">良好</span>主要指<span style="font-weight:700;">更快</span>的 Spark 程序。对于 Spark 底层的执行模型的了解对于写出效率更高的 Spark 程序非常有帮助。</p><div class="md-section-divider" style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"></div><h2 id="spark-是如何执行程序的" style="font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;font-weight:500;line-height:40px;color:rgb(44,62,80);font-size:26px;background-color:rgb(249,249,245);">Spark 是如何执行程序的</h2><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">一个 Spark 应用包括一个 <em>driver</em> 进程和若干个分布在集群的各个节点上的 <em>executor</em> 进程。</p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"><em>driver</em> 主要负责调度一些高层次的任务流（flow of work）。<em>exectuor</em> 负责执行这些任务，这些任务以 <em>task</em> 的形式存在， 同时存储用户设置需要caching的数据。 <em>task</em> 和所有的 <em>executor</em> 的生命周期为整个程序的运行过程（如果使用了dynamic resource allocation 时可能不是这样的）。如何调度这些进程是通过集群管理应用完成的（比如YARN，Mesos，Spark Standalone），但是任何一个 Spark 程序都会包含一个 <em>driver</em> 和多个 <em>executor</em> 进程。</p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"><img src="http://blog.cloudera.com/wp-content/uploads/2015/02/spark-tuning-f1.png" alt="此处输入图片的描述" style="vertical-align:middle;border:0px;"></p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">在执行层次结构的最上方是一系列 Job。调用一个Spark内部的 <em>action</em> 会产生一个 Spark job 来完成它。 为了确定这些job实际的内容，Spark 检查 <em>RDD</em> 的DAG再计算出执行 plan 。这个 plan 以最远端的 <em>RDD</em> 为起点（最远端指的是对外没有依赖的 <em>RDD</em> 或者 数据已经缓存下来的 <em>RDD</em>），产生结果 <em>RDD</em> 的 <em>action</em> 为结束 。</p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">执行的 plan 由一系列 <em>stage</em> 组成，<em>stage</em> 是 <em>job</em> 的 <em>transformation</em> 的组合，<em>stage</em> 对应于一系列 <em>task</em>， <em>task</em> 指的对于不同的数据集执行的相同代码。每个 <em>stage</em> 包含不需要 <em>shuffle</em> 数据的 <em>transformation</em> 的序列。</p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">什么决定数据是否需要 <em>shuffle</em> ？<em>RDD</em> 包含固定数目的 <em>partition</em>， 每个 <em>partiton</em> 包含若干的 <em>record</em>。对于那些通过 <em>narrow tansformation</em>（比如 <span style="font-weight:700;">map</span> 和 <span style="font-weight:700;">filter</span>）返回的 <em>RDD</em>，一个 <em>partition</em> 中的 <em>record</em> 只需要从父 <em>RDD</em> 对应的 <em>partition</em> 中的 <em>record</em> 计算得到。每个对象只依赖于父 <em>RDD</em> 的一个对象。有些操作（比如 <span style="font-weight:700;">coalesce</span>）可能导致一个 <em>task</em> 处理多个输入 <em>partition</em> ，但是这种 <em>transformation</em> 仍然被认为是 <em>narrow</em> 的，因为用于计算的多个输入 <em>record</em>始终是来自有限个数的 <em>partition</em>。</p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">然而 Spark 也支持需要 <em>wide</em> 依赖的 <em>transformation</em>，比如 <span style="font-weight:700;">groupByKey</span>，<span style="font-weight:700;">reduceByKey</span>。在这种依赖中，计算得到一个 <em>partition</em> 中的数据需要从父 <em>RDD</em> 中的多个 <em>partition</em> 中读取数据。所有拥有相同 <em>key</em> 的元组最终会被聚合到同一个 <em>partition</em> 中，被同一个 <em>stage</em> 处理。为了完成这种操作， Spark需要对数据进行 <em>shuffle</em>，意味着数据需要在集群内传递，最终生成由新的 <em>partition</em> 集合组成的新的 <em>stage</em>。</p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">举例，以下的代码中，只有一个 <em>action</em> 以及 从一个文本串下来的一系列 <em>RDD</em>， 这些代码就只有一个 <em>stage</em>，因为没有哪个操作需要从不同的 <em>partition</em> 里面读取数据。</p><div class="md-section-divider" style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"></div><pre class="prettyprint linenums prettyprinted" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:14px;color:rgb(51,51,51);background:rgba(102,128,153,.05) none repeat scroll 0px 0px;border-width:0px;border-style:solid;border-color:rgba(0,0,0,.15);"></pre><ol class="linenums" style="margin-left:35px;color:rgba(102,128,153,.4);"><li class="L0" style="line-height:20px;"><code class="language-scala" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:inherit;background-color:transparent;border:0px;"><span class="pln" style="color:rgb(0,0,0);">sc</span><span class="pun" style="color:rgb(102,102,0);">.</span><span class="pln" style="color:rgb(0,0,0);">textFile</span><span class="pun" style="color:rgb(102,102,0);">(</span><span class="str" style="color:rgb(0,136,0);">"someFile.txt"</span><span class="pun" style="color:rgb(102,102,0);">).</span></code></li><li class="L1" style="line-height:20px;"><code class="language-scala" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:inherit;background-color:transparent;border:0px;"><span class="pln" style="color:rgb(0,0,0);">  map</span><span class="pun" style="color:rgb(102,102,0);">(</span><span class="pln" style="color:rgb(0,0,0);">mapFunc</span><span class="pun" style="color:rgb(102,102,0);">).</span></code></li><li class="L2" style="line-height:20px;"><code class="language-scala" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:inherit;background-color:transparent;border:0px;"><span class="pln" style="color:rgb(0,0,0);">  flatMap</span><span class="pun" style="color:rgb(102,102,0);">(</span><span class="pln" style="color:rgb(0,0,0);">flatMapFunc</span><span class="pun" style="color:rgb(102,102,0);">).</span></code></li><li class="L3" style="line-height:20px;"><code class="language-scala" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:inherit;background-color:transparent;border:0px;"><span class="pln" style="color:rgb(0,0,0);">  filter</span><span class="pun" style="color:rgb(102,102,0);">(</span><span class="pln" style="color:rgb(0,0,0);">filterFunc</span><span class="pun" style="color:rgb(102,102,0);">).</span></code></li><li class="L4" style="line-height:20px;"><code class="language-scala" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:inherit;background-color:transparent;border:0px;"><span class="pln" style="color:rgb(0,0,0);">  count</span><span class="pun" style="color:rgb(102,102,0);">()</span></code></li></ol><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">跟上面的代码不同，下面一段代码需要统计总共出现超过1000次的字母，</p><div class="md-section-divider" style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"></div><pre class="prettyprint linenums prettyprinted" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:14px;color:rgb(51,51,51);background:rgba(102,128,153,.05) none repeat scroll 0px 0px;border-width:0px;border-style:solid;border-color:rgba(0,0,0,.15);"></pre><ol class="linenums" style="margin-left:35px;color:rgba(102,128,153,.4);"><li class="L0" style="line-height:20px;"><code class="language-scala" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:inherit;background-color:transparent;border:0px;"><span class="pln" style="color:rgb(0,0,0);">val tokenized </span><span class="pun" style="color:rgb(102,102,0);">=</span><span class="pln" style="color:rgb(0,0,0);"> sc</span><span class="pun" style="color:rgb(102,102,0);">.</span><span class="pln" style="color:rgb(0,0,0);">textFile</span><span class="pun" style="color:rgb(102,102,0);">(</span><span class="pln" style="color:rgb(0,0,0);">args</span><span class="pun" style="color:rgb(102,102,0);">(</span><span class="lit" style="color:rgb(0,102,102);">0</span><span class="pun" style="color:rgb(102,102,0);">)).</span><span class="pln" style="color:rgb(0,0,0);">flatMap</span><span class="pun" style="color:rgb(102,102,0);">(</span><span class="pln" style="color:rgb(0,0,0);">_</span><span class="pun" style="color:rgb(102,102,0);">.</span><span class="pln" style="color:rgb(0,0,0);">split</span><span class="pun" style="color:rgb(102,102,0);">(</span><span class="str" style="color:rgb(0,136,0);">' '</span><span class="pun" style="color:rgb(102,102,0);">))</span></code></li><li class="L1" style="line-height:20px;"><code class="language-scala" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:inherit;background-color:transparent;border:0px;"><span class="pln" style="color:rgb(0,0,0);">val wordCounts </span><span class="pun" style="color:rgb(102,102,0);">=</span><span class="pln" style="color:rgb(0,0,0);"> tokenized</span><span class="pun" style="color:rgb(102,102,0);">.</span><span class="pln" style="color:rgb(0,0,0);">map</span><span class="pun" style="color:rgb(102,102,0);">((</span><span class="pln" style="color:rgb(0,0,0);">_</span><span class="pun" style="color:rgb(102,102,0);">,</span><span class="pln" style="color:rgb(0,0,0);"> </span><span class="lit" style="color:rgb(0,102,102);">1</span><span class="pun" style="color:rgb(102,102,0);">)).</span><span class="pln" style="color:rgb(0,0,0);">reduceByKey</span><span class="pun" style="color:rgb(102,102,0);">(</span><span class="pln" style="color:rgb(0,0,0);">_ </span><span class="pun" style="color:rgb(102,102,0);">+</span><span class="pln" style="color:rgb(0,0,0);"> _</span><span class="pun" style="color:rgb(102,102,0);">)</span></code></li><li class="L2" style="line-height:20px;"><code class="language-scala" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:inherit;background-color:transparent;border:0px;"><span class="pln" style="color:rgb(0,0,0);">val filtered </span><span class="pun" style="color:rgb(102,102,0);">=</span><span class="pln" style="color:rgb(0,0,0);"> wordCounts</span><span class="pun" style="color:rgb(102,102,0);">.</span><span class="pln" style="color:rgb(0,0,0);">filter</span><span class="pun" style="color:rgb(102,102,0);">(</span><span class="pln" style="color:rgb(0,0,0);">_</span><span class="pun" style="color:rgb(102,102,0);">.</span><span class="pln" style="color:rgb(0,0,0);">_2 </span><span class="pun" style="color:rgb(102,102,0);">&gt;=</span><span class="pln" style="color:rgb(0,0,0);"> </span><span class="lit" style="color:rgb(0,102,102);">1000</span><span class="pun" style="color:rgb(102,102,0);">)</span></code></li><li class="L3" style="line-height:20px;"><code class="language-scala" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:inherit;background-color:transparent;border:0px;"><span class="pln" style="color:rgb(0,0,0);">val charCounts </span><span class="pun" style="color:rgb(102,102,0);">=</span><span class="pln" style="color:rgb(0,0,0);"> filtered</span><span class="pun" style="color:rgb(102,102,0);">.</span><span class="pln" style="color:rgb(0,0,0);">flatMap</span><span class="pun" style="color:rgb(102,102,0);">(</span><span class="pln" style="color:rgb(0,0,0);">_</span><span class="pun" style="color:rgb(102,102,0);">.</span><span class="pln" style="color:rgb(0,0,0);">_1</span><span class="pun" style="color:rgb(102,102,0);">.</span><span class="pln" style="color:rgb(0,0,0);">toCharArray</span><span class="pun" style="color:rgb(102,102,0);">).</span><span class="pln" style="color:rgb(0,0,0);">map</span><span class="pun" style="color:rgb(102,102,0);">((</span><span class="pln" style="color:rgb(0,0,0);">_</span><span class="pun" style="color:rgb(102,102,0);">,</span><span class="pln" style="color:rgb(0,0,0);"> </span><span class="lit" style="color:rgb(0,102,102);">1</span><span class="pun" style="color:rgb(102,102,0);">)).</span></code></li><li class="L4" style="line-height:20px;"><code class="language-scala" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:inherit;background-color:transparent;border:0px;"><span class="pln" style="color:rgb(0,0,0);">  reduceByKey</span><span class="pun" style="color:rgb(102,102,0);">(</span><span class="pln" style="color:rgb(0,0,0);">_ </span><span class="pun" style="color:rgb(102,102,0);">+</span><span class="pln" style="color:rgb(0,0,0);"> _</span><span class="pun" style="color:rgb(102,102,0);">)</span></code></li><li class="L5" style="line-height:20px;"><code class="language-scala" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:inherit;background-color:transparent;border:0px;"><span class="pln" style="color:rgb(0,0,0);">charCounts</span><span class="pun" style="color:rgb(102,102,0);">.</span><span class="pln" style="color:rgb(0,0,0);">collect</span><span class="pun" style="color:rgb(102,102,0);">()</span></code></li></ol><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">这段代码可以分成三个 <em>stage</em>。<span style="font-weight:700;">recudeByKey</span> 操作是各 <em>stage</em> 之间的分界，因为计算 <span style="font-weight:700;">recudeByKey</span> 的输出需要按照可以重新分配 <em>partition</em>。</p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">这里还有一个更加复杂的 <em>transfromation</em> 图，包含一个有多路依赖的 <em>join transformation</em>。</p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"><img src="http://blog.cloudera.com/wp-content/uploads/2015/02/spark-tuning-f2.png" alt="此处输入图片的描述" style="vertical-align:middle;border:0px;"></p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">粉红色的框框展示了运行时使用的 <em>stage</em> 图。</p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"><img src="http://blog.cloudera.com/wp-content/uploads/2015/02/spark-tuning-f3.png" alt="此处输入图片的描述" title="" style="vertical-align:middle;border:0px;"></p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">运行到每个 <em>stage</em> 的边界时，数据在父 <em>stage</em> 中按照 <em>task</em> 写到磁盘上，而在子 <em>stage</em> 中通过网络按照 <em>task</em> 去读取数据。这些操作会导致很重的网络以及磁盘的I/O，所以 <em>stage</em> 的边界是非常占资源的，在编写 Spark 程序的时候需要尽量避免的。父 <em>stage</em> 中 <em>partition</em> 个数与子 <em>stage</em> 的 <em>partition</em> 个数可能不同，所以那些产生 <em>stage</em> 边界的 <em>transformation</em> 常常需要接受一个 numPartition 的参数来觉得子 <em>stage</em> 中的数据将被切分为多少个 <em>partition</em>。</p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">正如在调试 <em>MapReduce</em> 是选择 <em>reducor</em> 的个数是一项非常重要的参数，调整在 <em>stage</em> 边届时的 <em>partition</em> 个数经常可以很大程度上影响程序的执行效率。我们会在后面的章节中讨论如何调整这些值。</p><div class="md-section-divider" style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"></div><h2 id="选择正确的-operator" style="font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;font-weight:500;line-height:40px;color:rgb(44,62,80);font-size:26px;background-color:rgb(249,249,245);">选择正确的 <em>Operator</em></h2><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">当需要使用 Spark 完成某项功能时，程序员需要从不同的 <em>action</em> 和 <em>transformation</em> 中选择不同的方案以获得相同的结果。但是不同的方案，最后执行的效率可能有云泥之别。回避常见的陷阱选择正确的方案可以使得最后的表现有巨大的不同。一些规则和深入的理解可以帮助你做出更好的选择。</p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">在最新的 <a href="https://issues.apache.org/jira/browse/SPARK-5097" rel="nofollow" style="color:rgb(0,136,204);">Spark5097</a> 文档中开始稳定 <em>SchemaRDD</em>（也就是 Spark 1.3 开始支持的DataFrame)，这将为使用 Spark 核心API的程序员打开 Spark的 Catalyst optimizer，允许 Spark 在使用 <em>Operator</em> 时做出更加高级的选择。当 <em>SchemaRDD</em> 稳定之后，某些决定将不需要用户去考虑了。</p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">选择 <em>Operator</em> 方案的主要目标是减少 <em>shuffle</em> 的次数以及被 <em>shuffle</em> 的文件的大小。因为 <em>shuffle</em> 是最耗资源的操作，所以有 <em>shuffle</em> 的数据都需要写到磁盘并且通过网络传递。<span style="font-weight:700;">repartition</span>，<span style="font-weight:700;">join</span>，<span style="font-weight:700;">cogroup</span>，以及任何 <span style="font-weight:700;">*By</span> 或者 <span style="font-weight:700;">*ByKey</span>的 <em>transformation</em> 都需要 <em>shuffle</em> 数据。不是所有这些 <em>Operator</em> 都是平等的，但是有些常见的性能陷阱是需要注意的。</p><ul style="margin-left:25px;color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"><li style="line-height:27px;">当进行联合的规约操作时，避免使用 <span style="font-weight:700;">groupByKey</span>。举个例子，rdd.groupByKey().mapValues(_ .sum) 与 rdd.reduceByKey(_ + _) 执行的结果是一样的，但是前者需要把全部的数据通过网络传递一遍，而后者只需要根据每个 <em>key</em> 局部的 <em>partition</em> 累积结果，在 <em>shuffle</em> 的之后把局部的累积值相加后得到结果。</li><li style="line-height:27px;">当输入和输入的类型不一致时，避免使用 <span style="font-weight:700;">reduceByKey</span>。举个例子，我们需要实现为每一个key查找所有不相同的 string。一个方法是利用 <span style="font-weight:700;">map</span> 把每个元素的转换成一个 Set，再使用 <span style="font-weight:700;">reduceByKey</span> 将这些 Set 合并起来</li></ul><div class="md-section-divider" style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"></div><pre class="prettyprint linenums prettyprinted" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:14px;color:rgb(51,51,51);background:rgba(102,128,153,.05) none repeat scroll 0px 0px;border-width:0px;border-style:solid;border-color:rgba(0,0,0,.15);"></pre><ol class="linenums" style="margin-left:35px;color:rgba(102,128,153,.4);"><li class="L0" style="line-height:20px;"><code class="language-scala" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:inherit;background-color:transparent;border:0px;"><span class="pln" style="color:rgb(0,0,0);">rdd</span><span class="pun" style="color:rgb(102,102,0);">.</span><span class="pln" style="color:rgb(0,0,0);">map</span><span class="pun" style="color:rgb(102,102,0);">(</span><span class="pln" style="color:rgb(0,0,0);">kv </span><span class="pun" style="color:rgb(102,102,0);">=&gt;</span><span class="pln" style="color:rgb(0,0,0);"> </span><span class="pun" style="color:rgb(102,102,0);">(</span><span class="pln" style="color:rgb(0,0,0);">kv</span><span class="pun" style="color:rgb(102,102,0);">.</span><span class="pln" style="color:rgb(0,0,0);">_1</span><span class="pun" style="color:rgb(102,102,0);">,</span><span class="pln" style="color:rgb(0,0,0);"> </span><span class="kwd" style="color:rgb(0,0,136);">new</span><span class="pln" style="color:rgb(0,0,0);"> </span><span class="typ" style="color:rgb(102,0,102);">Set</span><span class="pun" style="color:rgb(102,102,0);">[</span><span class="typ" style="color:rgb(102,0,102);">String</span><span class="pun" style="color:rgb(102,102,0);">]()</span><span class="pln" style="color:rgb(0,0,0);"> </span><span class="pun" style="color:rgb(102,102,0);">+</span><span class="pln" style="color:rgb(0,0,0);"> kv</span><span class="pun" style="color:rgb(102,102,0);">.</span><span class="pln" style="color:rgb(0,0,0);">_2</span><span class="pun" style="color:rgb(102,102,0);">))</span></code></li><li class="L1" style="line-height:20px;"><code class="language-scala" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:inherit;background-color:transparent;border:0px;"><span class="pln" style="color:rgb(0,0,0);">    </span><span class="pun" style="color:rgb(102,102,0);">.</span><span class="pln" style="color:rgb(0,0,0);">reduceByKey</span><span class="pun" style="color:rgb(102,102,0);">(</span><span class="pln" style="color:rgb(0,0,0);">_ </span><span class="pun" style="color:rgb(102,102,0);">++</span><span class="pln" style="color:rgb(0,0,0);"> _</span><span class="pun" style="color:rgb(102,102,0);">)</span></code></li></ol><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">这段代码生成了无数的非必须的对象，因为每个需要为每个 record 新建一个 Set。这里使用 <span style="font-weight:700;">aggregateByKey</span> 更加适合，因为这个操作是在 <span style="font-weight:700;">map</span> 阶段做聚合。</p><div class="md-section-divider" style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"></div><pre class="prettyprint linenums prettyprinted" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:14px;color:rgb(51,51,51);background:rgba(102,128,153,.05) none repeat scroll 0px 0px;border-width:0px;border-style:solid;border-color:rgba(0,0,0,.15);"></pre><ol class="linenums" style="margin-left:35px;color:rgba(102,128,153,.4);"><li class="L0" style="line-height:20px;"><code class="language-scala" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:inherit;background-color:transparent;border:0px;"><span class="pln" style="color:rgb(0,0,0);">val zero </span><span class="pun" style="color:rgb(102,102,0);">=</span><span class="pln" style="color:rgb(0,0,0);"> </span><span class="kwd" style="color:rgb(0,0,136);">new</span><span class="pln" style="color:rgb(0,0,0);"> collection</span><span class="pun" style="color:rgb(102,102,0);">.</span><span class="kwd" style="color:rgb(0,0,136);">mutable</span><span class="pun" style="color:rgb(102,102,0);">.</span><span class="typ" style="color:rgb(102,0,102);">Set</span><span class="pun" style="color:rgb(102,102,0);">[</span><span class="typ" style="color:rgb(102,0,102);">String</span><span class="pun" style="color:rgb(102,102,0);">]()</span></code></li><li class="L1" style="line-height:20px;"><code class="language-scala" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:inherit;background-color:transparent;border:0px;"><span class="pln" style="color:rgb(0,0,0);">rdd</span><span class="pun" style="color:rgb(102,102,0);">.</span><span class="pln" style="color:rgb(0,0,0);">aggregateByKey</span><span class="pun" style="color:rgb(102,102,0);">(</span><span class="pln" style="color:rgb(0,0,0);">zero</span><span class="pun" style="color:rgb(102,102,0);">)(</span></code></li><li class="L2" style="line-height:20px;"><code class="language-scala" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:inherit;background-color:transparent;border:0px;"><span class="pln" style="color:rgb(0,0,0);">    </span><span class="pun" style="color:rgb(102,102,0);">(</span><span class="kwd" style="color:rgb(0,0,136);">set</span><span class="pun" style="color:rgb(102,102,0);">,</span><span class="pln" style="color:rgb(0,0,0);"> v</span><span class="pun" style="color:rgb(102,102,0);">)</span><span class="pln" style="color:rgb(0,0,0);"> </span><span class="pun" style="color:rgb(102,102,0);">=&gt;</span><span class="pln" style="color:rgb(0,0,0);"> </span><span class="kwd" style="color:rgb(0,0,136);">set</span><span class="pln" style="color:rgb(0,0,0);"> </span><span class="pun" style="color:rgb(102,102,0);">+=</span><span class="pln" style="color:rgb(0,0,0);"> v</span><span class="pun" style="color:rgb(102,102,0);">,</span></code></li><li class="L3" style="line-height:20px;"><code class="language-scala" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:inherit;background-color:transparent;border:0px;"><span class="pln" style="color:rgb(0,0,0);">    </span><span class="pun" style="color:rgb(102,102,0);">(</span><span class="pln" style="color:rgb(0,0,0);">set1</span><span class="pun" style="color:rgb(102,102,0);">,</span><span class="pln" style="color:rgb(0,0,0);"> set2</span><span class="pun" style="color:rgb(102,102,0);">)</span><span class="pln" style="color:rgb(0,0,0);"> </span><span class="pun" style="color:rgb(102,102,0);">=&gt;</span><span class="pln" style="color:rgb(0,0,0);"> set1 </span><span class="pun" style="color:rgb(102,102,0);">++=</span><span class="pln" style="color:rgb(0,0,0);"> set2</span><span class="pun" style="color:rgb(102,102,0);">)</span></code></li></ol><ul style="margin-left:25px;color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"><li style="line-height:27px;">避免 flatMap-join-groupBy 的模式。当有两个已经按照key分组的数据集，你希望将两个数据集合并，并且保持分组，这种情况可以使用 <span style="font-weight:700;">cogroup</span>。这样可以避免对group进行打包解包的开销。</li></ul><div class="md-section-divider" style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"></div><h2 id="什么时候不发生-shuffle" style="font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;font-weight:500;line-height:40px;color:rgb(44,62,80);font-size:26px;background-color:rgb(249,249,245);">什么时候不发生 <em>Shuffle</em></h2><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">当然了解在哪些 <em>transformation</em> 上不会发生 <em>shuffle</em> 也是非常重要的。当前一个 <em>transformation</em> 已经用相同的 <em>patitioner</em> 把数据分 patition 了，Spark知道如何避免 <em>shuffle</em>。参考一下代码：</p><div class="md-section-divider" style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"></div><pre class="prettyprint linenums prettyprinted" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:14px;color:rgb(51,51,51);background:rgba(102,128,153,.05) none repeat scroll 0px 0px;border-width:0px;border-style:solid;border-color:rgba(0,0,0,.15);"></pre><ol class="linenums" style="margin-left:35px;color:rgba(102,128,153,.4);"><li class="L0" style="line-height:20px;"><code class="language-scala" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:inherit;background-color:transparent;border:0px;"><span class="pln" style="color:rgb(0,0,0);">rdd1 </span><span class="pun" style="color:rgb(102,102,0);">=</span><span class="pln" style="color:rgb(0,0,0);"> someRdd</span><span class="pun" style="color:rgb(102,102,0);">.</span><span class="pln" style="color:rgb(0,0,0);">reduceByKey</span><span class="pun" style="color:rgb(102,102,0);">(...)</span></code></li><li class="L1" style="line-height:20px;"><code class="language-scala" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:inherit;background-color:transparent;border:0px;"><span class="pln" style="color:rgb(0,0,0);">rdd2 </span><span class="pun" style="color:rgb(102,102,0);">=</span><span class="pln" style="color:rgb(0,0,0);"> someOtherRdd</span><span class="pun" style="color:rgb(102,102,0);">.</span><span class="pln" style="color:rgb(0,0,0);">reduceByKey</span><span class="pun" style="color:rgb(102,102,0);">(...)</span></code></li><li class="L2" style="line-height:20px;"><code class="language-scala" style="font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;color:inherit;background-color:transparent;border:0px;"><span class="pln" style="color:rgb(0,0,0);">rdd3 </span><span class="pun" style="color:rgb(102,102,0);">=</span><span class="pln" style="color:rgb(0,0,0);"> rdd1</span><span class="pun" style="color:rgb(102,102,0);">.</span><span class="pln" style="color:rgb(0,0,0);">join</span><span class="pun" style="color:rgb(102,102,0);">(</span><span class="pln" style="color:rgb(0,0,0);">rdd2</span><span class="pun" style="color:rgb(102,102,0);">)</span></code></li></ol><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">因为没有 <em>partitioner</em> 传递给 <span style="font-weight:700;">reduceByKey</span>，所以系统使用默认的 <em>partitioner</em>，所以 rdd1 和 rdd2 都会使用 hash 进行分 <em>partition</em>。代码中的两个 <span style="font-weight:700;">reduceByKey</span> 会发生两次 <em>shuffle</em> 。如果 <em>RDD</em> 包含相同个数的 <em>partition</em>， <em>join</em> 的时候将不会发生额外的 <em>shuffle</em>。因为这里的 <em>RDD</em> 使用相同的 hash 方式进行 <em>partition</em>，所以全部 <em>RDD</em> 中同一个 <em>partition</em>中的 key的集合都是相同的。因此，rdd3中一个 <em>partiton</em> 的输出只依赖rdd2和rdd1的同一个对应的 <em>partition</em>，所以第三次 <em>shuffle</em> 是不必要的。</p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">举个例子说，当 <em>someRdd</em> 有4个 <em>partition</em>， <em>someOtherRdd</em> 有两个 <em>partition</em>，两个 <span style="font-weight:700;">reduceByKey</span> 都使用3个 <em>partiton</em>，所有的 <em>task</em> 会按照如下的方式执行：</p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"><img src="http://blog.cloudera.com/wp-content/uploads/2015/02/spark-tuning-f4.png" alt="此处输入图片的描述" title="" style="vertical-align:middle;border:0px;"></p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">如果 rdd1 和 rdd2 在 <span style="font-weight:700;">reduceByKey</span> 时使用不同的 <em>partitioner</em> 或者使用相同的 <em>partitioner</em> 但是 <em>partition</em> 的个数不同的情况，那么只用一个 <em>RDD</em> (<em>partiton</em> 数更少的那个)需要重新 <em>shuffle</em>。</p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">相同的 <em>tansformation</em>，相同的输入，不同的 <em>partition</em> 个数：</p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"><img src="http://blog.cloudera.com/wp-content/uploads/2015/02/spark-tuning-f5.png" alt="此处输入图片的描述" title="" style="vertical-align:middle;border:0px;"></p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">当两个数据集需要 <span style="font-weight:700;">join</span> 的时候，避免 <em>shuffle</em> 的一个方法是使用 <a href="http://spark.apache.org/docs/latest/programming-guide.html#broadcast-variables" rel="nofollow" style="color:rgb(0,136,204);">broadcast variables</a>。如果一个数据集小到能够塞进一个 <em>executor</em> 的内存中，那么它就可以在 <em>driver</em> 中写入到一个 hash table中，然后 broadcast 到所有的 <em>executor</em> 中。然后 <em>map transformation</em> 可以引用这个 hash table 作查询。</p><div class="md-section-divider" style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"></div><h2 id="什么情况下-shuffle-越多越好" style="font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;font-weight:500;line-height:40px;color:rgb(44,62,80);font-size:26px;background-color:rgb(249,249,245);">什么情况下 <em>Shuffle</em> 越多越好</h2><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">尽可能减少 <em>shuffle</em> 的准则也有例外的场合。如果额外的 <em>shuffle</em> 能够增加并发那么这也能够提高性能。比如当你的数据保存在几个没有切分过的大文件中时，那么使用 InputFormat 产生分 partition 可能会导致每个 partiton 中聚集了大量的 <em>record</em>，如果 <em>partition</em> 不够，导致没有启动足够的并发。在这种情况下，我们需要在数据载入之后使用 <span style="font-weight:700;">repartiton</span>（会导致shuffle)提高 partiton 的个数，这样能够充分使用集群的CPU。</p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">另外一种例外情况是在使用 recude 或者 aggregate <em>action</em> 聚集数据到 <em>driver</em> 时，如果数据把很多 <em>partititon</em> 个数的数据，单进程执行的 <em>driver</em> merge 所有 <em>partition</em> 的输出时很容易成为计算的瓶颈。为了缓解 <em>driver</em> 的计算压力，可以使用 <span style="font-weight:700;">reduceByKey</span> 或者 <span style="font-weight:700;">aggregateByKey</span> 执行分布式的 aggregate 操作把数据分布到更少的 <em>partition</em> 上。每个 <em>partition</em> 中的数据并行的进行 merge，再把 merge 的结果发个 <em>driver</em> 以进行最后一轮 aggregation。查看 <span style="font-weight:700;">treeReduce</span> 和 <span style="font-weight:700;">treeAggregate</span> 查看如何这么使用的例子。</p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">这个技巧在已经按照 Key 聚集的数据集上格外有效，比如当一个应用是需要统计一个语料库中每个单词出现的次数，并且把结果输出到一个map中。一个实现的方式是使用 <span style="font-weight:700;">aggregation</span>，在每个 <em>partition</em> 中本地计算一个 map，然后在 <em>driver</em> 中把各个 <em>partition</em> 中计算的 map merge 起来。另一种方式是通过 <span style="font-weight:700;">aggregateByKey</span> 把 merge 的操作分布到各个 <em>partiton</em> 中计算，然后在简单地通过 <span style="font-weight:700;">collectAsMap</span> 把结果输出到 <em>driver</em> 中。</p><div class="md-section-divider" style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"></div><h2 id="二次排序" style="font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;font-weight:500;line-height:40px;color:rgb(44,62,80);font-size:26px;background-color:rgb(249,249,245);">二次排序</h2><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">还有一个重要的技能是了解接口 <span style="font-weight:700;">repartitionAndSortWithinPartitions</span> <em>transformation</em>。这是一个听起来很晦涩的 <em>transformation</em>，但是却能涵盖各种奇怪情况下的排序，这个 <em>transformation</em> 把排序推迟到 <em>shuffle</em> 操作中，这使大量的数据有效的输出，排序操作可以和其他操作合并。</p><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">举例说，Apache Hive on Spark 在join的实现中，使用了这个 <em>transformation</em> 。而且这个操作在 <a href="http://www.quora.com/What-is-secondary-sort-in-Hadoop-and-how-does-it-work" rel="nofollow" style="color:rgb(0,136,204);">secondary sort</a> 模式中扮演着至关重要的角色。secondary sort 模式是指用户期望数据按照 key 分组，并且希望按照特定的顺序遍历 value。使用 <span style="font-weight:700;">repartitionAndSortWithinPartitions</span> 再加上一部分用户的额外的工作可以实现 secondary sort。</p><div class="md-section-divider" style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);"></div><h2 id="结论" style="font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;font-weight:500;line-height:40px;color:rgb(44,62,80);font-size:26px;background-color:rgb(249,249,245);">结论</h2><p style="color:rgb(44,62,80);font-family:'PingFang SC', 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft Yahei', 'WenQuanYi Micro Hei', sans-serif;background-color:rgb(249,249,245);">现在你应该对完成一个高效的 Spark 程序所需的所有基本要素有了很好的了解。在 Part II 中将详细介绍资源调用、并发以及数据结构相关的调试。</p>            </div>
                </div>