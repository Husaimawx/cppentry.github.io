---
layout:     post
title:      Flume相关技术汇总
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								<div class="article-copyright">
					版权声明：转载请注明出处。					https://blog.csdn.net/tiantang_1986/article/details/45192355				</div>
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                
<p>这些知识基本来源网络，我自己收集了一下做个汇总。</p>
<p></p>
<p>1<span style="font-family:'宋体';">、简介</span></p>
<p>Flume<span style="font-family:'宋体';">支持在日志系统中定制各类数据发送方，用于收集数据。</span><span style="font-family:Verdana;">Flume</span><span style="font-family:'宋体';">最早是</span><span style="font-family:Verdana;">Cloudera</span><span style="font-family:'宋体';">提供的日志收集系统，目前是</span><span style="font-family:Verdana;">Apache</span><span style="font-family:'宋体';">下的一个孵化项目。</span></p>
<p>当前<span style="font-family:Verdana;">Flume</span><span style="font-family:'宋体';">有两个版本</span><span style="font-family:Verdana;">Flume 0.9X</span><span style="font-family:'宋体';">版本的统称</span><span style="font-family:Verdana;">Flume-og</span><span style="font-family:'宋体';">，</span><span style="font-family:Verdana;">Flume1.X</span><span style="font-family:'宋体';">版本的统称</span><span style="font-family:Verdana;">Flume-ng</span><span style="font-family:'宋体';">。</span></p>
<p>Flume<span style="font-family:'宋体';">提供对数据进行简单处理，并写到各种数据接受方（可定制）的能力 </span><span style="font-family:Verdana;">Flume</span><span style="font-family:'宋体';">提供了从</span><span style="font-family:Verdana;">console</span><span style="font-family:'宋体';">（控制台）、</span><span style="font-family:Verdana;">RPC</span><span style="font-family:'宋体';">（</span><span style="font-family:Verdana;">Thrift-RPC</span><span style="font-family:'宋体';">）、</span><span style="font-family:Verdana;">text</span><span style="font-family:'宋体';">（文件）、</span><span style="font-family:Verdana;">tail</span><span style="font-family:'宋体';">（</span><span style="font-family:Verdana;">UNIX tail</span><span style="font-family:'宋体';">）、</span><span style="font-family:Verdana;">syslog</span><span style="font-family:'宋体';">（</span><span style="font-family:Verdana;">syslog</span><span style="font-family:'宋体';">日志系统，支持</span><span style="font-family:Verdana;">TCP</span><span style="font-family:'宋体';">和</span><span style="font-family:Verdana;">UDP</span><span style="font-family:'宋体';">等</span><span style="font-family:Verdana;">2</span><span style="font-family:'宋体';">种模式），</span><span style="font-family:Verdana;">exec</span><span style="font-family:'宋体';">（命令执行）等数据源上收集数据的能力。</span></p>
<p>官网：<span style="font-family:Verdana;">http://flume.apache.org/</span><span style="font-family:'宋体';">。源码可以从</span><span style="font-family:Verdana;">git </span><span style="font-family:'宋体';">获取，地址：</span><a href="https://git-wip-us.apache.org/repos/asf/flume.git" rel="nofollow"><span style="color:rgb(0,0,0);">https://git-wip-us.apache.org/repos/asf/flume.git</span></a>，或者从官网获取：<span style="font-family:Verdana;">http://flume.apache.org/download.html</span><span style="font-family:'宋体';">。解压即可，下面是解压后得到的文件：</span></p>
<p> <img src="" alt=""><img src="https://img-blog.csdn.net/20150707103643406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>bin<span style="font-family:'宋体';">目录放的是启动脚本，</span><span style="font-family:Verdana;">conf</span><span style="font-family:'宋体';">目录放的是配置文件，</span><span style="font-family:Verdana;">lib</span><span style="font-family:'宋体';">是放的是所必须的</span><span style="font-family:Verdana;">jar</span><span style="font-family:'宋体';">包，</span><span style="font-family:Verdana;">logs</span><span style="font-family:'宋体';">是日志目录。其他几个基本上不会使用到。</span></p>
<p> </p>
<p>2<span style="font-family:'宋体';">、原理</span></p>
<p>flume-ng <span style="font-family:'宋体';">是由一个个</span><span style="font-family:Verdana;">agent</span><span style="font-family:'宋体';">组成的。一个</span><span style="font-family:Verdana;">agent</span><span style="font-family:'宋体';">就像一个细胞一样。</span></p>
<p>每个<span style="font-family:Verdana;">agent</span><span style="font-family:'宋体';">里都有三部分构成：</span><span style="font-family:Verdana;">source</span><span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">和</span><span style="font-family:Verdana;">sink</span><span style="font-family:'宋体';">。</span></p>
<p>就相当于<span style="font-family:Verdana;">source</span><span style="font-family:'宋体';">接收数据，通过</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">传输数据，</span><span style="font-family:Verdana;">sink</span><span style="font-family:'宋体';">把数据写到下一端。其中</span><span style="font-family:Verdana;">source</span><span style="font-family:'宋体';">有很多种可以选择，</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">有很多种可以选择，</span><span style="font-family:Verdana;">sink</span><span style="font-family:'宋体';">也同样有多种可以选择，并且都支持自定义。同时，</span><span style="font-family:Verdana;">agent</span><span style="font-family:'宋体';">还支持选择器，就是一个</span><span style="font-family:Verdana;">source</span><span style="font-family:'宋体';">支持多个</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">和多个</span><span style="font-family:Verdana;">sink</span><span style="font-family:'宋体';">，这样就完成了数据的分发。其架构图如下：</span></p>
<p></p>
<p> <img src="" alt=""><img src="https://img-blog.csdn.net/20150707103703340?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>当然可以自由组合，如下图：</p>
<p></p>
<p> <img src="" alt=""><img src="https://img-blog.csdn.net/20150707103714207?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>时序图如下：</p>
<p> <img src="" alt=""><img src="https://img-blog.csdn.net/20150707103729734?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>Flume<span style="font-family:'宋体';">为了保证数据的完整性和一致性，在每个</span><span style="font-family:Verdana;">agent</span><span style="font-family:'宋体';">里面都加了事务。</span></p>
<p>当然，也可以这么配：</p>
<p> <img src="" alt=""><img src="https://img-blog.csdn.net/20150707103745181?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p> </p>
<p> </p>
<p>3<span style="font-family:'宋体';">、组件</span></p>
<p>Flume-ng<span style="font-family:'宋体';">（现网使用的是</span><span style="font-family:Verdana;">1.5.2</span><span style="font-family:'宋体';">）支持的主要几个组件如下：</span></p>
<p> </p>
<p> </p>
<table><tbody><tr><td valign="top" style="background:rgb(240,240,240);">
<p><span style="color:rgb(51,51,51);">组件</span></p>
</td>
<td valign="top" style="background:rgb(240,240,240);">
<p><span style="color:rgb(51,51,51);">类型</span></p>
</td>
<td valign="top" style="background:rgb(240,240,240);">
<p><span style="color:rgb(51,51,51);">描述</span></p>
</td>
<td valign="top" style="background:rgb(240,240,240);">
<p><span style="color:rgb(51,51,51);">实现类</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Channel</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">memory </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(49,49,49);">写入</span><span style="color:rgb(49,49,49);">内存</span><span style="color:rgb(49,49,49);">，特点快，容易内存溢出</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">MemoryChannel</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Channel</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">file</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(49,49,49);">写入文件，特点稳定、慢</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">FileChannel</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Channel</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">spillable</span><span style="color:rgb(51,51,51);">memory </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(49,49,49);">内存与文件结合使用</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">SpillableMemoryChannel</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Channel</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">jdbc</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(49,49,49);">基于<span style="font-family:Arial;">jdbc</span><span style="font-family:'宋体';">的持久</span></span><span style="color:rgb(49,49,49);">化</span><span style="color:rgb(49,49,49);">传输<span style="font-family:Arial;">(derby)</span></span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">JDBCChannel</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Channel</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">recoverablememory</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(49,49,49);">持久</span><span style="color:rgb(49,49,49);">化结合</span><span style="color:rgb(49,49,49);">本地文件存储</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">RecoverableMemoryChannel</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Channel</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">org.apache.flume.channel.PseudoTxnMemoryChannel</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(49,49,49);">用于测试</span><span style="color:rgb(49,49,49);">，</span><span style="color:rgb(49,49,49);">不适合生产使用。</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">PseudoTxnMemoryChannel</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Channel</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">(custom FQCN)</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(49,49,49);">自定义<span style="font-family:Arial;">channel</span><span style="font-family:'宋体';">实现</span></span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">(custom FQCN)</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Source</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">avro</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">使用</span><span style="color:rgb(51,51,51);">Avro Netty RPC</span><span style="color:rgb(51,51,51);">协议</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">AvroSource</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Source</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">exec</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">从</span><span style="color:rgb(51,51,51);">Unix</span><span style="color:rgb(51,51,51);">读取</span><span style="color:rgb(51,51,51);">tail -F</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">ExecSource</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Source</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">netcat</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">网关数据源</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">NetcatSource</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Source</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">seq</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(49,49,49);">单调递增序列发生器的事件源</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">SequenceGeneratorSource</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Source</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">org.apache.flume.source.StressSource</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(49,49,49);">用于测试</span><span style="color:rgb(49,49,49);">，</span><span style="color:rgb(49,49,49);">不适合生产使用。</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">org.apache.flume.source.StressSource</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Source </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">syslogtcp </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);"> </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">SyslogTcpSource </span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Source</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">syslogudp</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);"> </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">SyslogUDPSource</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Source</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">org.apache.flume.source.avroLegacy.</span></p>
<p><span style="color:rgb(51,51,51);">AvroLegacySource</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);"> </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">AvroLegacySource </span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Source</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">org.apache.flume.source.thriftLegacy.</span></p>
<p><span style="color:rgb(51,51,51);">ThriftLegacySource</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);"> </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">ThriftLegacySource </span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Source</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">org.apache.flume.source.scribe.ScribeSource</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);"> </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">ScribeSource </span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Source </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">(custom FQCN)</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">自定义</span><span style="color:rgb(51,51,51);">source</span><span style="color:rgb(51,51,51);"> </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">(custom FQCN)</span><span style="color:rgb(51,51,51);"> </span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Sink</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">hdfs</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">写入</span><span style="color:rgb(51,51,51);">HDFS</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">HDFSEventSink</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Sink </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">org.apache.flume.sink.hbase.HBaseSink</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">写入</span><span style="color:rgb(51,51,51);">HBase</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">org.apache.flume.sink.hbase.HBaseSink</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Sink </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">org.apache.flume.sink.hbase.AsyncHBaseSink</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);"> </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">org.apache.flume.sink.hbase.</span></p>
<p><span style="color:rgb(51,51,51);">AsyncHBaseSink</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Sink</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">logger</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">写入日志</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">LoggerSink</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Sink</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">avro</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">使用<span style="font-family:Arial;">AVRO RPC</span><span style="font-family:'宋体';">机制</span></span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">AvroSink</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Sink </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">file_roll </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);"> </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">RollingFileSink </span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Sink </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">irc </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);"> </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">IRCSink </span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Sink</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">null </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">丢弃所有</span><span style="color:rgb(51,51,51);">events</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">NullSink</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Sink </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">(custom FQCN)</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">自定义</span><span style="color:rgb(51,51,51);">sink</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">(custom FQCN)</span><span style="color:rgb(51,51,51);"> </span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">ChannelSelector </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">replicating </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);"> </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">ReplicatingChannelSelector</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">ChannelSelector </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">multiplexing </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);"> </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">MultiplexingChannelSelector</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">ChannelSelector </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">(custom type) </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">自定义</span><span style="color:rgb(51,51,51);">ChannelSelector </span><span style="color:rgb(51,51,51);">实现</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">(custom FQCN)</span><span style="color:rgb(51,51,51);"> </span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">SinkProcessor </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">default </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);"> </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">DefaultSinkProcessor</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">SinkProcessor </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">failover </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">failover<span style="font-family:'宋体';">的机器是一直发送给其中一个</span></span></p>
<p><span style="color:rgb(51,51,51);"><span style="font-family:'宋体';">优先级高的</span><span style="font-family:Arial;">sink</span><span style="font-family:'宋体';">，</span></span><span style="color:rgb(51,51,51);font-family:'宋体';">当这个</span><span style="color:rgb(51,51,51);font-family:Arial;">sink</span><span style="color:rgb(51,51,51);font-family:'宋体';">不可用的时候，</span></p>
<p><span style="color:rgb(51,51,51);font-family:'宋体';">自动发送到下一个</span><span style="color:rgb(51,51,51);font-family:Arial;">sink</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">FailoverSinkProcessor</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">SinkProcessor </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">load_balance </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">处理一个<span style="font-family:Arial;">sink</span><span style="font-family:'宋体';">的</span><span style="font-family:Arial;">group</span><span style="font-family:'宋体';">组，为每个</span><span style="font-family:Arial;">sink</span></span></p>
<p><span style="color:rgb(49,49,49);">提供了负载平衡流的能力。</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">LoadBalancingSinkProcessor</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">SinkProcessor </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">(custom FQCN)</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">自定义</span><span style="color:rgb(51,51,51);">SinkProcessor </span><span style="color:rgb(51,51,51);">实现</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">(custom FQCN)</span><span style="color:rgb(51,51,51);"> </span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Interceptor$Builder</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">host</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);"> </span>使用<span style="font-family:Verdana;">IP</span><span style="font-family:'宋体';">或</span><span style="font-family:Verdana;">hostname</span><span style="font-family:'宋体';">拦截</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">HostInterceptor$Builder</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Interceptor$Builder</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">timestamp</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">使用时间戳拦截</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">TimestampInterceptor$Builder</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Interceptor$Builder</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">static </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);"> </span>可以自定义<span style="font-family:Verdana;">event</span><span style="font-family:'宋体';">的</span><span style="font-family:Verdana;">header</span><span style="font-family:'宋体';">的</span><span style="font-family:Verdana;">value</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">StaticInterceptor$Builder</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Interceptor$Builder</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">regex_filter </span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);"> </span>提取正则表达式匹配组</p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">RegexFilteringInterceptor$Builder</span></p>
</td>
</tr><tr><td valign="top">
<p><span style="color:rgb(51,51,51);">Interceptor$Builder</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">(custom FQCN)</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">自定义</span><span style="color:rgb(51,51,51);"> Interceptor$Builder</span><span style="color:rgb(51,51,51);">实现</span></p>
</td>
<td valign="top">
<p><span style="color:rgb(51,51,51);">(custom FQCN)</span></p>
</td>
</tr></tbody></table><p> </p>
<p>* 1.6<span style="font-family:'宋体';">的版本还提供了</span><span style="font-family:Verdana;">kafkaChannel</span><span style="font-family:'宋体';">，性能比</span><span style="color:rgb(51,51,51);">memory</span><span style="color:rgb(51,51,51);">Channel<span style="font-family:'宋体';">差，但比</span></span>fileChannel<span style="font-family:'宋体';">好；而且稳定性不输</span><span style="font-family:Verdana;">fileChannel</span><span style="font-family:'宋体';">，比</span><span style="color:rgb(51,51,51);">memory</span><span style="color:rgb(51,51,51);">Channel<span style="font-family:'宋体';">更稳定</span></span>。</p>
<p> </p>
<p>Flume1.5.2<span style="font-family:'宋体';">提供的</span><span style="font-family:Verdana;">jar</span><span style="font-family:'宋体';">包：</span></p>
<p> <img src="" alt=""></p>
<p> </p>
<p>4<span style="font-family:'宋体';">、实现</span></p>
<p>实现很简单，通过配置。</p>
<p>案例<span style="font-family:Verdana;">1</span><span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">avro</span></p>
<p><span style="font-family:Verdana;"></span></p>
<pre><code class="language-plain">a1.channels = c1
a1.sources = r1
a1.sinks = k1
a1.channels.c1.type = memory
a1.sources.r1.channels = c1
a1.sources.r1.type = avro
a1.sources.r1.bind = 0.0.0.0
a1.sources.r1.port = 41414
 a1.sinks.k1.channel = c1
a1.sinks.k1.type = logger</code></pre><br><p></p>
<p>案例<span style="font-family:Verdana;">2</span><span style="font-family:'宋体';">：</span><span style="font-family:Verdana;">Spool</span></p>
<p><span style="font-family:Verdana;"></span></p>
<pre><code class="language-plain">a1.sources = r1
a1.sinks = k1
a1.channels = c1
 
a1.sources.r1.type = spooldir
a1.sources.r1.channels = c1
a1.sources.r1.spoolDir = /home/hadoop/flume-1.5.0-bin/logs
a1.sources.r1.fileHeader = true
 
a1.sinks.k1.type = logger
a1.sinks.k1.channel = c1
 
a1.channels.c1.type = memory
a1.channels.c1.capacity = 1000
a1.channels.c1.transactionCapacity = 100</code></pre>
<p></p>
<br><p>案例<span style="font-family:Verdana;">3</span><span style="font-family:'宋体';">：</span><span style="font-family:Verdana;">Exec</span></p>
<p><span style="font-family:Verdana;"></span></p>
<pre><code class="language-plain">a1.sources = r1
a1.sinks = k1
a1.channels = c1
 
a1.sources.r1.type = exec
a1.sources.r1.channels = c1
a1.sources.r1.command = tail -F /home/hadoop/flume-1.5.0-bin/log_exec_tail
 
a1.sinks.k1.type = logger
a1.sinks.k1.channel = c1
 
a1.channels.c1.type = memory
a1.channels.c1.capacity = 1000
a1.channels.c1.transactionCapacity = 100</code></pre><br><p></p>
<p>案例<span style="font-family:Verdana;">4</span><span style="font-family:'宋体';">：</span><span style="font-family:Verdana;">Syslogtcp</span></p>
<p><span style="font-family:Verdana;"></span></p>
<pre><code class="language-plain">a1.sources = r1
a1.sinks = k1
a1.channels = c1
 
a1.sources.r1.type = syslogtcp
a1.sources.r1.port = 5140
a1.sources.r1.host = localhost
a1.sources.r1.channels = c1
 
a1.sinks.k1.type = logger
a1.sinks.k1.channel = c1
 
a1.channels.c1.type = memory
a1.channels.c1.capacity = 1000
a1.channels.c1.transactionCapacity = 100</code></pre><br><br><p></p>
<p> </p>
<p>案例<span style="font-family:Verdana;">5</span><span style="font-family:'宋体';">：</span><span style="font-family:Verdana;">JSONHandler</span></p>
<p><span style="font-family:Verdana;"></span></p>
<pre><code class="language-plain">a1.sources = r1
a1.sinks = k1
a1.channels = c1
 
a1.sources.r1.type = org.apache.flume.source.http.HTTPSource
a1.sources.r1.port = 8888
a1.sources.r1.channels = c1
 
a1.sinks.k1.type = logger
a1.sinks.k1.channel = c1
 
a1.channels.c1.type = memory
a1.channels.c1.capacity = 1000
a1.channels.c1.transactionCapacity = 100</code></pre>
<p></p>
<p> </p>
<p>启动脚本：</p>
<p>bin/flume-ng agent --conf ./conf/ -f conf/flume.conf -Dflume.root.logger=DEBUG,console -n a1</p>
<p>对应的<span style="font-family:Verdana;">agent</span><span style="font-family:'宋体';">名字</span><span style="font-family:Verdana;">a1 </span><span style="font-family:'宋体';">，依赖的环境</span><span style="font-family:Verdana;">JDK1.6+</span><span style="font-family:'宋体';">。</span></p>
<p> </p>
<p>5<span style="font-family:'宋体';">、自定义组件</span></p>
<p>如果是自定义的<span style="font-family:Verdana;">source</span><span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">sink</span><span style="font-family:'宋体';">，（</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">不建议自定义），可以这么配置：</span></p>
<p></p>
<pre><code class="language-plain">agent01.sources = kafka0 
agent01.channels = ch0
agent01.sinks = sink0
 
agent01.sources.kafka0.type = cn.com.mysite.source.KafkaSource
agent01.sources.kafka0.channels = ch0
agent01.sources.kafka0.zookeeper.connect = 127.0.0.1:2181
agent01.sources.kafka0.batchSize = 15000
 
agent01.channels.ch3.type = memory  
agent01.channels.ch3.keep-alive = 30  
agent01.channels.ch3.transactionCapacity = 10000
agent01.channels.ch3.capacity = 100000
 
agent01.sinks.sink0.type = cn.com.mysite.sink.MySink
agent01.sinks.sink0.channel = ch0
agent01.sinks.sink0.batchsize = 1000</code></pre>
<p></p>
<p>红色部分是自定义的类（全包名），把自定义的类打成<span style="font-family:Verdana;">jar</span><span style="font-family:'宋体';">包，放到</span><span style="font-family:Verdana;">lib</span><span style="font-family:'宋体';">目录。</span></p>
<p>为了减少<span style="font-family:Verdana;">IO</span><span style="font-family:'宋体';">访问，提高性能。一般都要设置</span><span style="font-family:Verdana;">batchSize</span><span style="font-family:'宋体';">。</span></p>
<p>自定义的<span style="font-family:Verdana;">source</span><span style="font-family:'宋体';">类需要继承</span><span style="font-family:Verdana;">org.apache.flume.source.AbstractSource</span><span style="font-family:'宋体';">，并实现</span><span style="font-family:Verdana;">org.apache.flume.conf.Configurable</span><span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">org.apache.flume.EventDrivenSource</span><span style="font-family:'宋体';">接口。</span></p>
<p>重写父类的方法：<span style="font-family:Verdana;">configure</span><span style="font-family:'宋体';">（初始化配置）、</span><span style="font-family:Verdana;">start</span><span style="font-family:'宋体';">（启动入口，非必须）、</span><span style="font-family:Verdana;">stop</span><span style="font-family:'宋体';">（停止）、</span><span style="font-family:Verdana;">process</span><span style="font-family:'宋体';">（处理）。</span></p>
<p>自定义<span style="font-family:Verdana;">sink</span><span style="font-family:'宋体';">也是一样需要继承需要继承</span><span style="font-family:Verdana;">org.apache.flume.sink.AbstractSink</span><span style="font-family:'宋体';">，并实现</span><span style="font-family:Verdana;">Configurable</span><span style="font-family:'宋体';">接口。</span></p>
<p>重写父类的方法：<span style="font-family:Verdana;">configure</span><span style="font-family:'宋体';">（初始化配置）、</span><span style="font-family:Verdana;">start</span><span style="font-family:'宋体';">（启动入口，非必须）、</span><span style="font-family:Verdana;">stop</span><span style="font-family:'宋体';">（停止）、</span><span style="font-family:Verdana;">process</span><span style="font-family:'宋体';">（处理）。</span></p>
<p>自定义拦截器<span style="font-family:Verdana;">Interceptor</span>都实现了<span style="font-family:Verdana;">org.apache.flume.interceptor.Interceptor</span><span style="font-family:'宋体';">接口，该接口有四个方法以及一个内部接口：</span></p>
<p>1<span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">public void initialize()</span><span style="font-family:'宋体';">运行前的初始化，一般不需要实现（上面的几个都没实现这个方法）；</span></p>
<p>2<span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">public Event intercept(Event event)</span><span style="font-family:'宋体';">处理单个</span><span style="font-family:Verdana;">event</span><span style="font-family:'宋体';">；</span></p>
<p>3<span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">public List&lt;Event&gt; intercept(List&lt;Event&gt; events)</span><span style="font-family:'宋体';">批量处理</span><span style="font-family:Verdana;">event</span><span style="font-family:'宋体';">，实际上市循环调用上面的</span><span style="font-family:Verdana;">2</span><span style="font-family:'宋体';">；</span></p>
<p>4<span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">public void close()</span><span style="font-family:'宋体';">可以做一些清理工作，上面几个也都没有实现这个方法；</span></p>
<p>5<span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">public interface Builder extends Configurable </span><span style="font-family:'宋体';">构建</span><span style="font-family:Verdana;">Interceptor</span><span style="font-family:'宋体';">对象，外部使用这个</span><span style="font-family:Verdana;">Builder</span><span style="font-family:'宋体';">来获取</span><span style="font-family:Verdana;">Interceptor</span><span style="font-family:'宋体';">对象。</span></p>
<p>Builder<span style="font-family:'宋体';">类是构造</span><span style="font-family:Arial;">interceptor</span><span style="font-family:'宋体';">对象的，它会首先通过</span><span style="font-family:Arial;">configure(Context context)</span><span style="font-family:'宋体';">方法获取配置文件中</span><span style="font-family:Arial;">interceptor</span><span style="font-family:'宋体';">的参数，然后方法</span><span style="font-family:Arial;">build()</span><span style="font-family:'宋体';">用来返回一个</span><span style="font-family:Arial;">interceptor</span><span style="font-family:'宋体';">对象</span></p>
<p><span style="font-family:'宋体';"></span></p>
<pre><code class="language-java">public static class Builder implements Interceptor.Builder {
@Override  
public Interceptor build() { 
     return new Interceptor();    
}
 
@Override    
public void configure(Context context) {      
	//TO-DO  
    }
}</code></pre><br><br><p></p>
<p>自定义拦截器的配置</p>
<p></p>
<pre><code class="language-plain">a1.sources.r1.interceptors=i1  
a1.sources.r1.interceptors.i1.type=com.mysite.flume.RegexInterceptor$Builder
a1.sources.r1.interceptors.i1.regex=(.*)\\.(.*)\\.(.*)  
a1.sources.r1.interceptors.i1.extractorHeader=true  
a1.sources.r1.interceptors.i1.extractorHeaderKey=basename  
a1.sources.r1.interceptors.i1.serializers=s1 s2 s3  
a1.sources.r1.interceptors.i1.serializers.s1.name=one  
a1.sources.r1.interceptors.i1.serializers.s2.name=two  
a1.sources.r1.interceptors.i1.serializers.s3.name=three</code></pre><br><br><p></p>
<p>正则表达式按“<span style="font-family:Arial;">.</span><span style="font-family:'宋体';">”分隔抽取三部分，分别放到</span><span style="font-family:Arial;">header</span><span style="font-family:'宋体';">中的</span><span style="font-family:Arial;">key:one,two,three</span><span style="font-family:'宋体';">当中去，如：</span><span style="font-family:Arial;">event body</span><span style="font-family:'宋体';">有这样的内容</span></p>
<p>a.log.2014-07-31<span style="font-family:'宋体';">，通过拦截器后，在</span><span style="font-family:Arial;">header</span><span style="font-family:'宋体';">当中就会增加三个</span><span style="font-family:Arial;">key: one=a,two=log,three=2014-07-31</span><span style="font-family:'宋体';">。</span></p>
<p> </p>
<p>6<span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">Flume </span><span style="font-family:'宋体';">内置监控</span></p>
<p>Flume<span style="font-family:'宋体';">的内置监控可以使用</span><span style="font-family:Verdana;">Cloudera Manager</span><span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">Ganglia</span><span style="font-family:'宋体';">有图形的监控工具，以及从浏览器获取</span><span style="font-family:Verdana;">json</span><span style="font-family:'宋体';">串</span>(Http)，或者自定义向其他监控系统汇报信息。</p>
<p>Flume<span style="font-family:'宋体';">天生支持这</span>两种监控方式：HTTP<span style="font-family:'宋体';">方式</span><span style="font-family:Verdana;">(</span><span style="font-family:'宋体';">就是</span><span style="font-family:Verdana;">json</span><span style="font-family:'宋体';">串</span><span style="font-family:Verdana;">)</span><span style="font-family:'宋体';">和</span><span style="font-family:Verdana;">Ganglia</span><span style="font-family:'宋体';">，后者需要安装</span><span style="font-family:Verdana;">Ganglia</span><span style="font-family:'宋体';">，前者非常简单，只需要在</span><span style="font-family:Verdana;">Flume</span><span style="font-family:'宋体';">的启动命令中加上：</span><span style="font-family:Verdana;">-Dflume.monitoring.type=http -Dflume.monitoring.port=XXXX </span><span style="font-family:'宋体';">，最后的</span><span style="font-family:Verdana;">XXXX</span><span style="font-family:'宋体';">是你需要设置的端口！然后你就可以在浏览器上通过访问这个</span><span style="font-family:Verdana;">Flume</span><span style="font-family:'宋体';">所在节点的</span><span style="font-family:Verdana;">IP</span><span style="font-family:'宋体';">：</span><span style="font-family:Verdana;">XXXX/metrics</span><span style="font-family:'宋体';">，不断刷新就可以看到最新的组件统计信息。关于</span><span style="font-family:Verdana;">Ganglia</span><span style="font-family:'宋体';">的请读者自行组建</span><span style="font-family:Verdana;">Ganglia</span><span style="font-family:'宋体';">集群并参考用户指南来操作。</span></p>
<p>目前只对三大组件：<span style="font-family:Verdana;">source</span><span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">sink</span><span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">进行统计分别是</span><span style="font-family:Verdana;">SourceCounter</span><span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">SinkCounter</span><span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">ChannelCounter</span><span style="font-family:'宋体';">，这三个计数器的统计项是固定的，就是你不能自己设置自己的统计项；</span>他们都继承自MonitoredCounterGroup。</p>
<p>(1)<span style="font-family:'宋体';">、构造方法</span><span style="font-family:Verdana;">MonitoredCounterGroup(Type type, String name, String... attrs)</span><span style="font-family:'宋体';">，这个方法主要是设置组件的类型、名称；然后将所有的</span><span style="font-family:Verdana;">attrs(</span><span style="font-family:'宋体';">这是设定的各个统计项</span><span style="font-family:Verdana;">)</span><span style="font-family:'宋体';">加入</span><span style="font-family:Verdana;">Map&lt;String, AtomicLong&gt; counterMap</span><span style="font-family:'宋体';">，值设定为</span><span style="font-family:Verdana;">0</span><span style="font-family:'宋体';">；然后初始化计数器的开始时间和结束时间，都设为</span><span style="font-family:Verdana;">0</span>。</p>
<p>(2)<span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">start()</span><span style="font-family:'宋体';">方法，会先注册计数器，然后对所有统计项的统计值设为</span><span style="font-family:Verdana;">0</span><span style="font-family:'宋体';">；将开始时间设置为当前时间</span></p>
<p>(3)<span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">register()</span><span style="font-family:'宋体';">方法，如果这个计数器还未注册，将这个计数器的</span><span style="font-family:Verdana;">MBean</span><span style="font-family:'宋体';">进行注册，就可以进行跟踪了</span></p>
<p>(4)<span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">stop()</span><span style="font-family:'宋体';">方法，会设置结束时间为当前时间；输出各个统计项的信息。</span></p>
<p>三个组件中各种统计项及其含义：</p>
<p>一、<span style="font-family:Verdana;">SourceCounter</span>，主要统计项如下：</p>
<p>(1)、"src.events.received"<span style="font-family:'宋体';">，表示</span><span style="font-family:Verdana;">source</span><span style="font-family:'宋体';">接受的</span><span style="font-family:Verdana;">event</span><span style="font-family:'宋体';">个数；</span></p>
<p>(2)、"src.events.accepted"<span style="font-family:'宋体';">，表示</span><span style="font-family:Verdana;">source</span><span style="font-family:'宋体';">处理成功的</span><span style="font-family:Verdana;">event</span><span style="font-family:'宋体';">个数，和上面的区别就是上面虽然接受了可能没处理成功；</span></p>
<p>(3)、"src.append.received"<span style="font-family:'宋体';">，表示调用</span><span style="font-family:Verdana;">append</span><span style="font-family:'宋体';">次数，在</span><span style="font-family:Verdana;">avrosource</span><span style="font-family:'宋体';">和</span><span style="font-family:Verdana;">thriftsource</span><span style="font-family:'宋体';">中调用；</span></p>
<p>(4)、"src.append.accepted"<span style="font-family:'宋体';">，表示</span><span style="font-family:Verdana;">append</span><span style="font-family:'宋体';">处理成功次数；</span></p>
<p>(5)、"src.append-batch.received"<span style="font-family:'宋体';">，表示</span><span style="font-family:Verdana;">appendBatch</span><span style="font-family:'宋体';">被调用的次数，在</span><span style="font-family:Verdana;">avrosource</span><span style="font-family:'宋体';">和</span><span style="font-family:Verdana;">thriftsource</span><span style="font-family:'宋体';">中调用；</span></p>
<p>(6)、"src.append-batch.accepted"<span style="font-family:'宋体';">，表示</span><span style="font-family:Verdana;">appendBatch</span><span style="font-family:'宋体';">处理成功次数；</span></p>
<p>(7)、"src.open-connection.count"<span style="font-family:'宋体';">，用在</span><span style="font-family:Verdana;">avrosource</span><span style="font-family:'宋体';">中表示打开连接的数量；</span></p>
<p>一般<span style="font-family:Verdana;">source</span><span style="font-family:'宋体';">调用都集中在前俩。</span></p>
<p>一、SinkCounter，主要统计项如下：</p>
<p>(1)、"sink.connection.creation.count"<span style="font-family:'宋体';">，这个调用的地方颇多，都表示</span><span style="font-family:Verdana;">“</span><span style="font-family:'宋体';">链接</span><span style="font-family:Verdana;">”</span><span style="font-family:'宋体';">创建的数量，比如与</span><span style="font-family:Verdana;">HBase</span>、avrosource<span style="font-family:'宋体';">建立链接以及文件的打开等；</span></p>
<p>(2)、"sink.connection.closed.count"<span style="font-family:'宋体';">，对应于上面的</span><span style="font-family:Verdana;">stop</span><span style="font-family:'宋体';">操作、</span><span style="font-family:Verdana;">destroyConnection</span><span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">close</span><span style="font-family:'宋体';">文件操作等。</span></p>
<p>(3)、"sink.connection.failed.count"<span style="font-family:'宋体';">，表示上面所表示</span><span style="font-family:Verdana;">“</span><span style="font-family:'宋体';">链接</span><span style="font-family:Verdana;">”</span><span style="font-family:'宋体';">时异常、失败的次数；</span></p>
<p>(4)、"sink.batch.empty"<span style="font-family:'宋体';">，表示这个批次处理的</span><span style="font-family:Verdana;">event</span><span style="font-family:'宋体';">数量为</span><span style="font-family:Verdana;">0</span><span style="font-family:'宋体';">的情况；</span></p>
<p>(5)、"sink.batch.underflow"<span style="font-family:'宋体';">，表示这个批次处理的</span><span style="font-family:Verdana;">event</span><span style="font-family:'宋体';">的数量介于</span><span style="font-family:Verdana;">0</span><span style="font-family:'宋体';">和配置的</span><span style="font-family:Verdana;">batchSize</span><span style="font-family:'宋体';">之间；</span></p>
<p>(6)、"sink.batch.complete"<span style="font-family:'宋体';">，表示这个批次处理的</span><span style="font-family:Verdana;">event</span><span style="font-family:'宋体';">数量等于设定的</span><span style="font-family:Verdana;">batchSize</span><span style="font-family:'宋体';">；</span></p>
<p>(7)、"sink.event.drain.attempt"<span style="font-family:'宋体';">，准备处理的</span><span style="font-family:Verdana;">event</span><span style="font-family:'宋体';">的个数；</span></p>
<p>(8)、"sink.event.drain.sucess"<span style="font-family:'宋体';">，这个表示处理成功的</span><span style="font-family:Verdana;">event</span><span style="font-family:'宋体';">数量，与上面不同的是上面的是还未处理的。</span></p>
<p>三、<span style="font-family:Verdana;">ChannelCounter</span>，主要统计项如下：</p>
<p>(1)、"channel.current.size"<span style="font-family:'宋体';">，这个表示这个</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">的当前容量；</span></p>
<p>(2)、"channel.event.put.attempt"<span style="font-family:'宋体';">，一般指的是在</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">的事务当中，</span><span style="font-family:Verdana;">source</span><span style="font-family:'宋体';">的</span><span style="font-family:Verdana;">put</span><span style="font-family:'宋体';">操作中记录尝试发送</span><span style="font-family:Verdana;">event</span><span style="font-family:'宋体';">的个数；</span></p>
<p>(3)、"channel.event.take.attempt"<span style="font-family:'宋体';">，一般指的是在</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">的事务中，</span><span style="font-family:Verdana;">sink</span><span style="font-family:'宋体';">的</span><span style="font-family:Verdana;">take</span><span style="font-family:'宋体';">操作记录尝试拿</span><span style="font-family:Verdana;">event</span><span style="font-family:'宋体';">的个数；</span></p>
<p>(4)、"channel.event.put.success"<span style="font-family:'宋体';">，一般指的是在</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">的事务中，</span><span style="font-family:Verdana;">put</span><span style="font-family:'宋体';">成功的</span><span style="font-family:Verdana;">event</span><span style="font-family:'宋体';">的数量；</span></p>
<p>(5)、"channel.event.take.success"<span style="font-family:'宋体';">，一般指的是</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">事务中，</span><span style="font-family:Verdana;">take</span><span style="font-family:'宋体';">成功的</span><span style="font-family:Verdana;">event</span><span style="font-family:'宋体';">的数量；</span></p>
<p>(6)、"channel.capacity"<span style="font-family:'宋体';">，指的是</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">的容量，在</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">的</span><span style="font-family:Verdana;">start</span><span style="font-family:'宋体';">方法中设置。</span></p>
<p>上面这些统计项都是固定的，我们可以根据需要增加相应项的值，可以在监控中查看组件的变化情况，从而掌握<span style="font-family:Verdana;">flume</span><span style="font-family:'宋体';">进程的运行情况。比如可以查看</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">的容量从而了解到</span><span style="font-family:Verdana;">source</span><span style="font-family:'宋体';">和</span><span style="font-family:Verdana;">sink</span><span style="font-family:'宋体';">的相对处理速度，还有可以看</span><span style="font-family:Verdana;">source</span><span style="font-family:'宋体';">或者</span><span style="font-family:Verdana;">sink</span><span style="font-family:'宋体';">每个批次处理成功与失败的次数，了解组件的运行状况等等。</span></p>
<p> </p>
<p>自定义Counter<span style="font-family:'宋体';">必须要继承</span><span style="font-family:Verdana;">MonitoredCounterGroup</span><span style="font-family:'宋体';">这个抽象类</span>并实现SourceCounterMBean接口，设定自己的统计项，然后将统计项设置成数组调用<span style="font-family:Verdana;">MonitoredCounterGroup</span><span style="font-family:'宋体';">的构造函数；然后在自定义的计数器中增加更新数值的方法。最后在自定义的组件中构造自定义的计数器，并启用它的</span><span style="font-family:Verdana;">start</span><span style="font-family:'宋体';">方法，剩下的就是在该更新统计项数值的地方更新就可以了。</span>例：</p>
<p></p>
<pre><code class="language-java">private static final String COUNTER_KAFKA_SEND_FLOW = "sink.kafka.send.flow";
private static final String[] ATTRIBUTES = {COUNTER_KAFKA_SEND_FLOW };
public KafkaSinkCounter(String name) {
   super(name, ATTRIBUTES);
}
public long countKafkaSendFlow(long delta) {
   return addAndGet(COUNTER_KAFKA_SEND_FLOW, delta);
}
public long getKafkaSendFlowCount() {
   return get(COUNTER_KAFKA_SEND_FLOW);
}</code></pre>
<p></p>
<p>然后将计数器、监控类、自定义组件<span style="font-family:Verdana;">(source</span><span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">sink</span><span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">channel)</span><span style="font-family:'宋体';">打包放到</span><span style="font-family:Verdana;">lib</span><span style="font-family:'宋体';">下，在启动命令后加</span><span style="font-family:Verdana;">-Dflume.monitoring.type=AAAAA -Dflume.monitoring.node=BBBB</span><span style="font-family:'宋体';">，就可以了</span></p>
<p> </p>
<p>7<span style="font-family:'宋体';">、实现案例</span></p>
<p>我们来看<span style="font-family:Verdana;">source</span><span style="font-family:'宋体';">是怎么把数据</span><span style="font-family:Verdana;">msg</span><span style="font-family:'宋体';">放到</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">的：</span></p>
<pre><code class="language-java">ChannelProcessor channelProcessor = source.getChannelProcessor();
Event eTmp = EventBuilder.withBody(msg.getBytes());
channelProcessor.processEvent(eTmp);</code></pre>
<p></p>
<p>sink<span style="font-family:'宋体';">又是怎么取出来的：</span></p>
<p><span style="font-family:'宋体';"></span></p>
<pre><code class="language-java">Channel channel = getChannel();
Transaction tx = channel.getTransaction();
tx.begin();//事务
List&lt;KeyedMessage&lt;byte[], byte[]&gt;&gt; batch = Lists.newLinkedList();
for (int i = 0; i &lt; batchSize; i++) {
   Event event = channel.take();//获取event（一条日志）
   byte[] bs=event.getBody();
   batch.add(new KeyedMessage&lt;byte[], byte[]&gt;(topic, bs));
}
producer.send(batch);//发送给kafka
tx.commit();//提交事务</code></pre>
<p></p>
<p><br></p>
<p>之前介绍<span style="font-family:Verdana;">flume</span><span style="font-family:'宋体';">可以配置多个</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">和</span><span style="font-family:Verdana;">sink</span><span style="font-family:'宋体';">，在</span><span style="font-family:Verdana;">flume</span><span style="font-family:'宋体';">的设计上，实现这一点是很容易的，下面是我们的实际的案例：</span></p>
<p><span style="font-family:'宋体';"></span></p>
<pre><code class="language-plain">agent01.sources = kafka0 
agent01.channels = ch0 ch1
agent01.sinks = sink0 sink1
 
agent01.sources.kafka0.type = cn.com.mysite.source.KafkaSource
agent01.sources.kafka0.channels = ch0 ch1
agent01.sources.kafka0.zookeeper.connect = 192.168.1.131:2181
agent01.sources.kafka0.zookeeper.session.timeout.ms = 50000
agent01.sources.kafka0.zookeeper.connection.timeout.ms = 40000
#replicating,multiplexing
agent01.sources.kafka0.selector.type= replicating
 
agent01.channels.ch0.type = memory
agent01.channels.ch0.capacity = 40000
agent01.channels.ch0.transactionCapacity = 10000
 
agent01.channels.ch1.type = memory
agent01.channels.ch1.capacity = 40000
agent01.channels.ch1.transactionCapacity = 10000
 
agent01.sinks.sink0.channel = ch0
agent01.sinks.sink0.type=FILE_ROLL
agent01.sinks.sink0.sink.directory=D:/flume/data
agent01.sinks.sink0.sink.rollSize=1000000
 
agent01.sinks.sink1.channel = ch1
agent01.sinks.sink1.type = hdfs
agent01.sinks.sink1.hdfs.useLocalTimeStamp = true  
agent01.sinks.sink1.hdfs.path = hdfs://127.0.0.1:9000/flume/events/%y/%m/%d  
agent01.sinks.sink1.hdfs.filePrefix = flume-%H%M
agent01.sinks.sink1.hdfs.batchSize = 5000
#DataStream,SequenceFile,CompressedStream
agent01.sinks.sink1.hdfs.fileType = DataStream
#HEADER_AND_TEXT,TEXT,AVRO_EVENT
agent01.sinks.sink1.hdfs.writeFormat = TEXT
agent01.sinks.sink1.hdfs.minBlockReplicas = 1  
agent01.sinks.sink1.hdfs.rollInterval = 3600  
agent01.sinks.sink1.hdfs.rollSize = 0  
agent01.sinks.sink1.hdfs.rollCount = 0  
agent01.sinks.sink1.hdfs.idleTimeout = 0 </code></pre><br><br><p></p>
<p></p>
<p>Agent Source<span style="font-family:'宋体';">的</span><span style="font-family:Verdana;">selector.type</span><span style="font-family:'宋体';">有两种方式：</span><span style="font-family:Verdana;">replicating</span><span style="font-family:'宋体';">，</span><span style="font-family:Verdana;">multiplexing</span><span style="font-family:'宋体';">。</span></p>
<p>采用<span style="font-family:Verdana;">replicating</span><span style="font-family:'宋体';">的方式进行复制，对收到的报文复制成两份，发往不同的</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">，最终送给相应的</span><span style="font-family:Verdana;">sink</span><span style="font-family:'宋体';">。如上面的配置</span></p>
<p>采用<span style="font-family:Verdana;">multiplexing</span><span style="font-family:'宋体';">的方式进行选择，对收到的报文进行分类，发往不同的</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">，最终送给相应的</span><span style="font-family:Verdana;">sink</span><span style="font-family:'宋体';">。<br></span></p>
<p><span style="font-family:'宋体';"></span></p>
<pre><code class="language-plain">agent1.sources.kafka0.channels = ch0 ch1
agent1.sources.kafka0.header = LOG_TYPE 
agent1.sources.kafka0.selector.type = multiplexing
agent1.sources.kafka0.selector.header = LOG_TYPE
agent1.sources.kafka0.selector.mapping.CREDIT = ch0
agent1.sources.kafka0.selector.mapping.OTHER = ch1
agent1.sources.kafka0.selector.default = ch1</code></pre>
<p></p>
<p>这里标红的<span style="font-family:Verdana;">header </span><span style="font-family:'宋体';">是指在获取的报文里面的</span><span style="font-family:Verdana;">header</span><span style="font-family:'宋体';">属性。一个</span><span style="font-family:Verdana;">event</span><span style="font-family:'宋体';">分为</span><span style="font-family:Verdana;">header</span><span style="font-family:'宋体';">和</span><span style="font-family:Verdana;">body</span><span style="font-family:'宋体';">两部分。在</span><span style="font-family:Verdana;">header</span><span style="font-family:'宋体';">里面有一个</span><span style="font-family:Verdana;">LOG_TYPE</span><span style="font-family:'宋体';">字段，</span><span style="font-family:Verdana;">LOG_TYPE</span><span style="font-family:'宋体';">字段有两个值：</span><span style="font-family:Verdana;">CREDIT </span><span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">OTHER </span><span style="font-family:'宋体';">，针对</span><span style="font-family:Verdana;">CREDIT </span><span style="font-family:'宋体';">的发送到</span><span style="font-family:Verdana;">ch0</span><span style="font-family:'宋体';">，而</span><span style="font-family:Verdana;">OTHER </span><span style="font-family:'宋体';">的发送到</span><span style="font-family:Verdana;">ch1</span><span style="font-family:'宋体';">，默认是选择</span><span style="font-family:Verdana;">ch1</span><span style="font-family:'宋体';">。使用这种方式需要对数据进行加工，把</span><span style="font-family:Verdana;">LOG_TYPE</span><span style="font-family:'宋体';">放入到</span><span style="font-family:Verdana;">header</span><span style="font-family:'宋体';">里面。</span></p>
<p><span style="font-family:'宋体';"></span></p>
<pre><code class="language-java">Event event = channel.take();
event.getHeaders().put("LOG_TYPE","CREDIT");
//event.getHeaders().put("LOG_TYPE","OTHER");</code></pre><br><p></p>
<p>为了数据的可靠性及程序的性能，可以在多个<span style="font-family:Verdana;">sink</span><span style="font-family:'宋体';">里面设置成</span><span style="font-family:Verdana;">sinkgroups</span><span style="font-family:'宋体';">，实现如下：</span></p>
<p>实现<span style="font-family:Verdana;">load balance</span><span style="font-family:'宋体';">功能</span><span style="font-family:Verdana;">(</span><span style="color:rgb(51,51,51);">处理一个<span style="font-family:Arial;">sink</span><span style="font-family:'宋体';">的</span><span style="font-family:Arial;">group</span><span style="font-family:'宋体';">组，为每个</span><span style="font-family:Arial;">sink</span></span><span style="color:rgb(49,49,49);">提供了负载均衡的能力</span>)<br></p>
<p></p>
<pre><code class="language-plain">a1.sinkgroups = g1
a1.sinkgroups.g1.sinks = k1 k2 k3
a1.sinkgroups.g1.processor.type = load_balance
a1.sinkgroups.g1.processor.backoff = true
a1.sinkgroups.g1.processor.selector = round_robin
a1.sinkgroups.g1.processor.selector.maxTimeOut=10000</code></pre><br>
实现<span style="font-family:Verdana;">failover</span><span style="font-family:'宋体';">功能</span><span style="font-family:Verdana;">(</span><span style="color:rgb(51,51,51);">failover<span style="font-family:'宋体';">的机器是一直发送给其中一个优先级高的</span><span style="font-family:Arial;">sink</span><span style="font-family:'宋体';">，当这个</span><span style="font-family:Arial;">sink</span><span style="font-family:'宋体';">不可用的时候，自动发送到下一个</span><span style="font-family:Arial;">sink)</span></span><pre><code class="language-plain">a1.sinkgroups = g1
a1.sinkgroups.g1.sinks = k1 k2 k3
a1.sinkgroups.g1.processor.type = failover
a1.sinkgroups.g1.processor.priority.k1 = 5
a1.sinkgroups.g1.processor.priority.k2 = 7
a1.sinkgroups.g1.processor.priority.k3 = 6
a1.sinkgroups.g1.processor.maxpenalty = 20000</code></pre>
<p></p>
<p><span style="color:rgb(51,51,51);">我们只要稍微修改一下配置，就可以实现不同的功能需求，在这点</span><span style="color:rgb(51,51,51);font-family:Arial;">flume</span><span style="color:rgb(51,51,51);font-family:'宋体';">非常适用。</span></p>
 
<p><br></p>
<p>8<span style="font-family:'宋体';">、</span><a href="http://www.cnblogs.com/lxf20061900/p/4012847.html" rel="nofollow"><span style="color:rgb(0,0,0);">Flume-NG<span style="font-family:'宋体';">的一些注意事项</span></span></a></p>
<p>A<span style="font-family:'宋体';">、关于</span><span style="font-family:Verdana;">Source</span><span style="font-family:'宋体';">：</span></p>
<p>1<span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">spool-source</span><span style="font-family:'宋体';">：适合静态文件，即文件本身不是动态变化的；</span></p>
<p>2<span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">avro source</span><span style="font-family:'宋体';">可以适当提高线程数量来提高此</span><span style="font-family:Verdana;">source</span><span style="font-family:'宋体';">性能；</span></p>
<p>3<span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">ThriftSource</span><span style="font-family:'宋体';">在使用时有个问题需要注意，使用批量操作时出现异常并不会打印异常内容而是</span><span style="font-family:Verdana;">"Thrift source %s could not append events to the channel."</span><span style="font-family:'宋体';">，这是因为源码中在出现异常时，它并未捕获异常而是获取组件名称，这是源码中的一个</span><span style="font-family:Verdana;">bug</span><span style="font-family:'宋体';">，也可以说明</span><span style="font-family:Verdana;">thrift</span><span style="font-family:'宋体';">很少有人用，否则这个问题也不会存在在很多版本中；</span></p>
<p>4<span style="font-family:'宋体';">、如果一个</span><span style="font-family:Verdana;">source</span><span style="font-family:'宋体';">对应多个</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">，默认就是每个</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">是同样的一份数据，会把这批数据复制</span><span style="font-family:Verdana;">N</span><span style="font-family:'宋体';">份发送到</span><span style="font-family:Verdana;">N</span><span style="font-family:'宋体';">个</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">中，所以如果某个</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">满了会影响整体的速度的哦；</span></p>
<p>5<span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">ExecSource</span><span style="font-family:'宋体';">官方文档已经说明是异步的，可能会丢数据哦，尽量使用</span><span style="font-family:Verdana;">tail -F</span><span style="font-family:'宋体';">，注意是大写的；</span></p>
<p>B、关于<span style="font-family:Verdana;">Channel</span><span style="font-family:'宋体';">：</span></p>
<p>1<span style="font-family:'宋体';">、采集节点建议使用新的复合类型的</span><span style="font-family:Verdana;">SpillableMemoryChannel</span><span style="font-family:'宋体';">，汇总节点建议采用</span><span style="font-family:Verdana;">memory channel</span><span style="font-family:'宋体';">，具体还要看实际的数据量，一般每分钟数据量超过</span><span style="font-family:Verdana;">120MB</span><span style="font-family:'宋体';">大小的</span><span style="font-family:Verdana;">flume agent</span><span style="font-family:'宋体';">都建议用</span><span style="font-family:Verdana;">memory channel(</span><span style="font-family:'宋体';">自己测的</span><span style="font-family:Verdana;">file channel</span><span style="font-family:'宋体';">处理速率大概是</span><span style="font-family:Verdana;">2M/s</span><span style="font-family:'宋体';">，不同机器、不同环境可能不同，这里只提供参考</span><span style="font-family:Verdana;">)</span><span style="font-family:'宋体';">，因为一旦此</span><span style="font-family:Verdana;">agent</span><span style="font-family:'宋体';">的</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">出现溢出情况，将会导致大多数时间处于</span><span style="font-family:Verdana;">file channel(SpillableMemoryChannel</span><span style="font-family:'宋体';">本身是</span><span style="font-family:Verdana;">file channel</span><span style="font-family:'宋体';">的一个子类，而且复合</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">会保证一定的</span><span style="font-family:Verdana;">event</span><span style="font-family:'宋体';">的顺序的使得读完内存中的数据后，再需要把溢出的拿走，可能这时内存已满又会溢出。。。</span><span style="font-family:Verdana;">)</span><span style="font-family:'宋体';">，性能大大降低，汇总一旦成为这样后果可想而知；</span></p>
<p>2<span style="font-family:'宋体';">、调整</span><span style="font-family:Verdana;">memory </span><span style="font-family:'宋体';">占用物理内存空间，需要两个参数</span><span style="font-family:Verdana;">byteCapacityBufferPercentage(</span><span style="font-family:'宋体';">默认是</span><span style="font-family:Verdana;">20)</span><span style="font-family:'宋体';">和</span><span style="font-family:Verdana;">byteCapacity(</span><span style="font-family:'宋体';">默认是</span><span style="font-family:Verdana;">JVM</span><span style="font-family:'宋体';">最大可用内存的</span><span style="font-family:Verdana;">0.8)</span><span style="font-family:'宋体';">来控制，计算公式是：</span><span style="font-family:Verdana;">byteCapacity = (int)((context.getLong("byteCapacity", defaultByteCapacity).longValue() * (1 - byteCapacityBufferPercentage * .01 )) /byteCapacitySlotSize)</span><span style="font-family:'宋体';">，很明显可以调节这两个参数来控制，至于</span><span style="font-family:Verdana;">byteCapacitySlotSize</span><span style="font-family:'宋体';">默认是</span><span style="font-family:Verdana;">100</span><span style="font-family:'宋体';">，将物理内存转换成槽</span><span style="font-family:Verdana;">(slot)</span><span style="font-family:'宋体';">数，这样易于管理，但是可能会浪费空间；</span></p>
<p>3<span style="font-family:'宋体';">、还有一个有用的参数</span><span style="font-family:Verdana;">"keep-alive"</span><span style="font-family:'宋体';">这个参数用来控制</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">满时影响</span><span style="font-family:Verdana;">source</span><span style="font-family:'宋体';">的发送，</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">空时影响</span><span style="font-family:Verdana;">sink</span><span style="font-family:'宋体';">的消费，就是等待时间，默认是</span><span style="font-family:Verdana;">3s</span><span style="font-family:'宋体';">，超过这个时间就甩异常，一般不需配置，但是有些情况很有用，比如你得场景是每分钟开头集中发一次数据，这时每分钟的开头量可能比较大，后面会越来越小，这时你可以调大这个参数，不至于出现</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">满了得情况；</span></p>
<p>C、关于<span style="font-family:Verdana;">Sink</span><span style="font-family:'宋体';">：</span></p>
<p>1<span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">avro sink</span><span style="font-family:'宋体';">的</span><span style="font-family:Verdana;">batch-size</span><span style="font-family:'宋体';">可以设置大一点，默认是</span><span style="font-family:Verdana;">100</span><span style="font-family:'宋体';">，增大会减少</span><span style="font-family:Verdana;">RPC</span><span style="font-family:'宋体';">次数，提高性能；</span></p>
<p>2<span style="font-family:'宋体';">、内置</span><span style="font-family:Verdana;">hdfs sink</span><span style="font-family:'宋体';">的解析时间戳来设置目录或者文件前缀非常损耗性能，因为是基于正则来匹配的，可以通过修改源码来替换解析时间功能来极大提升性能；</span></p>
<p>3<span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">RollingFileSink</span><span style="font-family:'宋体';">文件名不能自定义，而且不能定时滚动文件，只能按时间间隔滚动，可以自己定义</span><span style="font-family:Verdana;">sink</span><span style="font-family:'宋体';">，来做定时写文件；</span></p>
<p>4<span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">hdfs sink</span><span style="font-family:'宋体';">的文件名中的时间戳部分不能省去，可增加前缀、后缀以及正在写的文件的前后缀等信息；</span><span style="font-family:Verdana;">"hdfs.idleTimeout"</span><span style="font-family:'宋体';">这个参数很有意义，指的是正在写的</span><span style="font-family:Verdana;">hdfs</span><span style="font-family:'宋体';">文件多长时间不更新就关闭文件，建议都配置上，比如你设置了解析时间戳存不同的目录、文件名，而且</span><span style="font-family:Verdana;">rollInterval=0</span><span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">rollCount=0</span><span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">rollSize=1000000</span><span style="font-family:'宋体';">，如果这个时间内的数据量达不到</span><span style="font-family:Verdana;">rollSize</span><span style="font-family:'宋体';">的要求而且后续的写入新的文件中了，就是一直打开，类似情景不注意的话可能很多；</span><span style="font-family:Verdana;">"hdfs.callTimeout"</span><span style="font-family:'宋体';">这个参数指的是每个</span><span style="font-family:Verdana;">hdfs</span><span style="font-family:'宋体';">操作</span><span style="font-family:Verdana;">(</span><span style="font-family:'宋体';">读、写、打开、关闭等</span><span style="font-family:Verdana;">)</span><span style="font-family:'宋体';">规定的最长操作时间，每个操作都会放入</span><span style="font-family:Verdana;">"hdfs.threadsPoolSize"</span><span style="font-family:'宋体';">指定的线程池中得一个线程来操作；</span></p>
<p>如果启用压缩，则<span style="font-family:Verdana;">rollSize</span><span style="font-family:'宋体';">指的是未压缩文件大小，压缩后大小未知。</span></p>
<p>5<span style="font-family:'宋体';">、关于</span><span style="font-family:Verdana;">HBase sink(</span><span style="font-family:'宋体';">非异步</span><span style="font-family:Verdana;">hbase sink</span><span style="font-family:'宋体';">：</span><span style="font-family:Verdana;">AsyncHBaseSink)</span><span style="font-family:'宋体';">，</span><span style="font-family:Verdana;">rowkey</span><span style="font-family:'宋体';">不能自定义，而且一个</span><span style="font-family:Verdana;">serializer</span><span style="font-family:'宋体';">只能写一列，一个</span><span style="font-family:Verdana;">serializer</span><span style="font-family:'宋体';">按正则匹配多个列，性能可能存在问题，建议自己根据需求写一个</span><span style="font-family:Verdana;">hbase sink</span><span style="font-family:'宋体';">；</span></p>
<p>6<span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">avro sink</span><span style="font-family:'宋体';">可以配置</span><span style="font-family:Verdana;">failover</span><span style="font-family:'宋体';">和</span><span style="font-family:Verdana;">loadbalance</span><span style="font-family:'宋体';">，所用的组件和</span><span style="font-family:Verdana;">sinkgroup</span><span style="font-family:'宋体';">中的是一样的，而且也可以在此配置压缩选项，需要在</span><span style="font-family:Verdana;">avro source</span><span style="font-family:'宋体';">中配置解压缩；</span></p>
<p>D、关于<span style="font-family:Verdana;">SinkGroup</span><span style="font-family:'宋体';">：</span></p>
<p>1<span style="font-family:'宋体';">、不管是</span><span style="font-family:Verdana;">loadbalance</span><span style="font-family:'宋体';">或者是</span><span style="font-family:Verdana;">failover</span><span style="font-family:'宋体';">的多个</span><span style="font-family:Verdana;">sink</span><span style="font-family:'宋体';">需要共用一个</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">；</span></p>
<p>2<span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">loadbalance</span><span style="font-family:'宋体';">的多个</span><span style="font-family:Verdana;">sink</span><span style="font-family:'宋体';">如果都是直接输出到同一种设备，比如都是</span><span style="font-family:Verdana;">hdfs</span><span style="font-family:'宋体';">，性能并不会有明显增加，因为</span><span style="font-family:Verdana;">sinkgroup</span><span style="font-family:'宋体';">是单线程的它的</span><span style="font-family:Verdana;">process</span><span style="font-family:'宋体';">方法会轮流调用每个</span><span style="font-family:Verdana;">sink</span><span style="font-family:'宋体';">去</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">中</span><span style="font-family:Verdana;">take</span><span style="font-family:'宋体';">数据，并确保处理正确，使得是顺序操作的，但是如果是发送到下一级的</span><span style="font-family:Verdana;">flume agent</span><span style="font-family:'宋体';">就不一样了，</span><span style="font-family:Verdana;">take</span><span style="font-family:'宋体';">操作是顺序的，但是下一级</span><span style="font-family:Verdana;">agent</span><span style="font-family:'宋体';">的写入操作是并行的，所以肯定是快的；</span></p>
<p>3<span style="font-family:'宋体';">、其实用</span><span style="font-family:Verdana;">loadbalance</span><span style="font-family:'宋体';">在一定意义上可以起到</span><span style="font-family:Verdana;">failover</span><span style="font-family:'宋体';">的作用，生产环境量大建议</span><span style="font-family:Verdana;">loadbalance</span><span style="font-family:'宋体';">；</span></p>
<p>E、关于监控<span style="font-family:Verdana;">monitor</span><span style="font-family:'宋体';">：</span></p>
<p>1<span style="font-family:'宋体';">、监控我这边做得还是比较少的，但是目前已知的有以下几种吧：</span><span style="font-family:Verdana;">cloudera manager</span><span style="font-family:'宋体';">（前提是你得安装</span><span style="font-family:Verdana;">CDH</span><span style="font-family:'宋体';">版本）、</span><span style="font-family:Verdana;">ganglia(</span><span style="font-family:'宋体';">这个天生就是支持的</span><span style="font-family:Verdana;">)</span><span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">http(</span><span style="font-family:'宋体';">其实就是将统计信息</span><span style="font-family:Verdana;">jmx</span><span style="font-family:'宋体';">信息，封装成</span><span style="font-family:Verdana;">json</span><span style="font-family:'宋体';">串，使用</span><span style="font-family:Verdana;">jetty</span><span style="font-family:'宋体';">展示在浏览器中而已</span><span style="font-family:Verdana;">)</span><span style="font-family:'宋体';">、再一个就是自己实现收集监控信息，自己做</span><span style="font-family:Verdana;">(</span><span style="font-family:'宋体';">可以收集</span><span style="font-family:Verdana;">http</span><span style="font-family:'宋体';">的信息或者自己实现相应的接口实现自己的逻辑，具体可以参考我以前的博客</span><span style="font-family:Verdana;">)</span><span style="font-family:'宋体';">；</span></p>
<p>2<span style="font-family:'宋体';">、简单说一下</span><span style="font-family:Verdana;">cloudera manager</span><span style="font-family:'宋体';">这种监控，最近在使用，确实很强大，可以查看实时的</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">进出数据速率、</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">实时容量、</span><span style="font-family:Verdana;">sink</span><span style="font-family:'宋体';">的出速率、</span><span style="font-family:Verdana;">source</span><span style="font-family:'宋体';">的入速率等等，图形化的东西确实很丰富很直观，可以提供很多</span><span style="font-family:Verdana;">flume agent</span><span style="font-family:'宋体';">整体运行情况的信息和潜在的一些信息；</span></p>
<p><span style="font-family:'宋体';">3、自定义的监控要放到包：org.apache.flume 的包里面，否则不会加载。</span></p>
<p>F、关于<span style="font-family:Verdana;">flume</span><span style="font-family:'宋体';">启动：</span></p>
<p>1<span style="font-family:'宋体';">、</span><span style="font-family:Verdana;">flume</span><span style="font-family:'宋体';">组件启动顺序：</span><span style="font-family:Verdana;">channels——&gt;sinks——&gt;sources</span><span style="font-family:'宋体';">，关闭顺序：</span><span style="font-family:Verdana;">sources——&gt;sinks——&gt;channels</span><span style="font-family:'宋体';">；</span></p>
<p>2<span style="font-family:'宋体';">、自动加载配置文件功能，会先关闭所有组件，再重启所有组件；</span></p>
<p>3<span style="font-family:'宋体';">、关于</span><span style="font-family:Verdana;">AbstractConfigurationProvider</span><span style="font-family:'宋体';">中的</span><span style="font-family:Verdana;">Map&lt;Class&lt;? extends Channel&gt;, Map&lt;String, Channel&gt;&gt; channelCache</span><span style="font-family:'宋体';">这个对象，始终存储着</span><span style="font-family:Verdana;">agent</span><span style="font-family:'宋体';">中得所有</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">对象，因为在动态加载时，</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">中可能还有未消费完的数据，但是需要对</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">重新配置，所以用以来缓存</span><span style="font-family:Verdana;">channel</span><span style="font-family:'宋体';">对象的所有数据及配置信息；</span></p>
<p>4<span style="font-family:'宋体';">、通过在启动命令中添加</span><span style="font-family:Verdana;">"no-reload-conf"</span><span style="font-family:'宋体';">参数为</span><span style="font-family:Verdana;">true</span><span style="font-family:'宋体';">来取消自动加载配置文件功能；</span></p>
<br><div id="KSFIND_MASK" style="width:0px;border:0px none !important;z-index:1000000 !important;background:rgb(0,0,0);">
</div>
<div id="0KSFindDIVKSFindDIV" class="KSFIND_CLASS_POP" style="font-family:monospace;font-size:12px;text-decoration:none;text-align:center;width:176px;">
<br></div>
<div class="KSFIND_CLASS_POP" style="font-family:monospace;font-size:12px;text-decoration:none;text-align:center;width:176px;">
<br></div>
            </div>
                </div>