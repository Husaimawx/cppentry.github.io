---
layout:     post
title:      flume入门
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                
<p><strong></strong></p>
<h1 class="ts"><span id="thread_subject">Flume1.5.0入门：安装、部署、及flume的案例</span></h1>
<p></p>
<p><strong><span style="color:#ff0000;">1.什么是flume</span></strong></p>
<strong><span style="color:#ff0000;">2.flume的官方网站在哪里？</span><br><span style="color:#ff0000;">3.flume有哪些术语？</span><br><span style="color:#ff0000;">4.如何配置flume数据源码？</span><br><br><span style="font-size:18px;">　　一、什么是Flume?</span></strong><br>
　　flume 作为 cloudera 开发的实时日志收集系统，受到了业界的认可与广泛应用。Flume 初始的发行版本目前被统称为 Flume OG（original generation），属于 cloudera。但随着 FLume 功能的扩展，Flume OG 代码工程臃肿、核心组件设计不合理、核心配置不标准等缺点暴露出来，尤其是在 Flume OG 的最后一个发行版本 0.94.0 中，日志传输不稳定的现象尤为严重，为了解决这些问题，2011 年 10 月 22 号，cloudera 完成了 Flume-728，对
 Flume 进行了里程碑式的改动：重构核心组件、核心配置以及代码架构，重构后的版本统称为 Flume NG（next generation）；改动的另一原因是将 Flume 纳入 apache 旗下，cloudera Flume 改名为 Apache Flume。<br><br><strong>        flume的特点：</strong><br>
　　flume是一个分布式、可靠、和高可用的海量日志采集、聚合和传输的系统。支持在日志系统中定制各类数据发送方，用于收集数据;同时，Flume提供对数据进行简单处理，并写到各种数据接受方(比如文本、HDFS、Hbase等)的能力 。<br>
　　flume的数据流由事件(Event)贯穿始终。事件是Flume的基本数据单位，它携带日志数据(字节数组形式)并且携带有头信息，这些Event由Agent外部的Source生成，当Source捕获事件后会进行特定的格式化，然后Source会把事件推入(单个或多个)Channel中。你可以把Channel看作是一个缓冲区，它将保存事件直到Sink处理完该事件。Sink负责持久化日志或者把事件推向另一个Source。<br><br><strong>        flume的可靠性 </strong><br>
　　当节点出现故障时，日志能够被传送到其他节点上而不会丢失。Flume提供了三种级别的可靠性保障，从强到弱依次分别为：end-to-end（收到数据agent首先将event写到磁盘上，当数据传送成功后，再删除；如果数据发送失败，可以重新发送。），Store on failure（这也是scribe采用的策略，当数据接收方crash时，将数据写到本地，待恢复后，继续发送），Besteffort（数据发送到接收方后，不会进行确认）。<br><br><strong>        flume的可恢复性：</strong><br>
　　还是靠Channel。推荐使用FileChannel，事件持久化在本地文件系统里(性能较差)。 <br><br><strong>　　flume的一些核心概念：</strong><br><ul class="litype_1"><li>Agent        使用JVM 运行Flume。每台机器运行一个agent，但是可以在一个agent中包含多个sources和sinks。</li><li>Client        生产数据，运行在一个独立的线程。</li><li>Source        从Client收集数据，传递给Channel。</li><li>Sink        从Channel收集数据，运行在一个独立线程。</li><li>Channel        连接 sources 和 sinks ，这个有点像一个队列。</li><li>Events        可以是日志记录、 avro 对象等。<br></li></ul><br><br>
　　Flume以agent为最小的独立运行单位。一个agent就是一个JVM。单agent由Source、Sink和Channel三大组件构成，如下图：<br><br><img id="aimg_6655" src="http://www.aboutyun.com/data/attachment/forum/201408/26/015536rufi6pmapcks6vmu.png" class="zoom" width="456" alt=""><br><br><br>
　　值得注意的是，Flume提供了大量内置的Source、Channel和Sink类型。不同类型的Source,Channel和Sink可以自由组合。组合方式基于用户设置的配置文件，非常灵活。比如：Channel可以把事件暂存在内存里，也可以持久化到本地硬盘上。Sink可以把日志写入HDFS, HBase，甚至是另外一个Source等等。Flume支持用户建立多级流，也就是说，多个agent可以协同工作，并且支持Fan-in、Fan-out、Contextual Routing、Backup Routes，这也正是NB之处。如下图所示:<br><br><img id="aimg_6656" src="http://www.aboutyun.com/data/attachment/forum/201408/26/015537b84jaxujvllxj5ac.png" class="zoom" width="600" alt=""><br><br><br><br><strong><span style="font-size:18px;">　　二、flume的官方网站在哪里？</span></strong><br>
　　<a href="http://flume.apache.org/" rel="nofollow">http://flume.apache.org/</a><br><br><strong><span style="font-size:18px;">　　三、在哪里下载？</span></strong><br>
　　<a href="http://www.apache.org/dyn/closer.cgi/flume/1.5.0/apache-flume-1.5.0-bin.tar.gz" rel="nofollow">http://www.apache.org/dyn/closer.cgi/flume/1.5.0/apache-flume-1.5.0-bin.tar.gz</a><br><br><strong><span style="font-size:18px;">　　四、如何安装？</span></strong><br>
　　　　1)将下载的flume包，解压到/home/hadoop目录中，你就已经完成了50%：）简单吧<br>
　　　　2)修改 flume-env.sh 配置文件,主要是JAVA_HOME变量设置<br><br><div class="blockcode">
<div id="code_u2i">
<ol><li>root@m1:/home/hadoop/flume-1.5.0-bin# cp conf/flume-env.sh.template conf/flume-env.sh<br></li><li>root@m1:/home/hadoop/flume-1.5.0-bin# vi conf/flume-env.sh<br></li><li># Licensed to the Apache Software Foundation (ASF) under one<br></li><li># or more contributor license agreements.  See the NOTICE file<br></li><li># distributed with this work for additional information<br></li><li># regarding copyright ownership.  The ASF licenses this file<br></li><li># to you under the Apache License, Version 2.0 (the<br></li><li># "License"); you may not use this file except in compliance<br></li><li># with the License.  You may obtain a copy of the License at<br></li><li>#<br></li><li>#     http://www.apache.org/licenses/LICENSE-2.0<br></li><li>#<br></li><li># Unless required by applicable law or agreed to in writing, software<br></li><li># distributed under the License is distributed on an "AS IS" BASIS,<br></li><li># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br></li><li># See the License for the specific language governing permissions and<br></li><li># limitations under the License.<br></li><li><br></li><li># If this file is placed at FLUME_CONF_DIR/flume-env.sh, it will be sourced<br></li><li># during Flume startup.<br></li><li><br></li><li># Enviroment variables can be set here.<br></li><li><br></li><li>JAVA_HOME=/usr/lib/jvm/java-7-oracle<br></li><li><br></li><li># Give Flume more memory and pre-allocate, enable remote monitoring via JMX<br></li><li>#JAVA_OPTS="-Xms100m -Xmx200m -Dcom.sun.management.jmxremote"<br></li><li><br></li><li># Note that the Flume conf directory is always included in the classpath.<br></li><li>#FLUME_CLASSPATH=""</li></ol></div>
<em>复制代码</em></div>
<br>
              3)验证是否安装成功<br><br><div class="blockcode">
<div id="code_y87">
<ol><li>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng version<br></li><li>Flume 1.5.0<br></li><li>Source code repository: https://git-wip-us.apache.org/repos/asf/flume.git<br></li><li>Revision: 8633220df808c4cd0c13d1cf0320454a94f1ea97<br></li><li>Compiled by hshreedharan on Wed May  7 14:49:18 PDT 2014<br></li><li>From source with checksum a01fe726e4380ba0c9f7a7d222db961f<br></li><li>root@m1:/home/hadoop#</li></ol></div>
<em>复制代码</em></div>
　　　　出现上面的信息，表示安装成功了<br><br><br><strong><span style="font-size:18px;">　　五、flume的案例</span></strong><br>
　　　　1)案例1：Avro<br>
　　　　Avro可以发送一个给定的文件给Flume，Avro 源使用AVRO RPC机制。<br>
　　　　　　a)创建agent配置文件<br><br><div class="blockcode">
<div id="code_HEp">
<ol><li>root@m1:/home/hadoop#vi /home/hadoop/flume-1.5.0-bin/conf/avro.conf<br></li><li><br></li><li>a1.sources = r1<br></li><li>a1.sinks = k1<br></li><li>a1.channels = c1<br></li><li><br></li><li># Describe/configure the source<br></li><li>a1.sources.r1.type = avro<br></li><li>a1.sources.r1.channels = c1<br></li><li>a1.sources.r1.bind = 0.0.0.0<br></li><li>a1.sources.r1.port = 4141<br></li><li><br></li><li># Describe the sink<br></li><li>a1.sinks.k1.type = logger<br></li><li><br></li><li># Use a channel which buffers events in memory<br></li><li>a1.channels.c1.type = memory<br></li><li>a1.channels.c1.capacity = 1000<br></li><li>a1.channels.c1.transactionCapacity = 100<br></li><li><br></li><li># Bind the source and sink to the channel<br></li><li>a1.sources.r1.channels = c1<br></li><li>a1.sinks.k1.channel = c1</li></ol></div>
<em>复制代码</em></div>
<br><br><br>
　　　　　　b)启动flume agent a1<br><br><div class="blockcode">
<div id="code_rPD">
<ol><li>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/avro.conf -n a1 -Dflume.root.logger=INFO,console<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　c)创建指定文件<br><br><div class="blockcode">
<div id="code_I6o">
<ol><li>root@m1:/home/hadoop# echo "hello world" &gt; /home/hadoop/flume-1.5.0-bin/log.00</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　d)使用avro-client发送文件<br><br><div class="blockcode">
<div id="code_moo">
<ol><li>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng avro-client -c . -H m1 -p 4141 -F /home/hadoop/flume-1.5.0-bin/log.00</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　d)使用avro-client发送文件<br><br><br><div class="blockcode">
<div id="code_hee">
<ol><li>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng avro-client -c . -H m1 -p 4141 -F /</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　f)在m1的控制台，可以看到以下信息，注意最后一行：<br><br><br><div class="blockcode">
<div id="code_KI4">
<ol><li>root@m1:/home/hadoop/flume-1.5.0-bin/conf# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/avro.conf -n a1 -Dflume.root.logger=INFO,console<br></li><li>Info: Sourcing environment configuration script /home/hadoop/flume-1.5.0-bin/conf/flume-env.sh<br></li><li>Info: Including Hadoop libraries found via (/home/hadoop/hadoop-2.2.0/bin/hadoop) for HDFS access<br></li><li>Info: Excluding /home/hadoop/hadoop-2.2.0/share/hadoop/common/lib/slf4j-api-1.7.5.jar from classpath<br></li><li>Info: Excluding /home/hadoop/hadoop-2.2.0/share/hadoop/common/lib/slf4j-log4j12-1.7.5.jar from classpath<br></li><li>...<br></li><li>2014-08-10 10:43:25,112 (New I/O  worker #1) [INFO - org.apache.avro.ipc.NettyServer$NettyServerAvroHandler.handleUpstream(NettyServer.java:171)] [id: 0x92464c4f, /192.168.1.50:59850 :&gt; /192.168.1.50:4141] UNBOUND<br></li><li>2014-08-10 10:43:25,112 (New I/O  worker #1) [INFO - org.apache.avro.ipc.NettyServer$NettyServerAvroHandler.handleUpstream(NettyServer.java:171)] [id: 0x92464c4f, /192.168.1.50:59850 :&gt; /192.168.1.50:4141] CLOSED<br></li><li>2014-08-10 10:43:25,112 (New I/O  worker #1) [INFO - org.apache.avro.ipc.NettyServer$NettyServerAvroHandler.channelClosed(NettyServer.java:209)] Connection to /192.168.1.50:59850 disconnected.<br></li><li>2014-08-10 10:43:26,718 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 68 65 6C 6C 6F 20 77 6F 72 6C 64                hello world }<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br><br>
　　　　2)案例2：Spool<br>
　　　　Spool监测配置的目录下新增的文件，并将文件中的数据读取出来。需要注意两点：<br>
　　　　1) 拷贝到spool目录下的文件不可以再打开编辑。<br>
　　　　2) spool目录下不可包含相应的子目录<br><br><br>
　　　　　　a)创建agent配置文件<br><br><div class="blockcode">
<div id="code_YUT">
<ol><li>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/spool.conf<br></li><li><br></li><li>a1.sources = r1<br></li><li>a1.sinks = k1<br></li><li>a1.channels = c1<br></li><li><br></li><li># Describe/configure the source<br></li><li>a1.sources.r1.type = spooldir<br></li><li>a1.sources.r1.channels = c1<br></li><li>a1.sources.r1.spoolDir = /home/hadoop/flume-1.5.0-bin/logs<br></li><li>a1.sources.r1.fileHeader = true<br></li><li><br></li><li># Describe the sink<br></li><li>a1.sinks.k1.type = logger<br></li><li><br></li><li># Use a channel which buffers events in memory<br></li><li>a1.channels.c1.type = memory<br></li><li>a1.channels.c1.capacity = 1000<br></li><li>a1.channels.c1.transactionCapacity = 100<br></li><li><br></li><li># Bind the source and sink to the channel<br></li><li>a1.sources.r1.channels = c1<br></li><li>a1.sinks.k1.channel = c1<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　b)启动flume agent a1<br><br><div class="blockcode">
<div id="code_BHC">
<ol><li>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/spool.conf -n a1 -Dflume.root.logger=INFO,console<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　c)追加文件到/home/hadoop/flume-1.5.0-bin/logs目录<br><br><div class="blockcode">
<div id="code_SUZ">
<ol><li>root@m1:/home/hadoop# echo "spool test1" &gt; /home/hadoop/flume-1.5.0-bin/logs/spool_text.log<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　d)在m1的控制台，可以看到以下相关信息：<br><br><div class="blockcode">
<div id="code_npW">
<ol><li>14/08/10 11:37:13 INFO source.SpoolDirectorySource: Spooling Directory Source runner has shutdown.<br></li><li>14/08/10 11:37:13 INFO source.SpoolDirectorySource: Spooling Directory Source runner has shutdown.<br></li><li>14/08/10 11:37:14 INFO avro.ReliableSpoolingFileEventReader: Preparing to move file /home/hadoop/flume-1.5.0-bin/logs/spool_text.log to /home/hadoop/flume-1.5.0-bin/logs/spool_text.log.COMPLETED<br></li><li>14/08/10 11:37:14 INFO source.SpoolDirectorySource: Spooling Directory Source runner has shutdown.<br></li><li>14/08/10 11:37:14 INFO source.SpoolDirectorySource: Spooling Directory Source runner has shutdown.<br></li><li>14/08/10 11:37:14 INFO sink.LoggerSink: Event: { headers:{file=/home/hadoop/flume-1.5.0-bin/logs/spool_text.log} body: 73 70 6F 6F 6C 20 74 65 73 74 31                spool test1 }<br></li><li>14/08/10 11:37:15 INFO source.SpoolDirectorySource: Spooling Directory Source runner has shutdown.<br></li><li>14/08/10 11:37:15 INFO source.SpoolDirectorySource: Spooling Directory Source runner has shutdown.<br></li><li>14/08/10 11:37:16 INFO source.SpoolDirectorySource: Spooling Directory Source runner has shutdown.<br></li><li>14/08/10 11:37:16 INFO source.SpoolDirectorySource: Spooling Directory Source runner has shutdown.<br></li><li>14/08/10 11:37:17 INFO source.SpoolDirectorySource: Spooling Directory Source runner has shutdown.</li></ol></div>
<em>复制代码</em></div>
<br><br><br>
　　　　3)案例3：Exec<br>
　　　　EXEC执行一个给定的命令获得输出的源,如果要使用tail命令，必选使得file足够大才能看到输出内容<br><br>
　　　　　　a)创建agent配置文件<br><br><div class="blockcode">
<div id="code_K11">
<ol><li>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/exec_tail.conf<br></li><li><br></li><li>a1.sources = r1<br></li><li>a1.sinks = k1<br></li><li>a1.channels = c1<br></li><li><br></li><li># Describe/configure the source<br></li><li>a1.sources.r1.type = exec<br></li><li>a1.sources.r1.channels = c1<br></li><li>a1.sources.r1.command = tail -F /home/hadoop/flume-1.5.0-bin/log_exec_tail<br></li><li><br></li><li># Describe the sink<br></li><li>a1.sinks.k1.type = logger<br></li><li><br></li><li># Use a channel which buffers events in memory<br></li><li>a1.channels.c1.type = memory<br></li><li>a1.channels.c1.capacity = 1000<br></li><li>a1.channels.c1.transactionCapacity = 100<br></li><li><br></li><li># Bind the source and sink to the channel<br></li><li>a1.sources.r1.channels = c1<br></li><li>a1.sinks.k1.channel = c1</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　b)启动flume agent a1<br><br><div class="blockcode">
<div id="code_KQ8">
<ol><li>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/exec_tail.conf -n a1 -Dflume.root.logger=INFO,console<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　c)生成足够多的内容在文件里<br><br><div class="blockcode">
<div id="code_Jfj">
<ol><li>root@m1:/home/hadoop# for i in {1..100};do echo "exec tail$i" &gt;&gt; /home/hadoop/flume-1.5.0-bin/log_</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　e)在m1的控制台，可以看到以下信息：<br><br><div class="blockcode">
<div id="code_u5q">
<ol><li>2014-08-10 10:59:25,513 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 20 74 65 73 74       exec tail test }<br></li><li>2014-08-10 10:59:34,535 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 20 74 65 73 74       exec tail test }<br></li><li>2014-08-10 11:01:40,557 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 31                   exec tail1 }<br></li><li>2014-08-10 11:01:41,180 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 32                   exec tail2 }<br></li><li>2014-08-10 11:01:41,180 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 33                   exec tail3 }<br></li><li>2014-08-10 11:01:41,181 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 34                   exec tail4 }<br></li><li>2014-08-10 11:01:41,181 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 35                   exec tail5 }<br></li><li>2014-08-10 11:01:41,181 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 36                   exec tail6 }<br></li><li>....<br></li><li>....<br></li><li>....<br></li><li>2014-08-10 11:01:51,550 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 39 36                exec tail96 }<br></li><li>2014-08-10 11:01:51,550 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 39 37                exec tail97 }<br></li><li>2014-08-10 11:01:51,551 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 39 38                exec tail98 }<br></li><li>2014-08-10 11:01:51,551 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 39 39                exec tail99 }<br></li><li>2014-08-10 11:01:51,551 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 65 78 65 63 20 74 61 69 6C 31 30 30             exec tail100 }<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br><br><br>
　　　　4)案例4：Syslogtcp<br>
　　　　Syslogtcp监听TCP的端口做为数据源<br><br>
　　　　　　a)创建agent配置文件<br><br><div class="blockcode">
<div id="code_mb0">
<ol><li>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/syslog_tcp.conf<br></li><li><br></li><li>a1.sources = r1<br></li><li>a1.sinks = k1<br></li><li>a1.channels = c1<br></li><li><br></li><li># Describe/configure the source<br></li><li>a1.sources.r1.type = syslogtcp<br></li><li>a1.sources.r1.port = 5140<br></li><li>a1.sources.r1.host = localhost<br></li><li>a1.sources.r1.channels = c1<br></li><li><br></li><li># Describe the sink<br></li><li>a1.sinks.k1.type = logger<br></li><li><br></li><li># Use a channel which buffers events in memory<br></li><li>a1.channels.c1.type = memory<br></li><li>a1.channels.c1.capacity = 1000<br></li><li>a1.channels.c1.transactionCapacity = 100<br></li><li><br></li><li># Bind the source and sink to the channel<br></li><li>a1.sources.r1.channels = c1<br></li><li>a1.sinks.k1.channel = c1</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　b)启动flume agent a1<br><br><br><div class="blockcode">
<div id="code_HDf">
<ol><li>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/syslog_tcp.conf -n a1 -Dflume.root.logger=INFO,console<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　c)测试产生syslog<br><br><div class="blockcode">
<div id="code_aiQ">
<ol><li>root@m1:/home/hadoop# echo "hello idoall.org syslog" | nc localhost 5140</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　d)在m1的控制台，可以看到以下信息：<br><br><div class="blockcode">
<div id="code_Zl7">
<ol><li>14/08/10 11:41:45 INFO node.PollingPropertiesFileConfigurationProvider: Reloading configuration file:/home/hadoop/flume-1.5.0-bin/conf/syslog_tcp.conf<br></li><li>14/08/10 11:41:45 INFO conf.FlumeConfiguration: Added sinks: k1 Agent: a1<br></li><li>14/08/10 11:41:45 INFO conf.FlumeConfiguration: Processing:k1<br></li><li>14/08/10 11:41:45 INFO conf.FlumeConfiguration: Processing:k1<br></li><li>14/08/10 11:41:45 INFO conf.FlumeConfiguration: Post-validation flume configuration contains configuration for agents: [a1]<br></li><li>14/08/10 11:41:45 INFO node.AbstractConfigurationProvider: Creating channels<br></li><li>14/08/10 11:41:45 INFO channel.DefaultChannelFactory: Creating instance of channel c1 type memory<br></li><li>14/08/10 11:41:45 INFO node.AbstractConfigurationProvider: Created channel c1<br></li><li>14/08/10 11:41:45 INFO source.DefaultSourceFactory: Creating instance of source r1, type syslogtcp<br></li><li>14/08/10 11:41:45 INFO sink.DefaultSinkFactory: Creating instance of sink: k1, type: logger<br></li><li>14/08/10 11:41:45 INFO node.AbstractConfigurationProvider: Channel c1 connected to [r1, k1]<br></li><li>14/08/10 11:41:45 INFO node.Application: Starting new configuration:{ sourceRunners:{r1=EventDrivenSourceRunner: { source:org.apache.flume.source.SyslogTcpSource{name:r1,state:IDLE} }} sinkRunners:{k1=SinkRunner: { policy:org.apache.flume.sink.DefaultSinkProcessor@6538b14
 counterGroup:{ name:null counters:{} } }} channels:{c1=org.apache.flume.channel.MemoryChannel{name: c1}} }<br></li><li>14/08/10 11:41:45 INFO node.Application: Starting Channel c1<br></li><li>14/08/10 11:41:45 INFO instrumentation.MonitoredCounterGroup: Monitored counter group for type: CHANNEL, name: c1: Successfully registered new MBean.<br></li><li>14/08/10 11:41:45 INFO instrumentation.MonitoredCounterGroup: Component type: CHANNEL, name: c1 started<br></li><li>14/08/10 11:41:45 INFO node.Application: Starting Sink k1<br></li><li>14/08/10 11:41:45 INFO node.Application: Starting Source r1<br></li><li>14/08/10 11:41:45 INFO source.SyslogTcpSource: Syslog TCP Source starting...<br></li><li>14/08/10 11:42:15 WARN source.SyslogUtils: Event created from Invalid Syslog data.<br></li><li>14/08/10 11:42:15 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 68 65 6C 6C 6F 20 69 64 6F 61 6C 6C 2E 6F 72 67 hello idoall.org }</li></ol></div>
<em>复制代码</em></div>
<br><br><br>
　　　　5)案例5：JSONHandler<br>
　　　　　　a)创建agent配置文件<br><br><div class="blockcode">
<div id="code_Wnf">
<ol><li>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/post_json.conf<br></li><li><br></li><li>a1.sources = r1<br></li><li>a1.sinks = k1<br></li><li>a1.channels = c1<br></li><li><br></li><li># Describe/configure the source<br></li><li>a1.sources.r1.type = org.apache.flume.source.http.HTTPSource<br></li><li>a1.sources.r1.port = 8888<br></li><li>a1.sources.r1.channels = c1<br></li><li><br></li><li># Describe the sink<br></li><li>a1.sinks.k1.type = logger<br></li><li><br></li><li># Use a channel which buffers events in memory<br></li><li>a1.channels.c1.type = memory<br></li><li>a1.channels.c1.capacity = 1000<br></li><li>a1.channels.c1.transactionCapacity = 100<br></li><li><br></li><li># Bind the source and sink to the channel<br></li><li>a1.sources.r1.channels = c1<br></li><li>a1.sinks.k1.channel = c1</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　b)启动flume agent a1<br><br><br><div class="blockcode">
<div id="code_lHm">
<ol><li>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/post_json.conf -n a1 -Dflume.root.logger=INFO,console</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　c)生成JSON 格式的POST request<br><br><div class="blockcode">
<div id="code_IAH">
<ol><li>root@m1:/home/hadoop# curl -X POST -d '[{ "headers" :{"a" : "a1","b" : "b1"},"body" : "idoall.org_body"}]' http://localhost:8888<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　d)在m1的控制台，可以看到以下信息：<br><br><div class="blockcode">
<div id="code_u5e">
<ol><li>14/08/10 11:49:59 INFO node.Application: Starting Channel c1<br></li><li>14/08/10 11:49:59 INFO instrumentation.MonitoredCounterGroup: Monitored counter group for type: CHANNEL, name: c1: Successfully registered new MBean.<br></li><li>14/08/10 11:49:59 INFO instrumentation.MonitoredCounterGroup: Component type: CHANNEL, name: c1 started<br></li><li>14/08/10 11:49:59 INFO node.Application: Starting Sink k1<br></li><li>14/08/10 11:49:59 INFO node.Application: Starting Source r1<br></li><li>14/08/10 11:49:59 INFO mortbay.log: Logging to org.slf4j.impl.Log4jLoggerAdapter(org.mortbay.log) via org.mortbay.log.Slf4jLog<br></li><li>14/08/10 11:49:59 INFO mortbay.log: jetty-6.1.26<br></li><li>14/08/10 11:50:00 INFO mortbay.log: Started SelectChannelConnector@0.0.0.0:8888<br></li><li>14/08/10 11:50:00 INFO instrumentation.MonitoredCounterGroup: Monitored counter group for type: SOURCE, name: r1: Successfully registered new MBean.<br></li><li>14/08/10 11:50:00 INFO instrumentation.MonitoredCounterGroup: Component type: SOURCE, name: r1 started<br></li><li>14/08/10 12:14:32 INFO sink.LoggerSink: Event: { headers:{b=b1, a=a1} body: 69 64 6F 61 6C 6C 2E 6F 72 67 5F 62 6F 64 79    idoall.org_body }<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　6)案例6：Hadoop sink<br>
　　　　　　a)创建agent配置文件<br><br><div class="blockcode">
<div id="code_IAY">
<ol><li>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/hdfs_sink.conf<br></li><li><br></li><li>a1.sources = r1<br></li><li>a1.sinks = k1<br></li><li>a1.channels = c1<br></li><li><br></li><li># Describe/configure the source<br></li><li>a1.sources.r1.type = syslogtcp<br></li><li>a1.sources.r1.port = 5140<br></li><li>a1.sources.r1.host = localhost<br></li><li>a1.sources.r1.channels = c1<br></li><li><br></li><li># Describe the sink<br></li><li>a1.sinks.k1.type = hdfs<br></li><li>a1.sinks.k1.channel = c1<br></li><li>a1.sinks.k1.hdfs.path = hdfs://m1:9000/user/flume/syslogtcp<br></li><li>a1.sinks.k1.hdfs.filePrefix = Syslog<br></li><li>a1.sinks.k1.hdfs.round = true<br></li><li>a1.sinks.k1.hdfs.roundValue = 10<br></li><li>a1.sinks.k1.hdfs.roundUnit = minute<br></li><li><br></li><li># Use a channel which buffers events in memory<br></li><li>a1.channels.c1.type = memory<br></li><li>a1.channels.c1.capacity = 1000<br></li><li>a1.channels.c1.transactionCapacity = 100<br></li><li><br></li><li># Bind the source and sink to the channel<br></li><li>a1.sources.r1.channels = c1<br></li><li>a1.sinks.k1.channel = c1</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　b)启动flume agent a1<br><br><div class="blockcode">
<div id="code_pDM">
<ol><li>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/hdfs_sink.conf -n a1 -Dflume.root.logger=INFO,console</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　c)测试产生syslog<br><br><div class="blockcode">
<div id="code_dSG">
<ol><li>root@m1:/home/hadoop# echo "hello idoall flume -&gt; hadoop testing one" | nc localhost 5140<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　d)在m1的控制台，可以看到以下信息：<br><br><div class="blockcode">
<div id="code_zAO">
<ol><li>14/08/10 12:20:39 INFO instrumentation.MonitoredCounterGroup: Monitored counter group for type: CHANNEL, name: c1: Successfully registered new MBean.<br></li><li>14/08/10 12:20:39 INFO instrumentation.MonitoredCounterGroup: Component type: CHANNEL, name: c1 started<br></li><li>14/08/10 12:20:39 INFO node.Application: Starting Sink k1<br></li><li>14/08/10 12:20:39 INFO node.Application: Starting Source r1<br></li><li>14/08/10 12:20:39 INFO instrumentation.MonitoredCounterGroup: Monitored counter group for type: SINK, name: k1: Successfully registered new MBean.<br></li><li>14/08/10 12:20:39 INFO instrumentation.MonitoredCounterGroup: Component type: SINK, name: k1 started<br></li><li>14/08/10 12:20:39 INFO source.SyslogTcpSource: Syslog TCP Source starting...<br></li><li>14/08/10 12:21:46 WARN source.SyslogUtils: Event created from Invalid Syslog data.<br></li><li>14/08/10 12:21:49 INFO hdfs.HDFSSequenceFile: writeFormat = Writable, UseRawLocalFileSystem = false<br></li><li>14/08/10 12:21:49 INFO hdfs.BucketWriter: Creating hdfs://m1:9000/user/flume/syslogtcp//Syslog.1407644509504.tmp<br></li><li>14/08/10 12:22:20 INFO hdfs.BucketWriter: Closing hdfs://m1:9000/user/flume/syslogtcp//Syslog.1407644509504.tmp<br></li><li>14/08/10 12:22:20 INFO hdfs.BucketWriter: Close tries incremented<br></li><li>14/08/10 12:22:20 INFO hdfs.BucketWriter: Renaming hdfs://m1:9000/user/flume/syslogtcp/Syslog.1407644509504.tmp to hdfs://m1:9000/user/flume/syslogtcp/Syslog.1407644509504<br></li><li>14/08/10 12:22:20 INFO hdfs.HDFSEventSink: Writer callback called.</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　e)在m1上再打开一个窗口，去hadoop上检查文件是否生成<br><br><div class="blockcode">
<div id="code_qO7">
<ol><li>root@m1:/home/hadoop# /home/hadoop/hadoop-2.2.0/bin/hadoop fs -ls /user/flume/syslogtcp<br></li><li>Found 1 items<br></li><li>-rw-r--r--   3 root supergroup        155 2014-08-10 12:22 /user/flume/syslogtcp/Syslog.1407644509504<br></li><li>root@m1:/home/hadoop# /home/hadoop/hadoop-2.2.0/bin/hadoop fs -cat /user/flume/syslogtcp/Syslog.1407644509504<br></li><li>SEQ!org.apache.hadoop.io.LongWritable"org.apache.hadoop.io.BytesWritable^;&gt;Gv$hello idoall flume -&gt; hadoop testing one<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br><br><br>
　　　　7)案例7：File Roll Sink<br>
　　　　　　a)创建agent配置文件<br><br><div class="blockcode">
<div id="code_O5p">
<ol><li>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/file_roll.conf<br></li><li><br></li><li>a1.sources = r1<br></li><li>a1.sinks = k1<br></li><li>a1.channels = c1<br></li><li><br></li><li># Describe/configure the source<br></li><li>a1.sources.r1.type = syslogtcp<br></li><li>a1.sources.r1.port = 5555<br></li><li>a1.sources.r1.host = localhost<br></li><li>a1.sources.r1.channels = c1<br></li><li><br></li><li># Describe the sink<br></li><li>a1.sinks.k1.type = file_roll<br></li><li>a1.sinks.k1.sink.directory = /home/hadoop/flume-1.5.0-bin/logs<br></li><li><br></li><li># Use a channel which buffers events in memory<br></li><li>a1.channels.c1.type = memory<br></li><li>a1.channels.c1.capacity = 1000<br></li><li>a1.channels.c1.transactionCapacity = 100<br></li><li><br></li><li># Bind the source and sink to the channel<br></li><li>a1.sources.r1.channels = c1<br></li><li>a1.sinks.k1.channel = c1</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　b)启动flume agent a1<br><br><div class="blockcode">
<div id="code_dGw">
<ol><li>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/file_roll.conf -n a1 -Dflume.root.logger=INFO,console<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　c)测试产生log<br><br><div class="blockcode">
<div id="code_j5h">
<ol><li>root@m1:/home/hadoop# echo "hello idoall.org syslog" | nc localhost 5555<br></li><li>root@m1:/home/hadoop# echo "hello idoall.org syslog 2" | nc localhost 5555</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　d)查看/home/hadoop/flume-1.5.0-bin/logs下是否生成文件,默认每30秒生成一个新文件<br><br><div class="blockcode">
<div id="code_nBv">
<ol><li>root@m1:/home/hadoop# ll /home/hadoop/flume-1.5.0-bin/logs<br></li><li>总用量 272<br></li><li>drwxr-xr-x 3 root root   4096 Aug 10 12:50 ./<br></li><li>drwxr-xr-x 9 root root   4096 Aug 10 10:59 ../<br></li><li>-rw-r--r-- 1 root root     50 Aug 10 12:49 1407646164782-1<br></li><li>-rw-r--r-- 1 root root      0 Aug 10 12:49 1407646164782-2<br></li><li>-rw-r--r-- 1 root root      0 Aug 10 12:50 1407646164782-3<br></li><li>root@m1:/home/hadoop# cat /home/hadoop/flume-1.5.0-bin/logs/1407646164782-1 /home/hadoop/flume-1.5.0-bin/logs/1407646164782-2<br></li><li>hello idoall.org syslog<br></li><li>hello idoall.org syslog 2</li></ol></div>
<em>复制代码</em></div>
<br><br><br>
　　　　8)案例8：Replicating Channel Selector<br>
　　　　Flume支持Fan out流从一个源到多个通道。有两种模式的Fan out，分别是复制和复用。在复制的情况下，流的事件被发送到所有的配置通道。在复用的情况下，事件被发送到可用的渠道中的一个子集。Fan out流需要指定源和Fan out通道的规则。<br><br>
　　　　这次我们需要用到m1,m2两台机器<br><br>
　　　　　　a)在m1创建replicating_Channel_Selector配置文件<br><div class="blockcode">
<div id="code_AZn">
<ol><li>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/replicating_Channel_Selector.conf<br></li><li><br></li><li>a1.sources = r1<br></li><li>a1.sinks = k1 k2<br></li><li>a1.channels = c1 c2<br></li><li><br></li><li># Describe/configure the source<br></li><li>a1.sources.r1.type = syslogtcp<br></li><li>a1.sources.r1.port = 5140<br></li><li>a1.sources.r1.host = localhost<br></li><li>a1.sources.r1.channels = c1 c2<br></li><li>a1.sources.r1.selector.type = replicating<br></li><li><br></li><li># Describe the sink<br></li><li>a1.sinks.k1.type = avro<br></li><li>a1.sinks.k1.channel = c1<br></li><li>a1.sinks.k1.hostname = m1<br></li><li>a1.sinks.k1.port = 5555<br></li><li><br></li><li>a1.sinks.k2.type = avro<br></li><li>a1.sinks.k2.channel = c2<br></li><li>a1.sinks.k2.hostname = m2<br></li><li>a1.sinks.k2.port = 5555<br></li><li><br></li><li># Use a channel which buffers events in memory<br></li><li>a1.channels.c1.type = memory<br></li><li>a1.channels.c1.capacity = 1000<br></li><li>a1.channels.c1.transactionCapacity = 100<br></li><li><br></li><li>a1.channels.c2.type = memory<br></li><li>a1.channels.c2.capacity = 1000<br></li><li>a1.channels.c2.transactionCapacity = 100</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　b)在m1创建replicating_Channel_Selector_avro配置文件<br><div class="blockcode">
<div id="code_crm">
<ol><li>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/replicating_Channel_Selector_avro.conf<br></li><li><br></li><li>a1.sources = r1<br></li><li>a1.sinks = k1<br></li><li>a1.channels = c1<br></li><li><br></li><li># Describe/configure the source<br></li><li>a1.sources.r1.type = avro<br></li><li>a1.sources.r1.channels = c1<br></li><li>a1.sources.r1.bind = 0.0.0.0<br></li><li>a1.sources.r1.port = 5555<br></li><li><br></li><li># Describe the sink<br></li><li>a1.sinks.k1.type = logger<br></li><li><br></li><li># Use a channel which buffers events in memory<br></li><li>a1.channels.c1.type = memory<br></li><li>a1.channels.c1.capacity = 1000<br></li><li>a1.channels.c1.transactionCapacity = 100<br></li><li><br></li><li># Bind the source and sink to the channel<br></li><li>a1.sources.r1.channels = c1<br></li><li>a1.sinks.k1.channel = c1</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　c)在m1上将2个配置文件复制到m2上一份<br><div class="blockcode">
<div id="code_qkk">
<ol><li>root@m1:/home/hadoop/flume-1.5.0-bin# scp -r /home/hadoop/flume-1.5.0-bin/conf/replicating_Channel_Selector.conf root@m2:/home/hadoop/flume-1.5.0-bin/conf/replicating_Channel_Selector.conf<br></li><li>root@m1:/home/hadoop/flume-1.5.0-bin# scp -r /home/hadoop/flume-1.5.0-bin/conf/replicating_Channel_Selector_avro.conf root@m2:/home/hadoop/flume-1.5.0-bin/conf/replicating_Channel_Selector_avro.conf<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
　　　　　　d)打开4个窗口，在m1和m2上同时启动两个flume agent<br><div class="blockcode">
<div id="code_Thz">
<ol><li>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/replicating_Channel_Selector_avro.conf -n a1 -Dflume.root.logger=INFO,console<br></li><li>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/replicating_Channel_Selector.conf -n a1 -Dflume.root.logger=INFO,console<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　e)然后在m1或m2的任意一台机器上，测试产生syslog<br><div class="blockcode">
<div id="code_TVK">
<ol><li>root@m1:/home/hadoop# echo "hello idoall.org syslog" | nc localhost 5140<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　f)在m1和m2的sink窗口，分别可以看到以下信息,这说明信息得到了同步：<br><div class="blockcode">
<div id="code_uZQ">
<ol><li>14/08/10 14:08:18 INFO ipc.NettyServer: Connection to /192.168.1.51:46844 disconnected.<br></li><li>14/08/10 14:08:52 INFO ipc.NettyServer: [id: 0x90f8fe1f, /192.168.1.50:35873 =&gt; /192.168.1.50:5555] OPEN<br></li><li>14/08/10 14:08:52 INFO ipc.NettyServer: [id: 0x90f8fe1f, /192.168.1.50:35873 =&gt; /192.168.1.50:5555] BOUND: /192.168.1.50:5555<br></li><li>14/08/10 14:08:52 INFO ipc.NettyServer: [id: 0x90f8fe1f, /192.168.1.50:35873 =&gt; /192.168.1.50:5555] CONNECTED: /192.168.1.50:35873<br></li><li>14/08/10 14:08:59 INFO ipc.NettyServer: [id: 0xd6318635, /192.168.1.51:46858 =&gt; /192.168.1.50:5555] OPEN<br></li><li>14/08/10 14:08:59 INFO ipc.NettyServer: [id: 0xd6318635, /192.168.1.51:46858 =&gt; /192.168.1.50:5555] BOUND: /192.168.1.50:5555<br></li><li>14/08/10 14:08:59 INFO ipc.NettyServer: [id: 0xd6318635, /192.168.1.51:46858 =&gt; /192.168.1.50:5555] CONNECTED: /192.168.1.51:46858<br></li><li>14/08/10 14:09:20 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 68 65 6C 6C 6F 20 69 64 6F 61 6C 6C 2E 6F 72 67 hello idoall.org }<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br><br><br>
　　　　9)案例9：Multiplexing Channel Selector<br>
　　　　　　a)在m1创建Multiplexing_Channel_Selector配置文件<br><br><div class="blockcode">
<div id="code_nCC">
<ol><li>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/Multiplexing_Channel_Selector.conf<br></li><li><br></li><li>a1.sources = r1<br></li><li>a1.sinks = k1 k2<br></li><li>a1.channels = c1 c2<br></li><li><br></li><li># Describe/configure the source<br></li><li>a1.sources.r1.type = org.apache.flume.source.http.HTTPSource<br></li><li>a1.sources.r1.port = 5140<br></li><li>a1.sources.r1.channels = c1 c2<br></li><li>a1.sources.r1.selector.type = multiplexing<br></li><li><br></li><li>a1.sources.r1.selector.header = type<br></li><li>#映射允许每个值通道可以重叠。默认值可以包含任意数量的通道。<br></li><li>a1.sources.r1.selector.mapping.baidu = c1<br></li><li>a1.sources.r1.selector.mapping.ali = c2<br></li><li>a1.sources.r1.selector.default = c1<br></li><li><br></li><li># Describe the sink<br></li><li>a1.sinks.k1.type = avro<br></li><li>a1.sinks.k1.channel = c1<br></li><li>a1.sinks.k1.hostname = m1<br></li><li>a1.sinks.k1.port = 5555<br></li><li><br></li><li>a1.sinks.k2.type = avro<br></li><li>a1.sinks.k2.channel = c2<br></li><li>a1.sinks.k2.hostname = m2<br></li><li>a1.sinks.k2.port = 5555<br></li><li><br></li><li># Use a channel which buffers events in memory<br></li><li>a1.channels.c1.type = memory<br></li><li>a1.channels.c1.capacity = 1000<br></li><li>a1.channels.c1.transactionCapacity = 100<br></li><li><br></li><li>a1.channels.c2.type = memory<br></li><li>a1.channels.c2.capacity = 1000<br></li><li>a1.channels.c2.transactionCapacity = 100</li></ol></div>
<em>复制代码</em></div>
<br><br><br>
　　　　　　b)在m1创建Multiplexing_Channel_Selector_avro配置文件<br><div class="blockcode">
<div id="code_b1s">
<ol><li>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/Multiplexing_Channel_Selector_avro.conf<br></li><li><br></li><li>a1.sources = r1<br></li><li>a1.sinks = k1<br></li><li>a1.channels = c1<br></li><li><br></li><li># Describe/configure the source<br></li><li>a1.sources.r1.type = avro<br></li><li>a1.sources.r1.channels = c1<br></li><li>a1.sources.r1.bind = 0.0.0.0<br></li><li>a1.sources.r1.port = 5555<br></li><li><br></li><li># Describe the sink<br></li><li>a1.sinks.k1.type = logger<br></li><li><br></li><li># Use a channel which buffers events in memory<br></li><li>a1.channels.c1.type = memory<br></li><li>a1.channels.c1.capacity = 1000<br></li><li>a1.channels.c1.transactionCapacity = 100<br></li><li><br></li><li># Bind the source and sink to the channel<br></li><li>a1.sources.r1.channels = c1<br></li><li>a1.sinks.k1.channel = c1</li></ol></div>
<em>复制代码</em></div>
<br><br><br>
　　　　　　c)将2个配置文件复制到m2上一份<br><div class="blockcode">
<div id="code_NSz">
<ol><li>root@m1:/home/hadoop/flume-1.5.0-bin# scp -r /home/hadoop/flume-1.5.0-bin/conf/Multiplexing_Channel_Selector.conf  root@m2:/home/hadoop/flume-1.5.0-bin/conf/Multiplexing_Channel_Selector.conf<br></li><li>root@m1:/home/hadoop/flume-1.5.0-bin# scp -r /home/hadoop/flume-1.5.0-bin/conf/Multiplexing_Channel_Selector_avro.conf root@m2:/home/hadoop/flume-1.5.0-bin/conf/Multiplexing_Channel_Selector_avro.conf<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br><br><br>
　　　　　　d)打开4个窗口，在m1和m2上同时启动两个flume agent<br><div class="blockcode">
<div id="code_xjC">
<ol><li>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/Multiplexing_Channel_Selector_avro.conf -n a1 -Dflume.root.logger=INFO,console<br></li><li>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/Multiplexing_Channel_Selector.conf -n a1 -Dflume.root.logger=INFO,console<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br><br><br>
　　　　　　e)然后在m1或m2的任意一台机器上，测试产生syslog<br><div class="blockcode">
<div id="code_vUg">
<ol><li>root@m1:/home/hadoop# curl -X POST -d '[{ "headers" :{"type" : "baidu"},"body" : "idoall_TEST1"}]' http://localhost:5140 &amp;&amp; curl -X POST -d '[{ "headers" :{"type" : "ali"},"body" : "idoall_TEST2"}]' http://localhost:5140 &amp;&amp; curl -X POST -d '[{ "headers"
 :{"type" : "qq"},"body" : "idoall_TEST3"}]' http://localhost:5140<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　f)在m1的sink窗口，可以看到以下信息：<br><div class="blockcode">
<div id="code_fq5">
<ol><li>14/08/10 14:32:21 INFO node.Application: Starting Sink k1<br></li><li>14/08/10 14:32:21 INFO node.Application: Starting Source r1<br></li><li>14/08/10 14:32:21 INFO source.AvroSource: Starting Avro source r1: { bindAddress: 0.0.0.0, port: 5555 }...<br></li><li>14/08/10 14:32:21 INFO instrumentation.MonitoredCounterGroup: Monitored counter group for type: SOURCE, name: r1: Successfully registered new MBean.<br></li><li>14/08/10 14:32:21 INFO instrumentation.MonitoredCounterGroup: Component type: SOURCE, name: r1 started<br></li><li>14/08/10 14:32:21 INFO source.AvroSource: Avro source r1 started.<br></li><li>14/08/10 14:32:36 INFO ipc.NettyServer: [id: 0xcf00eea6, /192.168.1.50:35916 =&gt; /192.168.1.50:5555] OPEN<br></li><li>14/08/10 14:32:36 INFO ipc.NettyServer: [id: 0xcf00eea6, /192.168.1.50:35916 =&gt; /192.168.1.50:5555] BOUND: /192.168.1.50:5555<br></li><li>14/08/10 14:32:36 INFO ipc.NettyServer: [id: 0xcf00eea6, /192.168.1.50:35916 =&gt; /192.168.1.50:5555] CONNECTED: /192.168.1.50:35916<br></li><li>14/08/10 14:32:44 INFO ipc.NettyServer: [id: 0x432f5468, /192.168.1.51:46945 =&gt; /192.168.1.50:5555] OPEN<br></li><li>14/08/10 14:32:44 INFO ipc.NettyServer: [id: 0x432f5468, /192.168.1.51:46945 =&gt; /192.168.1.50:5555] BOUND: /192.168.1.50:5555<br></li><li>14/08/10 14:32:44 INFO ipc.NettyServer: [id: 0x432f5468, /192.168.1.51:46945 =&gt; /192.168.1.50:5555] CONNECTED: /192.168.1.51:46945<br></li><li>14/08/10 14:34:11 INFO sink.LoggerSink: Event: { headers:{type=baidu} body: 69 64 6F 61 6C 6C 5F 54 45 53 54 31             idoall_TEST1 }<br></li><li>14/08/10 14:34:57 INFO sink.LoggerSink: Event: { headers:{type=qq} body: 69 64 6F 61 6C 6C 5F 54 45 53 54 33             idoall_TEST3 }<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　g)在m2的sink窗口，可以看到以下信息：<br><br><div class="blockcode">
<div id="code_beS">
<ol><li>14/08/10 14:32:27 INFO node.Application: Starting Sink k1<br></li><li>14/08/10 14:32:27 INFO node.Application: Starting Source r1<br></li><li>14/08/10 14:32:27 INFO source.AvroSource: Starting Avro source r1: { bindAddress: 0.0.0.0, port: 5555 }...<br></li><li>14/08/10 14:32:27 INFO instrumentation.MonitoredCounterGroup: Monitored counter group for type: SOURCE, name: r1: Successfully registered new MBean.<br></li><li>14/08/10 14:32:27 INFO instrumentation.MonitoredCounterGroup: Component type: SOURCE, name: r1 started<br></li><li>14/08/10 14:32:27 INFO source.AvroSource: Avro source r1 started.<br></li><li>14/08/10 14:32:36 INFO ipc.NettyServer: [id: 0x7c2f0aec, /192.168.1.50:38104 =&gt; /192.168.1.51:5555] OPEN<br></li><li>14/08/10 14:32:36 INFO ipc.NettyServer: [id: 0x7c2f0aec, /192.168.1.50:38104 =&gt; /192.168.1.51:5555] BOUND: /192.168.1.51:5555<br></li><li>14/08/10 14:32:36 INFO ipc.NettyServer: [id: 0x7c2f0aec, /192.168.1.50:38104 =&gt; /192.168.1.51:5555] CONNECTED: /192.168.1.50:38104<br></li><li>14/08/10 14:32:44 INFO ipc.NettyServer: [id: 0x3d36f553, /192.168.1.51:48599 =&gt; /192.168.1.51:5555] OPEN<br></li><li>14/08/10 14:32:44 INFO ipc.NettyServer: [id: 0x3d36f553, /192.168.1.51:48599 =&gt; /192.168.1.51:5555] BOUND: /192.168.1.51:5555<br></li><li>14/08/10 14:32:44 INFO ipc.NettyServer: [id: 0x3d36f553, /192.168.1.51:48599 =&gt; /192.168.1.51:5555] CONNECTED: /192.168.1.51:48599<br></li><li>14/08/10 14:34:33 INFO sink.LoggerSink: Event: { headers:{type=ali} body: 69 64 6F 61 6C 6C 5F 54 45 53 54 32             idoall_TEST2 }<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br><br><br>
　　　　可以看到，根据header中不同的条件分布到不同的channel上<br><br>
　　　　10)案例10：Flume Sink Processors<br>
　　　　failover的机器是一直发送给其中一个sink，当这个sink不可用的时候，自动发送到下一个sink。<br><br>
　　　　　　a)在m1创建Flume_Sink_Processors配置文件<br><br><div class="blockcode">
<div id="code_Gsf">
<ol><li>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/Flume_Sink_Processors.conf<br></li><li><br></li><li>a1.sources = r1<br></li><li>a1.sinks = k1 k2<br></li><li>a1.channels = c1 c2<br></li><li><br></li><li>#这个是配置failover的关键，需要有一个sink group<br></li><li>a1.sinkgroups = g1<br></li><li>a1.sinkgroups.g1.sinks = k1 k2<br></li><li>#处理的类型是failover<br></li><li>a1.sinkgroups.g1.processor.type = failover<br></li><li>#优先级，数字越大优先级越高，每个sink的优先级必须不相同<br></li><li>a1.sinkgroups.g1.processor.priority.k1 = 5<br></li><li>a1.sinkgroups.g1.processor.priority.k2 = 10<br></li><li>#设置为10秒，当然可以根据你的实际状况更改成更快或者很慢<br></li><li>a1.sinkgroups.g1.processor.maxpenalty = 10000<br></li><li><br></li><li># Describe/configure the source<br></li><li>a1.sources.r1.type = syslogtcp<br></li><li>a1.sources.r1.port = 5140<br></li><li>a1.sources.r1.channels = c1 c2<br></li><li>a1.sources.r1.selector.type = replicating<br></li><li><br></li><li><br></li><li># Describe the sink<br></li><li>a1.sinks.k1.type = avro<br></li><li>a1.sinks.k1.channel = c1<br></li><li>a1.sinks.k1.hostname = m1<br></li><li>a1.sinks.k1.port = 5555<br></li><li><br></li><li>a1.sinks.k2.type = avro<br></li><li>a1.sinks.k2.channel = c2<br></li><li>a1.sinks.k2.hostname = m2<br></li><li>a1.sinks.k2.port = 5555<br></li><li><br></li><li># Use a channel which buffers events in memory<br></li><li>a1.channels.c1.type = memory<br></li><li>a1.channels.c1.capacity = 1000<br></li><li>a1.channels.c1.transactionCapacity = 100<br></li><li><br></li><li>a1.channels.c2.type = memory<br></li><li>a1.channels.c2.capacity = 1000<br></li><li>a1.channels.c2.transactionCapacity = 100</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　b)在m1创建Flume_Sink_Processors_avro配置文件<br><div class="blockcode">
<div id="code_Hct">
<ol><li>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/Flume_Sink_Processors_avro.conf<br></li><li><br></li><li>a1.sources = r1<br></li><li>a1.sinks = k1<br></li><li>a1.channels = c1<br></li><li><br></li><li># Describe/configure the source<br></li><li>a1.sources.r1.type = avro<br></li><li>a1.sources.r1.channels = c1<br></li><li>a1.sources.r1.bind = 0.0.0.0<br></li><li>a1.sources.r1.port = 5555<br></li><li><br></li><li># Describe the sink<br></li><li>a1.sinks.k1.type = logger<br></li><li><br></li><li># Use a channel which buffers events in memory<br></li><li>a1.channels.c1.type = memory<br></li><li>a1.channels.c1.capacity = 1000<br></li><li>a1.channels.c1.transactionCapacity = 100<br></li><li><br></li><li># Bind the source and sink to the channel<br></li><li>a1.sources.r1.channels = c1<br></li><li>a1.sinks.k1.channel = c1</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　c)将2个配置文件复制到m2上一份<br><div class="blockcode">
<div id="code_yUX">
<ol><li>root@m1:/home/hadoop/flume-1.5.0-bin# scp -r /home/hadoop/flume-1.5.0-bin/conf/Flume_Sink_Processors.conf  root@m2:/home/hadoop/flume-1.5.0-bin/conf/Flume_Sink_Processors.conf<br></li><li>root@m1:/home/hadoop/flume-1.5.0-bin# scp -r /home/hadoop/flume-1.5.0-bin/conf/Flume_Sink_Processors_avro.conf root@m2:/home/hadoop/flume-1.5.0-bin/conf/Flume_Sink_Processors_avro.conf<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　d)打开4个窗口，在m1和m2上同时启动两个flume agent<br><div class="blockcode">
<div id="code_dr9">
<ol><li>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/Flume_Sink_Processors_avro.conf -n a1 -Dflume.root.logger=INFO,console<br></li><li>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/Flume_Sink_Processors.conf -n a1 -Dflume.root.logger=INFO,console<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　e)然后在m1或m2的任意一台机器上，测试产生log<br><div class="blockcode">
<div id="code_oAz">
<ol><li>root@m1:/home/hadoop# echo "idoall.org test1 failover" | nc localhost 5140</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　f)因为m2的优先级高，所以在m2的sink窗口，可以看到以下信息，而m1没有：<br><div class="blockcode">
<div id="code_Qv6">
<ol><li>14/08/10 15:02:46 INFO ipc.NettyServer: Connection to /192.168.1.51:48692 disconnected.<br></li><li>14/08/10 15:03:12 INFO ipc.NettyServer: [id: 0x09a14036, /192.168.1.51:48704 =&gt; /192.168.1.51:5555] OPEN<br></li><li>14/08/10 15:03:12 INFO ipc.NettyServer: [id: 0x09a14036, /192.168.1.51:48704 =&gt; /192.168.1.51:5555] BOUND: /192.168.1.51:5555<br></li><li>14/08/10 15:03:12 INFO ipc.NettyServer: [id: 0x09a14036, /192.168.1.51:48704 =&gt; /192.168.1.51:5555] CONNECTED: /192.168.1.51:48704<br></li><li>14/08/10 15:03:26 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 69 64 6F 61 6C 6C 2E 6F 72 67 20 74 65 73 74 31 idoall.org test1 }<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　g)这时我们停止掉m2机器上的sink(ctrl+c)，再次输出测试数据：<br><div class="blockcode">
<div id="code_a8u">
<ol><li>root@m1:/home/hadoop# echo "idoall.org test2 failover" | nc localhost 5140</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　h)可以在m1的sink窗口，看到读取到了刚才发送的两条测试数据：<br><div class="blockcode">
<div id="code_LNI">
<ol><li>14/08/10 15:02:46 INFO ipc.NettyServer: Connection to /192.168.1.51:47036 disconnected.<br></li><li>14/08/10 15:03:12 INFO ipc.NettyServer: [id: 0xbcf79851, /192.168.1.51:47048 =&gt; /192.168.1.50:5555] OPEN<br></li><li>14/08/10 15:03:12 INFO ipc.NettyServer: [id: 0xbcf79851, /192.168.1.51:47048 =&gt; /192.168.1.50:5555] BOUND: /192.168.1.50:5555<br></li><li>14/08/10 15:03:12 INFO ipc.NettyServer: [id: 0xbcf79851, /192.168.1.51:47048 =&gt; /192.168.1.50:5555] CONNECTED: /192.168.1.51:47048<br></li><li>14/08/10 15:07:56 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 69 64 6F 61 6C 6C 2E 6F 72 67 20 74 65 73 74 31 idoall.org test1 }<br></li><li>14/08/10 15:07:56 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 69 64 6F 61 6C 6C 2E 6F 72 67 20 74 65 73 74 32 idoall.org test2 }<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　i)我们再在m2的sink窗口中，启动sink：<br><div class="blockcode">
<div id="code_P7l">
<ol><li>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/Flume_Sink_Processors_avro.conf -n a1 -Dflume.root.logger=INFO,console<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　j)输入两批测试数据：<br><div class="blockcode">
<div id="code_Q0i">
<ol><li>root@m1:/home/hadoop# echo "idoall.org test3 failover" | nc localhost 5140 &amp;&amp; echo "idoall.org test4 failover" | nc localhost 5140<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　k)在m2的sink窗口，我们可以看到以下信息，因为优先级的关系，log消息会再次落到m2上：<br><div class="blockcode">
<div id="code_eFn">
<ol><li>14/08/10 15:09:47 INFO node.Application: Starting Sink k1<br></li><li>14/08/10 15:09:47 INFO node.Application: Starting Source r1<br></li><li>14/08/10 15:09:47 INFO source.AvroSource: Starting Avro source r1: { bindAddress: 0.0.0.0, port: 5555 }...<br></li><li>14/08/10 15:09:47 INFO instrumentation.MonitoredCounterGroup: Monitored counter group for type: SOURCE, name: r1: Successfully registered new MBean.<br></li><li>14/08/10 15:09:47 INFO instrumentation.MonitoredCounterGroup: Component type: SOURCE, name: r1 started<br></li><li>14/08/10 15:09:47 INFO source.AvroSource: Avro source r1 started.<br></li><li>14/08/10 15:09:54 INFO ipc.NettyServer: [id: 0x96615732, /192.168.1.51:48741 =&gt; /192.168.1.51:5555] OPEN<br></li><li>14/08/10 15:09:54 INFO ipc.NettyServer: [id: 0x96615732, /192.168.1.51:48741 =&gt; /192.168.1.51:5555] BOUND: /192.168.1.51:5555<br></li><li>14/08/10 15:09:54 INFO ipc.NettyServer: [id: 0x96615732, /192.168.1.51:48741 =&gt; /192.168.1.51:5555] CONNECTED: /192.168.1.51:48741<br></li><li>14/08/10 15:09:57 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 69 64 6F 61 6C 6C 2E 6F 72 67 20 74 65 73 74 32 idoall.org test2 }<br></li><li>14/08/10 15:10:43 INFO ipc.NettyServer: [id: 0x12621f9a, /192.168.1.50:38166 =&gt; /192.168.1.51:5555] OPEN<br></li><li>14/08/10 15:10:43 INFO ipc.NettyServer: [id: 0x12621f9a, /192.168.1.50:38166 =&gt; /192.168.1.51:5555] BOUND: /192.168.1.51:5555<br></li><li>14/08/10 15:10:43 INFO ipc.NettyServer: [id: 0x12621f9a, /192.168.1.50:38166 =&gt; /192.168.1.51:5555] CONNECTED: /192.168.1.50:38166<br></li><li>14/08/10 15:10:43 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 69 64 6F 61 6C 6C 2E 6F 72 67 20 74 65 73 74 33 idoall.org test3 }<br></li><li>14/08/10 15:10:43 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 69 64 6F 61 6C 6C 2E 6F 72 67 20 74 65 73 74 34 idoall.org test4 }<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br><br><br>
　　　　11)案例11：Load balancing Sink Processor<br>
　　　　load balance type和failover不同的地方是，load balance有两个配置，一个是轮询，一个是随机。两种情况下如果被选择的sink不可用，就会自动尝试发送到下一个可用的sink上面。<br><br>
　　　　　　a)在m1创建Load_balancing_Sink_Processors配置文件<br><br><div class="blockcode">
<div id="code_vLg">
<ol><li>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/Load_balancing_Sink_Processors.conf<br></li><li><br></li><li>a1.sources = r1<br></li><li>a1.sinks = k1 k2<br></li><li>a1.channels = c1<br></li><li><br></li><li>#这个是配置Load balancing的关键，需要有一个sink group<br></li><li>a1.sinkgroups = g1<br></li><li>a1.sinkgroups.g1.sinks = k1 k2<br></li><li>a1.sinkgroups.g1.processor.type = load_balance<br></li><li>a1.sinkgroups.g1.processor.backoff = true<br></li><li>a1.sinkgroups.g1.processor.selector = round_robin<br></li><li><br></li><li># Describe/configure the source<br></li><li>a1.sources.r1.type = syslogtcp<br></li><li>a1.sources.r1.port = 5140<br></li><li>a1.sources.r1.channels = c1<br></li><li><br></li><li><br></li><li># Describe the sink<br></li><li>a1.sinks.k1.type = avro<br></li><li>a1.sinks.k1.channel = c1<br></li><li>a1.sinks.k1.hostname = m1<br></li><li>a1.sinks.k1.port = 5555<br></li><li><br></li><li>a1.sinks.k2.type = avro<br></li><li>a1.sinks.k2.channel = c1<br></li><li>a1.sinks.k2.hostname = m2<br></li><li>a1.sinks.k2.port = 5555<br></li><li><br></li><li># Use a channel which buffers events in memory<br></li><li>a1.channels.c1.type = memory<br></li><li>a1.channels.c1.capacity = 1000<br></li><li>a1.channels.c1.transactionCapacity = 100</li></ol></div>
<em>复制代码</em></div>
<br><br><br>
　　　　　　b)在m1创建Load_balancing_Sink_Processors_avro配置文件<br><div class="blockcode">
<div id="code_Bv2">
<ol><li>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/Load_balancing_Sink_Processors_avro.conf<br></li><li><br></li><li>a1.sources = r1<br></li><li>a1.sinks = k1<br></li><li>a1.channels = c1<br></li><li><br></li><li># Describe/configure the source<br></li><li>a1.sources.r1.type = avro<br></li><li>a1.sources.r1.channels = c1<br></li><li>a1.sources.r1.bind = 0.0.0.0<br></li><li>a1.sources.r1.port = 5555<br></li><li><br></li><li># Describe the sink<br></li><li>a1.sinks.k1.type = logger<br></li><li><br></li><li># Use a channel which buffers events in memory<br></li><li>a1.channels.c1.type = memory<br></li><li>a1.channels.c1.capacity = 1000<br></li><li>a1.channels.c1.transactionCapacity = 100<br></li><li><br></li><li># Bind the source and sink to the channel<br></li><li>a1.sources.r1.channels = c1<br></li><li>a1.sinks.k1.channel = c1</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　c)将2个配置文件复制到m2上一份<br><div class="blockcode">
<div id="code_b5M">
<ol><li>root@m1:/home/hadoop/flume-1.5.0-bin# scp -r /home/hadoop/flume-1.5.0-bin/conf/Load_balancing_Sink_Processors.conf  root@m2:/home/hadoop/flume-1.5.0-bin/conf/Load_balancing_Sink_Processors.conf<br></li><li>root@m1:/home/hadoop/flume-1.5.0-bin# scp -r /home/hadoop/flume-1.5.0-bin/conf/Load_balancing_Sink_Processors_avro.conf root@m2:/home/hadoop/flume-1.5.0-bin/conf/Load_balancing_Sink_Processors_avro.conf<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　d)打开4个窗口，在m1和m2上同时启动两个flume agent<br><br><div class="blockcode">
<div id="code_ez2">
<ol><li>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/Load_balancing_Sink_Processors_avro.conf -n a1 -Dflume.root.logger=INFO,console<br></li><li>root@m1:/home/hadoop# /home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/Load_balancing_Sink_Processors.conf -n a1 -Dflume.root.logger=INFO,console<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　e)然后在m1或m2的任意一台机器上，测试产生log，一行一行输入，输入太快，容易落到一台机器上<br><div class="blockcode">
<div id="code_ynr">
<ol><li>root@m1:/home/hadoop# echo "idoall.org test1" | nc localhost 5140<br></li><li>root@m1:/home/hadoop# echo "idoall.org test2" | nc localhost 5140<br></li><li>root@m1:/home/hadoop# echo "idoall.org test3" | nc localhost 5140<br></li><li>root@m1:/home/hadoop# echo "idoall.org test4" | nc localhost 5140</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　f)在m1的sink窗口，可以看到以下信息：<br><div class="blockcode">
<div id="code_Ts8">
<ol><li>14/08/10 15:35:29 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 69 64 6F 61 6C 6C 2E 6F 72 67 20 74 65 73 74 32 idoall.org test2 }<br></li><li>14/08/10 15:35:33 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 69 64 6F 61 6C 6C 2E 6F 72 67 20 74 65 73 74 34 idoall.org test4 }<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　g)在m2的sink窗口，可以看到以下信息：<br><div class="blockcode">
<div id="code_P4J">
<ol><li>14/08/10 15:35:27 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 69 64 6F 61 6C 6C 2E 6F 72 67 20 74 65 73 74 31 idoall.org test1 }<br></li><li>14/08/10 15:35:29 INFO sink.LoggerSink: Event: { headers:{Severity=0, flume.syslog.status=Invalid, Facility=0} body: 69 64 6F 61 6C 6C 2E 6F 72 67 20 74 65 73 74 33 idoall.org test3 }<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br><br><br>
　　　　说明轮询模式起到了作用。<br><br>
　　　　12)案例12：Hbase sink<br><br><br>
　　　　　　a)在测试之前，请先参考《<a href="http://idoall.org/home.php?mod=space&amp;uid=1&amp;do=blog&amp;id=542" rel="nofollow">ubuntu12.04+hadoop2.2.0+zookeeper3.4.5+hbase0.96.2+hive0.13.1分布式环境部署</a>》将hbase启动<br><br>
　　　　　　b)然后将以下文件复制到flume中：<br><br><div class="blockcode">
<div id="code_TBt">
<ol><li>cp /home/hadoop/hbase-0.96.2-hadoop2/lib/protobuf-java-2.5.0.jar /home/hadoop/flume-1.5.0-bin/lib<br></li><li>cp /home/hadoop/hbase-0.96.2-hadoop2/lib/hbase-client-0.96.2-hadoop2.jar /home/hadoop/flume-1.5.0-bin/lib<br></li><li>cp /home/hadoop/hbase-0.96.2-hadoop2/lib/hbase-common-0.96.2-hadoop2.jar /home/hadoop/flume-1.5.0-bin/lib<br></li><li>cp /home/hadoop/hbase-0.96.2-hadoop2/lib/hbase-protocol-0.96.2-hadoop2.jar /home/hadoop/flume-1.5.0-bin/lib<br></li><li>cp /home/hadoop/hbase-0.96.2-hadoop2/lib/hbase-server-0.96.2-hadoop2.jar /home/hadoop/flume-1.5.0-bin/lib<br></li><li>cp /home/hadoop/hbase-0.96.2-hadoop2/lib/hbase-hadoop2-compat-0.96.2-hadoop2.jar /home/hadoop/flume-1.5.0-bin/lib<br></li><li>cp /home/hadoop/hbase-0.96.2-hadoop2/lib/hbase-hadoop-compat-0.96.2-hadoop2.jar /home/hadoop/flume-1.5.0-bin/lib@@@<br></li><li>cp /home/hadoop/hbase-0.96.2-hadoop2/lib/htrace-core-2.04.jar /home/hadoop/flume-1.5.0-bin/lib<br></li><li><br></li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　c)确保test_idoall_org表在hbase中已经存在<br><br>
　　　　　　d)在m1创建hbase_simple配置文件<br><div class="blockcode">
<div id="code_p9W">
<ol><li>root@m1:/home/hadoop# vi /home/hadoop/flume-1.5.0-bin/conf/hbase_simple.conf<br></li><li><br></li><li>a1.sources = r1<br></li><li>a1.sinks = k1<br></li><li>a1.channels = c1<br></li><li><br></li><li># Describe/configure the source<br></li><li>a1.sources.r1.type = syslogtcp<br></li><li>a1.sources.r1.port = 5140<br></li><li>a1.sources.r1.host = localhost<br></li><li>a1.sources.r1.channels = c1<br></li><li><br></li><li># Describe the sink<br></li><li>a1.sinks.k1.type = logger<br></li><li>a1.sinks.k1.type = hbase<br></li><li>a1.sinks.k1.table = test_idoall_org<br></li><li>a1.sinks.k1.columnFamily = name<br></li><li>a1.sinks.k1.column = idoall<br></li><li>a1.sinks.k1.serializer =  org.apache.flume.sink.hbase.RegexHbaseEventSerializer<br></li><li>a1.sinks.k1.channel = memoryChannel<br></li><li><br></li><li># Use a channel which buffers events in memory<br></li><li>a1.channels.c1.type = memory<br></li><li>a1.channels.c1.capacity = 1000<br></li><li>a1.channels.c1.transactionCapacity = 100<br></li><li><br></li><li># Bind the source and sink to the channel<br></li><li>a1.sources.r1.channels = c1<br></li><li>a1.sinks.k1.channel = c1</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　e)启动flume agent<br><div class="blockcode">
<div id="code_KTT">
<ol><li>/home/hadoop/flume-1.5.0-bin/bin/flume-ng agent -c . -f /home/hadoop/flume-1.5.0-bin/conf/hbase_simple.conf -n a1 -Dflume.root.logger=INFO,console</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　f)测试产生syslog<br><div class="blockcode">
<div id="code_btc">
<ol><li>root@m1:/home/hadoop# echo "hello idoall.org from flume" | nc localhost 5140</li></ol></div>
<em>复制代码</em></div>
<br>
　　　　　　g)这时登录到hbase中，可以发现新数据已经插入<br><div class="blockcode">
<div id="code_r0n">
<ol><li>root@m1:/home/hadoop# /home/hadoop/hbase-0.96.2-hadoop2/bin/hbase shell<br></li><li>2014-08-10 16:09:48,984 INFO  [main] Configuration.deprecation: hadoop.native.lib is deprecated. Instead, use io.native.lib.available<br></li><li>HBase Shell; enter 'help&lt;RETURN&gt;' for list of supported commands.<br></li><li>Type "exit&lt;RETURN&gt;" to leave the HBase Shell<br></li><li>Version 0.96.2-hadoop2, r1581096, Mon Mar 24 16:03:18 PDT 2014<br></li><li><br></li><li>hbase(main):001:0&gt; list<br></li><li>TABLE                                                                                                                                                                                                                  <br></li><li>SLF4J: Class path contains multiple SLF4J bindings.<br></li><li>SLF4J: Found binding in [jar:file:/home/hadoop/hbase-0.96.2-hadoop2/lib/slf4j-log4j12-1.6.4.jar!/org/slf4j/impl/StaticLoggerBinder.class]<br></li><li>SLF4J: Found binding in [jar:file:/home/hadoop/hadoop-2.2.0/share/hadoop/common/lib/slf4j-log4j12-1.7.5.jar!/org/slf4j/impl/StaticLoggerBinder.class]<br></li><li>SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.<br></li><li>hbase2hive_idoall                                                                                                                                                                                                      <br></li><li>hive2hbase_idoall                                                                                                                                                                                                      <br></li><li>test_idoall_org                                                                                                                                                                                                        <br></li><li>3 row(s) in 2.6880 seconds<br></li><li><br></li><li>=&gt; ["hbase2hive_idoall", "hive2hbase_idoall", "test_idoall_org"]<br></li><li>hbase(main):002:0&gt; scan "test_idoall_org"<br></li><li>ROW                                                    COLUMN+CELL                                                                                                                                                     <br></li><li>10086                                                 column=name:idoall, timestamp=1406424831473, value=idoallvalue                                                                                                  <br></li><li>1 row(s) in 0.0550 seconds<br></li><li><br></li><li>hbase(main):003:0&gt; scan "test_idoall_org"<br></li><li>ROW                                                    COLUMN+CELL                                                                                                                                                     <br></li><li>10086                                                 column=name:idoall, timestamp=1406424831473, value=idoallvalue                                                                                                  <br></li><li>1407658495588-XbQCOZrKK8-0                            column=name:payload, timestamp=1407658498203, value=hello idoall.org from flume                                                                                 <br></li><li>2 row(s) in 0.0200 seconds<br></li><li><br></li><li>hbase(main):004:0&gt; quit</li></ol></div>
<em>复制代码</em></div>
<br>
经过这么多flume的例子测试，如果你全部做完后，会发现flume的功能真的很强大，可以进行各种搭配来完成你想要的工作，俗话说师傅领进门，修行在个人，如何能够结合你的产品业务，将flume更好的应用起来，快去动手实践吧。
            </div>
                </div>