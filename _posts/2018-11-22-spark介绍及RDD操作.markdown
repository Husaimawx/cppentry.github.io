---
layout:     post
title:      spark介绍及RDD操作
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								<div class="article-copyright">
					版权声明：本文为博主原创文章，未经博主允许不得转载。					https://blog.csdn.net/Gscsd_T/article/details/79822166				</div>
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                <p><strong><span style="color:#FF0000;">Spark</span></strong></p><p>   Spark的主要部件</p><p>        <span style="color:#FF0000;">Spark core</span>:包含spark的主要功能。功能跟RDD有关的API都出自spark core</p><p>        <span style="color:#FF0000;">Spark SQL</span>：spark 中用于结构化数据处理的软件包。用户可以在spark环境下用SQL语言处理数据</p><p>        <span style="color:#FF0000;">Spark streaming</span>：spark 中用于处理流数据的部件</p><p>       <span style="color:#FF0000;"> MLlib </span> ：spark中用来进行机器学习和数据建模的软件包</p><p>        <span style="color:#FF0000;">GraphX</span> ：spark中用来进行图形计算（如社交媒体关系）的库函数</p><p>        <span style="color:#FF0000;">ClusterManagers</span> ：spark中用来管理集群或者节点的软件平台，这包括hadoop Yarn，Apache Mesos,和standalone scheduler（spark自带的用于单机系统）</p><p></p><p>Spark core 应用程序包括以下两部分</p><p>     Driver</p><p>1.     初始化sparkContext（spark的入口）</p><p>2.     Executor部分运行完毕后将SparkContext关闭</p><p>     Executor</p><p>1.     集合数据集</p><p>2.     文件数据集</p><p><span style="color:#FF0000;">Spark</span><span style="color:#FF0000;">运行模式</span></p><p>       Standalone模式（spark自带的模式）</p><p>      1.     <span style="color:#FF0000;">Spark-shell</span>  交互式工具提交spark的job时，Driver在Master节点上运行</p><p>      2.     <span style="color:#FF0000;">Spark-submit</span> 工具提交job时Driver运行在本地client端上</p><p>  Yarn-client模式</p><p>  Yarn-cluster模式  当用户向YARN中提交一个应用程序后，YARN将分</p><p>       两个阶段运行该应用程序</p><p>  Mesos模式 另一种开源的Cluster Manager</p><p><span style="color:#FF0000;">Spark </span><span style="color:#FF0000;">调度模式</span></p><p>     Yarn 模式</p><p>     NodeManger</p><p><strong><span style="color:#FF0000;">RDD</span><span style="color:#FF0000;">类型</span></strong></p><p>     1.     <strong><span style="color:#FF0000;">并行集合</span></strong>（Paralleliced Collections）</p><p>             来自于分布式化的数据对象比如python中的list对象，比如用户自己输入的数据</p><p><strong><span style="color:#FF0000;">     2.      </span><span style="color:#FF0000;">文件系统数据集</span></strong></p><p>             比如hadoop datasets或文本文件，比如通过SparkContext.textFlie()读取的数据</p><p></p><p><strong><span style="color:#FF0000;">RDD</span><span style="color:#FF0000;">计算方式</span></strong></p><p>    1.     <strong><span style="color:#FF0000;">变换</span></strong>（Transformation）</p><p>      如：map、filter的返回值仍然是一个RDD，Transformation操作是Lazy的，也就是说变换只是一些指令集而并不会去马上执行，需要等到有Actions操作的时候才会去真正计算给出结果。Lazy Evalustion</p><p>   2.     <strong><span style="color:#FF0000;">操作</span></strong>（Actions）</p><p>     如count，collect，Action操作会返回结果或把RDD数据输出到各类系统中。Action触发spark启动并找到最优的计算途径。返回值是非并行化的数据集合如python中的list</p><p> </p><p>编写处理RDD的代码有两类</p><p>        1.     <span style="color:#FF0000;">Driver </span>只有一个（普通的python代码）</p><p>        2.     <span style="color:#FF0000;">Worker</span>（两类算子）</p><p>              a)       变换（transformation）懒执行</p><p>              b)       行为（Action）立即执行</p><p> </p><p><span style="color:#FF0000;">属于变换</span>：map flatMap groupByKey reduceByKey…</p><p><span style="color:#FF0000;">属于行为</span>：count take collect countByValue reduce….</p><p>RDD的所有操作方法</p><p></p><p><strong><span style="color:#FF0000;">RDD</span><span style="color:#FF0000;">元素变换</span>                 <span style="color:#FF0000;">                     RDD</span><span style="color:#FF0000;">元素操作</span></strong></p><p>   map(func)                                               count()</p><p>   flatMap(func)                                          reduce()</p><p>   filter(func)                                               countByValue()</p><p>      连接变换                                               aggregate((0,0),seqOp,combOp)</p><p>         union()</p><p>         intersection()</p><p>         subtract()                   </p><p>         cartesian()</p><p> </p><p><strong><span style="color:#FF0000;">RDD</span><span style="color:#FF0000;">元素取值操作</span>              <span style="color:#FF0000;">                     RDD Key-Value</span><span style="color:#FF0000;">变换</span></strong></p><p>   take(n)                                                         zip(seq1,seq2)</p><p>   top(num)                                                      reduceByKey(func)</p><p>   first()                                                            groupByKey()</p><p>   collect()                                                        mapValue(func)</p><p>   foreach(func)                                                sortByKey()</p><p>   taleSample()                                                 combineByKey(4个参数)</p><p>                                                                          连接变换</p><p><strong><span style="color:#FF0000;">RDD Key-Value </span><span style="color:#FF0000;">操作</span></strong>                                                 join() 内连接</p><p>   countByKey()                                                          rightOuterjoin()右链接</p><p>   collectAsMap()                                                        leftOuterjoin()左连接</p><p>   lookup(key)                                                             cogroup()全连接</p><p>   countByKey()                                                           subtractByKey()减连接</p><p><br></p><p>详细解释RDD所有操作</p><p><strong><span style="color:#FF0000;">RDD</span><span style="color:#FF0000;">元素变换</span></strong></p><p><span style="color:#FF0000;">         <strong>map(func)</strong></span>参数是函数,函数应用于RDD每一个元素，返回值是新的RDD</p><p>                       <img src="https://img-blog.csdn.net/20180404210802321?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dzY3NkX1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p></p><p align="left"> </p><p align="left"> <span style="color:#FF0000;">         <strong>flatMap(func)</strong></span> 参数是函数，函数应用于RDD每一个元素，将元素数据进行<span style="color:#FF0000;">拆分</span>，变成<span style="color:#FF0000;">迭代器</span>，返回值是新的RDD</p>                 <img src="https://img-blog.csdn.net/2018040421082621?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dzY3NkX1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br><p><br></p><p align="left">                                连接变换</p><p align="left">                                <strong><span style="color:#FF0000;">  union()</span></strong>        两个RDD的并集（联合）</p><p align="left"><strong><span style="color:#FF0000;">                                  intersection()</span></strong>  交集</p><p align="left">                                 <strong><span style="color:#FF0000;">subtract() </span></strong>     差集</p><p align="left"><strong><span style="color:#FF0000;">                                 cartesian() </span></strong>    笛卡尔</p><p>                          <img src="https://img-blog.csdn.net/20180404210904927?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dzY3NkX1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p></p><p align="left"><strong><span style="color:#FF0000;">RDD</span><span style="color:#FF0000;">元素操作</span></strong></p><p align="left">  <strong><span style="color:#FF0000;">     count()</span></strong> 返回RDD里元素数目</p><p>                <img src="https://img-blog.csdn.net/20180404210926212?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dzY3NkX1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p></p><p align="left">      <strong><span style="color:#FF0000;">reduce(func)</span></strong>并行汇总所有RDD元素</p><p align="left">           lambda中接收两个参数</p><p>                <img src="https://img-blog.csdn.net/20180404210943699?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dzY3NkX1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p></p><p>   reduce()参数是一个函数，这个函数有两个参数（首先会分区（默认分区数量与虚拟机的核心数有关，我的是2），然后每个分区得出结果最后汇总），两个参数分别是每次分区后两个分区的结果</p><p>执行过程：</p><p>        分区：[(1,2),(3,4,5)]</p><p>        第一次结果：[3,12]</p><p>        最后结果：15</p><p align="left"> 如果是减法的话那分区的分量就显得更明显了，分区的个数不同，那么每次的值都会不一样,后面可以parallelize([1,2,3,4,5]，3)这样写说明分成了三个分区，<span style="color:#FF0000;">这里有个问题，如果我们只有2</span>个分区，但我们给了三个，计算的时候只会先计算前面2个，算好后再来和第三个一起算。</p><strong><span style="color:#FF0000;">         countByValue()</span></strong> 各RDD元素在RDD中出现次数<br><p>                      <img src="https://img-blog.csdn.net/20180404211028246?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dzY3NkX1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p></p><p align="left"><strong><span style="color:#FF0000;">        aggregate((0,0),seqOp,combOp)</span></strong> 将前面的数一直累加</p><p>                           <img src="https://img-blog.csdn.net/20180404211047655?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dzY3NkX1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p></p><p align="left">         简单理解（spark操作都是分布式计算，所以都会分区，这里不考虑分区去理解）：</p><p align="left">             首先理解第一个lambda</p><p align="left">              x 程序开始时指代前面的(0,0)初始值，之后是每一次执行后的结果</p><p align="left">              y 指代RDD里的每一个元素</p><p align="left">              看看执行过程：</p><p align="left">                       第一次：0（zoroValue元组的第一个值）+ 1（RDD的第一个元素的值）</p><p align="left">                                    0（zoroValue元组的第二个值）+ 1 （固定值，目前我们可以用来表示执行次数）</p><p align="left">                                    结果：(1,1) --这个时候 x 的值将是这个</p><p align="left">                       第二次：1 + 2（RDD的第二个元素的值）,1+ 1</p><p align="left">                                    结果：(3,2)</p><p align="left">                       第三次：3+ 3（RDD的第三个元素的值）,2+ 1</p><p align="left">                                    结果：(6,3)</p><p align="left">                       第四次：6 + 4（RDD的第四个元素的值）,3+1</p><p align="left">                                    结果：(10,4)</p><p align="left">                       第二个lambda是spark的分区汇总操作</p><p align="left">                                  x 指代第一个分区的结果</p><p align="left">                                  y 指代第二个分区的结果</p><p align="left">      简单描述一下分区：第一个lambda的执行过程并不是上面那样一个区执行的，而是分成两个区去分别执行上述操作，然后通过第二个lambda汇总</p><p align="left"></p><p align="left"><strong><span style="color:#FF0000;">RDD</span><span style="color:#FF0000;">元素取值操作</span></strong></p><p align="left"><strong><span style="color:#FF0000;">          take(n)</span></strong> 从RDD返回n个元素</p><p align="left"><strong><span style="color:#FF0000;">          top(num)</span></strong>先从大到小排序，然后从RDD中返回前面的num个数的元素</p><p align="left"><strong><span style="color:#FF0000;">          first()</span></strong> 从RDD中返回第一个元素</p><p align="left"><strong><span style="color:#FF0000;">          collect()</span></strong> 从RDD中返回所有的元素（慎用，练习可以用，工作中千万不能用，因为会收集所有的信息，数据量大的会卡死电脑）</p><p align="left">                            <img src="https://img-blog.csdn.net/20180404211335820?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dzY3NkX1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p><p align="left"></p><p align="left"><strong><span style="color:#FF0000;">           foreach(func)</span></strong></p><p align="left"><strong><span style="color:#FF0000;">           taskSample(cithReplacement,num,[seed])</span></strong></p><p align="left"><strong><span style="color:#FF0000;"><br></span></strong></p><p align="left"><strong><span style="color:#FF0000;">RDD KEY-VALUE</span><span style="color:#FF0000;">变换</span></strong></p><p align="left"><strong><span style="color:#FF0000;">        zip(seq1,seq2)</span></strong> 建立KEY-VALUE RDD，在RDD每个配对元素中，第一个被认定为键，第二个认定为值</p><p>                   <img src="https://img-blog.csdn.net/2018040421135966?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dzY3NkX1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p></p><p align="left"><strong><span style="color:#FF0000;">         reduceByKey(func)</span></strong> 在每一键组内进行汇总变换</p>                     <img src="https://img-blog.csdn.net/20180404211413478?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dzY3NkX1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br><p align="left"></p><p align="left"><strong><span style="color:#FF0000;">         groupByKey() </span></strong>将值放到每一相同键组内,值是一个迭代器</p>                     <img src="https://img-blog.csdn.net/20180404211427616?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dzY3NkX1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br><p align="left"><strong><span style="color:#FF0000;">         mapValues(func)</span></strong> 将每一对RDD键值进行函数func值变换而不改变键</p>                    <img src="https://img-blog.csdn.net/20180404211438898?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dzY3NkX1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br><p align="left"> </p><p align="left"><strong><span style="color:#FF0000;">         sortByKey()</span></strong> 得到以键排序的RDD</p><p>                    <img src="https://img-blog.csdn.net/20180404211451740?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dzY3NkX1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p><br></p><p></p><p align="left"><strong><span style="color:#FF0000;">          combineByKey</span></strong>(createCombiner,mergeValue,mergeCombiners,partitioner)</p><p>                          <img src="https://img-blog.csdn.net/20180404211510238?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dzY3NkX1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p></p><p align="left"><strong><span style="color:#FF0000;">             flatMapValues(func)</span></strong> 用函数产生迭代器并用于RDD每一个键值组对中并产生新的键值对</p><p align="left">                 <img src="https://img-blog.csdn.net/20180404211538656?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dzY3NkX1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p><p align="left"></p><p align="left"><strong><span style="color:#FF0000;">                               </span></strong>连接变换</p><p align="left">                                       <strong><span style="color:#FF0000;">join</span></strong>           内连接</p><p align="left">                                     <strong><span style="color:#FF0000;"> rightOuterJoin</span></strong> 右连接  </p><p align="left">                                      <strong><span style="color:#FF0000;">leftOuterJoin </span></strong> 左连接</p><p align="left">                                      <strong><span style="color:#FF0000;">cogroup </span></strong>       全连接</p><p align="left">                                     <strong><span style="color:#FF0000;"> subtractByKey</span></strong>  减连接</p><p><br></p><p></p><p align="left"><strong><span style="color:#FF0000;">RDD KEY-VALUE</span><span style="color:#FF0000;">操作</span></strong></p><p align="left">         <strong><span style="color:#FF0000;">countByKey()</span></strong> 返回每一键组内的记录数，是个字典</p>                     <img src="https://img-blog.csdn.net/20180404211559439?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dzY3NkX1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br><p>        <strong><span style="color:#FF0000;">collectAsMap()</span></strong> 返回一MAP形式的串行化结果</p><p>                    <img src="https://img-blog.csdn.net/2018040421161653?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dzY3NkX1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p><p>          <strong><span style="color:#FF0000;">lookup(key)</span></strong> 返回某键值下的所有值<br></p><p>                   <img src="https://img-blog.csdn.net/20180404211630601?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dzY3NkX1Q=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br></p><p><br></p>            </div>
                </div>