---
layout:     post
title:      spark（5）-spark内核架构（course13）
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								<div class="article-copyright">
					版权声明：本文为博主原创文章，未经博主允许不得转载。					https://blog.csdn.net/answer100answer/article/details/78740009				</div>
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                
<h1></h1>
<h1 style="font-size:30px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-weight:500;line-height:1.1;color:rgb(49,126,172);">
</h1>
<h1 style="font-weight:500;line-height:1.1;"><span style="font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;color:#454545;"><span style="font-size:12px;">参考：http://blog.csdn.net/slq1023/article/details/50816669</span></span></h1>
<h1 style="font-size:30px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-weight:500;line-height:1.1;color:rgb(49,126,172);">
1. Spark内核架构</h1>
<h2 style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-weight:500;line-height:1.1;color:rgb(49,126,172);font-size:24px;">
1.1 spark runtime 流程示意图</h2>
<div><img src="https://img-blog.csdn.net/20171207131419912?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYW5zd2VyMTAwYW5zd2Vy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br></div>
<div>
<h2 style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-weight:500;line-height:1.1;color:rgb(49,126,172);font-size:24px;">
1.2 driver、SparkContextspark、executor等概念</h2>
<div>
<div>
<div style="font-size:16px;"><span style="line-height:1.8;"><span style="font-size:16px;"><span style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;color:#555555;">        </span></span><span style="font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);"></span></span><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">Executor是运行在Worker节点上的为当前应用程序而开启的一个进程里面的处理对象，这个对象负责了Task的运行，通过线程池中的线程并发执行和线程复用的方式，线程池中的每一个线程可以运行一个任务，任务完成后回收到线程池中进行线程复用。</span><span style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;color:#555555;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"></span></span></span></span></span></span></span></span></div>
<div style="font-size:16px;"><span style="line-height:1.8;"><span style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;color:#555555;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><br></span></span></span></span></span></span></span></span></div>
<div style="font-size:16px;">
<pre style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;line-height:1.42857;color:rgb(51,51,51);background-color:rgb(245,245,245);border:1px solid rgb(204,204,204);">application = driver + executor</pre>
<div><br></div>
</div>
<div style="font-size:16px;"><span style="line-height:1.8;"><span style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;color:#555555;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"> 
       <strong>SparkContext</strong>里有高层调度器、低层调度器、SchedulerBackend。<span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><em>高层调度器</em>就是把整个作业划分成几个阶段，<em>底层调度器</em>是每个阶段里的任务该如何处理，<span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">SchedulerBackend是管理整个集群中为当前程序分配的计算资源（Executor）。</span></span></span></span></span></span></span></div>
<div style="font-size:16px;"><span style="line-height:1.8;"><span style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;color:#555555;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"> 
       SparkContext在创建这些对象的同时会向<strong>Master</strong>注册当前程序，注册OK后会分配资源，根据Action触发的JOB，JOB里有RDD，从后往前推，如果有宽依赖的话，就划分成不同的Stage（<span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">一个Stage内部都是计算轮回完全一样，只是计算的数据不同而已</span>）。stage划分完成后提交给底层调度器TaskScheduler。<span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">TaskScheduler拿到任务的集合，就会根据数据的本地性把任务发到<strong>Executor</strong>执行。</span></span><br></span></span></span></span></span></span></span></div>
<div style="font-size:16px;"><br></div>
<div style="font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">        Executor在出问题时会向Driver汇报。运行完后SparkContext会关闭。当然创建的对象也都会关闭。</span></div>
<div style="font-size:16px;"><br></div>
<div style="font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">        </span><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;"><strong>Driver</strong></span><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;">是驱动</span><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;"><strong>Executor</strong></span><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;">工作的，Executor是具体处理数据分片的，内部是线程池并发地处理数据分片。</span><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;">应用程序是Driver和</span></div>
<div style="font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;line-height:1.8;">Executors的模式，每个应用程序都有Executor代码。</span></div>
<div style="font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;line-height:1.8;"><u><em>Executor部分代码</em></u>：<span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">main方法中new
 SparkConf 以及一些操作方法</span></span><br></span></div>
<div style="font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;line-height:1.8;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><em><u>driver部分的代码</u></em>：</span><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">SparkConf进行配置然后创建SparkContext，<span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">SparkConf+SparkContext，如下：</span></span><br></span></span></span></div>
<div style="font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;line-height:1.8;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><br></span></span></span></span></span></div>
<div><span><span style="line-height:1.8;"><span></span></span></span>
<pre style="line-height:1.42857;background-color:rgb(245,245,245);border:1px solid rgb(204,204,204);"><span style="color:rgb(51,51,51);font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;"><strong>driver部分代码：Sparkconf + SparkContext</strong>
val conf =new SparkConf()
conf.setAppName("...")
conf.setMaster("...")

val sc = new SparkContext(conf)</span></pre>
<span style="color:rgb(69,69,69);line-height:1.8;font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">       <strong>SparkContext</strong>创建的过程中做了很多内容，包括DAG Scheduler（<span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><em>一个应用程序默认只有一个DAG
 Scheduler</em></span>）、TaskScheduler、SchedulerBackend、SparkEnv<strong>。</strong></span></div>
<div><span><span style="line-height:1.8;"><span><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"> 
       textFile、flatMap、map、reduceByKey：这些代码都是Transformation级别的，都会产生RDD，既是RDD操作又会产生RDD，这些代码就是具体的业务实现，就是Executor中具体执行的代码。最后都会被Action触发执行，都是在Worker中的Executor中处理的。</span></span></span></span></span></div>
<div><span><span style="line-height:1.8;"><span><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><br></span></span></span></span></span></div>
</div>
<strong></strong>
<pre style="font-family:Menlo, Monaco, Consolas, 'Courier New', monospace;font-size:13px;line-height:1.42857;color:rgb(51,51,51);background-color:rgb(245,245,245);border:1px solid rgb(204,204,204);">注：driver是以sparkContext为核心的，可以理解为driver就是sparkContext</pre>
<h1 style="font-size:30px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-weight:500;line-height:1.1;color:rgb(49,126,172);">
</h1>
<h2 style="font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;font-weight:500;line-height:1.1;color:rgb(49,126,172);font-size:24px;">
1.3 spark cluster 流程示意图</h2>
<img src="https://img-blog.csdn.net/20171207144230761?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYW5zd2VyMTAwYW5zd2Vy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><span style="line-height:1.8;color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">        Executor是运行在Worker节点上的为当前应用程序而开启的一个进程里面的处理对象，这个对象负责了Task的运行，通过线程池中的线程并发执行和线程复用的方式，线程池中的每一个线程可以运行一个任务，任务完成后回收到线程池中进行线程复用。</span><br style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;line-height:1.8;"><div style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">
<div style="line-height:1.8;"><span style="color:rgb(85,85,85);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:1.8;"><span><strong>        </strong><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">Executor就是进程里的对象。<span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">默认情况下Driver运行在当前提交的机器上，<span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">一个worker默认分为当前的应用程序只开启一个executor，当然可以配置为多个。</span></span></span></span></span></div>
<div style="line-height:1.8;"><span style="color:rgb(85,85,85);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:1.8;"><span><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><u>※
 问题：一个worker里executor是多点好还是少点好？</u></span><br></span></span></span></span></span></div>
<div style="line-height:1.8;"><span style="color:rgb(85,85,85);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:1.8;"><span><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">=&gt;看情况。如果只分了一个Executor，占据了大量CPU
 core，但资源闲置，造成资源浪费。</span><br style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">由于CPU Cores的个数是有限的，如果只开启一个Executor，当任务比较大时内存易OOM。这时最好分成几个不同的Executor。</span><br></span></span></span></span></span></span></div>
<div style="line-height:1.8;"><span style="color:rgb(85,85,85);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:1.8;"><span><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><br></span></span></span></span></span></div>
<div style="line-height:1.8;"><span style="color:rgb(85,85,85);font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:1.8;"><span><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"> 
      <strong> ClusterManager</strong>是集群获取资源的外部服务。Spark最开始时没有Yarn模式，也没有Standalone模式，最开始的资源管理服务是mesos。</span></span></span></span></span></span>Spark程序的运行不依赖于ClusterManager。<span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">Spark应用程序向clustermanager注册成功后，Master就提前直接分配好资源，程序运行过程中不需要ClusterManager参与。（</span><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">ClusterManager是可插拨的，<span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">这种资源分配方式是粗粒度的资源分配方式）</span></span></div>
<div style="line-height:1.8;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"> 
       worker就是集群中任何可以运行APP具体操作代码的节点。worker上不会运行程序代码，worker是管理当前节点内存CPU等资源使用状况的，它会接收Master分配资源的指令，并通过executor runner启动一个新进程，进程内有Executor。</span><br></span></span></div>
<div style="line-height:1.8;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">        clustermanager是项目经理，<span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">管理很多worker，</span></span>worker是工头，Worker下面有很多资源。</div>
<div style="line-height:1.8;"><br></div>
<div style="line-height:1.8;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><u>※ worker会不会向master汇报当前node的资源信息？</u></span><br style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">=&gt; 不会。</span><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">worker会不断向Master发的心跳，但内容只有worker
 ID。是用来判断Worker是否活着。</span><br style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">那master怎么知道各节点的资源信息？</span><br style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">=&gt; 分配资源的时候就已经知道了。应用程序在向Master注册时，注册成功后master就会分配资源，分配时就会记录资源，所有的资源都是Master分配的，所以Master当然知道各节点的资源信息了。</span><br style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">只有当Worker出现故障时才会向Master汇报资源情况。</span><br></div>
<div style="line-height:1.8;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><br></span></div>
<div style="line-height:1.8;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><strong>JOB</strong></span><br></span></div>
<div style="line-height:1.8;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"> 
       JOB就是包含了一系列Task的并行计算。JOB一般由应用程序的Action操作触发，比如saveAsTextFile。</span><br style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">JOB里面是一系列的RDD及作用在RDD的各种operation操作，</span><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">collect就是一个Action，会触发一个作业。</span><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">wordCountOrdered就是一系列的RDD及对RDD的操作。</span><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">包括map、flatMap、TextFile，每一步都会至少产生一个RDD。TextFile就会产生hadoopRDD
 和MapPartitionsRDD。</span><br style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">        JOB都是由Action触发的，触发时前面有一系列的RDD。</span><br style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">        action不会产生RDD，只会导致RunJOB。</span><br style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">        action前是RDD，是transformation级别的，是lazy级别的执行方式。</span><br style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">        如果后面的RDD对前面的RDD进行回溯时是窄依赖的话，就会在内存中进行迭代，这是Spark快的一个很重要的原因。</span><br style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">       <em>spark快不仅是因为<strong>基于内存</strong>。<strong>调度</strong>，<strong>容错</strong>才是Spark的精髓的基本点。</em></span><br style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">        窄依赖有一个Range级别，即依赖固定个数的父RDD。所谓固定个数是说不会随着数据规模的扩大而改变。</span><br style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">        依赖构成了DAG。如果是宽依赖DAG Scheduler就会划分Stage，Stage内部是基于内存迭代的，当然也可以基于磁盘迭代。</span><br style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">stage内部计算逻辑完全一样，只是计算的数据不同。</span></span></span></div>
<div style="line-height:1.8;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><br style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">任务（Task）就是计算一个数据分片的，</span><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">数据分片：例如从HDFS上读取数据时默认数据分片就是128MB。</span></span></span></div>
<div style="line-height:1.8;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><br style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><u>※ 一个数据分片是否精准地等于一个Block的大小（默认128MB）？</u></span><br style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">=&gt; 一般情况下都不等于，因为最后一个分片会跨两个Block。</span><br></span></span></div>
<div style="line-height:1.8;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"></span></span>
<h2 style="font-weight:500;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:1.1;color:rgb(49,126,172);font-size:24px;">
1.4 通过spark historyserver UI查看</h2>
<div>        http://master-1a:18080<br></div>
<div>        问题：没有发现DAG visualization界面，待解决。</div>
<br></div>
<div style="line-height:1.8;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;"></span></span>
<h1 style="font-weight:500;font-size:30px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;line-height:1.1;color:rgb(49,126,172);">
2. SparkDAG概念</h1>
<div><span style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">        在spark里每一个操作生成一个RDD，RDD之间连一条边，最后这些RDD和他们之间的边组成一个有向无环图，这个就是DAG。</span><br></div>
<p style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">
        Spark内核会在需要计算发生的时刻绘制一张关于计算路径的有向无环图，也就是DAG。</p>
<p style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">
        有了计算的DAG图，Spark内核下一步的任务就是根据DAG图将计算划分成任务集，也就是Stage，这样可以将任务提交到计算节点进行真正的计算。Spark计算的中间结果默认是保存在内存中的，Spark在划分Stage的时候会充分考虑在分布式计算中可流水线计算（pipeline）的部分来提高计算的效率，而在这个过程中，主要的根据就是RDD的依赖类型。根据不同的transformation操作，RDD的依赖可以分为窄依赖（Narrow Dependency）和宽依赖（Wide Dependency，在代码中为ShuffleDependency）两种类型。窄依赖指的是生成的RDD中每个partition只依赖于父RDD(s)
 固定的partition。宽依赖指的是生成的RDD的每一个partition都依赖于父 RDD(s) 所有partition。窄依赖典型的操作有map, filter, union等，宽依赖典型的操作有groupByKey, sortByKey等。可以看到，宽依赖往往意味着shuffle操作，这也是Spark划分stage的主要边界。对于窄依赖，Spark会将其尽量划分在同一个stage中，因为它们可以进行流水线计算。</p>
<p style="color:rgb(69,69,69);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;">
         至于以上一些shuffer过程建议大家多看看spark官网会比较好点。</p>
<br></div>
</div>
</div>
</div>
<div><br></div>
            </div>
                </div>