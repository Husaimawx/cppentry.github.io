---
layout:     post
title:      Flume入门
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                <p style="background-color:rgb(255,255,255);"><span style="font-size:14px;"><span style="font-family:SimSun;margin:0px;padding:0px;color:rgb(51,51,51);">    Flume是一个分布式、可靠、和高可用的海量日志聚合的系统</span><span style="font-family:SimSun;color:rgb(51,51,51);">，支持在系统中定制各类数据发送方，用于收集数据</span><span style="font-family:SimSun;color:rgb(51,51,51);">；同时，Flume提供对数据进行简单处理，并写到各种数据接受方（可定制）的能力。</span><span style="font-family:SimSun;color:rgb(51,51,51);">一个独立的Flume进程称之为Agent,包含组件Source、Channel、Sink Source。</span></span></p><p style="background-color:rgb(255,255,255);"><span style="font-weight:bold;font-size:14px;font-family:SimSun;">Flume OG:Flume original generation ，即Flume 0.9.x版本 ； </span></p><p style="background-color:rgb(255,255,255);"><span style="font-weight:bold;font-size:14px;font-family:SimSun;">Flume NG:Flume next generation ，即Flume 1.x版本</span></p><p style="background-color:rgb(255,255,255);"><span style="color:rgb(51,51,51);font-size:14px;">一、Flume OG ： 一个分布式日志收集系统，有Master概念，依赖于zookeeper，以下是其架构图</span></p><div class="article_content csdn-tracking-statistics" style="padding:0px;margin:0px;"><div class="htmledit_views" style="padding:0px;margin-bottom:0px;"><div style="color:rgb(51,51,51);font-size:14px;padding:0px;margin:0px;"><img src="https://img-blog.csdn.net/20170304123727755?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1eGlhbzcyMzg0Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br></div><div style="color:rgb(51,51,51);padding:0px;margin:0px;"><span style="font-size:14px;">Flume采用了分层架构：分别为agent，collector和storage。<span style="color:rgb(255,0,0);">其中，agent和collector均由两部分组成：source和sink，source是数据来源，sink是数据去向</span>。Flume使用两个组件：Master和Node，Node根据在Master shell或web中动态配置，决定其是作为Agent还是Collector。<span style="white-space:pre;"></span></span></div><div style="color:rgb(51,51,51);padding:0px;margin:0px;"><span style="font-size:14px;">Agent用于采集数据，agent是flume中产生数据流的地方，同时，agent会将产生的数据流传输到collector。对应的，collector用于对数据进行聚合，往往会产生一个更大的流。</span><br></div><div style="padding:0px;margin:0px;"><span style="color:rgb(255,0,0);"><strong><span style="font-size:14px;">1、agent的作用是将数据源的数据发送给collector。</span></strong></span></div><div style="padding:0px;margin:0px;"><span style="font-size:14px;"><span style="color:rgb(51,51,51);">1）Flume自带了很多直接可用的数据源（source），如：</span><br><span style="color:rgb(51,51,51);">text(“filename”)：将文件filename作为数据源，按行发送</span><br><span style="color:rgb(51,51,51);">tail(“filename”)：探测filename新产生的数据，按行发送出去</span><br><span style="color:rgb(51,51,51);">fsyslogTcp(5140)：监听TCP的5140端口，并且接收到的数据发送出去</span><br><span style="color:rgb(51,51,51);">tailDir("dirname"[, fileregex=".*"[, startFromEnd=false[, recurseDepth=0]]])：监听目录中的文件末尾，使用正则去选定需要监听的文件（不包含目录），recurseDepth为递归监听其下子目录的深度</span><br><span style="color:rgb(51,51,51);">更多可参见这位朋友的整理：http://www.cnblogs.com/zhangmiao-chp/archive/2011/05/18/2050465.html</span><br><br><span style="color:rgb(51,51,51);">2）同时提供了很多sink，如：</span><br><span style="color:rgb(51,51,51);">console[("format")] ：直接将将数据显示在consolr上</span><br><span style="color:rgb(51,51,51);">text(“txtfile”)：将数据写到文件txtfile中</span><br><span style="color:rgb(51,51,51);">dfs(“dfsfile”)：将数据写到HDFS上的dfsfile文件中</span><br><span style="color:rgb(51,51,51);">syslogTcp(“host”,port)：将数据通过TCP传递给host节点</span><br><span style="color:rgb(51,51,51);">agentSink[("machine"[,port])]：等价于agentE2ESink，如果省略，machine参数，默认使用flume.collector.event.host与flume.collector.event.port作为默认collecotr</span><br><span style="color:rgb(51,51,51);">agentDFOSink[("machine" [,port])]：本地热备agent，agent发现collector节点故障后，不断检查collector的存活状态以便重新发送event，在此间产生的数据将缓存到本地磁盘中</span><br><span style="color:rgb(51,51,51);">agentBESink[("machine"[,port])]：不负责的agent，如果collector故障，将不做任何处理，它发送的数据也将被直接丢弃</span><br><span style="color:rgb(51,51,51);">agentE2EChain：指定多个collector提高可用性。 当向主collector发送event失效后，转向第二个collector发送，当所有的collector失败后，它会非常执着的再来一遍</span><br><span style="color:rgb(51,51,51);">更多可参见这位朋友的整理：http://www.cnblogs.com/zhangmiao-chp/archive/2011/05/18/2050472.html</span><br></span><br><span style="font-size:14px;"><span style="color:rgb(51,51,51);"><strong>2、collector : </strong></span><span style="color:#ff0000;">collector的作用是将多个agent的数据汇总后，加载到storage中。它的source和sink与agent类似。</span><br><span style="color:rgb(51,51,51);">1）数据源（source），如：</span></span></div><div style="color:rgb(51,51,51);padding:0px;margin:0px;"><span style="font-size:14px;">collectorSource[(port)]：Collector source，监听端口汇聚数据<br>autoCollectorSource：通过master协调物理节点自动汇聚数据<br>logicalSource：逻辑source，由master分配端口并监听rpcSink<br>2）sink，如：</span></div><div style="padding:0px;margin:0px;"><span style="font-size:14px;"><span style="color:#333333;">collectorSink( "fsdir","fsfileprefix",rollmillis)：collectorSink，数据通过collector汇聚之后发送到hdfs, fsdir 是hdfs目录，fsfileprefix为文件前缀码</span><br><span style="color:#333333;">customdfs("hdfspath"[, "format"])：自定义格式dfs</span><br><strong><span style="color:#333333;">3、 storage :</span><span style="color:#ff0000;"> </span></strong><span style="color:#ff0000;">storage是存储系统，可以是一个普通file，也可以是HDFS，HIVE，HBase，分布式存储等。</span></span></div><div style="padding:0px;margin:0px;"><span style="font-size:14px;"><span style="color:#333333;"><strong>4、 Master </strong>：</span><span style="color:#ff0000;">Master是管理协调agent和collector的配置等信息，是flume集群的控制器。</span><br><span style="color:#333333;">在Flume中，最重要的抽象是data flow（数据流），data flow描述了数据从产生，传输、处理并最终写入目标的一条路径。</span><br></span></div><div style="color:rgb(51,51,51);padding:0px;margin:0px;"><span style="font-size:14px;">对于agent数据流配置就是从哪得到数据，把数据发送到哪个collector。<br>对于collector是接收agent发过来的数据，把数据发送到指定的目标机器上。<br>注：Flume框架对hadoop和zookeeper的依赖只是在jar包上，并不要求flume启动时必须将hadoop和zookeeper服务也启动。<br></span></div><div style="color:rgb(51,51,51);padding:0px;margin:0px;"><span style="font-size:14px;">参考：http://www.cnblogs.com/oubo/archive/2012/05/25/2517751.html</span></div><div style="color:rgb(51,51,51);padding:0px;margin:0px;"><span style="font-size:14px;"><br></span></div><div style="color:rgb(51,51,51);padding:0px;margin:0px;"><span style="font-size:14px;">二、Flume NG</span></div><div style="color:rgb(51,51,51);padding:0px;margin:0px;"><span style="font-size:14px;"><span style="font-family:'Microsoft YaHei';">而对于</span><span style="font-family:'Microsoft YaHei';">Flume NG</span><span style="font-family:'Microsoft YaHei';">，它摒弃了Master和zookeeper，collector也没有了，web配置台也没有了，只剩下source，sink和channel，此时一个Agent的概念包括source,channel和sink，完全由一个分布式系统变成了传输工具。不同机器之间的数据传输不再是OG那样由agent-&gt;collector，而是由一个Agent端的sink流向另一个agent的source。其新的架构如下</span></span><br></div><div style="color:rgb(51,51,51);font-size:14px;padding:0px;margin:0px;"><img src="https://img-blog.csdn.net/20170112151753532?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk2NTM3Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" style="color:rgb(255,0,0);font-family:Verdana, Arial, Helvetica, sans-serif;"></div></div></div><p style="background-color:rgb(255,255,255);"><span style="font-size:14px;"><span style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;margin:0px;padding:0px;"><span style="margin:0px;padding:0px;color:rgb(255,0,0);">Event：</span></span><span style="color:rgb(51,51,51);font-family:Verdana, Arial, Helvetica, sans-serif;">Event是Flume数据传输的基本单元。Flume以Event的形式将数据从源头传送到最终目的。</span></span></p><p style="margin:10px auto;color:rgb(51,51,51);background-color:rgb(255,255,255);font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="font-size:14px;"><span style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;color:rgb(255,0,0);">Source：</span></span>Source负责接收events或通过特殊机制产生events，并将events批量的放到一个或多个Channels。Flume支持文件、消息流等数据源，并在Source部件中将接收到的数据转换为一个Event。例如Flume支持监听文件目录（spooling directory source），当监听的目录下新到一个文件，Flume就会将其作为数据源通过Source转换为Event实时的传输走。</span></p><p style="margin:10px auto;color:rgb(51,51,51);background-color:rgb(255,255,255);font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="font-size:14px;"><span style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;color:rgb(255,0,0);">Channel：</span></span>Channel位于Source和Sink之间，用于缓存进来的events，当Sink成功地将events发送到下一跳的channel或最终目的，events从Channel移除。目前Flume支持3种channel </span></p><p style="margin:10px auto;color:rgb(51,51,51);background-color:rgb(255,255,255);font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="font-size:14px;">    1、memory channel：消息放在内存中，提供高吞吐，但不提供可靠性；可能丢失数据； </span></p><p style="margin:10px auto;color:rgb(51,51,51);background-color:rgb(255,255,255);font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="font-size:14px;">    2、file channel：对数据持久化；但是配置较为麻烦，需要配置数据目录和checkpoint目录；不同的file channel均需要配置一个checkpoint 目录； </span></p><p style="margin:10px auto;color:rgb(51,51,51);background-color:rgb(255,255,255);font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="font-size:14px;">    3、jdbc channel：内置的derby数据库，对event进行了持久化，提供高可靠性；未来取代同样具有持久特性的file channel</span></p><p style="margin:10px auto;color:rgb(51,51,51);background-color:rgb(255,255,255);font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="font-size:14px;"><span style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;color:rgb(255,0,0);">Sink：</span></span>Sink负责将events传输到下一跳或最终目的。Sink支持将数据写入到离线存储如HDFS、消息系统如Kafka等。</span></p><p style="margin:10px auto;color:rgb(51,51,51);background-color:rgb(255,255,255);font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="font-size:14px;"><span style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;color:rgb(255,0,0);">Interceptor：</span></span>用于Source的一组拦截器，按照预设的顺序在必要地方对events进行过滤和自定义的处理逻辑实现。</span></p><p style="margin:10px auto;background-color:rgb(255,255,255);font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="font-size:14px;"><span style="color:#ff0000;">Channel Selector</span><span style="color:rgb(51,51,51);">允许Source基于预设的规则，从所有Channel中，选择一个或多个Channel。例如根据话单中的漫游字段，可以将原始话单放到不同的Channel，这样Sink就可以将数据送到不同的目标系统中。</span></span></p><p style="margin:10px auto;color:rgb(51,51,51);background-color:rgb(255,255,255);font-family:Verdana, Arial, Helvetica, sans-serif;"><span style="font-size:14px;">Channel Selector支持两种选择器： 复制Replicating: 一个event被复制到多个channel； 复用Multiplexing: event被路由到特定的channel，即非复制模式。</span></p>            </div>
                </div>