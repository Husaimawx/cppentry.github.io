---
layout:     post
title:      Hadoop原理（HDFS+MR+YARN）
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                <h2 style="margin-top:0px;margin-bottom:1em;padding:.8em 0px 0px;border:0px;font-family:Lato, sans-serif;font-weight:normal;line-height:inherit;font-size:1.5em;vertical-align:baseline;color:rgb(34,34,34);background-position:left top;">一、HDFS原理</h2><h3><span style="margin:0px;padding:0px;border:0px;font-family:inherit;font-style:inherit;line-height:inherit;vertical-align:baseline;font-weight:normal;">1-&gt;HDFS 架构</span></h3><p style="margin-bottom:1em;border:0px;font-family:Lato, sans-serif;line-height:inherit;vertical-align:baseline;color:rgb(34,34,34);">HDFS是一个分布式文件系统。一个HDFS集群主要由一个 <code style="margin:-1px 0px;padding:0px .3em;border:1px solid rgb(221,221,221);font-family:Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace;font-style:inherit;line-height:1.5em;font-size:.8em;vertical-align:baseline;background-color:rgb(255,255,255);color:rgb(85,85,85);">NameNode</code> ,一个<code style="margin:-1px 0px;padding:0px .3em;border:1px solid rgb(221,221,221);font-family:Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace;font-style:inherit;line-height:1.5em;font-size:.8em;vertical-align:baseline;background-color:rgb(255,255,255);color:rgb(85,85,85);">Secondary NameNode</code> 和多个 <code style="margin:-1px 0px;padding:0px .3em;border:1px solid rgb(221,221,221);font-family:Menlo, Monaco, 'Andale Mono', 'lucida console', 'Courier New', monospace;font-style:inherit;line-height:1.5em;font-size:.8em;vertical-align:baseline;background-color:rgb(255,255,255);color:rgb(85,85,85);">Datanode</code> 组成：Namenode管理文件系统的元数据，Datanode存储数据。</p><p style="margin-bottom:1em;border:0px;font-family:Lato, sans-serif;line-height:inherit;vertical-align:baseline;"><br></p><p style="color:rgb(34,34,34);"><img src="http://7xjuf4.com1.z0.glb.clouddn.com/hadoop_hadoop_arch_2.png" alt="此处输入图片的描述" style="margin-bottom:0px;padding:0px;border:.5em solid rgb(255,255,255);font-family:Lato, sans-serif;line-height:inherit;vertical-align:baseline;height:auto;color:rgb(34,34,34);"></p><p></p><h3 style="color:rgb(34,34,34);margin-top:0px;margin-bottom:1em;padding:0px;border:0px;font-family:Lato, sans-serif;font-weight:normal;line-height:inherit;font-size:1.3em;vertical-align:baseline;">2-&gt;HDFS各个节点的功能</h3><h3 style="color:rgb(34,34,34);margin-top:0px;margin-bottom:1em;padding:0px;border:0px;font-weight:normal;line-height:inherit;font-size:1.3em;vertical-align:baseline;"><span style="font-size:16px;text-align:justify;"><span style="background-color:rgb(255,255,255);color:rgb(17,17,17);font-size:16.00160026550293px;"><span style="font-family:SimSun;"><span style="margin:0px;padding:0px;border:0px;font-size:16.00160026550293px;line-height:inherit;vertical-align:baseline;color:rgb(17,17,17);"><em><span style="margin:0px;padding:0px;border:0px;font-style:inherit;line-height:inherit;vertical-align:baseline;">NameNode</span></em></span><span style="color:rgb(17,17,17);font-size:16.00160026550293px;background-color:rgb(255,255,255);">：</span>Master节点，是领导。管理数据块映射；处理客户端的读写请求；监控nanmenode的健康状态；管理HDFS的名称空间。</span></span><span style="font-family:'comic sans ms', sans-serif;background-color:rgb(255,255,255);color:rgb(17,17,17);font-size:16.00160026550293px;">                </span></span></h3><h3 style="color:rgb(34,34,34);margin-top:0px;margin-bottom:1em;padding:0px;border:0px;font-family:Lato, sans-serif;font-weight:normal;line-height:inherit;font-size:1.3em;vertical-align:baseline;"><span style="color:rgb(69,69,69);font-size:12px;line-height:normal;">注意：</span><span style="color:rgb(69,69,69);font-family:'Helvetica Neue';font-size:12px;"><u>namenode</u></span><span style="color:rgb(69,69,69);font-size:12px;line-height:normal;"><u>内存中存储的是</u></span><span style="color:rgb(69,69,69);font-family:'Helvetica Neue';font-size:12px;"><u>=fsimage+edits</u></span><span style="color:rgb(69,69,69);font-size:12px;line-height:normal;"><u>。</u></span><span style="color:rgb(17,17,17);font-family:'comic sans ms', sans-serif;font-size:16.00160026550293px;background-color:rgb(255,255,255);">    </span></h3><h3 style="color:rgb(34,34,34);margin-top:0px;margin-bottom:1em;padding:0px;border:0px;font-family:Lato, sans-serif;font-weight:normal;line-height:inherit;font-size:1.3em;vertical-align:baseline;"><img src="http://7xjuf4.com1.z0.glb.clouddn.com/hadoop_namenode_wzm2.PNG" alt="此处输入图片的描述" style="font-size:16px;text-align:justify;"></h3><h3 style="color:rgb(34,34,34);margin-top:0px;margin-bottom:1em;padding:0px;border:0px;font-family:Lato, sans-serif;font-weight:normal;line-height:inherit;font-size:1.3em;vertical-align:baseline;"></h3><div><p style="margin-top:.75em;margin-bottom:.75em;border:0px;font-size:16.00160026550293px;line-height:inherit;vertical-align:baseline;color:rgb(17,17,17);"><span style="font-family:SimSun;"><span style="margin:0px;padding:0px;border:0px;font-style:inherit;line-height:inherit;vertical-align:baseline;"><span style="margin:0px;padding:0px;border:0px;line-height:inherit;vertical-align:baseline;"><em><span style="margin:0px;padding:0px;border:0px;font-style:inherit;line-height:inherit;vertical-align:baseline;">SecondaryNameNode</span></em></span>：</span><span style="font-style:inherit;">是秘书，分担领导namenode的工作量；是NameNode的冷备份；<span style="color:rgb(17,17,17);font-size:16.00160026550293px;background-color:rgb(255,255,255);">SecondaryNameNode负责定时默认1小时，从namenode上，获取fsimage和edits来进行合并，然后再发送给namenode。减少namenode的工作量。</span>( 其中：</span><span style="margin:0px;padding:0px;border:0px;line-height:inherit;vertical-align:baseline;"><em><span style="margin:0px;padding:0px;border:0px;font-style:inherit;line-height:inherit;vertical-align:baseline;">fsimage</span></em></span><span style="font-style:inherit;">:元数据镜像文件（文件系统的目录树。）</span><span style="margin:0px;padding:0px;border:0px;line-height:inherit;vertical-align:baseline;"><em><span style="margin:0px;padding:0px;border:0px;font-style:inherit;line-height:inherit;vertical-align:baseline;">edits</span></em></span><span style="font-style:inherit;">：元数据的操作日志（针对文件系统做的修改操作记录）</span></span><span style="font-style:inherit;"><span style="font-family:SimSun;">)</span><br><br></span></p><p style="margin-top:.75em;margin-bottom:.75em;border:0px;font-family:'Droid Sans', Arial, Tahoma;font-size:16.00160026550293px;line-height:inherit;vertical-align:baseline;color:rgb(17,17,17);"><span style="font-family:'comic sans ms', sans-serif;font-style:inherit;"><img src="http://7xjuf4.com1.z0.glb.clouddn.com/hadoop_second_check.jpg" alt="此处输入图片的描述"><br></span></p><div><span style="margin:0px;padding:0px;border:0px;font-style:inherit;line-height:inherit;vertical-align:baseline;"><span style="font-family:SimSun;"><span style="margin:0px;padding:0px;border:0px;font-size:16.00160026550293px;line-height:inherit;vertical-align:baseline;color:rgb(17,17,17);"><em><span style="margin:0px;padding:0px;border:0px;font-style:inherit;line-height:inherit;vertical-align:baseline;">DataNode</span>：Slave</em></span><span style="color:rgb(17,17,17);font-size:16.00160026550293px;background-color:rgb(255,255,255);">节点，是工人，负责存储client发来的数据块block（默认大小128M）；执行数据块的读写操作。</span></span></span></div><img src="http://7xjuf4.com1.z0.glb.clouddn.com/hadoop_datanode_1_2_3.png" alt="此处输入图片的描述"><br></div><div><br></div><h3><span style="font-weight:normal;">3-&gt;HDFS读写数据原理</span></h3><div>（1）写数据原理</div><div><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">          客户端要向HDFS写数据，首先要跟namenode通信以确认可以写文件并获得接收文件block的datanode，然后，客户端按顺序将文件逐个block传递给相应datanode，并由接收到block的datanode负责向其他datanode复制block的副本</span></div><p><span style="color:#222222;"><img src="http://7xjuf4.com1.z0.glb.clouddn.com/hadoop_hdfs_2.png" alt="此处输入图片的描述"></span></p><p style="color:rgb(34,34,34);">（2）读数据原理</p><p style="color:rgb(34,34,34);"><span style="font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;background-color:rgb(255,255,255);">         客户端将要读取的文件路径发送给namenode，namenode获取文件的元信息（主要是block的存放位置信息）返回给客户端，客户端根据返回的信息找到相应datanode逐个获取文件的block并在客户端本地进行数据追加合并，从而获得整个文件</span></p><p style="color:rgb(34,34,34);"><img src="http://7xjuf4.com1.z0.glb.clouddn.com/hadoop_hdfs_1.png" alt="此处输入图片的描述"></p><h3><span style="color:rgb(34,34,34);font-weight:normal;">4-&gt;HDFS优缺点</span></h3><p style="margin-bottom:1em;border:0px;font-family:Lato, sans-serif;line-height:inherit;vertical-align:baseline;color:rgb(34,34,34);">*优点</p><p style="margin-bottom:1em;border:0px;font-family:Lato, sans-serif;line-height:inherit;vertical-align:baseline;color:rgb(34,34,34);">(1) 适合大数据处理（支持GB，TB，PB级别的数据存储，支持百万规模以上的文件数量）</p><p style="margin-bottom:1em;border:0px;font-family:Lato, sans-serif;line-height:inherit;vertical-align:baseline;color:rgb(34,34,34);">(2) 适合批处理（支持离线的批量数据处理，支持高吞吐率）</p><p style="margin-bottom:1em;border:0px;font-family:Lato, sans-serif;line-height:inherit;vertical-align:baseline;color:rgb(34,34,34);">(3) 高容错性（以数据块存储，可以保存多个副本，容易实现负载均衡）</p><p style="margin-bottom:1em;border:0px;font-family:Lato, sans-serif;line-height:inherit;vertical-align:baseline;color:rgb(34,34,34);">*缺点</p><p style="margin-bottom:1em;border:0px;font-family:Lato, sans-serif;line-height:inherit;vertical-align:baseline;color:rgb(34,34,34);">(1) 小文件存取（占用namenode大量内存，浪费磁盘空间）</p><p style="margin-bottom:1em;border:0px;font-family:Lato, sans-serif;line-height:inherit;vertical-align:baseline;color:rgb(34,34,34);">(2) 不支持并发写入（同一时刻只能有一个进程写入，不支持随机修改）</p><h3><span style="font-family:inherit;font-style:inherit;font-weight:normal;">5-&gt;HDFS回收站</span></h3><p style="margin-bottom:1em;border:0px;font-family:Lato, sans-serif;line-height:inherit;vertical-align:baseline;color:rgb(34,34,34);">        当删除某个文件时，这个文件并没有立刻从HDFS中删除。实际上，HDFS会将这个文件重命名转移到/trash目录。只要文件还在/trash目录中，该文件就可以被迅速地恢复。文件在/trash中保存的时间是可配置的，当超过这个时间时，Namenode就会将该文件从名字空间中删除。删除文件会使得该文件相关的数据块被释放。注意，从用户删除文件到HDFS空闲空间的增加之间会有一定时间的延迟。</p><p style="margin-bottom:1em;border:0px;font-family:Lato, sans-serif;line-height:inherit;vertical-align:baseline;color:rgb(34,34,34);"><br></p><h2>二、mapreduce原理</h2><p><span style="color:rgb(48,48,48);font-family:Verdana, Helvetica, Arial;text-align:left;background-color:rgb(255,255,255);"><span style="font-size:16px;">MR有两个阶段组成：Map和Reduce，只需实现map()和reduce()两个函数，即可实现分布式计算</span></span></p><p><span style="color:rgb(48,48,48);font-family:Verdana, Helvetica, Arial;font-size:18.66666603088379px;text-align:left;background-color:rgb(255,255,255);"><img src="https://images2015.cnblogs.com/blog/1110462/201703/1110462-20170330105359920-995323028.png" alt=""><br></span></p><h3><span style="font-weight:normal;">1-&gt;shuffle原理</span></h3><h3><span style="color:rgb(51,51,51);font-family:Helvetica, Tahoma, Arial, sans-serif;background-color:rgb(255,255,255);"><span style="font-size:16px;">       <span style="font-weight:normal;"> MapReduce计算模型一般包括两个重要的阶段：Map是映射，负责数据的过滤分发；Reduce是规约，负责数据的计算归并。Reduce的数据来源于Map，Map的输出即是Reduce的输入，Reduce需要通过Shuffle来获取数据。</span></span></span><span style="font-size:16px;"><span style="color:rgb(69,69,69);font-weight:normal;line-height:normal;">从</span><span style="color:rgb(69,69,69);font-family:'Helvetica Neue';font-weight:normal;background-color:rgb(255,255,255);">Map</span><span style="color:rgb(69,69,69);font-weight:normal;line-height:normal;">输出到</span><span style="color:rgb(69,69,69);font-family:'Helvetica Neue';font-weight:normal;background-color:rgb(255,255,255);">Reduce</span><span style="color:rgb(69,69,69);font-weight:normal;line-height:normal;">输入的整个过程可以广义地称为</span><span style="color:rgb(69,69,69);font-family:'Helvetica Neue';font-weight:normal;background-color:rgb(255,255,255);">Shuffle</span><span style="color:rgb(69,69,69);font-weight:normal;line-height:normal;">。</span><span style="color:rgb(69,69,69);font-family:'Helvetica Neue';font-weight:normal;background-color:rgb(255,255,255);">Shuffle</span><span style="color:rgb(69,69,69);font-weight:normal;line-height:normal;">横跨</span><span style="color:rgb(69,69,69);font-family:'Helvetica Neue';font-weight:normal;background-color:rgb(255,255,255);">Map</span><span style="color:rgb(69,69,69);font-weight:normal;line-height:normal;">端和</span><span style="color:rgb(69,69,69);font-family:'Helvetica Neue';font-weight:normal;background-color:rgb(255,255,255);">Reduce</span><span style="color:rgb(69,69,69);font-weight:normal;line-height:normal;">端，在</span><span style="color:rgb(69,69,69);font-family:'Helvetica Neue';font-weight:normal;background-color:rgb(255,255,255);">Map</span><span style="color:rgb(69,69,69);font-weight:normal;line-height:normal;">端包括</span><span style="color:rgb(69,69,69);font-family:'Helvetica Neue';font-weight:normal;background-color:rgb(255,255,255);">Spill</span><span style="color:rgb(69,69,69);font-weight:normal;line-height:normal;">过程，在</span><span style="color:rgb(69,69,69);font-family:'Helvetica Neue';font-weight:normal;background-color:rgb(255,255,255);">Reduce</span><span style="color:rgb(69,69,69);font-weight:normal;line-height:normal;">端包括</span><span style="color:rgb(69,69,69);font-family:'Helvetica Neue';font-weight:normal;background-color:rgb(255,255,255);">copy</span><span style="color:rgb(69,69,69);font-weight:normal;line-height:normal;">和</span><span style="color:rgb(69,69,69);font-family:'Helvetica Neue';font-weight:normal;background-color:rgb(255,255,255);">sort</span><span style="color:rgb(69,69,69);font-weight:normal;line-height:normal;">过程，如图所示：</span></span></h3><div><span style="color:rgb(51,51,51);font-family:Helvetica, Tahoma, Arial, sans-serif;background-color:rgb(255,255,255);"><span style="font-size:16px;"><img src="http://cms.csdnimg.cn/article/201405/19/5379cc04b2d75.jpg" border="0" alt="" style="border:0px none;vertical-align:middle;"><br></span></span></div><h3><span style="font-weight:normal;">2-&gt;执行过程</span></h3><p style="margin:10px auto;color:rgb(48,48,48);font-family:Verdana, Helvetica, Arial;text-align:left;"><span style="font-size:16px;">1、Map任务处理</span></p><p style="margin:10px auto;font-family:Verdana, Helvetica, Arial;text-align:left;"><span style="font-size:16px;"><span style="color:#303030;">　　1.1 读取HDFS中的文件。每一行解析成一个&lt;k,v&gt;。每一个键值对调用一次map函数。                               </span></span></p><p style="margin:10px auto;font-family:Verdana, Helvetica, Arial;text-align:left;"><span style="font-size:16px;"><span style="color:#303030;">            </span><span style="background-color:rgb(255,255,255);"><strong><span style="color:#333333;">&lt;0,hello you&gt;   &lt;10,hello me&gt;</span></strong></span><span style="color:#303030;">                    </span></span></p><p style="margin:10px auto;color:rgb(48,48,48);font-family:Verdana, Helvetica, Arial;text-align:left;"><span style="font-size:16px;">　　1.2 覆盖map()，接收1.1产生的&lt;k,v&gt;，进行处理，转换为新的&lt;k,v&gt;输出。</span></p><p style="margin:10px auto;font-family:Verdana, Helvetica, Arial;text-align:left;"><span style="font-size:16px;"><span style="font-family:Verdana, Helvetica, Arial;font-size:18px;text-align:left;"><strong><span style="color:rgb(48,48,48);background-color:rgb(255,255,255);">           </span><span style="background-color:rgb(255,255,255);"><span style="color:#333333;">&lt;hello,1&gt; &lt;you,1&gt; &lt;hello,1&gt; &lt;me,1&gt;</span></span></strong></span><br></span></p><p style="margin:10px auto;color:rgb(48,48,48);font-family:Verdana, Helvetica, Arial;text-align:left;"><span style="font-size:16px;">　　1.3 对1.2输出的&lt;k,v&gt;进行分区。默认分为一个区。</span></p><p style="margin:10px auto;font-family:Verdana, Helvetica, Arial;text-align:left;"><span style="font-size:16px;"><span style="color:#303030;">　　1.4 对不同分区中的数据进行排序（按照k）、分组。分组指的是相同key的value放到一个集合中。</span></span></p><p style="margin:10px auto;font-family:Verdana, Helvetica, Arial;text-align:left;"><span style="font-size:16px;"><span style="color:#303030;">           排序后：</span><span style="background-color:rgb(255,255,255);"><span style="color:#333333;"><strong>&lt;hello,1&gt; &lt;hello,1&gt; &lt;me,1&gt; &lt;you,1&gt;</strong> </span></span><span style="color:#303030;"> 分组后：</span><span style="background-color:rgb(255,255,255);"><strong><span style="color:#333333;">&lt;hello,{1,1}&gt;&lt;me,{1}&gt;&lt;you,{1}&gt;</span></strong></span><br></span></p><p style="margin:10px auto;color:rgb(48,48,48);font-family:Verdana, Helvetica, Arial;text-align:left;"><span style="font-size:16px;">　　1.5 （可选）对分组后的数据进行归约：<span style="color:rgb(48,48,48);font-family:Verdana, Helvetica, Arial;font-size:18.66666603088379px;text-align:left;background-color:rgb(255,255,255);">Combiner</span>。</span></p><p style="margin:10px auto;color:rgb(48,48,48);font-family:Verdana, Helvetica, Arial;text-align:left;"><span style="font-size:16px;">2、Reduce任务处理</span></p><p style="margin:10px auto;color:rgb(48,48,48);font-family:Verdana, Helvetica, Arial;text-align:left;"><span style="font-size:16px;">　　2.1 多个map任务的输出，按照不同的分区，通过网络copy到不同的reduce节点上。</span></p><p style="margin:10px auto;font-family:Verdana, Helvetica, Arial;text-align:left;"><span style="font-size:16px;"><span style="color:#303030;">　　2.2 对多个map的输出进行合并、排序。覆盖reduce函数，接收的是分组后的数据，实现自己的业务</span></span></p><p style="margin:10px auto;font-family:Verdana, Helvetica, Arial;text-align:left;"><span style="font-size:16px;"><span style="color:#303030;">           逻辑，</span><span style="background-color:rgb(255,255,255);"><strong><span style="color:#333333;">&lt;hello,2&gt; &lt;me,1&gt; &lt;you,1&gt;</span></strong></span></span><span style="color:rgb(48,48,48);">处理后，产生新的&lt;k,v&gt;输出。</span></p><p style="margin:10px auto;color:rgb(48,48,48);font-family:Verdana, Helvetica, Arial;text-align:left;">　　2.3 对reduce输出的&lt;k,v&gt;写到HDFS中。</p>代码实现：<br><div class="cnblogs_code" style="background-color:rgb(245,245,245);border:1px solid rgb(204,204,204);padding:5px;margin:5px 0px;color:rgb(0,0,0);font-size:12px;text-align:left;font-family:'Courier New';"><div class="cnblogs_code_toolbar" style="margin-top:5px;"><span class="cnblogs_code_copy" style="padding-right:5px;line-height:1.5;"><a title="复制代码" style="color:rgb(54,105,0);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="max-width:900px;border:none;"></a></span></div><pre style="margin-bottom:0px;white-space:pre-wrap;font-family:'Courier New';"><span style="color:rgb(0,128,128);line-height:1.5;">  1</span> <span style="color:rgb(0,0,255);line-height:1.5;">package</span><span style="line-height:1.5;"> combine;
</span><span style="color:rgb(0,128,128);line-height:1.5;">  2</span> 
<span style="color:rgb(0,128,128);line-height:1.5;">  3</span> <span style="color:rgb(0,0,255);line-height:1.5;">import</span><span style="line-height:1.5;"> java.net.URI;
</span><span style="color:rgb(0,128,128);line-height:1.5;">  4</span> 
<span style="color:rgb(0,128,128);line-height:1.5;">  5</span> <span style="color:rgb(0,0,255);line-height:1.5;">import</span><span style="line-height:1.5;"> org.apache.hadoop.conf.Configuration;
</span><span style="color:rgb(0,128,128);line-height:1.5;">  6</span> <span style="color:rgb(0,0,255);line-height:1.5;">import</span><span style="line-height:1.5;"> org.apache.hadoop.fs.FileSystem;
</span><span style="color:rgb(0,128,128);line-height:1.5;">  7</span> <span style="color:rgb(0,0,255);line-height:1.5;">import</span><span style="line-height:1.5;"> org.apache.hadoop.fs.Path;
</span><span style="color:rgb(0,128,128);line-height:1.5;">  8</span> <span style="color:rgb(0,0,255);line-height:1.5;">import</span><span style="line-height:1.5;"> org.apache.hadoop.io.LongWritable;
</span><span style="color:rgb(0,128,128);line-height:1.5;">  9</span> <span style="color:rgb(0,0,255);line-height:1.5;">import</span><span style="line-height:1.5;"> org.apache.hadoop.io.Text;
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 10</span> <span style="color:rgb(0,0,255);line-height:1.5;">import</span><span style="line-height:1.5;"> org.apache.hadoop.mapreduce.Job;
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 11</span> <span style="color:rgb(0,0,255);line-height:1.5;">import</span><span style="line-height:1.5;"> org.apache.hadoop.mapreduce.Mapper;
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 12</span> <span style="color:rgb(0,0,255);line-height:1.5;">import</span><span style="line-height:1.5;"> org.apache.hadoop.mapreduce.Reducer;
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 13</span> <span style="color:rgb(0,0,255);line-height:1.5;">import</span><span style="line-height:1.5;"> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 14</span> <span style="color:rgb(0,0,255);line-height:1.5;">import</span><span style="line-height:1.5;"> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 15</span> 
<span style="color:rgb(0,128,128);line-height:1.5;"> 16</span> <span style="color:rgb(0,128,0);line-height:1.5;">/**</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 17</span> <span style="color:rgb(0,128,0);line-height:1.5;"> * 问：为什么使用Combiner？
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 18</span> <span style="color:rgb(0,128,0);line-height:1.5;"> * 答：<span style="background-color:rgb(204,255,204);line-height:1.5;">Combiner发生在Map端，对数据进行规约处理，数据量变小了，传送到reduce端的数据量变小了，传输时间变短，作业的整体时间变短</span>。
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 19</span> <span style="color:rgb(0,128,0);line-height:1.5;"> * 
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 20</span> <span style="color:rgb(0,128,0);line-height:1.5;"> * 问：为什么Combiner不作为MR运行的标配，而是可选步骤呢？
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 21</span> <span style="color:rgb(0,128,0);line-height:1.5;"> * 答：因为<span style="background-color:rgb(204,255,204);line-height:1.5;">不是所有的算法都适合使用Combiner处理</span>，例如求平均数。
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 22</span> <span style="color:rgb(0,128,0);line-height:1.5;"> *
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 23</span> <span style="color:rgb(0,128,0);line-height:1.5;"> * 问：Combiner本身已经执行了reduce操作，为什么在Reducer阶段还要执行reduce操作呢？
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 24</span> <span style="color:rgb(0,128,0);line-height:1.5;"> * 答：<span style="background-color:rgb(204,255,204);line-height:1.5;">combiner操作发生在map端的，处理<strong>一个任务</strong>所接收的文件中的数据，不能跨map任务执行；只有reduce可以接收<strong>多个map任务</strong>处理的数据。
</span></span><span style="color:rgb(0,128,128);line-height:1.5;"> 25</span> <span style="color:rgb(0,128,0);line-height:1.5;"> *
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 26</span>  <span style="color:rgb(0,128,0);line-height:1.5;">*/</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 27</span> <span style="color:rgb(0,0,255);line-height:1.5;">public</span> <span style="color:rgb(0,0,255);line-height:1.5;">class</span><span style="line-height:1.5;"> WordCountApp {
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 28</span>     <span style="color:rgb(0,0,255);line-height:1.5;">static</span> <span style="color:rgb(0,0,255);line-height:1.5;">final</span> String INPUT_PATH = "hdfs://chaoren:9000/hello"<span style="line-height:1.5;">;
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 29</span>     <span style="color:rgb(0,0,255);line-height:1.5;">static</span> <span style="color:rgb(0,0,255);line-height:1.5;">final</span> String OUT_PATH = "hdfs://chaoren:9000/out"<span style="line-height:1.5;">;
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 30</span>     
<span style="color:rgb(0,128,128);line-height:1.5;"> 31</span>     <span style="color:rgb(0,0,255);line-height:1.5;">public</span> <span style="color:rgb(0,0,255);line-height:1.5;">static</span> <span style="color:rgb(0,0,255);line-height:1.5;">void</span> main(String[] args) <span style="color:rgb(0,0,255);line-height:1.5;">throws</span><span style="line-height:1.5;"> Exception {
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 32</span>         Configuration conf = <span style="color:rgb(0,0,255);line-height:1.5;">new</span><span style="line-height:1.5;"> Configuration();
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 33</span>         <span style="color:rgb(0,0,255);line-height:1.5;">final</span> FileSystem fileSystem = FileSystem.get(<span style="color:rgb(0,0,255);line-height:1.5;">new</span><span style="line-height:1.5;"> URI(INPUT_PATH), conf);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 34</span>         <span style="color:rgb(0,0,255);line-height:1.5;">final</span> Path outPath = <span style="color:rgb(0,0,255);line-height:1.5;">new</span><span style="line-height:1.5;"> Path(OUT_PATH);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 35</span>         <span style="color:rgb(0,0,255);line-height:1.5;">if</span><span style="line-height:1.5;">(fileSystem.exists(outPath)){
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 36</span>             fileSystem.delete(outPath, <span style="color:rgb(0,0,255);line-height:1.5;">true</span><span style="line-height:1.5;">);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 37</span> <span style="line-height:1.5;">        }
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 38</span>         
<span style="color:rgb(0,128,128);line-height:1.5;"> 39</span>         <span style="color:rgb(0,0,255);line-height:1.5;">final</span> Job job = <span style="color:rgb(0,0,255);line-height:1.5;">new</span> Job(conf , WordCountApp.<span style="color:rgb(0,0,255);line-height:1.5;">class</span><span style="line-height:1.5;">.getSimpleName());
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 40</span>         <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">1.1指定读取的文件位于哪里</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 41</span> <span style="line-height:1.5;">        FileInputFormat.setInputPaths(job, INPUT_PATH);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 42</span>         <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">指定如何对输入文件进行格式化，把输入文件每一行解析成键值对
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 43</span>         <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">job.setInputFormatClass(TextInputFormat.class);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 44</span>         
<span style="color:rgb(0,128,128);line-height:1.5;"> 45</span>         <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">1.2 指定自定义的map类</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 46</span>         job.setMapperClass(MyMapper.<span style="color:rgb(0,0,255);line-height:1.5;">class</span><span style="line-height:1.5;">);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 47</span>         <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">map输出的&lt;k,v&gt;类型。如果&lt;k3,v3&gt;的类型与&lt;k2,v2&gt;类型一致，则可以省略
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 48</span>         <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">job.setMapOutputKeyClass(Text.class);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 49</span>         <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">job.setMapOutputValueClass(LongWritable.class);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 50</span>         
<span style="color:rgb(0,128,128);line-height:1.5;"> 51</span>         <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">1.3 分区
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 52</span>         <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">job.setPartitionerClass(HashPartitioner.class);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 53</span>         <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">有一个reduce任务运行
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 54</span>         <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">job.setNumReduceTasks(1);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 55</span>         
<span style="color:rgb(0,128,128);line-height:1.5;"> 56</span>         <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">1.4 TODO 排序、分组
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 57</span>         
<span style="color:rgb(0,128,128);line-height:1.5;"> 58</span>         <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">1.5 规约</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 59</span>         <span style="background-color:rgb(0,255,255);line-height:1.5;">job.setCombinerClass(<span style="background-color:rgb(255,255,0);line-height:1.5;"><strong>MyCombiner.<span style="color:rgb(0,0,255);line-height:1.5;">class</span></strong></span><span style="line-height:1.5;">);
</span></span><span style="color:rgb(0,128,128);line-height:1.5;"> 60</span>         
<span style="color:rgb(0,128,128);line-height:1.5;"> 61</span>         <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">2.2 指定自定义reduce类</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 62</span>         job.setReducerClass(MyReducer.<span style="color:rgb(0,0,255);line-height:1.5;">class</span><span style="line-height:1.5;">);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 63</span>         <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">指定reduce的输出类型</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 64</span>         job.setOutputKeyClass(Text.<span style="color:rgb(0,0,255);line-height:1.5;">class</span><span style="line-height:1.5;">);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 65</span>         job.setOutputValueClass(LongWritable.<span style="color:rgb(0,0,255);line-height:1.5;">class</span><span style="line-height:1.5;">);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 66</span>         
<span style="color:rgb(0,128,128);line-height:1.5;"> 67</span>         <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">2.3 指定写出到哪里</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 68</span> <span style="line-height:1.5;">        FileOutputFormat.setOutputPath(job, outPath);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 69</span>         <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">指定输出文件的格式化类
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 70</span>         <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">job.setOutputFormatClass(TextOutputFormat.class);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 71</span>         
<span style="color:rgb(0,128,128);line-height:1.5;"> 72</span>         <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">把job提交给JobTracker运行</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 73</span>         job.waitForCompletion(<span style="color:rgb(0,0,255);line-height:1.5;">true</span><span style="line-height:1.5;">);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 74</span> <span style="line-height:1.5;">    }
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 75</span>     
<span style="color:rgb(0,128,128);line-height:1.5;"> 76</span>     <span style="color:rgb(0,128,0);line-height:1.5;">/**</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 77</span> <span style="color:rgb(0,128,0);line-height:1.5;">     * KEYIN    即k1        表示行的偏移量
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 78</span> <span style="color:rgb(0,128,0);line-height:1.5;">     * VALUEIN    即v1        表示行文本内容
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 79</span> <span style="color:rgb(0,128,0);line-height:1.5;">     * KEYOUT    即k2        表示行中出现的单词
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 80</span> <span style="color:rgb(0,128,0);line-height:1.5;">     * VALUEOUT    即v2        表示行中出现的单词的次数，固定值1
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 81</span>      <span style="color:rgb(0,128,0);line-height:1.5;">*/</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 82</span>     <span style="color:rgb(0,0,255);line-height:1.5;">static</span> <span style="color:rgb(0,0,255);line-height:1.5;">class</span> MyMapper <span style="color:rgb(0,0,255);line-height:1.5;">extends</span> Mapper&lt;LongWritable, Text, Text, LongWritable&gt;<span style="line-height:1.5;">{
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 83</span>         <span style="color:rgb(0,0,255);line-height:1.5;">protected</span> <span style="color:rgb(0,0,255);line-height:1.5;">void</span> map(LongWritable k1, Text v1, Context context) <span style="color:rgb(0,0,255);line-height:1.5;">throws</span><span style="line-height:1.5;"> java.io.IOException ,InterruptedException {
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 84</span>             <span style="color:rgb(0,0,255);line-height:1.5;">final</span> String[] splited = v1.toString().split("\t"<span style="line-height:1.5;">);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 85</span>             <span style="color:rgb(0,0,255);line-height:1.5;">for</span><span style="line-height:1.5;"> (String word : splited) {
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 86</span>                 context.write(<span style="color:rgb(0,0,255);line-height:1.5;">new</span> Text(word), <span style="color:rgb(0,0,255);line-height:1.5;">new</span> LongWritable(1<span style="line-height:1.5;">));
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 87</span>                 System.out.println("Mapper输出&lt;"+word+","+1+"&gt;"<span style="line-height:1.5;">);
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 88</span> <span style="line-height:1.5;">            }
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 89</span> <span style="line-height:1.5;">        };
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 90</span> <span style="line-height:1.5;">    }
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 91</span>     
<span style="color:rgb(0,128,128);line-height:1.5;"> 92</span>     <span style="color:rgb(0,128,0);line-height:1.5;">/**</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 93</span> <span style="color:rgb(0,128,0);line-height:1.5;">     * KEYIN    即k2        表示行中出现的单词
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 94</span> <span style="color:rgb(0,128,0);line-height:1.5;">     * VALUEIN    即v2        表示行中出现的单词的次数
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 95</span> <span style="color:rgb(0,128,0);line-height:1.5;">     * KEYOUT    即k3        表示文本中出现的不同单词
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 96</span> <span style="color:rgb(0,128,0);line-height:1.5;">     * VALUEOUT    即v3        表示文本中出现的不同单词的总次数
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 97</span> <span style="color:rgb(0,128,0);line-height:1.5;">     *
</span><span style="color:rgb(0,128,128);line-height:1.5;"> 98</span>      <span style="color:rgb(0,128,0);line-height:1.5;">*/</span>
<span style="color:rgb(0,128,128);line-height:1.5;"> 99</span>     <span style="color:rgb(0,0,255);line-height:1.5;">static</span> <span style="color:rgb(0,0,255);line-height:1.5;">class</span> MyReducer <span style="color:rgb(0,0,255);line-height:1.5;">extends</span> Reducer&lt;Text, LongWritable, Text, LongWritable&gt;<span style="line-height:1.5;">{
</span><span style="color:rgb(0,128,128);line-height:1.5;">100</span>         <span style="color:rgb(0,0,255);line-height:1.5;">protected</span> <span style="color:rgb(0,0,255);line-height:1.5;">void</span> reduce(Text k2, java.lang.Iterable&lt;LongWritable&gt; v2s, Context ctx) <span style="color:rgb(0,0,255);line-height:1.5;">throws</span><span style="line-height:1.5;"> java.io.IOException ,InterruptedException {
</span><span style="color:rgb(0,128,128);line-height:1.5;">101</span>             <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">显示次数表示redcue函数被调用了多少次，表示k2有多少个分组</span>
<span style="color:rgb(0,128,128);line-height:1.5;">102</span>             System.out.println("MyReducer输入分组&lt;"+k2.toString()+",...&gt;"<span style="line-height:1.5;">);
</span><span style="color:rgb(0,128,128);line-height:1.5;">103</span>             <span style="color:rgb(0,0,255);line-height:1.5;">long</span> times = 0L<span style="line-height:1.5;">;
</span><span style="color:rgb(0,128,128);line-height:1.5;">104</span>             <span style="color:rgb(0,0,255);line-height:1.5;">for</span><span style="line-height:1.5;"> (LongWritable count : v2s) {
</span><span style="color:rgb(0,128,128);line-height:1.5;">105</span>                 times +=<span style="line-height:1.5;"> count.get();
</span><span style="color:rgb(0,128,128);line-height:1.5;">106</span>                 <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">显示次数表示输入的k2,v2的键值对数量</span>
<span style="color:rgb(0,128,128);line-height:1.5;">107</span>                 System.out.println("MyReducer输入键值对&lt;"+k2.toString()+","+count.get()+"&gt;"<span style="line-height:1.5;">);
</span><span style="color:rgb(0,128,128);line-height:1.5;">108</span> <span style="line-height:1.5;">            }
</span><span style="color:rgb(0,128,128);line-height:1.5;">109</span>             ctx.write(k2, <span style="color:rgb(0,0,255);line-height:1.5;">new</span><span style="line-height:1.5;"> LongWritable(times));
</span><span style="color:rgb(0,128,128);line-height:1.5;">110</span> <span style="line-height:1.5;">        };
</span><span style="color:rgb(0,128,128);line-height:1.5;">111</span> <span style="line-height:1.5;">    }
</span><span style="color:rgb(0,128,128);line-height:1.5;">112</span>     
<span style="color:rgb(0,128,128);line-height:1.5;">113</span>     
<span style="color:rgb(0,128,128);line-height:1.5;">114</span>     <span style="color:rgb(0,0,255);line-height:1.5;">static</span> <span style="color:rgb(0,0,255);line-height:1.5;">class</span> <span style="background-color:rgb(255,255,0);line-height:1.5;">MyCombiner</span> <span style="color:rgb(0,0,255);line-height:1.5;">extends</span> Reducer&lt;Text, LongWritable, Text, LongWritable&gt;<span style="line-height:1.5;">{
</span><span style="color:rgb(0,128,128);line-height:1.5;">115</span>         <span style="color:rgb(0,0,255);line-height:1.5;">protected</span> <span style="color:rgb(0,0,255);line-height:1.5;">void</span> reduce(Text k2, java.lang.Iterable&lt;LongWritable&gt; v2s, Context ctx) <span style="color:rgb(0,0,255);line-height:1.5;">throws</span><span style="line-height:1.5;"> java.io.IOException ,InterruptedException {
</span><span style="color:rgb(0,128,128);line-height:1.5;">116</span>             <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">显示次数表示redcue函数被调用了多少次，表示k2有多少个分组</span>
<span style="color:rgb(0,128,128);line-height:1.5;">117</span>             System.out.println("Combiner输入分组&lt;"+k2.toString()+",...&gt;"<span style="line-height:1.5;">);
</span><span style="color:rgb(0,128,128);line-height:1.5;">118</span>             <span style="color:rgb(0,0,255);line-height:1.5;">long</span> times = 0L<span style="line-height:1.5;">;
</span><span style="color:rgb(0,128,128);line-height:1.5;">119</span>             <span style="color:rgb(0,0,255);line-height:1.5;">for</span><span style="line-height:1.5;"> (LongWritable count : v2s) {
</span><span style="color:rgb(0,128,128);line-height:1.5;">120</span>                 times +=<span style="line-height:1.5;"> count.get();
</span><span style="color:rgb(0,128,128);line-height:1.5;">121</span>                 <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">显示次数表示输入的k2,v2的键值对数量</span>
<span style="color:rgb(0,128,128);line-height:1.5;">122</span>                 System.out.println("Combiner输入键值对&lt;"+k2.toString()+","+count.get()+"&gt;"<span style="line-height:1.5;">);
</span><span style="color:rgb(0,128,128);line-height:1.5;">123</span> <span style="line-height:1.5;">            }
</span><span style="color:rgb(0,128,128);line-height:1.5;">124</span>             
<span style="color:rgb(0,128,128);line-height:1.5;">125</span>             ctx.write(k2, <span style="color:rgb(0,0,255);line-height:1.5;">new</span><span style="line-height:1.5;"> LongWritable(times));
</span><span style="color:rgb(0,128,128);line-height:1.5;">126</span>             <span style="color:rgb(0,128,0);line-height:1.5;">//</span><span style="color:rgb(0,128,0);line-height:1.5;">显示次数表示输出的k2,v2的键值对数量</span>
<span style="color:rgb(0,128,128);line-height:1.5;">127</span>             System.out.println("Combiner输出键值对&lt;"+k2.toString()+","+times+"&gt;"<span style="line-height:1.5;">);
</span><span style="color:rgb(0,128,128);line-height:1.5;">128</span> <span style="line-height:1.5;">        };
</span><span style="color:rgb(0,128,128);line-height:1.5;">129</span> <span style="line-height:1.5;">    }
</span><span style="color:rgb(0,128,128);line-height:1.5;">130</span> }</pre><div class="cnblogs_code_toolbar" style="margin-top:5px;"><span class="cnblogs_code_copy" style="padding-right:5px;line-height:1.5;"><a title="复制代码" style="color:rgb(54,105,0);border:none;"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="max-width:900px;border:none;"></a></span></div></div><p style="margin:10px auto;color:rgb(48,48,48);font-family:Verdana, Helvetica, Arial;font-size:12px;text-align:left;"><img src="https://images2015.cnblogs.com/blog/1110462/201704/1110462-20170401213036649-625264849.png" alt="" style="color:rgb(79,79,79);font-family:'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-size:16px;text-align:justify;"></p><h3><br></h3><h3>三、YARN原理</h3><h5><span style="font-family:SimSun;text-indent:56px;"><span style="font-size:18px;">1-&gt;什么是YARN</span></span></h5><p><span style="font-family:SimSun;text-indent:56px;"></span></p><p style="font-size:18px;color:rgb(69,69,69);line-height:normal;margin-bottom:0px;text-indent:32px;"><span style="font-size:14px;"><span style="line-height:normal;font-family:'Helvetica Neue';">YARN</span>是<span style="line-height:normal;font-family:'Helvetica Neue';">Hadoop2.0</span>版本引进的资源管理系统，直接从<span style="line-height:normal;font-family:'Helvetica Neue';">MR1</span>演化而来。</span></p><p style="font-size:18px;color:rgb(69,69,69);line-height:normal;margin-bottom:0px;text-indent:32px;font-family:'Helvetica Neue';"><span style="font-size:14px;"><span style="line-height:normal;">核心思想：将</span>MR1<span style="line-height:normal;">中的</span>JobTracker<span style="line-height:normal;">的资源管理和作业调度两个功能分开，分别由</span>ResourceManager<span style="line-height:normal;">和</span>ApplicationMaster<span style="line-height:normal;">进程实现。</span></span></p><p style="font-size:18px;color:rgb(69,69,69);line-height:normal;margin-bottom:0px;text-indent:32px;font-family:'Helvetica Neue';"><span style="font-size:14px;">ResourceManager<span style="line-height:normal;">：负责整个集群的资源管理和调度</span></span></p><p style="font-size:18px;color:rgb(69,69,69);line-height:normal;margin-bottom:0px;text-indent:32px;"><span style="font-size:14px;"><span style="line-height:normal;font-family:'Helvetica Neue';">ApplicationMaster</span>：负责应用程序相关事务，比如任务调度、任务监控和容错等。</span></p><p style="font-size:18px;color:rgb(69,69,69);line-height:normal;margin-bottom:0px;text-indent:32px;"><span style="font-size:14px;"><span style="line-height:normal;font-family:'Helvetica Neue';">YARN</span>的出现，使得多个计算框架可以运行在同一个集群之中。</span></p><h5><span style="font-family:SimSun;text-indent:56px;"><span style="font-size:18px;">2-&gt;YARN架构</span></span></h5><p></p><p style="border-width:0px;margin-bottom:8px;list-style:none;text-indent:2em;color:rgb(51,51,51);font-family:Simsun;"></p><p style="margin-bottom:0px;line-height:normal;color:rgb(69,69,69);"><span style="font-size:14px;"><img src="https://img-blog.csdn.net/20160701170030551?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" style="font-size:12px;"><br></span></p><p style="margin:10px auto;color:rgb(57,57,57);font-family:verdana, 'ms song', Arial, Helvetica, sans-serif;font-size:14px;text-align:left;">从 YARN 的架构图来看，它主要由ResourceManager、NodeManager、ApplicationMaster和Container等以下几个组件构成。</p><div><p style="margin:10px auto;color:rgb(57,57,57);font-family:verdana, 'ms song', Arial, Helvetica, sans-serif;font-size:14px;text-align:left;">1、 ResourceManager（RM）</p><p style="margin:10px auto;color:rgb(57,57,57);font-family:verdana, 'ms song', Arial, Helvetica, sans-serif;font-size:14px;text-align:left;">    YARN 分层结构的本质是 ResourceManager。这个实体控制整个集群并管理应用程序向基础计算资源的分配。ResourceManager 将各个资源部分（计算、内存、带宽等）精心安排给基础 NodeManager（YARN 的每节点代理）。ResourceManager 还与 ApplicationMaster 一起分配资源，与 NodeManager 一起启动和监视它们的基础应用程序。在此上下文中，ApplicationMaster 承担了以前的 TaskTracker 的一些角色，ResourceManager 承担了 JobTracker 的角色。</p><p style="margin:10px auto;color:rgb(57,57,57);font-family:verdana, 'ms song', Arial, Helvetica, sans-serif;font-size:14px;text-align:left;">    总的来说，RM有以下作用</p><p style="margin:10px auto;color:rgb(57,57,57);font-family:verdana, 'ms song', Arial, Helvetica, sans-serif;font-size:14px;text-align:left;">    1）处理客户端请求</p><p style="margin:10px auto;color:rgb(57,57,57);font-family:verdana, 'ms song', Arial, Helvetica, sans-serif;font-size:14px;text-align:left;">    2）启动或监控ApplicationMaster</p><p style="margin:10px auto;color:rgb(57,57,57);font-family:verdana, 'ms song', Arial, Helvetica, sans-serif;font-size:14px;text-align:left;">    3）监控NodeManager</p><p style="margin:10px auto;color:rgb(57,57,57);font-family:verdana, 'ms song', Arial, Helvetica, sans-serif;font-size:14px;text-align:left;">    4）资源的分配与调度</p><p style="margin:10px auto;color:rgb(57,57,57);font-family:verdana, 'ms song', Arial, Helvetica, sans-serif;font-size:14px;text-align:left;">  2、 ApplicationMaster（AM）</p><p style="margin:10px auto;color:rgb(57,57,57);font-family:verdana, 'ms song', Arial, Helvetica, sans-serif;font-size:14px;text-align:left;">    ApplicationMaster 管理在YARN内运行的每个应用程序实例。ApplicationMaster 负责协调来自 ResourceManager 的资源，并通过 NodeManager 监视容器的执行和资源使用（CPU、内存等的资源分配）。请注意，尽管目前的资源更加传统（CPU 核心、内存），但未来会带来基于手头任务的新资源类型（比如图形处理单元或专用处理设备）。从 YARN 角度讲，ApplicationMaster 是用户代码，因此存在潜在的安全问题。YARN 假设 ApplicationMaster 存在错误或者甚至是恶意的，因此将它们当作无特权的代码对待。</p><p style="margin:10px auto;color:rgb(57,57,57);font-family:verdana, 'ms song', Arial, Helvetica, sans-serif;font-size:14px;text-align:left;">    总的来说,AM有以下作用</p><p style="margin:10px auto;color:rgb(57,57,57);font-family:verdana, 'ms song', Arial, Helvetica, sans-serif;font-size:14px;text-align:left;">    1）负责数据的切分</p><p style="margin:10px auto;color:rgb(57,57,57);font-family:verdana, 'ms song', Arial, Helvetica, sans-serif;font-size:14px;text-align:left;">    2）为应用程序申请资源并分配给内部的任务</p><p style="margin:10px auto;color:rgb(57,57,57);font-family:verdana, 'ms song', Arial, Helvetica, sans-serif;font-size:14px;text-align:left;">    3）任务的监控与容错</p><p style="margin:10px auto;color:rgb(57,57,57);font-family:verdana, 'ms song', Arial, Helvetica, sans-serif;font-size:14px;text-align:left;">  3、 NodeManager（NM）</p><p style="margin:10px auto;color:rgb(57,57,57);font-family:verdana, 'ms song', Arial, Helvetica, sans-serif;font-size:14px;text-align:left;">    NodeManager管理YARN集群中的每个节点。NodeManager 提供针对集群中每个节点的服务，从监督对一个容器的终生管理到监视资源和跟踪节点健康。MRv1 通过插槽管理 Map 和 Reduce 任务的执行，而 NodeManager 管理抽象容器，这些容器代表着可供一个特定应用程序使用的针对每个节点的资源。</p><p style="margin:10px auto;color:rgb(57,57,57);font-family:verdana, 'ms song', Arial, Helvetica, sans-serif;font-size:14px;text-align:left;">    总的来说，NM有以下作用</p><p style="margin:10px auto;color:rgb(57,57,57);font-family:verdana, 'ms song', Arial, Helvetica, sans-serif;font-size:14px;text-align:left;">    1）管理单个节点上的资源</p><p style="margin:10px auto;color:rgb(57,57,57);font-family:verdana, 'ms song', Arial, Helvetica, sans-serif;font-size:14px;text-align:left;">    2）处理来自ResourceManager的命令</p><p style="margin:10px auto;color:rgb(57,57,57);font-family:verdana, 'ms song', Arial, Helvetica, sans-serif;font-size:14px;text-align:left;">    3）处理来自ApplicationMaster的命令</p><p style="margin:10px auto;color:rgb(57,57,57);font-family:verdana, 'ms song', Arial, Helvetica, sans-serif;font-size:14px;text-align:left;">  4、 Container</p><p style="margin:10px auto;color:rgb(57,57,57);font-family:verdana, 'ms song', Arial, Helvetica, sans-serif;font-size:14px;text-align:left;">    Container 是 YARN 中的资源抽象，它封装了某个节点上的多维度资源，如内存、CPU、磁盘、网络等，当AM向RM申请资源时，RM为AM返回的资源便是用Container表示的。YARN会为每个任务分配一个Container，且该任务只能使用该Container中描述的资源。</p><p style="margin:10px auto;color:rgb(57,57,57);font-family:verdana, 'ms song', Arial, Helvetica, sans-serif;font-size:14px;text-align:left;"><span style="color:rgb(51,51,51);font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;font-size:14px;text-align:left;background-color:rgb(255,255,255);">     1）任务运行资源（节点、内存、CPU） </span><br style="color:rgb(51,51,51);font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;font-size:14px;text-align:left;"><span style="color:rgb(51,51,51);font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;font-size:14px;text-align:left;background-color:rgb(255,255,255);">             2） 任务启动命令 </span><br style="color:rgb(51,51,51);font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;font-size:14px;text-align:left;"><span style="color:rgb(51,51,51);font-family:'-apple-system', 'SF UI Text', Arial, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif, SimHei, SimSun;font-size:14px;text-align:left;background-color:rgb(255,255,255);">             3）任务运行环境</span><br></p><strong><span style="font-size:18px;">3-&gt;<span style="color:rgb(51,51,51);text-align:left;background-color:rgb(255,255,255);">MapReduce On YARN</span></span></strong></div><img src="https://img-blog.csdn.net/20160701170047004?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" style="font-size:12px;"><br><h3><span style="color:rgb(51,51,51);font-size:18px;">       <span style="font-weight:normal;"> MapReduce执行过程如上图。<span>首先，clien</span></span></span><span style="font-weight:normal;"><span style="color:rgb(51,51,51);font-size:18px;">t向ResourceManager提交一个job。</span><span style="color:rgb(51,51,51);font-size:18px;">Resource Manager为其分配一个Container，并指定一个NodeManager启动对应的ApplicationMaster。然后，ApplicationMaster向Resource Manager申请执行任务所需的资源。申请到资源以后，ApplicationMaster与NodeManager通讯。要求NodeManager启动Task执行work。</span><br></span></h3><p></p><h3><br></h3><div><br></div><p></p>            </div>
                </div>