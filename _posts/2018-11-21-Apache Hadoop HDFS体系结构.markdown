---
layout:     post
title:      Apache Hadoop HDFS体系结构
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                <h2 style="font-family:'open sans', Arial, sans-serif;color:rgb(51,51,51);font-weight:500;line-height:1.1;font-size:30px;background-color:rgb(255,255,255);text-align:justify;"><span style="font-size:18px;"><span style="font-weight:700;color:rgb(34,34,34);"><span style="font-family:verdana, geneva, sans-serif;font-size:16px;">Apache Hadoop HDFS</span></span></span><span style="font-weight:700;"><span style="color:rgb(34,34,34);font-size:16px;font-family:verdana, geneva, sans-serif;">体系结构</span></span></h2><h2 style="font-family:'open sans', Arial, sans-serif;color:rgb(51,51,51);font-weight:500;line-height:1.1;font-size:30px;background-color:rgb(255,255,255);text-align:center;"></h2><h2 style="font-family:'open sans', Arial, sans-serif;color:rgb(51,51,51);font-weight:500;line-height:1.1;font-size:30px;background-color:rgb(255,255,255);text-align:justify;"><span style="font-weight:700;"><span style="color:rgb(34,34,34);font-size:16px;font-family:verdana, geneva, sans-serif;">介绍：</span></span></h2><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">在这个博客中，我将讨论Apache Hadoop HDFS体系结构。</span><span style="vertical-align:inherit;">从我</span></span><span style="color:rgb(51,102,255);"><span><span style="font-weight:700;"><a href="https://www.edureka.co/blog/hdfs-tutorial" rel="nofollow" style="background-color:transparent;color:rgb(51,102,255);"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">之前的博客中</span></span></a></span></span></span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">，您已经知道HDFS是一个分布式文件系统，部署在低成本的商品硬件上。</span><span style="vertical-align:inherit;">所以，</span></span></span><span style="font-family:verdana, geneva, sans-serif;">这是</span><span style="font-family:verdana, geneva, sans-serif;">我们应该采取深入了解的Apache Hadoop的HDFS架构和解开它的美丽的时候了。</span></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;">Apache Hadoop HDFS体系结构的这个博客将涉及的主题如下：</span></p><ul style="color:rgb(51,51,51);font-family:'open sans', Arial, sans-serif;font-size:13px;background-color:rgb(255,255,255);text-align:justify;"><li style="text-align:justify;"><a href="https://www.edureka.co/blog/apache-hadoop-hdfs-architecture/#hdfs_architecture" rel="nofollow" style="background-color:transparent;color:rgb(51,122,183);"><span style="font-weight:700;"><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">HDFS主/从拓扑</span></span></a></li><li style="text-align:justify;"><span style="font-weight:700;"><span style="font-family:verdana, geneva, sans-serif;font-size:14px;"><a href="https://www.edureka.co/blog/apache-hadoop-hdfs-architecture/#namenode" rel="nofollow" style="background-color:transparent;color:rgb(51,122,183);"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">NameNode</span></span></a><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">，</span></span><a href="https://www.edureka.co/blog/apache-hadoop-hdfs-architecture/#datanode" rel="nofollow" style="background-color:transparent;color:rgb(51,122,183);"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">DataNode</span></span></a><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">和</span></span><a href="https://www.edureka.co/blog/apache-hadoop-hdfs-architecture/#secondary_namenode" rel="nofollow" style="background-color:transparent;color:rgb(51,122,183);"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">Secondary NameNode</span></span></a></span></span></li><li style="text-align:justify;"><a href="https://www.edureka.co/blog/apache-hadoop-hdfs-architecture/#hdfs_block" rel="nofollow" style="background-color:transparent;color:rgb(51,122,183);"><span style="font-weight:700;"><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">什么是块？</span></span></a></li><li style="text-align:justify;"><span style="font-weight:700;"><span style="font-family:verdana, geneva, sans-serif;font-size:14px;"><a href="https://www.edureka.co/blog/apache-hadoop-hdfs-architecture/#replication_management" rel="nofollow" style="background-color:transparent;color:rgb(51,122,183);">复制管理</a></span></span><a name="hdfs_architecture" style="background-color:transparent;color:rgb(51,122,183);"></a></li><li style="text-align:justify;"><a href="https://www.edureka.co/blog/apache-hadoop-hdfs-architecture/#rack_awareness" rel="nofollow" style="background-color:transparent;color:rgb(51,122,183);"><span style="font-weight:700;"><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">机架意识</span></span></a></li><li style="text-align:justify;"><a href="https://www.edureka.co/blog/apache-hadoop-hdfs-architecture/#hdfs_read_or_write_architecture" rel="nofollow" style="background-color:transparent;color:rgb(51,122,183);"><span style="font-weight:700;"><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">HDFS读/写 - 在幕后</span></span></a></li></ul><h2 style="font-family:'open sans', Arial, sans-serif;color:rgb(51,51,51);font-weight:500;line-height:1.1;font-size:30px;background-color:rgb(255,255,255);text-align:justify;"><span style="font-weight:700;"><span style="color:rgb(34,34,34);font-size:16px;font-family:verdana, geneva, sans-serif;">HDFS架构：</span></span></h2><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><img class="aligncenter size-large wp-image-36674" src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/11/HDFS-intoduction-HDFS-Tutorial-Edureka-489x300.png" alt="HDFS拓扑 -  Apache Hadoop HDFS架构 -  Edureka" width="489" height="300" style="border:0px;vertical-align:middle;display:list-item;margin-left:auto;min-width:1px !important;"></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span style="font-weight:700;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">Apache HDFS</span></span></span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">  或  </span></span><span style="font-weight:700;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">Hadoop分布式文件系统</span></span></span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">  是一个块结构的文件系统，其中每个文件被划分为预定大小的块。</span><span style="vertical-align:inherit;">这些块存储在一个或多个机器的集群中。</span><span style="vertical-align:inherit;">Apache Hadoop HDFS体系结构遵循  </span></span><span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">主/从体系结构</span></span></span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">，其中一个群集由单个NameNode（主节点）组成，其他所有节点都是DataNode（从节点）。</span></span><a name="namenode" style="background-color:transparent;color:rgb(51,122,183);"></a><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">HDFS可以部署在广泛的支持Java的机器上。</span><span style="vertical-align:inherit;">尽管可以在单台机器上运行多个DataNode，但在实际应用中，这些DataNode分布在各种机器上。</span></span></span></p><h2 style="font-family:'open sans', Arial, sans-serif;color:rgb(51,51,51);font-weight:500;line-height:1.1;font-size:30px;background-color:rgb(255,255,255);text-align:justify;"><span style="font-weight:700;"><span style="color:rgb(34,34,34);font-size:16px;font-family:verdana, geneva, sans-serif;">的NameNode：</span></span></h2><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);text-align:center;"><img class="aligncenter wp-image-40401" src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2013/05/Apache-Hadoop-HDFS-Architecture-Edureka.png" alt="Apache Hadoop HDFS架构 -  Edureka" width="653" height="337" style="border:0px;vertical-align:middle;display:list-item;margin-left:auto;min-width:1px !important;"></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">NameNode是Apache Hadoop HDFS体系结构中的主节点，用于维护和管理DataNode（从节点）上存在的块。</span></span></span><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">NameNode是一个高度可用的服务器，用于管理文件系统名称空间并控制客户端对文件的访问。</span><span style="vertical-align:inherit;">我将在下一篇博客中讨论Apache Hadoop HDFS的高可用性功能。</span><span style="vertical-align:inherit;">HDFS体系结构的构建方式是，用户数据永远不会驻留在NameNode上。</span><span style="vertical-align:inherit;">数据仅驻留在DataNode上。  </span></span></span></span></p><h3 style="font-family:'open sans', Arial, sans-serif;color:rgb(34,34,34);font-weight:500;line-height:1.1;font-size:18px;background-color:rgb(255,255,255);text-align:justify;"><span style="font-size:14px;"><span><span style="font-family:verdana, geneva, sans-serif;">NameNode的功能：</span></span></span></h3><ul style="color:rgb(51,51,51);font-family:'open sans', Arial, sans-serif;font-size:13px;background-color:rgb(255,255,255);text-align:justify;"><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">它是维护和管理DataNode（从节点）的主守护进程，</span></li><li><span style="font-size:14px;"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">它记录存储在集群中的所有文件的元数据，例如存储块的位置，</span></span></span><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">文件的大小，权限，层次结构等。有两个文件与元数据相关联：</span></span></span></span><ul><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;"><span style="font-weight:700;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">FsImage：</span></span></span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">  它包含自NameNode开始以来文件系统名称空间的完整状态。</span></span></span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;"><span style="font-weight:700;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">EditLogs：</span></span></span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">  它包含了最近对文件系统进行的所有关于最近的FsImage的修改。</span></span></span></li></ul></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">它记录对文件系统元数据发生的每个更改。</span><span style="vertical-align:inherit;">例如，如果一个文件在HDFS中被删除，NameNode会立即在EditLog中记录这个文件。</span></span></span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">它定期收到来自集群中所有DataNode的Heartbeat和Block报告，以确保DataNode处于活动状态。</span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">它保留了HDFS中所有块的记录以及这些块所在的节点。</span></li><li><span style="font-size:14px;"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">名称节点还负责采取照顾  </span></span><span style="font-weight:700;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">复制</span></span></span></span><span style="font-family:verdana, geneva, sans-serif;"><span style="font-weight:700;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">因子 </span></span></span></span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">的</span></span><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">所有这些，我们将较详细的HDFS教程博客后面讨论的块。</span></span></span></span><a name="datanode" style="background-color:transparent;color:rgb(51,122,183);"></a></li><li><span style="font-size:14px;"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">在  </span></span><span style="font-weight:700;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">DataNode失败的情况下</span></span></span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">，NameNode为新副本选择新的DataNode，</span></span></span> </span><span style="font-family:verdana, geneva, sans-serif;"><span style="font-size:14px;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">平衡</span></span></span> <span style="font-size:14px;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">磁盘使用并管理到DataNode的通信流量。</span></span></span></span></li></ul><h2 style="font-family:'open sans', Arial, sans-serif;color:rgb(51,51,51);font-weight:500;line-height:1.1;font-size:30px;background-color:rgb(255,255,255);text-align:justify;"><span style="font-weight:700;"><span style="color:rgb(34,34,34);font-size:16px;font-family:verdana, geneva, sans-serif;">数据节点：</span></span></h2><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">DataNode是HDFS中的从节点。</span><span style="vertical-align:inherit;">与NameNode不同的是，DataNode是一种商品硬件，也就是一个不昂贵的系统，它不具有高质量或高可用​​性。</span><span style="vertical-align:inherit;">DataNode是将数据存储在本地文件ext3或ext4中的块服务器。</span></span></span></p><h3 style="font-family:'open sans', Arial, sans-serif;color:rgb(34,34,34);font-weight:500;line-height:1.1;font-size:18px;background-color:rgb(255,255,255);text-align:justify;"><span><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">DataNode的功能：</span></span></h3><ul style="color:rgb(51,51,51);font-family:'open sans', Arial, sans-serif;font-size:13px;background-color:rgb(255,255,255);text-align:justify;"><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">这些是从属守护进程或在每个从属机器上运行的进程。</span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">实际的数据存储在DataNode上。</span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">DataNode执行文件系统客户端的低级读写请求。</span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">他们定期发送心跳到NameNode来报告HDFS的总体健康状况，默认情况下，这个频率设置为3秒。</span><a name="secondary_namenode" style="background-color:transparent;color:rgb(51,122,183);"></a></li></ul><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">到目前为止，您一定意识到NameNode对我们来说非常重要。</span><span style="vertical-align:inherit;">如果失败了，我们就注定了。</span><span style="vertical-align:inherit;">但是别担心，我们将讨论Hadoop如何解决下一个Apache Hadoop HDFS体系结构博客中的单点故障问题。</span><span style="vertical-align:inherit;">所以，现在就放松一下，让我们一步一个脚印吧。</span></span></span></p><h2 style="font-family:'open sans', Arial, sans-serif;color:rgb(51,51,51);font-weight:500;line-height:1.1;font-size:30px;background-color:rgb(255,255,255);text-align:justify;"><span style="font-weight:700;"><span style="color:rgb(34,34,34);font-size:16px;font-family:verdana, geneva, sans-serif;">次要名称节点：</span></span></h2><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">除了这两个守护进程之外，还有第三个守护进程或称为第二个NameNode的进程。</span><span style="vertical-align:inherit;">Secondary NameNode与主NameNode同时作为</span></span><span style="font-weight:700;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">助手守护进程工作。</span></span></span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">不要混淆Secondary NameNode作为</span></span><span style="font-weight:700;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">备份NameNode，因为它不是。</span></span></span></span></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);text-align:center;"><img class="aligncenter wp-image-36660 size-large" src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/11/Secondary-NameNode-Function-Apache-Hadoop-HDFS-Architecture-Edureka-528x185.png" alt="Secondary NameNode函数 -  Apache Hadoop HDFS体系结构 -  Edureka" width="528" height="185" style="border:0px;vertical-align:middle;display:list-item;margin-left:auto;min-width:1px !important;"></p><h3 style="font-family:'open sans', Arial, sans-serif;color:rgb(34,34,34);font-weight:500;line-height:1.1;font-size:18px;background-color:rgb(255,255,255);text-align:justify;"><span><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">Secondary NameNode的功能：</span></span></h3><ul style="color:rgb(51,51,51);font-family:'open sans', Arial, sans-serif;font-size:13px;background-color:rgb(255,255,255);text-align:justify;"><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">Secondary NameNode是一个不断读取NameNode的RAM中的所有文件系统和元数据并将其写入硬盘或文件系统的节点。</span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">它负责将EditLogs </span></span><span> </span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">和NameNode中</span><span style="vertical-align:inherit;">的FsImage结合起来</span><span style="vertical-align:inherit;">。 </span></span></span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">它会定期从NameNode下载EditLogs并应用于FsImage。</span><span style="vertical-align:inherit;">新的FsImage被复制回NameNode，NameNode在下次启动时使用。</span></span></span><a name="hdfs_block" style="background-color:transparent;color:rgb(51,122,183);"></a></li></ul><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">因此，Secondary NameNode在HDFS中执行常规检查点。</span><span style="vertical-align:inherit;">因此，它也被称为CheckpointNode。</span></span></span></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);text-align:center;"><a class="maxbutton-10 maxbutton maxbutton-enroll-blue-medium" href="https://www.edureka.co/big-data-and-hadoop" rel="nofollow" style="background:rgb(0,120,176);color:rgb(51,122,183);display:inline-block;border-color:rgb(55,120,176);width:210px;border-style:solid;border-width:0px;"><span class="mb-text" style="color:rgb(255,255,255);font-size:13px;font-weight:bold;line-height:1em;display:block;"><span style="vertical-align:inherit;">成为HDFS专家！</span></span></a></p><h2 style="font-family:'open sans', Arial, sans-serif;color:rgb(51,51,51);font-weight:500;line-height:1.1;font-size:30px;background-color:rgb(255,255,255);text-align:justify;"><span style="font-weight:700;"><span style="color:rgb(34,34,34);font-size:16px;font-family:verdana, geneva, sans-serif;">块：</span></span></h2><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">现在，</span></span></span> <span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">因为</span></span></span></span><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">我们知道，在HDFS的数据被分散在作为的DataNodes块。</span></span><span style="font-weight:700;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">让我们看看什么是块，它是如何形成的？</span></span></span></span></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">块是硬盘上存储数据的最小连续位置。</span><span style="vertical-align:inherit;">通常，在任何文件系统中，都将数据存储为块的集合。</span><span style="vertical-align:inherit;">同样，HDFS将每个文件存储为遍布Apache Hadoop集群的块。</span><span style="vertical-align:inherit;">Apache Hadoop 2中每个块的默认大小为128 MB</span></span></span><span style="vertical-align:inherit;">。</span><span style="font-family:verdana, geneva, sans-serif;">x（Apache Hadoop</span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;"> 1.x中为</span><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;">64 MB </span></span></span><span style="font-family:verdana, geneva, sans-serif;">），您可以按照您的要求进行配置。</span></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><img class="aligncenter wp-image-36357 size-large" src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/10/HDFS-File-Block-Apache-Hadoop-HDFS-Architecture-Edureka-528x91.png" alt="HDFS体系结构 -  HDFS教程简介在这篇博客中，我们将讨论HDFS体系结构。 从我之前的博客中，我们已经知道HDFS是一个分布式文件系统，部署在低成本的商品硬件上。 我也讨论了它的许多功能。 因此，我们深入了解Apache Hadoop HDFS体系结构并释放它的美好之处。 本博客将讨论的主题如下：•HDFS主/从拓扑•NameNode和DataNode•什么是块•复制管理•机架感知•HDFS读/写 - 幕后HDFS体系结构HDFS或Hadoop分布式文件系统是一个块结构的文件系统，其中每个文件被分成预定大小的块。 这些块存储在一个或多个机器的集群中。 Apache Hadoop HDFS体系结构遵循主/从体系结构，其中一个群集由单个NameNode（主节点）组成，其他所有节点都是DataNode（从节点）。 HDFS基于Java编程语言，因此HDFS可以部署在广泛的支持Java的机器上。 虽然可以在单台机器上运行多个DataNode，但在实际应用中，这些DataNode分布在各种机器上。 NameNode和DataNode NameNode：NameNode是HDFS的主节点，负责维护和管理DataNode（从节点）上存在的块。 把NameNode想象成一辆兰博基尼在其他各种汽车中。 因此，像兰博基尼一样，NameNode是一个高度可用的服务器，用于管理文件系统名字空间并控制客户对文件的访问。 我将在下一篇博客中讨论Apache Hadoop HDFS的高可用性功能。 HDFS体系结构的构建方式是，用户数据永远不会存储在NameNode中。 数据仅驻留在DataNode上。 NameNode的功能：•它是维护和管理DataNode（从属节点）的主守护进程•它记录集群中存储的所有文件的元数据，例如存储块的位置，文件大小，权限，层次结构等有两个与元数据相关的文件：o FsImage：启动NameNode时的文件系统映像。 EditLogs：启动NameNode后对文件系统进行的一系列修改。 它记录对文件系统元数据发生的每个更改。 例如，如果一个文件在HDFS中被删除，NameNode会立即在EditLog中记录这个文件。 •定期从集群中的所有DataNode接收Heartbeat和Block报告，以确保DataNode处于活动状态。 它保存HDFS中所有块的记录以及这些块所在的节点。 •NameNode还负责处理所有块的复制因子，我们将在本HDFS教程博客中稍后详细讨论。 •如果DataNode发生故障，NameNode为新副本选择新的DataNode，平衡磁盘使用并管理到DataNode的通信流量。 DataNode：DataNode是HDFS中的从节点，就像在兰博基尼面前的任何普通车辆一样！ 与NameNode不同的是，DataNode是一种商品硬件，也就是一个不昂贵的系统，它不具有高质量或高可用​​性。 DataNode是将数据存储在本地文件ext3或ext4中的块服务器。 DataNode的功能：•这些是从属守护进程或在每个从属机器上运行的进程。 •实际数据存储在DataNode中。 •DataNode执行文件系统客户端的低级读写请求。 •定期向NameNode发送心跳报告HDFS的整体健康状况，默认情况下，该频率设置为3秒。 所以，到现在为止，你们一定意识到NameNode对我们来说非常重要。 如果失败了，我们就注定了。 但是别担心，我们将讨论Hadoop如何在下一个HDFS教程博客中解决这个单点故障问题。 所以，现在就放松一下，让我们一步一个脚印吧。 Secondary NameNode除了这两个守护进程之外，还有第三个守护进程或称为Secondary NameNode的进程。 Secondary NameNode与主NameNode同时作为助手守护进程工作。 不要将Secondary NameNode混淆为备份NameNode，因为它不是。 Secondary NameNode的功能：Secondary NameNode是一种不断从NameNode的RAM中读取所有文件系统和元数据并将其写入硬盘或文件系统的功能。 它负责将EditLog与NameNode中的FsImage结合起来。 •定期从NameNode下载EditLog，并将其应用于FsImage。 新的FsImage被复制回NameNode，NameNode在下次启动时使用。 因此，Secondary NameNode只是在HDFS中执行常规检查点。 因此，它也被称为CheckpointNode。 块现在我们知道HDFS中的数据以块的形式分散在DataNode中。 让我们来看看什么是块，它是如何形成的？ 块是硬盘中存储数据的最小的连续位置。 一般来说，在任何文件系统中，数据都被存储为块的集合。 同样，HDFS将每个文件存储为遍布Apache Hadoop集群的块。 在Apache Hadoop 2.x（Apache Hadoop 1.x中为64 MB）中，每个块的默认大小为128MB，您可以按照您的要求进行配置。 HDFS中没有必要将每个文件存储在配置块大小（128MB，256MB等）的确切倍数中。 让我们举一个例子，我有一个大小为514MB的文件“example.txt”，如上图所示。 假设我们使用128Mb的默认块大小配置。 那么，多少块会被创建？ 5，对。 前四个块将是128 MB。 但， 最后一个块将只有2 MB大小。 现在你一定在想为什么我们需要有这么大的块大小，即128MB？ 那么，每当我们谈论HDFS时，我们都会谈论巨大的数据集，即TB级和PB级的数据。 所以，如果我们有一个像Linux文件系统那样的4KB的块大小，我们将会有太多的块，因此元数据太多。 所以，管理这些没有。 块和元数据会产生巨大的开销，这是我们不想要的。 正如你理解一个块是什么，让我们了解这些块是如何在下一节的地方。 复制管理和机架感知复制管理：HDFS提供了一种可靠的方式来将大量数据作为数据块存储在分布式环境中。 块也复制提供容错。 默认的复制因子是3，可以再次配置。 因此，如果您想在HDFS中存储1GB的文件，则考虑到默认配置，您将占用总共3GB（复制因子= 3）和24（1GB / 128MB = 8个数据块）数据块的空间。 不要担心，如果你一次没有得到数学。 把你的时间，然后继续前进。 NameNode定期从DataNode收集块报告以维护复制因子。 因此，每当块被过度复制或被复制时，NameNode会根据需要删除或添加副本。 机架意识：无论如何，前进，让我们来谈谈如何放置副本和什么是机架感知？ 同样，NameNode也确保所有副本不存储在同一个机架或单个机架上。 它遵循内置的机架感知算法来减少延迟。 考虑到复制因子是3， 机架感知算法指出，块的第一个副本将存储在本地机架上，接下来的两个副本将存储在不同（远程）机架上，但存储在该（远程）机架中的不同DataNode上。 如果有更多的副本，其余的副本将放置在随机的DataNode上，如果可能的话，提供不超过两个副本驻留在同一个机架上。 这就是实际的Hadoop生产集群的外观。 在这里，你有多个机架填充了许多DataNode。 机架感知的优点：所以现在你会想，为什么我们需要机架感知算法？ 原因如下：•提高网络性能：驻留在不同机架上的节点之间的通信是通过交换机进行的。 一般来说， 您将发现机架中的机器之间的网络带宽比驻留在不同机架中的机器之间的带宽要大。 因此，机架感知可以帮助您减少不同机架之间的写入流量，从而提供更好的写入性能。 而且，由于您使用多个机架的带宽，您将获得更高的读取性能。 •防止数据丢失：即使由于交换机故障或电源故障导致整个机架出现故障，我们也不必担心数据。 如果你仔细想一想，那就是说，不要把所有的鸡蛋放在同一个篮子里。 HDFS读写架构现在让我们来讨论如何在HDFS上执行数据读/写操作。 HDFS遵循“一次写入 - 读取多个”的理念。 所以，你不能编辑已经存储在HDFS中的文件。 但， 你可以在文件中附加新的数据。 HDFS写入架构：想象一下，一个HDFS客户端，想写一个名为“example.txt”的文件，大小为248MB。 假定系统块大小配置为128 MB（默认值）。 因此，客户端将文件“example.txt”分成两个块 -  128MB（块A）和120MB（块B）中的一个。 现在，当数据写入HDFS时，将遵循以下协议：•首先，HDFS客户端将与NameNode进行联系，以获得针对两个块，即块A和块B的写入请求。•NameNode将然后授予客户端写入权限，并将提供将最终复制文件块的DataNode的IP地址。 •DataNode的IP地址选择是根据可用性纯粹随机化的， 复制因素和机架意识，我们之前已经讨论过。 假设复制因子被设置为默认值，例如3.因此，对于每个块，NameNode将向客户端提供（3）DataNode的IP地址的列表。 该列表对于每个块将是唯一的。 •假设NameNode为客户端提供了以下IP地址列表：o对于块A，列表A = {DataNode 1的IP，DataNode 4的IP，DataNode 5的IP} o对于Block B，设置B = {IP DataNode 3，DataNode 7的IP，DataNode 9的IP}•将每个块复制到三个不同的DataNode中，以保持复制因子一致。 •现在整个数据复制过程将分三个阶段进行：1.管道设置2.数据流和复制3.关闭管道（确认阶段）1.管道设置：在写入块之前， 客户端确认每个IP列表中的DataNode是否准备好接收数据。 为此，客户端通过连接该块的相应列表中的各个DataNode来为每个块创建管道。 让我们考虑块A.由NameNode提供的DataNode的列表是：对于块A，列表A = {DataNode 1的IP，DataNode 4的IP，DataNode 5的IP}。 因此，对于块A，客户端将执行以下步骤来创建一个管道：客户端将选择列表中的第一个DataNode（数据节点A的数据节点IP），它是DataNode 1，并将打开一个TCP / IP连接。 客户端将通知DataNode 1准备好接收该块。 它还将提供下一个DataNode（4和5）的IP地址，其中块将被复制。 DataNode 1将连接到DataNode 4。 数据节点1将通知数据节点4准备好接收数据块，并将其给予数据节点5的IP。然后，数据节点4将告诉数据节点5准备好接收数据。 接下来，准备就绪的确认将按照相反的顺序进行，即从数据节点5到数据节点4，然后到数据节点1.最后DataNode 1将通知客户端所有数据节点都准备就绪，并且在客户端，数据节点1,4和5.现在流水线设置完成，客户端将最终开始数据复制或流处理。 2.数据流：由于流水线已经创建，客户端会将数据推送到流水线中。 现在，不要忘记，在HDFS中，数据是基于复制因子进行复制的。 所以，假设复制因子为3，则块A将被存储到三个DataNode中。向前移动， 客户端将只将块（A）复制到DataNode 1。 复制总是由DataNode按顺序完成。 因此，在复制过程中将执行以下步骤：一旦将块写入DataNode 1，它将连接到DataNode 4.然后，将会推送管道中的块，并将数据复制到DataNode 4中。 ，DataNode 4将连接到DataNode 5并将复制该块。 3.关闭流水线或确认阶段：一旦块被复制到所有三个DataNode中，将发生一系列确认，以确保客户端和NameNode确认数据已成功写入。 客户端将最终关闭管道来结束TCP会话。 如图所示，确认以相反的顺序发生，即从DataNode 5到4，然后到1.最后， DataNode 1会将三个确认（包括它自己的）推送到管道中并发送给客户端。 客户端将通知NameNode数据已成功写入。 NameNode将更新其元数据，客户端将关闭管道。 同样，Block B也会被复制到与Block A并行的DataNode中。但是，这里需要注意以下几点：Client将Block A和Block B同时复制到第一个DataNode。 因此，在我们的情况下，将为每个区块形成两条管线，上述讨论过程将在这两条管线中并行进行。 客户端将数据块写入第一个数据节点，然后DataNode将依次复制数据块。 伙计们！ 现在是一个测验的时间：在HDFS中，一个文件的块被并行写入， 但是这些块的复制是按顺序进行的：a。 对b。 假的。 对，伙计们。 所以，如果你仍然感到困惑，请再次通过HDFS写入体系结构。 我相信这次你会明白的。 HDFS读取架构：HDFS读取架构比较容易理解。 让我们再次上面的例子，HDFS客户端想要读取HDFS中已经存在的文件“example.txt”。 现在，读取文件时将执行以下步骤：•客户端将联系NameNode，请求文件example.txt的块元数据。 •NameNode将返回存储每个块（块A和块B）的DataNode列表。 •客户端之后，将连接到存储块的DataNode。 •客户端开始从数据节点（数据节点1的块A和数据节点5的块B）并行读取数据。 一旦获得所有必需的文件块，它将把这些块组合起来形成一个文件。 在提供客户端的读取请求时，HDFS选择最接近客户端的副本。 这减少了读取延迟和带宽消耗。 因此，如果可能，选择与阅读器节点位于同一机架上的副本。" width="528" height="91" style="border:0px;vertical-align:middle;display:list-item;margin-left:auto;min-width:1px !important;"></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">HDFS中没有必要将每个文件存储在配置块大小（128 MB，256 MB等）的确切倍数中。</span><span style="vertical-align:inherit;">我们举一个例子，其中有一个大小为514 MB的文件“example.txt”，如上图所示。</span><span style="vertical-align:inherit;">假设我们使用块大小的默认配置，即</span></span></span><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">128 MB。</span><span style="vertical-align:inherit;">那么，多少块会被创建？</span><span style="vertical-align:inherit;">5，对。</span><span style="vertical-align:inherit;">所述</span></span></span><span style="font-family:verdana, geneva, sans-serif;"><span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">˚F</span></span></span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;"> IRST </span></span><span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">四个块将是</span></span></span></span><span style="vertical-align:inherit;">的</span><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">128 MB。</span><span style="vertical-align:inherit;">但是，最后一个块将只有2 MB大小。</span></span></span></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span style="font-weight:700;">现在，你一定在想为什么我们需要有这么大的块大小，即128 MB？</span></span></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">那么，每当我们谈论HDFS的时候，我们都会谈论巨大的数据集，即TB级和PB级的数据。</span><span style="vertical-align:inherit;">所以，如果我们有4 KB的块大小，就像在Linux文件系统中一样，我们会有太多的块，因此太多的元数据。</span><span style="vertical-align:inherit;">所以，管理这些没有。</span></span></span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">的</span></span><span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">块和元数据，将创造巨大的开销</span></span></span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">，</span></span><span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">这是一件好事，我们不想要的。</span></span></span></span><span style="font-family:verdana, geneva, sans-serif;"> </span></p><div style="color:rgb(51,51,51);font-family:'open sans', Arial, sans-serif;font-size:13px;background-color:rgb(255,255,255);"><h2 style="font-family:inherit;color:inherit;font-weight:500;line-height:1.1;font-size:30px;text-align:justify;"><span style="font-weight:700;"><span style="font-family:verdana, geneva, sans-serif;font-size:16px;">复制管理：</span></span></h2></div><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">HDFS提供了一种可靠的方式来将大数据作为数据块存储在分布式环境中。</span><span style="vertical-align:inherit;">块也复制提供容错。</span><span style="vertical-align:inherit;">默认的复制因子是3，可以再次配置。</span><span style="vertical-align:inherit;">因此，如下图所示，每个块被复制三次并存储在不同的DataNode中（考虑默认的复制因子）： </span></span><img class="aligncenter wp-image-36374" src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/10/Replication-Management-Apache-Hadoop-HDFS-Architecture-Edureka-Blog.png" alt="复制管理 -  Apache Hadoop HDFS体系结构 -  Edureka" width="618" height="394" style="border:0px;vertical-align:middle;display:list-item;margin-left:auto;min-width:1px !important;"></span></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;">因此，如果使用默认配置在HDFS中存储128 MB的文件，则最终将占用384 MB（3 * 128 MB）的空间，因为块将被复制三次，每个副本将驻留在不同的DataNode。 </span><a name="rack_awareness" style="background-color:transparent;color:rgb(51,122,183);"></a></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span><span style="font-weight:700;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">注意：</span></span></span></span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;"> NameNode定期从DataNode收集块报告以维护复制因子。</span><span style="vertical-align:inherit;">因此，每当块被过度复制或被复制时，NameNode会根据需要删除或添加副本。 </span></span></span></p><h2 style="font-family:'open sans', Arial, sans-serif;color:rgb(51,51,51);font-weight:500;line-height:1.1;font-size:30px;background-color:rgb(255,255,255);text-align:justify;"><span style="font-weight:700;"><span style="color:rgb(34,34,34);font-size:16px;font-family:verdana, geneva, sans-serif;">机架意识：</span></span></h2><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><img class="aligncenter wp-image-40402" src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2013/05/Rack-Awareness-Apache-Hadoop-HDFS-Architecture-Edureka.png" alt="机架感知 -  Apache Hadoop HDFS体系结构 -  Edureka" width="643" height="340" style="border:0px;vertical-align:middle;display:list-item;margin-left:auto;min-width:1px !important;"></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">总而言之，让我们来进一步讨论HDFS如何放置副本以及什么是机架感知？</span><span style="vertical-align:inherit;">同样，NameNode也确保所有副本不存储在同一个机架或单个机架上。</span><span style="vertical-align:inherit;">它遵循内置的机架感知算法来减少延迟并提供容错功能。</span><span style="vertical-align:inherit;">考虑到复制因子是3，机架感知算法认为块的第一个副本将被存储在本地机架上，接下来的两个副本将被存储在不同的（远程）机架上，但是在不同的DataNode中（远程）机架，如上图所示。</span><span style="vertical-align:inherit;">如果有更多的副本，其余的副本将放置在随机的DataNode上，如果可能的话，提供不超过两个副本驻留在同一个机架上。</span></span></span></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">这就是实际的Hadoop生产集群的外观。</span><span style="vertical-align:inherit;">在这里，你有多个机架填充DataNode：</span></span></span></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);text-align:center;"><span style="font-family:verdana, geneva, sans-serif;"> <img class="aligncenter wp-image-36738" src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/11/Hadoop-cluster-Apache-Hadoop-HDFS-Architecture-Edureka-1.png" alt="Hadoop集群 -  Apache Hadoop HDFS体系结构 -  Edureka" width="607" height="485" style="border:0px;vertical-align:middle;display:list-item;margin-left:auto;min-width:1px !important;"><br></span></p><h3 style="font-family:'open sans', Arial, sans-serif;color:rgb(34,34,34);font-weight:500;line-height:1.1;font-size:18px;background-color:rgb(255,255,255);text-align:justify;"><span style="font-family:verdana, geneva, sans-serif;font-size:16px;">机架感知的优势：</span></h3><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">那么，现在你会想到为什么我们需要Rack Awareness算法？</span><span style="vertical-align:inherit;">原因是：</span></span></span></p><ul style="color:rgb(51,51,51);font-family:'open sans', Arial, sans-serif;font-size:13px;background-color:rgb(255,255,255);text-align:justify;"><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;"><span style="font-weight:700;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">提高网络性能：</span></span></span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">驻留在不同机架上的节点之间的通信是通过交换机进行的。</span><span style="vertical-align:inherit;">一般情况下，</span><span style="vertical-align:inherit;">在同一机架中的机器之间的</span></span><span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">网络带宽</span></span></span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">要比驻留在不同机架的机器之间的</span><span><span style="vertical-align:inherit;">带宽</span></span><span style="vertical-align:inherit;">要大。</span><span style="vertical-align:inherit;">因此，机架感知可以帮助您减少不同机架之间的写入流量，从而提供更好的写入性能。</span><span style="vertical-align:inherit;">而且，由于您使用多个机架的带宽，您将获得更高的读取性能。</span></span></span></li></ul><ul style="color:rgb(51,51,51);font-family:'open sans', Arial, sans-serif;font-size:13px;background-color:rgb(255,255,255);text-align:justify;"><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;"><span style="font-weight:700;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">为了防止数据丢失：</span></span></span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">即使由于交换机故障或电源故障导致整个机架出现故障，我们也不必担心数据。</span><span style="vertical-align:inherit;">如果你仔细想一想，那就是说，</span></span><span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">不要把所有的鸡蛋都放在同一个篮子里。</span></span></span></span><a name="hdfs_read_or_write_architecture" style="background-color:transparent;color:rgb(51,122,183);"></a></li></ul><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);text-align:center;"><a class="maxbutton-22 maxbutton maxbutton-certification-blue-big" href="https://www.edureka.co/big-data-and-hadoop" rel="nofollow" style="background:rgb(0,120,176);color:rgb(51,122,183);display:inline-block;border-color:rgb(55,120,176);width:280px;border-style:solid;border-width:0px;"><span class="mb-text" style="color:rgb(255,255,255);font-size:13px;font-weight:bold;line-height:1em;display:block;"><span style="vertical-align:inherit;">查看我们的Hadoop课程</span></span></a></p><h2 style="font-family:'open sans', Arial, sans-serif;color:rgb(51,51,51);font-weight:500;line-height:1.1;font-size:30px;background-color:rgb(255,255,255);text-align:justify;"><span style="font-weight:700;"><span style="color:rgb(34,34,34);font-size:16px;font-family:verdana, geneva, sans-serif;">HDFS读/写架构：</span></span><a name="hdfs_write_architecture" style="background-color:transparent;color:rgb(51,122,183);"></a></h2><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">现在让我们来讨论如何在HDFS上执行数据读/写操作。</span><span style="vertical-align:inherit;">HDFS遵循“一次写入 - 读许多哲学”。</span><span style="vertical-align:inherit;">所以，你不能编辑已经存储在HDFS中的文件。</span><span style="vertical-align:inherit;">但是，您可以通过重新打开文件来附加新的数据。</span></span></span></p><h2 style="font-family:'open sans', Arial, sans-serif;color:rgb(51,51,51);font-weight:500;line-height:1.1;font-size:30px;background-color:rgb(255,255,255);text-align:justify;"><span style="font-weight:700;"><span style="color:rgb(34,34,34);font-size:16px;font-family:verdana, geneva, sans-serif;">HDFS写入架构：</span></span></h2><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;">假设一个HDFS客户端想写一个名为“example.txt”的文件，大小为248 MB。</span></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><img class="aligncenter wp-image-36545" src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/11/HDFS-File-Blocks-Apache-Hadoop-HDFS-Architecture-Edureka.png" alt="HDFS文件块，Apache的Hadoop的HDFS架构，edureka" width="416" height="128" style="border:0px;vertical-align:middle;display:list-item;margin-left:auto;min-width:1px !important;"></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">假定系统块大小配置为128 MB（默认）。</span><span style="vertical-align:inherit;">因此，客户端将文件“example.txt”分成两个块 - 128MB（块A）和120MB（块B）中的一个。 </span></span></span></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;">现在，每当将数据写入HDFS时，将遵循以下协议：</span></p><ul style="color:rgb(51,51,51);font-family:'open sans', Arial, sans-serif;font-size:13px;background-color:rgb(255,255,255);text-align:justify;"><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">首先，HDFS客户端将与NameNode进行联系，以获得针对两个块（例如，块A和块B）的写入请求。</span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">然后，NameNode将授予客户端写入权限，并将提供将最终复制文件块的DataNode的IP地址。</span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">DataNode的IP地址的选择是基于我们前面讨论的可用性，复制因素和机架感知的纯粹随机化。</span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">假设复制因子被设置为默认值，即3.因此，对于每个块，NameNode将向客户端提供（3）DataNode的IP地址的列表。</span><span style="vertical-align:inherit;">该列表对于每个块将是唯一的。</span></span></span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">假设NameNode为客户端提供了以下IP地址列表： </span><ul><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">对于数据块A，列表A = {数据节点1的IP，数据节点4的IP，数据节点6的IP}</span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">对于Block B，设置B = {DataNode 3的IP，DataNode 7的IP，DataNode 9的IP}</span></li></ul></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">每个块将被复制到三个不同的DataNode中，以保持复制因子在整个群集中保持一致。</span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">现在整个数据复制过程将分三个阶段进行：</span></li></ul><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);text-align:center;"><img class="aligncenter wp-image-36664" src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/11/HDFS-Pipeline-Apache-Hadoop-HDFS-Architecture-Edureka.png" alt="HDFS管道 -  Apache Hadoop HDFS体系结构 -  Edureka" width="531" height="136" style="border:0px;vertical-align:middle;display:list-item;margin-left:auto;min-width:1px !important;"></p><ol style="color:rgb(51,51,51);font-family:'open sans', Arial, sans-serif;font-size:13px;background-color:rgb(255,255,255);"><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">管道的设置</span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">数据流和复制</span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">管道关闭（确认阶段） </span></li></ol><h3 style="font-family:'open sans', Arial, sans-serif;color:rgb(34,34,34);font-weight:500;line-height:1.1;font-size:18px;background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;font-size:16px;"><span style="font-weight:700;">1.管道设置：</span></span></h3><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">在写入块之前，</span></span></span> <span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">客户端确认每个IP列表中的DataNode是否准备好接收数据。</span></span></span> <span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">这样做时，客户端通过连接该块的各个列表中的各个DataNode来为每个块创建一个管道。</span><span style="vertical-align:inherit;">让我们考虑块A.由NameNode提供的DataNode的列表是</span></span></span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">：</span></span></span></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);text-align:center;"><span style="font-family:verdana, geneva, sans-serif;"><span style="font-weight:700;">对于块A，列表A = {数据节点1的IP，数据节点4的IP，数据节点6的IP}。 </span></span></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);text-align:center;"><img class="aligncenter wp-image-36919" src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/11/HDFS-Pipeline-Set-up-Apache-Hadoop-HDFS-Architecture-Edureka-1.png" alt="HDFS管道设置 -  Apache Hadoop HDFS体系结构 -  Edureka" width="586" height="427" style="border:0px;vertical-align:middle;display:list-item;margin-left:auto;min-width:1px !important;"></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;">因此，对于块A，客户端将执行以下步骤来创建管道：</span></p><ul style="color:rgb(51,51,51);font-family:'open sans', Arial, sans-serif;font-size:13px;background-color:rgb(255,255,255);text-align:justify;"><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">客户端将选择DataNode 1的列表中的第一个DataNode（数据节点A的数据节点IP），并建立TCP / IP连接。</span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">客户端将通知DataNode 1准备好接收该块。</span><span style="vertical-align:inherit;">它还将提供接下来两个DataNode（4和6）的IP给应该被复制块的DataNode 1。</span></span></span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">数据节点1将连接到数据节点4.数据节点1将通知数据节点4准备好接收数据块，并将其给予数据节点6的IP。然后，数据节点4将告诉数据节点6准备好接收数据。</span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">接下来，准备就绪的确认将遵循相反的顺序，即从DataNode 6到4，然后到1。</span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">DataNode 1最后会通知客户端所有的DataNode已经准备就绪，并且在客户端DataNode 1,4和6之间将形成一个流水线。</span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">现在流水线设置完成，客户端将最终开始数据复制或流式处理。</span></li></ul><h3 style="font-family:'open sans', Arial, sans-serif;color:rgb(34,34,34);font-weight:500;line-height:1.1;font-size:18px;background-color:rgb(255,255,255);"><span style="font-size:16px;font-family:verdana, geneva, sans-serif;"><span style="font-weight:700;">2.数据流：</span></span></h3><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">由于管道已经创建，客户端将把数据推送到管道中。</span><span style="vertical-align:inherit;">现在，不要忘记，在HDFS中，数据是基于复制因子进行复制的。</span><span style="vertical-align:inherit;">所以，这里假设复制因子是3，块A将被存储到三个DataNode中。向前移动，客户端将只将块（A）复制到DataNode 1。</span><span style="vertical-align:inherit;">复制总是由DataNode按顺序完成。</span></span></span></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><img class="aligncenter wp-image-36920" src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/11/HDFS-Write-Apache-Hadoop-HDFS-Architecture-Edureka-1.png" alt="HDFS写入 -  Apache Hadoop HDFS架构 -  Edureka" width="607" height="417" style="border:0px;vertical-align:middle;display:list-item;margin-left:auto;min-width:1px !important;"></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;">因此，在复制过程中将执行以下步骤：</span></p><ul style="color:rgb(51,51,51);font-family:'open sans', Arial, sans-serif;font-size:13px;background-color:rgb(255,255,255);text-align:justify;"><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">一旦块被客户端写入数据节点1，数据节点1将连接到数据节点4。</span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">然后，DataNode 1将会推送管道中的数据块，数据将被复制到DataNode 4。</span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">同样，DataNode 4将连接到DataNode 6，并将复制块的最后一个副本。</span></li></ul><h3 style="font-family:'open sans', Arial, sans-serif;color:rgb(34,34,34);font-weight:500;line-height:1.1;font-size:18px;background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;font-size:16px;"><span style="font-weight:700;">3.关闭管道或确认阶段：</span></span></h3><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">一旦块被复制到所有三个DataNode中，就会发生一系列确认，确保客户端和NameNode确认数据已成功写入。</span><span style="vertical-align:inherit;">然后，客户端将最终关闭管道来结束TCP会话。</span></span></span></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">如下图所示，确认以相反的顺序发生，即从DataNode 6到4，然后到1.最后，DataNode 1将三个确认（包括它自己的）推送到流水线并发送给客户端。</span><span style="vertical-align:inherit;">客户端将通知NameNode数据已成功写入。</span><span style="vertical-align:inherit;">NameNode将更新其元数据，客户端将关闭管道。</span></span></span></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><img class="aligncenter wp-image-36921" src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/11/HDFS-Write-Acknowledgement-Apache-Hadoop-HDFS-Architecture-Edureka-1.png" alt="HDFS写入确认 -  Apache Hadoop HDFS体系结构 -  Edureka" width="628" height="457" style="border:0px;vertical-align:middle;display:list-item;margin-left:auto;min-width:1px !important;"></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;">类似地，块B也将被复制到与块A并行的DataNode中。因此，下面将注意到以下事项：</span></p><ul style="color:rgb(51,51,51);font-family:'open sans', Arial, sans-serif;font-size:13px;background-color:rgb(255,255,255);text-align:justify;"><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">客户端将块A和嵌段B复制到第一数据节点</span></span><span style="font-weight:700;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">同时</span></span></span><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">。</span></span></span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">因此，在我们的情况下，将为每个区块形成两条管线，上述所有过程将在这两条管线中并行发生。</span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">客户端将数据块写入第一个数据节点，然后DataNode将依次复制数据块。</span></li></ul><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);text-align:center;"><img class="aligncenter wp-image-36923" src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/11/HDFS-Multi-Write-Pipeline-Apache-Hadoop-HDFS-Architecture-Edureka.png" alt="HDFS多重写入管道 -  Apache Hadoop HDFS架构 -  Edureka" width="619" height="431" style="border:0px;vertical-align:middle;display:list-item;margin-left:auto;min-width:1px !important;"></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">如上图所示，每个块（A和B）都有两条流水线。</span><span style="vertical-align:inherit;">以下是各个管道中每个区块正在进行的操作流程：</span></span></span><a name="hdfs_read_architecture" style="background-color:transparent;color:rgb(51,122,183);"></a></p><ul style="color:rgb(51,51,51);font-family:'open sans', Arial, sans-serif;font-size:13px;background-color:rgb(255,255,255);"><li style="text-align:justify;"><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">对于方框A：1A - &gt; 2A - &gt; 3A - &gt; 4A</span></li><li style="text-align:justify;"><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">对于块B：1B→2B→3B→4B→5B→6B </span></li></ul><h2 style="font-family:'open sans', Arial, sans-serif;color:rgb(51,51,51);font-weight:500;line-height:1.1;font-size:30px;background-color:rgb(255,255,255);text-align:justify;"><span style="font-weight:700;"><span style="color:rgb(34,34,34);font-size:16px;font-family:verdana, geneva, sans-serif;">HDFS读取架构：</span></span></h2><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">HDFS读取架构比较容易理解。</span><span style="vertical-align:inherit;">我们再来看看上面的例子，HDFS客户端现在想要读取文件“example.txt”。</span></span></span></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);text-align:center;"><img class="aligncenter wp-image-36924" src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/11/HDFS-Read-Apache-Hadoop-HDFS-Architecture-Edureka-1.png" alt="HDFS读取 -  Apache Hadoop HDFS架构 -  Edureka" width="611" height="445" style="border:0px;vertical-align:middle;display:list-item;margin-left:auto;min-width:1px !important;"></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;">现在，下面的步骤将在阅读文件时发生：</span></p><ul style="color:rgb(51,51,51);font-family:'open sans', Arial, sans-serif;font-size:13px;background-color:rgb(255,255,255);text-align:justify;"><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">客户端将与NameNode联系，询问文件“example.txt”的块元数据。</span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">NameNode将返回存储每个块（块A和块B）的DataNode列表。</span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">在那个客户端之后，将连接到存储块的DataNode。</span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">客户端开始从DataNode并行读取数据（DataNode 1的Block A和DataNode 3的Block B）。</span></li><li><span style="font-family:verdana, geneva, sans-serif;font-size:14px;">一旦客户端获得了所有必需的文件块，它将把这些块组合起来形成一个文件。</span></li></ul><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">在提供客户端的读取请求时，HDFS选择最接近客户端的副本。</span><span style="vertical-align:inherit;">这减少了读取延迟和带宽消耗。</span><span style="vertical-align:inherit;">因此，如果可能，选择与阅读器节点位于同一机架上的副本。</span></span></span></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">现在，您应该对Apache Hadoop HDFS体系结构有一个很好的想法。</span><span style="vertical-align:inherit;">我知道这里有很多信息，可能并不容易。</span><span style="vertical-align:inherit;">我建议你再来一遍，我相信你会发现这一次更容易。</span><span style="vertical-align:inherit;">现在，在我的下一篇博客中，我将讨论Apache Hadoop HDFS联合和高可用性体系结构。</span></span></span></p><p style="font-size:14px;color:rgb(68,68,68);line-height:26px;font-family:'open sans';background-color:rgb(255,255,255);"><span style="font-family:verdana, geneva, sans-serif;"><span style="vertical-align:inherit;"><span style="vertical-align:inherit;">原文地址：https://www.edureka.co/blog/apache-hadoop-hdfs-architecture/</span></span></span></p>            </div>
                </div>