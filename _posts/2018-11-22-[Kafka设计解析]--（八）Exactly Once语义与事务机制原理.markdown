---
layout:     post
title:      [Kafka设计解析]--（八）Exactly Once语义与事务机制原理
---
<div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post">
								            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-f76675cdea.css">
						<div class="htmledit_views" id="content_views">
                <p><span style="color:rgb(102,102,102);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">本文转发自</span><a href="http://www.jasongj.com/" rel="nofollow" style="background-color:rgb(255,255,255);color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;"><strong>技术世界</strong></a><span style="color:rgb(102,102,102);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">，</span><a href="http://www.jasongj.com/kafka/transaction/" rel="nofollow" style="background-color:rgb(255,255,255);color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;">原文链接</a><span style="color:rgb(102,102,102);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">　</span><a href="http://www.jasongj.com/kafka/transaction/" rel="nofollow" style="background-color:rgb(255,255,255);color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;">http://www.jasongj.com/kafka/transaction/</a></p><p></p><h1 style="font-size:24px;line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;color:rgb(85,85,85);background-color:rgb(255,255,255);">写在前面的话</h1><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">本文所有Kafka原理性的描述除特殊说明外均基于Kafka 1.0.0版本。</p><h1 style="font-size:24px;line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8F%90%E4%BE%9B%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6" rel="nofollow" class="headerlink" title="为什么要提供事务机制" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>为什么要提供事务机制</h1><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">Kafka事务机制的实现主要是为了支持</p><ul style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><li style="list-style:circle;"><code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Exactly Once</code>即正好一次语义</li><li style="list-style:circle;">操作的原子性</li><li style="list-style:circle;">有状态操作的可恢复性</li></ul><h2 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:22px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#Exactly-Once" rel="nofollow" class="headerlink" title="Exactly Once" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a><code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Exactly Once</code></h2><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">《<a href="http://www.jasongj.com/2015/03/10/KafkaColumn1/#Kafka-delivery-guarantee" rel="nofollow" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);">Kafka背景及架构介绍</a>》一文中有说明Kafka在0.11.0.0之前的版本中只支持<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">At Least Once</code>和<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">At Most Once</code>语义，尚不支持<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Exactly Once</code>语义。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">但是在很多要求严格的场景下，如使用Kafka处理交易数据，<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Exactly Once</code>语义是必须的。我们可以通过让下游系统具有幂等性来配合Kafka的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">At Least Once</code>语义来间接实现<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Exactly Once</code>。但是：</p><ul style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><li style="list-style:circle;">该方案要求下游系统支持幂等操作，限制了Kafka的适用场景</li><li style="list-style:circle;">实现门槛相对较高，需要用户对Kafka的工作机制非常了解</li><li style="list-style:circle;">对于Kafka Stream而言，Kafka本身即是自己的下游系统，但Kafka在0.11.0.0版本之前不具有幂等发送能力</li></ul><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">因此，Kafka本身对<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Exactly Once</code>语义的支持就非常必要。</p><h2 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:22px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E6%93%8D%E4%BD%9C%E5%8E%9F%E5%AD%90%E6%80%A7" rel="nofollow" class="headerlink" title="操作原子性" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>操作原子性</h2><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">操作的原子性是指，多个操作要么全部成功要么全部失败，不存在部分成功部分失败的可能。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">实现原子性操作的意义在于：</p><ul style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><li style="list-style:circle;">操作结果更可控，有助于提升数据一致性</li><li style="list-style:circle;">便于故障恢复。因为操作是原子的，从故障中恢复时只需要重试该操作（如果原操作失败）或者直接跳过该操作（如果原操作成功），而不需要记录中间状态，更不需要针对中间状态作特殊处理</li></ul><h1 style="font-size:24px;line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6%E7%9A%84%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5" rel="nofollow" class="headerlink" title="实现事务机制的几个阶段" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>实现事务机制的几个阶段</h1><h2 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:22px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E5%B9%82%E7%AD%89%E6%80%A7%E5%8F%91%E9%80%81" rel="nofollow" class="headerlink" title="幂等性发送" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>幂等性发送</h2><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">上文提到，实现<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Exactly Once</code>的一种方法是让下游系统具有幂等处理特性，而在Kafka Stream中，Kafka Producer本身就是“下游”系统，因此如果能让Producer具有幂等处理特性，那就可以让Kafka Stream在一定程度上支持<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Exactly once</code>语义。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">为了实现Producer的幂等语义，Kafka引入了<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Producer ID</code>（即<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">PID</code>）和<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Sequence Number</code>。每个新的Producer在初始化的时候会被分配一个唯一的PID，该PID对用户完全透明而不会暴露给用户。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">对于每个PID，该Producer发送数据的每个<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">&lt;Topic, Partition&gt;</code>都对应一个从0开始单调递增的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Sequence Number</code>。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">类似地，Broker端也会为每个<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">&lt;PID, Topic, Partition&gt;</code>维护一个序号，并且每次Commit一条消息时将其对应序号递增。对于接收的每条消息，如果其序号比Broker维护的序号（即最后一次Commit的消息的序号）大一，则Broker会接受它，否则将其丢弃：</p><ul style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><li style="list-style:circle;">如果消息序号比Broker维护的序号大一以上，说明中间有数据尚未写入，也即乱序，此时Broker拒绝该消息，Producer抛出<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">InvalidSequenceNumber</code></li><li style="list-style:circle;">如果消息序号小于等于Broker维护的序号，说明该消息已被保存，即为重复消息，Broker直接丢弃该消息，Producer抛出<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">DuplicateSequenceNumber</code></li></ul><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">上述设计解决了0.11.0.0之前版本中的两个问题：</p><ul style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><li style="list-style:circle;">Broker保存消息后，发送ACK前宕机，Producer认为消息未发送成功并重试，造成数据重复</li><li style="list-style:circle;">前一条消息发送失败，后一条消息发送成功，前一条消息重试后成功，造成数据乱序</li></ul><h2 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:22px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E4%BA%8B%E5%8A%A1%E6%80%A7%E4%BF%9D%E8%AF%81" rel="nofollow" class="headerlink" title="事务性保证" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>事务性保证</h2><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">上述幂等设计只能保证单个Producer对于同一个<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">&lt;Topic, Partition&gt;</code>的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Exactly Once</code>语义。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">另外，它并不能保证写操作的原子性——即多个写操作，要么全部被Commit要么全部不被Commit。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">更不能保证多个读写操作的的原子性。尤其对于Kafka Stream应用而言，典型的操作即是从某个Topic消费数据，经过一系列转换后写回另一个Topic，保证从源Topic的读取与向目标Topic的写入的原子性有助于从故障中恢复。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">事务保证可使得应用程序将生产数据和消费数据当作一个原子单元来处理，要么全部成功，要么全部失败，即使该生产或消费跨多个<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">&lt;Topic, Partition&gt;</code>。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">另外，有状态的应用也可以保证重启后从断点处继续处理，也即事务恢复。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">为了实现这种效果，应用程序必须提供一个稳定的（重启后不变）唯一的ID，也即<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction ID</code>。<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transactin ID</code>与<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">PID</code>可能一一对应。区别在于<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction ID</code>由用户提供，而<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">PID</code>是内部的实现对用户透明。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">另外，为了保证新的Producer启动后，旧的具有相同<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction ID</code>的Producer即失效，每次Producer通过<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction ID</code>拿到PID的同时，还会获取一个单调递增的epoch。由于旧的Producer的epoch比新Producer的epoch小，Kafka可以很容易识别出该Producer是老的Producer并拒绝其请求。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">有了<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction ID</code>后，Kafka可保证：</p><ul style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><li style="list-style:circle;">跨Session的数据幂等发送。当具有相同<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction ID</code>的新的Producer实例被创建且工作时，旧的且拥有相同<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction ID</code>的Producer将不再工作。</li><li style="list-style:circle;">跨Session的事务恢复。如果某个应用实例宕机，新的实例可以保证任何未完成的旧的事务要么Commit要么Abort，使得新实例从一个正常状态开始工作。</li></ul><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">需要注意的是，上述的事务保证是从Producer的角度去考虑的。从Consumer的角度来看，该保证会相对弱一些。尤其是不能保证所有被某事务Commit过的所有消息都被一起消费，因为：</p><ul style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><li style="list-style:circle;">对于压缩的Topic而言，同一事务的某些消息可能被其它版本覆盖</li><li style="list-style:circle;">事务包含的消息可能分布在多个Segment中（即使在同一个Partition内），当老的Segment被删除时，该事务的部分数据可能会丢失</li><li style="list-style:circle;">Consumer在一个事务内可能通过seek方法访问任意Offset的消息，从而可能丢失部分消息</li><li style="list-style:circle;">Consumer可能并不需要消费某一事务内的所有Partition，因此它将永远不会读取组成该事务的所有消息</li></ul><h1 style="font-size:24px;line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86" rel="nofollow" class="headerlink" title="事务机制原理" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>事务机制原理</h1><h2 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:22px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E4%BA%8B%E5%8A%A1%E6%80%A7%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92" rel="nofollow" class="headerlink" title="事务性消息传递" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>事务性消息传递</h2><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">这一节所说的事务主要指原子性，也即Producer将多条消息作为一个事务批量发送，要么全部成功要么全部失败。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">为了实现这一点，Kafka 0.11.0.0引入了一个服务器端的模块，名为<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>，用于管理Producer发送的消息的事务性。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">该<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>维护<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Log</code>，该log存于一个内部的Topic内。由于Topic数据具有持久性，因此事务的状态也具有持久性。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">Producer并不直接读写<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Log</code>，它与<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>通信，然后由<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>将该事务的状态插入相应的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Log</code>。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Log</code>的设计与<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Offset Log</code>用于保存Consumer的Offset类似。</p><h2 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:22px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E4%BA%8B%E5%8A%A1%E4%B8%ADOffset%E7%9A%84%E6%8F%90%E4%BA%A4" rel="nofollow" class="headerlink" title="事务中Offset的提交" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>事务中Offset的提交</h2><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">许多基于Kafka的应用，尤其是Kafka Stream应用中同时包含Consumer和Producer，前者负责从Kafka中获取消息，后者负责将处理完的数据写回Kafka的其它Topic中。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">为了实现该场景下的事务的原子性，Kafka需要保证对Consumer Offset的Commit与Producer对发送消息的Commit包含在同一个事务中。否则，如果在二者Commit中间发生异常，根据二者Commit的顺序可能会造成数据丢失和数据重复：</p><ul style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><li style="list-style:circle;">如果先Commit Producer发送数据的事务再Commit Consumer的Offset，即<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">At Least Once</code>语义，可能造成数据重复。</li><li style="list-style:circle;">如果先Commit Consumer的Offset，再Commit Producer数据发送事务，即<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">At Most Once</code>语义，可能造成数据丢失。</li></ul><h2 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:22px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E7%94%A8%E4%BA%8E%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7%E7%9A%84%E6%8E%A7%E5%88%B6%E5%9E%8B%E6%B6%88%E6%81%AF" rel="nofollow" class="headerlink" title="用于事务特性的控制型消息" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>用于事务特性的控制型消息</h2><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">为了区分写入Partition的消息被Commit还是Abort，Kafka引入了一种特殊类型的消息，即<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Control Message</code>。该类消息的Value内不包含任何应用相关的数据，并且不会暴露给应用程序。它只用于Broker与Client间的内部通信。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">对于Producer端事务，Kafka以Control Message的形式引入一系列的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Marker</code>。Consumer即可通过该标记判定对应的消息被Commit了还是Abort了，然后结合该Consumer配置的隔离级别决定是否应该将该消息返回给应用程序。</p><h2 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:22px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%A0%B7%E4%BE%8B%E4%BB%A3%E7%A0%81" rel="nofollow" class="headerlink" title="事务处理样例代码" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>事务处理样例代码</h2><pre><code class="language-java">Producer&lt;String, String&gt; producer = new KafkaProducer&lt;String, String&gt;(props);
    
// 初始化事务，包括结束该Transaction ID对应的未完成的事务（如果有）
// 保证新的事务在一个正确的状态下启动
producer.initTransactions();
// 开始事务
producer.beginTransaction();
// 消费数据
ConsumerRecords&lt;String, String&gt; records = consumer.poll(100);
try{
    // 发送数据
    producer.send(new ProducerRecord&lt;String, String&gt;("Topic", "Key", "Value"));
    
    // 发送消费数据的Offset，将上述数据消费与数据发送纳入同一个Transaction内
    producer.sendOffsetsToTransaction(offsets, "group1");
    // 数据发送及Offset发送均成功的情况下，提交事务
    producer.commitTransaction();
} catch (ProducerFencedException | OutOfOrderSequenceException | AuthorizationException e) {
    // 数据发送或者Offset发送出现异常时，终止事务
    producer.abortTransaction();
} finally {
    // 关闭Producer和Consumer
    producer.close();
    consumer.close();
}</code></pre><h2 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:22px;color:rgb(85,85,85);background-color:rgb(255,255,255);">完整事务过程</h2><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/img/kafka/KafkaColumn8/KafkaTransaction.png" rel="nofollow" class="fancybox fancybox.image" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"><img src="http://www.jasongj.com/img/kafka/KafkaColumn8/KafkaTransaction.png" alt="Kafka Transaction" style="border:1px solid rgb(221,221,221);"></a></p><h3 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:20px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E6%89%BE%E5%88%B0Transaction-Coordinator" rel="nofollow" class="headerlink" title="找到Transaction Coordinator" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>找到<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code></h3><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">由于<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>是分配PID和管理事务的核心，因此Producer要做的第一件事情就是通过向任意一个Broker发送<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">FindCoordinator</code>请求找到<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>的位置。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">注意：只有应用程序为Producer配置了<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction ID</code>时才可使用事务特性，也才需要这一步。另外，由于事务性要求Producer开启幂等特性，因此通过将<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">transactional.id</code>设置为非空从而开启事务特性的同时也需要通过将<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">enable.idempotence</code>设置为true来开启幂等特性。</p><h3 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:20px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E8%8E%B7%E5%8F%96PID" rel="nofollow" class="headerlink" title="获取PID" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>获取PID</h3><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">找到<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>后，具有幂等特性的Producer必须发起<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">InitPidRequest</code>请求以获取PID。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">注意：只要开启了幂等特性即必须执行该操作，而无须考虑该Producer是否开启了事务特性。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><strong><em>如果事务特性被开启 </em></strong><br><code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">InitPidRequest</code>会发送给<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>。如果<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>是第一次收到包含有该<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction ID</code>的InitPidRequest请求，它将会把该<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">&lt;TransactionID, PID&gt;</code>存入<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Log</code>，如上图中步骤2.1所示。这样可保证该对应关系被持久化，从而保证即使<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>宕机该对应关系也不会丢失。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">除了返回PID外，<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">InitPidRequest</code>还会执行如下任务：</p><ul style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><li style="list-style:circle;">增加该PID对应的epoch。具有相同PID但epoch小于该epoch的其它Producer（如果有）新开启的事务将被拒绝。</li><li style="list-style:circle;">恢复（Commit或Abort）之前的Producer未完成的事务（如果有）。</li></ul><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">注意：<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">InitPidRequest</code>的处理过程是同步阻塞的。一旦该调用正确返回，Producer即可开始新的事务。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">另外，如果事务特性未开启，<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">InitPidRequest</code>可发送至任意Broker，并且会得到一个全新的唯一的PID。该Producer将只能使用幂等特性以及单一Session内的事务特性，而不能使用跨Session的事务特性。</p><h3 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:20px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1" rel="nofollow" class="headerlink" title="开启事务" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>开启事务</h3><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">Kafka从0.11.0.0版本开始，提供<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">beginTransaction()</code>方法用于开启一个事务。调用该方法后，Producer本地会记录已经开启了事务，但<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>只有在Producer发送第一条消息后才认为事务已经开启。</p><h3 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:20px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#Consume-Transform-Produce" rel="nofollow" class="headerlink" title="Consume-Transform-Produce" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>Consume-Transform-Produce</h3><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">这一阶段，包含了整个事务的数据处理过程，并且包含了多种请求。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><strong><em>AddPartitionsToTxnRequest</em></strong><br>一个Producer可能会给多个<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">&lt;Topic, Partition&gt;</code>发送数据，给一个新的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">&lt;Topic, Partition&gt;</code>发送数据前，它需要先向<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>发送<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">AddPartitionsToTxnRequest</code>。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>会将该<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">&lt;Transaction, Topic, Partition&gt;</code>存于<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Log</code>内，并将其状态置为<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">BEGIN</code>，如上图中步骤4.1所示。有了该信息后，我们才可以在后续步骤中为每个<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Topic, Partition&gt;</code>设置COMMIT或者ABORT标记（如上图中步骤5.2所示）。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">另外，如果该<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">&lt;Topic, Partition&gt;</code>为该事务中第一个<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">&lt;Topic, Partition&gt;</code>，<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>还会启动对该事务的计时（每个事务都有自己的超时时间）。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><strong><em>ProduceRequest</em></strong><br>Producer通过一个或多个<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">ProduceRequest</code>发送一系列消息。除了应用数据外，该请求还包含了PID，epoch，和<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Sequence Number</code>。该过程如上图中步骤4.2所示。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><strong><em>AddOffsetsToTxnRequest</em></strong><br>为了提供事务性，Producer新增了<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">sendOffsetsToTransaction</code>方法，该方法将多组消息的发送和消费放入同一批处理内。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">该方法先判断在当前事务中该方法是否已经被调用并传入了相同的Group ID。若是，直接跳到下一步；若不是，则向<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>发送<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">AddOffsetsToTxnRequests</code>请求，<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>将对应的所有<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">&lt;Topic, Partition&gt;</code>存于<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Log</code>中，并将其状态记为<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">BEGIN</code>，如上图中步骤4.3所示。该方法会阻塞直到收到响应。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><strong><em>TxnOffsetCommitRequest</em></strong><br>作为<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">sendOffsetsToTransaction</code>方法的一部分，在处理完<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">AddOffsetsToTxnRequest</code>后，Producer也会发送<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">TxnOffsetCommit</code>请求给<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Consumer Coordinator</code>从而将本事务包含的与读操作相关的各<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">&lt;Topic, Partition&gt;</code>的Offset持久化到内部的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">__consumer_offsets</code>中，如上图步骤4.4所示。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">在此过程中，<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Consumer Coordinator</code>会通过PID和对应的epoch来验证是否应该允许该Producer的该请求。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">这里需要注意：</p><ul style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><li style="list-style:circle;">写入<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">__consumer_offsets</code>的Offset信息在当前事务Commit前对外是不可见的。也即在当前事务被Commit前，可认为该Offset尚未Commit，也即对应的消息尚未被完成处理。</li><li style="list-style:circle;"><code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Consumer Coordinator</code>并不会立即更新缓存中相应<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">&lt;Topic, Partition&gt;</code>的Offset，因为此时这些更新操作尚未被COMMIT或ABORT。</li></ul><h3 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:20px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#Commit%E6%88%96Abort%E4%BA%8B%E5%8A%A1" rel="nofollow" class="headerlink" title="Commit或Abort事务" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>Commit或Abort事务</h3><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">一旦上述数据写入操作完成，应用程序必须调用<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">KafkaProducer</code>的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">commitTransaction</code>方法或者<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">abortTransaction</code>方法以结束当前事务。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><strong><em>EndTxnRequest</em></strong><br><code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">commitTransaction</code>方法使得Producer写入的数据对下游Consumer可见。<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">abortTransaction</code>方法通过<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Marker</code>将Producer写入的数据标记为<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Aborted</code>状态。下游的Consumer如果将<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">isolation.level</code>设置为<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">READ_COMMITTED</code>，则它读到被Abort的消息后直接将其丢弃而不会返回给客户程序，也即被Abort的消息对应用程序不可见。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">无论是Commit还是Abort，Producer都会发送<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">EndTxnRequest</code>请求给<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>，并通过标志位标识是应该Commit还是Abort。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">收到该请求后，<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>会进行如下操作</p><ol style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><li>将<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">PREPARE_COMMIT</code>或<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">PREPARE_ABORT</code>消息写入<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Log</code>，如上图中步骤5.1所示</li><li>通过<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">WriteTxnMarker</code>请求以<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Marker</code>的形式将<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">COMMIT</code>或<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">ABORT</code>信息写入用户数据日志以及<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Offset Log</code>中，如上图中步骤5.2所示</li><li>最后将<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">COMPLETE_COMMIT</code>或<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">COMPLETE_ABORT</code>信息写入<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Log</code>中，如上图中步骤5.3所示</li></ol><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">补充说明：对于<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">commitTransaction</code>方法，它会在发送<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">EndTxnRequest</code>之前先调用flush方法以确保所有发送出去的数据都得到相应的ACK。对于<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">abortTransaction</code>方法，在发送<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">EndTxnRequest</code>之前直接将当前Buffer中的事务性消息（如果有）全部丢弃，但必须等待所有被发送但尚未收到ACK的消息发送完成。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">上述第二步是实现将一组读操作与写操作作为一个事务处理的关键。因为Producer写入的数据Topic以及记录Comsumer Offset的Topic会被写入相同的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transactin Marker</code>，所以这一组读操作与写操作要么全部COMMIT要么全部ABORT。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><strong><em>WriteTxnMarkerRequest</em></strong><br>上面提到的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">WriteTxnMarkerRequest</code>由<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>发送给当前事务涉及到的每个<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">&lt;Topic, Partition&gt;</code>的Leader。收到该请求后，对应的Leader会将对应的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">COMMIT(PID)</code>或者<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">ABORT(PID)</code>控制信息写入日志，如上图中步骤5.2所示。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">该控制消息向Broker以及Consumer表明对应PID的消息被Commit了还是被Abort了。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">这里要注意，如果事务也涉及到<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">__consumer_offsets</code>，即该事务中有消费数据的操作且将该消费的Offset存于<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">__consumer_offsets</code>中，<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>也需要向该内部Topic的各Partition的Leader发送<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">WriteTxnMarkerRequest</code>从而写入<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">COMMIT(PID)</code>或<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">COMMIT(PID)</code>控制信息。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><strong><em>写入最终的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">COMPLETE_COMMIT</code>或<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">COMPLETE_ABORT</code>消息</em></strong><br>写完所有的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Marker</code>后，<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>会将最终的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">COMPLETE_COMMIT</code>或<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">COMPLETE_ABORT</code>消息写入<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Log</code>中以标明该事务结束，如上图中步骤5.3所示。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">此时，<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Log</code>中所有关于该事务的消息全部可以移除。当然，由于Kafka内数据是Append Only的，不可直接更新和删除，这里说的移除只是将其标记为null从而在Log Compact时不再保留。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">另外，<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">COMPLETE_COMMIT</code>或<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">COMPLETE_ABORT</code>的写入并不需要得到所有Rreplica的ACK，因为如果该消息丢失，可以根据事务协议重发。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">补充说明，如果参与该事务的某些<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">&lt;Topic, Partition&gt;</code>在被写入<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Marker</code>前不可用，它对<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">READ_COMMITTED</code>的Consumer不可见，但不影响其它可用<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">&lt;Topic, Partition&gt;</code>的COMMIT或ABORT。在该<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">&lt;Topic, Partition&gt;</code>恢复可用后，<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>会重新根据<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">PREPARE_COMMIT</code>或<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">PREPARE_ABORT</code>向该<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">&lt;Topic, Partition&gt;</code>发送<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Marker</code>。</p><h2 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:22px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E6%80%BB%E7%BB%93" rel="nofollow" class="headerlink" title="总结" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>总结</h2><ul style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><li style="list-style:circle;"><code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">PID</code>与<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Sequence Number</code>的引入实现了写操作的幂等性</li><li style="list-style:circle;">写操作的幂等性结合<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">At Least Once</code>语义实现了单一Session内的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Exactly Once</code>语义</li><li style="list-style:circle;"><code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Marker</code>与<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">PID</code>提供了识别消息是否应该被读取的能力，从而实现了事务的隔离性</li><li style="list-style:circle;">Offset的更新标记了消息是否被读取，从而将对读操作的事务处理转换成了对写（Offset）操作的事务处理</li><li style="list-style:circle;">Kafka事务的本质是，将一组写操作（如果有）对应的消息与一组读操作（如果有）对应的Offset的更新进行同样的标记（即<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Marker</code>）来实现事务中涉及的所有读写操作同时对外可见或同时对外不可见</li><li style="list-style:circle;">Kafka只提供对Kafka本身的读写操作的事务性，不提供包含外部系统的事务性</li></ul><h1 style="font-size:24px;line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" rel="nofollow" class="headerlink" title="异常处理" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>异常处理</h1><h2 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:22px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#Exception%E5%A4%84%E7%90%86" rel="nofollow" class="headerlink" title="Exception处理" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>Exception处理</h2><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><strong><em>InvalidProducerEpoch</em></strong><br>这是一种Fatal Error，它说明当前Producer是一个过期的实例，有<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction ID</code>相同但epoch更新的Producer实例被创建并使用。此时Producer会停止并抛出Exception。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><strong><em>InvalidPidMapping</em></strong><br><code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>没有与该<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction ID</code>对应的PID。此时Producer会通过包含有<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction ID</code>的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">InitPidRequest</code>请求创建一个新的PID。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><strong><em>NotCorrdinatorForGTransactionalId</em></strong><br>该<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>不负责该当前事务。Producer会通过<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">FindCoordinatorRequest</code>请求重新寻找对应的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><strong><em>InvalidTxnRequest</em></strong><br>违反了事务协议。正确的Client实现不应该出现这种Exception。如果该异常发生了，用户需要检查自己的客户端实现是否有问题。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><strong><em>CoordinatorNotAvailable</em></strong><br><code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>仍在初始化中。Producer只需要重试即可。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><strong><em>DuplicateSequenceNumber</em></strong><br>发送的消息的序号低于Broker预期。该异常说明该消息已经被成功处理过，Producer可以直接忽略该异常并处理下一条消息</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><strong><em>InvalidSequenceNumber</em></strong><br>这是一个Fatal Error，它说明发送的消息中的序号大于Broker预期。此时有两种可能</p><ul style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><li style="list-style:circle;">数据乱序。比如前面的消息发送失败后重试期间，新的消息被接收。正常情况下不应该出现该问题，因为当幂等发送启用时，<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">max.inflight.requests.per.connection</code>被强制设置为1，而<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">acks</code>被强制设置为all。故前面消息重试期间，后续消息不会被发送，也即不会发生乱序。并且只有ISR中所有Replica都ACK，Producer才会认为消息已经被发送，也即不存在Broker端数据丢失问题。</li><li style="list-style:circle;">服务器由于日志被Truncate而造成数据丢失。此时应该停止Producer并将此Fatal Error报告给用户。</li></ul><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><strong><em>InvalidTransactionTimeout</em></strong><br><code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">InitPidRequest</code>调用出现的Fatal Error。它表明Producer传入的timeout时间不在可接受范围内，应该停止Producer并报告给用户。</p><h2 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:22px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E5%A4%84%E7%90%86Transaction-Coordinator%E5%A4%B1%E8%B4%A5" rel="nofollow" class="headerlink" title="处理Transaction Coordinator失败" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>处理<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>失败</h2><h3 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:20px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E5%86%99PREPARE-COMMIT-PREPARE-ABORT%E5%89%8D%E5%A4%B1%E8%B4%A5" rel="nofollow" class="headerlink" title="写PREPARE_COMMIT/PREPARE_ABORT前失败" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>写<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">PREPARE_COMMIT/PREPARE_ABORT</code>前失败</h3><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">Producer通过<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">FindCoordinatorRequest</code>找到新的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>，并通过<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">EndTxnRequest</code>请求发起<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">COMMIT</code>或<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">ABORT</code>流程，新的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>继续处理<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">EndTxnRequest</code>请求——写<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">PREPARE_COMMIT</code>或<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">PREPARE_ABORT</code>，写<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Marker</code>，写<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">COMPLETE_COMMIT</code>或<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">COMPLETE_ABORT</code>。</p><h3 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:20px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E5%86%99%E5%AE%8CPREPARE-COMMIT-PREPARE-ABORT%E5%90%8E%E5%A4%B1%E8%B4%A5" rel="nofollow" class="headerlink" title="写完PREPARE_COMMIT/PREPARE_ABORT后失败" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>写完<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">PREPARE_COMMIT/PREPARE_ABORT</code>后失败</h3><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">此时旧的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>可能已经成功写入部分<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Marker</code>。新的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>会重复这些操作，所以部分Partition中可能会存在重复的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">COMMIT</code>或<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">ABORT</code>，但只要该Producer在此期间没有发起新的事务，这些重复的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Marker</code>就不是问题。</p><h3 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:20px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E5%86%99%E5%AE%8CCOMPLETE-COMMIT-ABORT%E5%90%8E%E5%A4%B1%E8%B4%A5" rel="nofollow" class="headerlink" title="写完COMPLETE_COMMIT/ABORT后失败" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>写完<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">COMPLETE_COMMIT/ABORT</code>后失败</h3><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">旧的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>可能已经写完了<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">COMPLETE_COMMIT</code>或<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">COMPLETE_ABORT</code>但在返回<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">EndTxnRequest</code>之前失败。该场景下，新的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>会直接给Producer返回成功。</p><h2 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:22px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E4%BA%8B%E5%8A%A1%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6" rel="nofollow" class="headerlink" title="事务过期机制" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>事务过期机制</h2><h3 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:20px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E4%BA%8B%E5%8A%A1%E8%B6%85%E6%97%B6" rel="nofollow" class="headerlink" title="事务超时" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>事务超时</h3><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">transaction.timeout.ms</code></p><h3 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:20px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E7%BB%88%E6%AD%A2%E8%BF%87%E6%9C%9F%E4%BA%8B%E5%8A%A1" rel="nofollow" class="headerlink" title="终止过期事务" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>终止过期事务</h3><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">当Producer失败时，<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>必须能够主动的让某些进行中的事务过期。否则没有Producer的参与，<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>无法判断这些事务应该如何处理，这会造成：</p><ul style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><li style="list-style:circle;">如果这种进行中事务太多，会造成<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>需要维护大量的事务状态，大量占用内存</li><li style="list-style:circle;"><code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Log</code>内也会存在大量数据，造成新的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>启动缓慢</li><li style="list-style:circle;"><code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">READ_COMMITTED</code>的Consumer需要缓存大量的消息，造成不必要的内存浪费甚至是OOM</li><li style="list-style:circle;">如果多个<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction ID</code>不同的Producer交叉写同一个Partition，当一个Producer的事务状态不更新时，<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">READ_COMMITTED</code>的Consumer为了保证顺序消费而被阻塞</li></ul><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">为了避免上述问题，<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>会周期性遍历内存中的事务状态Map，并执行如下操作</p><ul style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><li style="list-style:circle;">如果状态是<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">BEGIN</code>并且其最后更新时间与当前时间差大于<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">transaction.remove.expired.transaction.cleanup.interval.ms</code>（默认值为1小时），则主动将其终止：1）未避免原Producer临时恢复与当前终止流程冲突，增加该Producer对应的PID的epoch，并确保将该更新的信息写入<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Log</code>；2）以更新后的epoch回滚事务，从而使得该事务相关的所有Broker都更新其缓存的该PID的epoch从而拒绝旧Producer的写操作</li><li style="list-style:circle;">如果状态是<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">PREPARE_COMMIT</code>，完成后续的COMMIT流程————向各<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">&lt;Topic, Partition&gt;</code>写入<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Marker</code>，在<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Log</code>内写入<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">COMPLETE_COMMIT</code></li><li style="list-style:circle;">如果状态是<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">PREPARE_ABORT</code>，完成后续ABORT流程</li></ul><h3 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:20px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E7%BB%88%E6%AD%A2Transaction-ID" rel="nofollow" class="headerlink" title="终止Transaction ID" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>终止<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction ID</code></h3><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">某<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction ID</code>的Producer可能很长时间不再发送数据，<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>没必要再保存该<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction ID</code>与<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">PID</code>等的映射，否则可能会造成大量的资源浪费。因此需要有一个机制探测不再活跃的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction ID</code>并将其信息删除。</p><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>会周期性遍历内存中的<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction ID</code>与<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">PID</code>映射，如果某<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction ID</code>没有对应的正在进行中的事务并且它对应的最后一个事务的结束时间与当前时间差大于<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">transactional.id.expiration.ms</code>（默认值是7天），则将其从内存中删除并在<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Log</code>中将其对应的日志的值设置为null从而使得Log Compact可将其记录删除。</p><h1 style="font-size:24px;line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E4%B8%8E%E5%85%B6%E5%AE%83%E7%B3%BB%E7%BB%9F%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6%E5%AF%B9%E6%AF%94" rel="nofollow" class="headerlink" title="与其它系统事务机制对比" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>与其它系统事务机制对比</h1><h2 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:22px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#PostgreSQL-MVCC" rel="nofollow" class="headerlink" title="PostgreSQL MVCC" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>PostgreSQL MVCC</h2><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">Kafka的事务机制与《<a href="http://www.jasongj.com/sql/mvcc/" rel="nofollow" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);">MVCC PostgreSQL实现事务和多版本并发控制的精华</a>》一文中介绍的PostgreSQL通过MVCC实现事务的机制非常类似，对于事务的回滚，并不需要删除已写入的数据，都是将写入数据的事务标记为Rollback/Abort从而在读数据时过滤该数据。</p><h2 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:22px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4" rel="nofollow" class="headerlink" title="两阶段提交" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>两阶段提交</h2><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">Kafka的事务机制与《<a href="http://www.jasongj.com/big_data/two_phase_commit/#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8E%9F%E7%90%86" rel="nofollow" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);">分布式事务（一）两阶段提交及JTA</a>》一文中所介绍的两阶段提交机制看似相似，都分PREPARE阶段和最终COMMIT阶段，但又有很大不同。</p><ul style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><li style="list-style:circle;">Kafka事务机制中，PREPARE时即要指明是<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">PREPARE_COMMIT</code>还是<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">PREPARE_ABORT</code>，并且只须在<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Log</code>中标记即可，无须其它组件参与。而两阶段提交的PREPARE需要发送给所有的分布式事务参与方，并且事务参与方需要尽可能准备好，并根据准备情况返回<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Prepared</code>或<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Non-Prepared</code>状态给事务管理器。</li><li style="list-style:circle;">Kafka事务中，一但发起<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">PREPARE_COMMIT</code>或<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">PREPARE_ABORT</code>，则确定该事务最终的结果应该是被<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">COMMIT</code>或<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">ABORT</code>。而分布式事务中，PREPARE后由各事务参与方返回状态，只有所有参与方均返回<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Prepared</code>状态才会真正执行COMMIT，否则执行ROLLBACK</li><li style="list-style:circle;">Kafka事务机制中，某几个Partition在COMMIT或ABORT过程中变为不可用，只影响该Partition不影响其它Partition。两阶段提交中，若唯一收到COMMIT命令参与者Crash，其它事务参与方无法判断事务状态从而使得整个事务阻塞</li><li style="list-style:circle;">Kafka事务机制引入事务超时机制，有效避免了挂起的事务影响其它事务的问题</li><li style="list-style:circle;">Kafka事务机制中存在多个<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>实例，而分布式事务中只有一个事务管理器</li></ul><h2 style="line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;font-size:22px;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#Zookeeper" rel="nofollow" class="headerlink" title="Zookeeper" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>Zookeeper</h2><p style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);">Zookeeper的原子广播协议与两阶段提交以及Kafka事务机制有相似之处，但又有各自的特点</p><ul style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><li style="list-style:circle;">Kafka事务可COMMIT也可ABORT。而Zookeeper原子广播协议只有COMMIT没有ABORT。当然，Zookeeper不COMMIT某消息也即等效于ABORT该消息的更新。</li><li style="list-style:circle;">Kafka存在多个<code style="font-family:consolas, Menlo, 'PingFang SC', 'Microsoft YaHei', monospace;font-size:13px;color:rgb(85,85,85);background:rgb(238,238,238);">Transaction Coordinator</code>实例，扩展性较好。而Zookeeper写操作只能在Leader节点进行，所以其写性能远低于读性能。</li><li style="list-style:circle;">Kafka事务是COMMIT还是ABORT完全取决于Producer即客户端。而Zookeeper原子广播协议中某条消息是否被COMMIT取决于是否有一大半FOLLOWER ACK该消息。</li></ul><h1 style="font-size:24px;line-height:1.5;font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;color:rgb(85,85,85);background-color:rgb(255,255,255);"><a href="http://www.jasongj.com/kafka/transaction/#Kafka%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0" rel="nofollow" class="headerlink" title="Kafka系列文章" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);"></a>Kafka系列文章</h1><ul style="color:rgb(85,85,85);font-family:Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;background-color:rgb(255,255,255);"><li style="list-style:circle;"><a href="http://www.jasongj.com/2015/03/10/KafkaColumn1/" rel="nofollow" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);">Kafka设计解析（一）- Kafka背景及架构介绍</a></li><li style="list-style:circle;"><a href="http://www.jasongj.com/2015/04/24/KafkaColumn2/" rel="nofollow" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);">Kafka设计解析（二）- Kafka High Availability （上）</a></li><li style="list-style:circle;"><a href="http://www.jasongj.com/2015/06/08/KafkaColumn3/" rel="nofollow" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);">Kafka设计解析（三）- Kafka High Availability （下）</a></li><li style="list-style:circle;"><a href="http://www.jasongj.com/2015/08/09/KafkaColumn4/" rel="nofollow" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);">Kafka设计解析（四）- Kafka Consumer设计解析</a></li><li style="list-style:circle;"><a href="http://www.jasongj.com/2015/12/31/KafkaColumn5_kafka_benchmark/" rel="nofollow" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);">Kafka设计解析（五）- Kafka性能测试方法及Benchmark报告</a></li><li style="list-style:circle;"><a href="http://www.jasongj.com/kafka/high_throughput/" rel="nofollow" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);">Kafka设计解析（六）- Kafka高性能架构之道</a></li><li style="list-style:circle;"><a href="http://www.jasongj.com/kafka/kafka_stream/" rel="nofollow" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);">Kafka设计解析（七）- Kafka Stream</a></li><li style="list-style:circle;"><a href="http://www.jasongj.com/kafka/transaction/" rel="nofollow" style="background-color:transparent;color:rgb(85,85,85);border-bottom:1px solid rgb(204,204,204);">Kafka设计解析（八）- Kafka Exactly Once语义与事务机制原理</a></li></ul><br>            </div>
                </div>